[
    {
        "article_id": "7183625285575639098",
        "snapshot": "",
        "title": "我的 2022 年，写书，房子，车子，晋升",
        "preview": "用 4 个关键词总结 2022 年——我的技术书，我的房子、我的车子和我的晋升，所以这篇年终总结以我的 2022 年为题。",
        "author": "何遇er",
        "view_count": 9635,
        "collect_count": 20,
        "comment_count": 49,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ad089cb4989f2babb031e9f0d8b1fe21~300x300.image",
        "category": "代码人生",
        "content": "今天是 2023 年 1 月 1 日，我在四川省邛崃市的一个民宿回顾我的 2022，昨天夜里被一阵阵炮竹声惊醒，心中竟充满了惊喜，海涛哥哥亲了我一下，用 4 个关键词总结 2022 年——我的技术书，我的房子、我的车子和我的晋升，所以这篇年终总结以我的 2022 年为题。\r\n\r\n## 我的技术书\r\n\r\n我的技术书暂时命名为《用 React 开发低代码系统》，这本书从 2021 年 12 月开始写，将在 2023 年 6 月 30 日前完稿交给机械工业出版社。开始写书的前 1 个月，我心中充满了热情，觉得自己在干一件光宗耀祖的事，早上 6 点 20 闹钟一响，便掀开被子起床洗漱，然后雄赳赳气昂昂的去上班，我通常是第二个到公司的人。在早上，公司楼下的大爷见了我，总会用四川话喊一声，‘来那么早！’，下午 6 点半下班，大爷见了我又要吆喝一声，‘你早就该下班了’。随着时间的推移，写书的热情在逐渐减小，早上起床没起初那么顺溜了，接下来 3 个月左右的时间，意志力被不断的摩擦，有些时候犯懒起床晚了，大爷见了我就会说：‘嘿，今天来得有点儿晚了哈’。之后意志力被摩擦麻木了，早上闹钟响就自觉的起床，大多数时候，我已经起床了，海涛哥哥还在睡觉。\r\n\r\n我的技术书包含 3 章基础知识，很担心有知识错误的地方，于是想让 Manger 给我校稿，校稿很枯燥，这件事放在心中久久的不好意思给他提起，要是还没提，自己就先放弃，又会不甘心，说不定以后还会怪自己，在心中预演了被他拒绝的情形后，最终向他提出了请求，实际上他没有拒绝我，而是一口就答应了。\r\n\r\n![qingqiu.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1434dedec32148c2a55a61f8f9a3976b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n不敢向别人提出自己的请求，看起来是怕麻烦人，实际上更多的是害怕别人知道自己菜。我已经工作 5 年了，看这篇总结的人大概都已经在工作了，在工作中大家是否遇到过这样一种同事，他明知道你已经忙得不行了，却还是要找你解决他遇到的问题，当你随便说了个可能的解决方案，他说他试过了，没有解决他的问题，他就是想你亲自去看看他遇到的问题。这种同事你会觉得他麻烦还是会佩服他？在我从小接受的教育中，‘厚脸皮’不是一个褒义词，但现在看来，很多时候它是一个褒义词。对自己做的事情尽心尽力，知道会麻烦别人，也要坚决推进，这就是我想到达的程度。\r\n\r\n到现在为止，《用 React 开发低代码系统》还没写完，预计还差最后两章就能完稿，完成之后我一定会相当骄傲，就像 2021 年写小说一样，写作期间不以为然，写完之后觉得自己特牛逼。写纸质的技术书是一个相当漫长的过程，但对结构化思维的训练有很大的帮助，我将技术书中的小部分内容以掘金文章的形式输出，希望与大家提前交流：\r\n\r\n1. [ECMAScript modules 详解](https://juejin.cn/post/7053627935655198751)\r\n2. [TypeScript 类型系统和自定义数据类型](https://juejin.cn/post/7065254608209182756)\r\n3. [类型断言 VS 类型守卫](https://juejin.cn/post/7075325455439495199)\r\n4. [我搞懂了 React 的函数组件](https://juejin.cn/post/7087032786963398664)\r\n5. [我搞懂了 React 的 useState 和 useEffect](https://juejin.cn/post/7098297316074848263)\r\n6. [讲清楚 TypeScript 类型兼容](https://juejin.cn/post/7109820147614908423)\r\n7. [HTML5 拖放操作](https://juejin.cn/post/7120924331693047822)\r\n8. [前端录制回放](https://juejin.cn/post/7132612035161882638)\r\n9. [webpack output.library 的 16 种取值](https://juejin.cn/post/7140619769853509640)\r\n10. [0基础开发一个前端脚手架](https://juejin.cn/post/7155098964771995678)\r\n11. [React 状态的不变性](https://juejin.cn/post/7165338973806526501)\r\n12. [React 高阶组件与 Render Props 的劣与优](https://juejin.cn/post/7165661340453830670)\r\n13. [讲清楚 React 的重新渲染](https://juejin.cn/post/7168257213738254344)\r\n14. [低代码跨 iframe 拖拽](https://juejin.cn/post/7170845236078313486)\r\n15. [用 Mobx 实现 React 应用的状态管理](https://juejin.cn/post/7173451717801934856)\r\n\r\n## 我的房子和车子\r\n\r\n2022 年 3 月我结束了租房子的日子，和老公一起搬到了自己的房子里，关于搬新家，我没有太大的喜悦，但是搬家之前和老公每周周末去选家具，心里感到特别开心。不管是属于自己的房子还是租房子，只要不是寄人篱下，只要我在的地方那就是家，并不在意房本上是不是自己的名字，这源于我没有租房被房东赶出来的经历，也源于我的物质欲望不大，自己挣得钱够花，每个月还能拿出一部分钱去做投资理财。\r\n\r\n![house1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a442901321b4ba98e59d30eb79b72bb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2022 年底我有了一辆小粉还有一个属于自己的司机，要是没有这辆车，现在我不可能在民宿里拿着电脑写总结，接下来很期待 2023 年和海涛哥哥在周末的时候开着车，背着电脑到成都周边的民宿住两天。\r\n\r\n![che.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a0cccdd7ee4597ab51e0af5ece668a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n和海涛哥哥认识不到一年就发生了新冠疫情，我们都没有车，结婚之后，周末经常待在家里，那种日子过久了真的很没劲。要是两个人结了婚，只能生个孩子，生活只有靠孩子才能有点活气儿，那么灵魂有什么意义，那叫什么人生。\r\n\r\n## 我的晋升\r\n\r\n2022 年发生了一件意外的事情——我晋升了。如果没有晋升，那么我的职业发展就是严重滞后，之所以意外，是因为平时做事不关注晋升。晋升只是结果不是目的，这是我的观念。2022 年第 1 季度结束，我原来的业务由于营收不及预期，停止迭代，产研人员全部撤出，大家都有了新的去处，我换了一个 Manger。得知这个消息时只感到难受，一方面因为和原来的同事合作很融洽，另一方面觉得自己 1 年半的付出全部清零。\r\n\r\n到新的组不出一个月，我被 HRBP 拉到一个晋升述职群之后，才知道原来的 Manger 给我提名晋升了，意外之喜从天而降，开始手足无措的准备晋升评审的资料，6 天之后便要述职，只觉得自己是个炮灰。述职完想知道结果，于是去问：\r\n\r\n![jins.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5744112974b46c0a659cf791814dcc1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n关于这次晋升，我唯一的感受就是，别人并不关心过程只关注结果，要是不能用数据衡量价值，述职的时候就难以让人信服，这无可厚非，公司人员众多，准确的衡量每个人的价值不是一件容易的事，用数字去衡量更加公平。在工作环境中，大家习惯用数据衡量价值，但社会上的人，除了生活在工作环境还生活在家庭环境中，家庭环境往往不以数字衡量价值，而是以人的良知去估算另一个人价值。我是一个女性，这让我想到了社会上一个不算职业的职业——家庭主妇。家庭主妇的可悲之处，就是难以向人例举自己的价值，做的事情有没有价值，价值是多少，这很大程度取决于自己老公的一句话。“军功章有你的一半”，我向来觉得这是一句体面话。自己有收入比伸手向别人要“军功章”爽了百倍不止。\r\n\r\n## 我的坏情绪\r\n\r\n2022 年 5 月，我建了一个微信群，群里有 10 个前端初学者，年纪较小，都是女生，建这个群的初衷是，养成持续学习和总结的习惯、顺便相互鼓励。我的情绪大体上很稳定，但是去年 8 月底的时候干啥都提不起劲，直到群里的小姐妹给我发了一段话\r\n\r\n![fankui.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/212534d6da0e40ee9969ae197616875f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n生活中有人对我说过类似的话，但从没觉得自己可以对别人产生影响。我与这个姑娘从未见面，只在一次模拟面试中听过对方的声音，她却发消息说很感谢我，其实我也感谢她，她发的消息给了我很大的鼓励，如同脉动广告说的那样——‘随时随地脉动了回来’，又情绪饱满的干活了。\r\n\r\n生活在这个社会上每天都在接受别人的影响，也在影响别人，疫情之下，失业的人很多，随之网上的负面情绪也很多，其实我对中国的发展是无脑乐观的。去年较以前的年份相比，我参加了更多的程序员社区活动，也给用到的开源项目提交了 PR，下面这张图是在 3 月 8 日时参加一个女性圆桌会的宣传图。\r\n\r\n![jina.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ba5400a8ad46059695fa4be8506528~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 总结\r\n\r\n2022 年毫无遗憾的过来了，2023 年也要毫无遗憾的度过。\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」"
    },
    {
        "article_id": "7184668640955301947",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd3b4e29c29489db2858e9a71662368~tplv-k3u1fbpfcp-watermark.image?",
        "title": "酸了！乐视工作制改为四天半；高通新年裁员；AI绘画公司开始倒闭；网易入股张艺谋元宇宙公司；GitHub今日热榜 | ShowMeAI资讯日报",
        "preview": "乐视实行四天半工作制；Movano推出智能戒指Evie；Nreal Air眼镜量产10万台；高通裁员；StockAI倒闭；百度&小马智行获准在京测试全无人自动驾驶；网易入股张艺谋元宇宙公司…",
        "author": "ShowMeAI",
        "view_count": 8649,
        "collect_count": 5,
        "comment_count": 14,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ddd95876f23c6e8ab56cab355f78a059~300x300.image",
        "category": "人工智能",
        "content": "<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc75ced9cb62474e9359b8a75b4ba6c8~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🎡 『乐视』开始实行每周四天半工作制，做与众不同的探路者\r\n\r\n2023的第一个工作日，乐视视频的微博发布了 2023 年第一封全员信，宣布自1月1日起执行每周四天半工作制：每周三实行行弹性的半天工作制，考勤时间调整为连续的5小时。\r\n\r\n全员信指出，公司2022年业务总体平稳，经营业务实现了现金流平衡，并且前3季度虽有5周居家办公，整体业绩目标均如期达成。工作制的调整有利于员工和家人及时就医、有利于缓解周一工作焦虑症、有利于员工学习和提高专业技能、有利于提升家庭幸福感等，以下是全文。（来源：乐视视频）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15fbb6a8430146428ac28783768c1d49~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🎡 『数字人民币』上线“发红包”功能，你体验了吗？\r\n\r\n2022年12月，数字人民币迎来一连串动作：试点范围扩大，数字人民币App能领取独一无二的个人头像、发放个人红包。数字人民币开展常态化试点已近3年，此次是其年内第二次扩围：目前其试点范围已扩大至17个省市的26个地区，其中全省试点的省份有5个，为广东、江苏、河北、四川、海南。\r\n\r\n与此同时，数字人民币试点场景已超过808.51万个，覆盖餐饮住宿、交通出行、购物消费、政务服务等领域。应用场景和试点地区范围逐步扩大，公众对于数字人民币的认知度也在不断增长。（来源：钛媒体APP）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaaa88f674be48a7bfbd275f43174257~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e15ca0399a69460f8552f48ec369fd1d~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n\r\n<a href=\\\"https://www.showmeai.tech/tutorials/85\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f4f8981484452ca8b1005def311ada~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></a>\r\n\r\n## 🎡 『Movano · Evie』Movano 推出首款智能戒指 Evie，专注女性健康细分领域\r\n\r\n美国医疗保健公司 Movano 近日推出首款智能戒指 Evie，可以测量记录**心率、血氧、皮肤温度变化、步数、卡路里、睡眠质量、经期和排卵**等数据，为佩戴者提供健康追踪服务，并将生物识别数据转化为健康建议。Evie 戒指将出现在1月初的 CES 2023 展会现场，即将进入上市销售日程，预计价格不高于 300 美元，且没有额外的订阅费用。\r\n\r\n从功能来看，Evie 戒指与 Oura、Apple 等公司的可穿戴设备有相似之处，不过锚定了更为细分的女性健康领域，并且可以提供更为精准的检测数据。Movano 公司表示，这款智能戒指有很大的信心通过美国食品和药物管理局批准，是一个用于脉搏血氧仪指标和心率测量的医疗级设备。（来源：TechCrunch）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f94d79207fc46898d4859879c708b4c~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🎡 『网易云音乐 · 声域』网易云音乐加码声音社交\r\n\r\n网易云音乐上线了一款名为“声域”App，用户通过语音聊天来进行交流：其优势在于可以更好地捕捉用户的情感，更容易建立起真正的友谊。\r\n\r\n声域提供了一些有趣的功能，比如匿名语音交友、语音游戏、语音直播等，增加社交的私密性和趣味性，帮助用户轻松地在线沟通。其中语音直播包括唱歌、情感、二次元等3种类型，用户进入直播房间后，可以在观看聆听的同时打赏主播。值得注意的是，声域也有“元宇宙直播间”，即直播间的主播是虚拟形象。（来源：Tech星球）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c0c6867fbe947d4a7cc349b64de106c~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🎡 『Nreal · Nreal Air』全球首个消费级 AR 眼镜达成 10 万台量产\r\n\r\n12月30日，Nreal 在苏州举办了第10万台AR眼镜下线仪式，这是全球首个消费级AR眼镜突破10万台量产。Nreal先后已进入中国、美国、英国、德国、日本、韩国等多个国家和市场。官方称，Nreal在消费级AR眼镜品牌的全球销量位列第一，在美国、日本也双双斩获当地智能眼镜品类销售第一。\r\n\r\n据了解，此次实现10万台量产的AR眼镜是 Nreal 第二代产品 Nreal Air，配备了130英寸空中投屏和201英寸AR锐彩天幕，并支持与手机、平板、笔记本、掌机、游戏主机甚至智能汽车等多种设备的连接。（来源：科创板日报）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45dac08081164f8f9bd5f6e094df468c~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968ebc96f2b14037aa969e24e5e91376~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🔥 『高通』高通新年裁员来了，未来看好汽车及物联网领域\r\n\r\n高通（Qualcomm）是著名的手机芯片制造商。根据华尔街日报的报道，高通对未来几个季度的业绩展望很悲观。为了应对未来业绩的情况，高通首席财务官 Akash Palkhiwala 表示，高通打算通过裁员减少成熟业务的支出，并在汽车及物联网领域新领域加大投入。\r\n\r\n据报道，高通手机芯片的销售业务下降比例，从原来预计的个位数猛增到二位数。之所以会有如此巨大的下降，一方面是新冠疫情催生了一大波的手机和移动芯片的需求，这些超额需求导致后续几年对移动客户端的需求下降。另外一方面最重要的还是现在经济形势不好，很多个人都暂时性的停止了非必要的设备更新。（来源：华尔街日报）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99ea9018002d42448ba65b4560e7e3ab~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🔥 『StockAI』第一批 AI 绘画公司已经倒闭了。。。\r\n2022年12月28日，AI绘画公司 StockAI 在 Twitter 上发帖称，StockAI 平台将正式关闭，用户订阅计划将被取消，并根据账户剩余时间进行退款，1月15日前用户仍可访问账户、发票、购买历史和收藏夹。创始人 Danny Postma 表示，StockAI 在23年第1季度推出新的平台，模式从用户生成内容转向由平台策划的AI生成内容。\r\n\r\n公开信息显示，StockAI 成立于2022年9月，从成立到关闭仅有 4 个月时间。创始人 Danny Postma 表示，运营一家像 StockAl 这样由人工智能驱动的初创公司成本很高，当前的付费用户基本无法支付这笔费用，所以公司不得不做出改变。（来源：AI前线）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b68113627394003b8144f13b1b2f589~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cf8b16647bf46fe973ee4e81e70ec73~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🔥 『百度 · 自动驾驶』在京开展全无人自动驾驶测试\r\n据 Apollo 智能驾驶官方消息，百度“萝卜快跑”首批获准在京开展全无人自动驾驶测试。据悉，此次百度“萝卜快跑”共投入10辆全无人自动驾驶车，在北京开发区划定时间与路线内开展全无人自动驾驶测试。\r\n\r\n至此，百度旗下自动驾驶出行服务平台“萝卜快跑”的全无人自动驾驶车队已驶入**北京、武汉、重庆**三城，是首家在全国多个城市开展全无人自动驾驶运营及测试的企业，覆盖总面积超百平方公里。2023年，百度 Apollo 将持续扩大业务规模，计划在全国范围内陆续增加投放 200 台全无人驾驶运营车辆，着力打造全球最大无人驾驶运营服务区。（来源：百度）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1778c5495bd846099a03c8dd4c96e503~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🔥 『小马智行 · 自动驾驶』获北京首批“无人化车外远程阶段”自动驾驶道路测试许可\r\n\r\n12月30日，北京市智能网联汽车政策先行区颁发 “无人化车外远程阶段”道路测试许可，小马智行再次成为首批获得许可的企业之一。\r\n\r\n获得许可后，小马智行将有序推动10辆无人化测试车在政策先行区划定的范围和时段内开启“整车无人”的道路测试。远程安全员将通过远程协助平台对测试车辆进行实时监控，并在必要情况下对车辆进行远程协助。目前小马智行同时在北京、广州两地进行全车无人的自动驾驶测试，为今后的“全车无人”示范应用及商业化运营打下了坚实的基础。（来源：小马智行）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6f415b498014d50afec9cb98d761891~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🔥 『张艺谋 · 元宇宙』张艺谋参与创立的元宇宙公司，获网易入股了\r\n\r\n近日，网易通过网易传媒科技(北京)有限公司参与了当红齐天的 B++ 轮融资。张艺谋不仅是当红齐天的股东，还是当红齐天的联合创始人兼艺术总监，而公司的法定代表人齐笑，还同时身兼创始人、董事长、首席执行官等多重身份。\r\n\r\n当红齐天的官网显示，公司致力于打造包括XR等技术在内的沉浸式体验，愿景是成为伟大的元宇宙文化科技公司。目前公司已经获得7轮融资，除网易外还有中航信托、联想创投、芒果基金、英特尔、小米、拉卡拉、蓝色光标等业界大佬。（来源：雷达财经）\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075ca6b537364e6ab9026d01a2209fc1~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b70312c85799493299bf3d2a314251b1~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7963de13eb15455098ff7c0de170a0e9~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🚧 『GPT Index』通过 LLM 使用大型外部知识库\r\n\r\n[https://github.com/jerryjliu/gpt_index](https://github.com/jerryjliu/gpt_index)\r\n\r\nGPT Index是外部数据和 LLM 之间简单、灵活的接口，提供了简单的数据结构来解决提示大小限制，为外部数据源提供数据连接器，提供一个全面的工具集。\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9736f01e5764e28827dc25a0fe27292~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🚧 『Statistical Rethinking (2023 Edition)』统计学反思2023年课程（持续更新中）\r\n\r\n[https://github.com/rmcelreath/stat_rethinking_2023](https://github.com/rmcelreath/stat_rethinking_2023)\r\n\r\n课程共10周，讲解侧重于科学模型的数据分析内容，课程视频与课件正在更新中。课程涉及大量编程任务，推荐使用 R 语言，也可以将其转换为你熟悉的 Python 等其他语言。\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a9a9c0718b14ed88f9361f6bd87a4e0~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🚧 『TorToiSe』经过训练的多语音 TTS 系统，强调质量\r\n\r\n[https://github.com/neonbjb/tortoise-tts](https://github.com/neonbjb/tortoise-tts)\r\n\r\nTortoise 是一个文本到语音转换程序，具有强大的多语音能力，以及高度逼真的韵律和语调。此存储库包含在推理模式下运行 Tortoise TTS 所需的所有代码。\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0caf7bb92ff4e7f99a994c143bdfdb5~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n## 🚧 『nanoGPT』用于训练/微调中型 GPT 的最简单、最快的存储库\r\n\r\n[https://github.com/karpathy/nanoGPT](https://github.com/karpathy/nanoGPT)\r\n\r\nnanoGPT 是用于训练/微调中型 GPT 的最简单、最快的存储库，是对复杂的 minGPT 的重写，旨在通过设计变得简单易读。目前正在努力在 OpenWebText 数据集上重现 GPT-2。\r\n\r\n<div align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1cc063894a14f95b15fd1ba61bbaecc~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></div>\r\n\r\n<a href=\\\"https://www.showmeai.tech/tutorials/85\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186bfceeb0f842e3b2aa8f75629d4b84~tplv-k3u1fbpfcp-zoom-1.image\\\" width=\\\"100%\\\" referrerpolicy=\\\"no-referrer\\\"></a>\r\n\r\n> ◉ 点击 👀[**日报合辑**](https://mp.weixin.qq.com/mp/homepage?__biz=Mzg2OTYyMTcwMw==&hid=2&sn=51f7bead52c41447cd0ecb3d57b884e7)，公众号内订阅话题 **#ShowMeAI资讯日报**，可接收每日最新推送。\r\n> \r\n> ◉ 点击 🎡[**AI应用与工具大全**](https://www.showmeai.tech/tutorials/85)，体验100+前沿AI产品带来的效率飞跃。"
    },
    {
        "article_id": "7127295203177676837",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cf3d180c6f14714befa6a842c101044~tplv-k3u1fbpfcp-watermark.image?",
        "title": "pnpm 是凭什么对 npm 和 yarn 降维打击的",
        "preview": "大家最近是不是经常听到 pnpm，我也一样。今天研究了一下它的机制，确实厉害，对 yarn 和 npm 可以说是降维打击。 那具体好在哪里呢？ 我们一起来看一下。 我们按照包管理工具的发展历史，从 n",
        "author": "zxg_神说要有光",
        "view_count": 64860,
        "collect_count": 1183,
        "comment_count": 248,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "大家最近是不是经常听到 pnpm，我也一样。今天研究了一下它的机制，确实厉害，对 yarn 和 npm 可以说是降维打击。\r\n\r\n那具体好在哪里呢？ 我们一起来看一下。\r\n\r\n我们按照包管理工具的发展历史，从 npm2 开始讲起：\r\n\r\n## npm2\r\n\r\n用 node 版本管理工具把 node 版本降到 4，那 npm 版本就是 2.x 了。\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4eef39cebc949859ff12c8d51e747e0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后找个目录，执行下 npm init -y，快速创建个 package.json。\r\n\r\n然后执行 npm install express，那么 express 包和它的依赖都会被下载下来：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ad0f0e13d1404c93089bde5ae08112~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n展开 express，它也有 node_modules：\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ada5f744720c4cb7b4d846ee2d1bf81b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n再展开几层，每个依赖都有自己的 node_modules：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff1d1c0cab14b65b905fe1e74db59a1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n也就是说 npm2 的 node_modules 是嵌套的。\r\n\r\n这很正常呀？有什么不对么？\r\n\r\n这样其实是有问题的，多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。\r\n\r\n这个还不是最大的问题，致命问题是 windows 的文件路径最长是 260 多个字符，这样嵌套是会超过 windows 路径的长度限制的。\r\n\r\n当时 npm 还没解决，社区就出来新的解决方案了，就是 yarn：\r\n\r\n## yarn\r\n\r\nyarn 是怎么解决依赖重复很多次，嵌套路径过长的问题的呢？\r\n\r\n铺平。所有的依赖不再一层层嵌套了，而是全部在同一层，这样也就没有依赖重复多次的问题了，也就没有路径过长的问题了。\r\n\r\n我们把 node_modules 删了，用 yarn 再重新安装下，执行 yarn add express：\r\n\r\n这时候 node_modules 就是这样了：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71906633d465460183c3eb880391bf2e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n全部铺平在了一层，展开下面的包大部分是没有二层 node_modules 的：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e6392c33f04f7a949c07fa7d65d358~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n当然也有的包还是有 node_modules 的，比如这样：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0a3971237445aea60f4de1c13250a7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n为什么还有嵌套呢？\r\n\r\n因为一个包是可能有多个版本的，提升只能提升一个，所以后面再遇到相同包的不同版本，依然还是用嵌套的方式。\r\n\r\nnpm 后来升级到 3 之后，也是采用这种铺平的方案了，和 yarn 很类似：\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f93e2855514117bb73de52284d86fa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n当然，yarn 还实现了 yarn.lock 来锁定依赖版本的功能，不过这个 npm 也实现了。\r\n\r\nyarn 和 npm 都采用了铺平的方案，这种方案就没有问题了么？\r\n\r\n并不是，扁平化的方案也有相应的问题。\r\n\r\n最主要的一个问题是幽灵依赖，也就是你明明没有声明在 dependencies 里的依赖，但在代码里却可以 require 进来。\r\n\r\n这个也很容易理解，因为都铺平了嘛，那依赖的依赖也是可以找到的。\r\n\r\n但是这样是有隐患的，因为没有显式依赖，万一有一天别的包不依赖这个包了，那你的代码也就不能跑了，因为你依赖这个包，但是现在不会被安装了。\r\n\r\n这就是幽灵依赖的问题。\r\n\r\n而且还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其余版本的包不还是复制了很多次么，依然有浪费磁盘空间的问题。\r\n\r\n那社区有没有解决这俩问题的思路呢？\r\n\r\n当然有，这不是 pnpm 就出来了嘛。\r\n\r\n那 pnpm 是怎么解决这俩问题的呢？\r\n\r\n## pnpm\r\n\r\n回想下 npm3 和 yarn 为什么要做 node_modules 扁平化？不就是因为同样的依赖会复制多次，并且路径过长在 windows 下有问题么？\r\n\r\n那如果不复制呢，比如通过 link。\r\n\r\n首先介绍下 link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。\r\n\r\n如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？\r\n\r\n这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。\r\n\r\n没错，pnpm 就是通过这种思路来实现的。\r\n\r\n再把 node_modules 删掉，然后用 pnpm 重新装一遍，执行 pnpm install。\r\n\r\n你会发现它打印了这样一句话：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2d51d9a17743a4bafc42f1bbfd310c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n包是从全局 store 硬连接到虚拟 store 的，这里的虚拟 store 就是 node_modules/.pnpm。\r\n\r\n我们打开 node_modules 看一下：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4dc807ca6e4ae7a955c8dd6385cb46~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n确实不是扁平化的了，依赖了 express，那 node_modules 下就只有 express，没有幽灵依赖。\r\n\r\n展开 .pnpm 看一下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a69589bd534fdd97bdbeb6e3e1024c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n所有的依赖都在这里铺平了，都是从全局 store 硬连接过来的，然后包和包之间的依赖关系是通过软链接组织的。\r\n\r\n比如 .pnpm 下的 expresss，这些都是软链接，\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c50d8dc8a2a4466ba9e5eccd5c15614e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n也就是说，所有的依赖都是从全局 store 硬连接到了 node_modules/.pnpm 下，然后之间通过软链接来相互依赖。\r\n\r\n官方给了一张原理图，配合着看一下就明白了：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326a2090786e4d16b2d6fce25e876680~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这就是 pnpm 的实现原理。\r\n\r\n那么回过头来看一下，pnpm 为什么优秀呢？\r\n\r\n首先，最大的优点是节省磁盘空间呀，一个包全局只保存一份，剩下的都是软硬连接，这得节省多少磁盘空间呀。\r\n\r\n其次就是快，因为通过链接的方式而不是复制，自然会快。\r\n\r\n这也是它所标榜的优点：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba8815b36b3498ea4a3c2248d192bd6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n相比 npm2 的优点就是不会进行同样依赖的多次复制。\r\n\r\n相比 yarn 和 npm3+ 呢，那就是没有幽灵依赖，也不会有没有被提升的依赖依然复制多份的问题。\r\n\r\n这就已经足够优秀了，对 yarn 和 npm 可以说是降维打击。\r\n\r\n## 总结\r\n\r\npnpm 最近经常会听到，可以说是爆火。本文我们梳理了下它爆火的原因：\r\n\r\nnpm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。\r\n\r\nnpm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。\r\n\r\npnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。\r\n\r\n这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。\r\n\r\npnpm 就是凭借这个对 npm 和 yarn 降维打击的。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7186512174779465765",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cd79c8da7a42b9b4a4e900bf8211fa~tplv-k3u1fbpfcp-watermark.image?",
        "title": "虽然是我遇到的一个棘手的生产问题，但是我写出来之后，就是你的了。",
        "preview": "前几天，就在大家还沉浸在等待春节到来的喜悦氛围的时候，在一个核心链路上的核心系统中，我踩到一个坑的一比的坑，要不是我沉着冷静，解决思路忙中有序，处理手段雷厉风行，把它给扼杀在萌芽阶段",
        "author": "why技术",
        "view_count": 3590,
        "collect_count": 97,
        "comment_count": 16,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/8b472f29b528ad097a78d288ef895900~300x300.image",
        "category": "后端",
        "content": "你好呀，是歪歪。\r\n\r\n前几天，就在大家还沉浸在等待春节到来的喜悦氛围的时候，在一个核心链路上的核心系统中，我踩到一个坑的一比的坑，要不是我沉着冷静，解决思路忙中有序，处理手段雷厉风行，把它给扼杀在萌芽阶段了，那这玩意肯定得引发一个比较严重的生产问题。\r\n\r\n从问题出现到定位到这个问题的根本原因，我大概是花了两天半的时间。\r\n\r\n所以写篇文章给大家复盘一下啊，这个案例就是一个纯技术的问题导致的，和业务的相关度其实并不大，所以你拿过去直接添油加醋，稍微改改，往自己的服务上套一下，那就是你的了。\r\n\r\n我再说一次：**虽然现在不是你的，但是你看完之后就是你的了，你明白我意思吧？**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aca1505968947cbb5c2b2663b8a4e98~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 表象\r\n\r\n事情是这样的，我这边有一个服务，你可以把这个服务粗暴的理解为是一个商城一样的服务。有商城肯定就有下单嘛。\r\n\r\n然后接到上游服务反馈，说调用下单接口偶尔有调用超时的情况出现，断断续续的出现好几次了，给了几笔流水号，让我看一下啥情况。当时我的第一反应是不可能是我这边服务的问题，因为这个服务上次上线都至少是一个多月前的事情了，所以不可能是由于近期服务投产导致的。\r\n\r\n但是下单接口，你听名字就知道了，核心链接上的核心功能，不能有一点麻痹大意。\r\n\r\n每一个请求都很重要，客户下单体验不好，可能就不买了，造成交易损失。\r\n\r\n交易上不去营业额就上不去，营业额上不去利润就上不去，利润上不去年终就上不去。\r\n\r\n想到这一层关系之后，我立马就登陆到服务器上，开始定位问题。\r\n\r\n一看日志，确实是我这边接口请求处理慢了，导致的调用方超时。\r\n\r\n为什么会慢呢？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2cc7dc2cad64ee588a88b0d38199685~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n于是按照常规思路先根据日志判断了一下下单接口中调用其他服务的接口相应是否正常，从数据库获取数据的时间是否正常。\r\n\r\n这些判断没问题之后，我转而把目光放到了 gc 上，通过监控发现那个时间点触发了一次耗时接近 1s 的 full gc，导致响应慢了。\r\n\r\n由于我们监控只采集服务近一周的 gc 数据，所以我把时间拉长后发现 full gc 在这一周的时间内出现的频率还有点高，虽然我还没定位到问题的根本原因，但是我定位到了问题的表面原因，就是触发了 full gc。\r\n\r\n因为是核心链路，核心流程，所以此时不应该急着去定位根本原因，而是先缓解问题。\r\n\r\n好在我们提前准备了各种原因的应急预案，其中就包含这个场景。预案的内容就是扩大应用堆内存，延缓 full gc 的出现。\r\n\r\n所以我当即进行操作报备并联系运维，按照紧急预案执行，把服务的堆内存由 8G 扩大一倍，提升到 16G。\r\n\r\n虽然这个方法简单粗暴，但是既解决了当前的调用超时的问题，也给了我足够的排查问题的时间。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37263633107d404eaaf45be4a535c16e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 定位原因\r\n\r\n当时我其实一点都不慌的，因为问题在萌芽阶段的时候我就把它给干掉了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e690199e31f44e8b9a2d45077bf0c3b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n不就是 full gc 吗，哦，我的老朋友。\r\n\r\n先大胆假设一波：程序里面某个逻辑不小心搞出了大对象，触发了 full gc。\r\n\r\n所以我先是双手插兜，带着监控图和日志请求，闲庭信步的走进项目代码里面，想要凭借肉眼找出一点蛛丝马迹......\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bfe5ee964204d3d924e79b634144528~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n没有任何收获，因为下单服务涉及到的逻辑真的是太多了，服务里面 List 和 Map 随处可见，我很难找到到底哪里是大对象。\r\n\r\n但是我还是一点都不慌，因为这半天都没有再次发生 Full GC，说明此时留给我的时间还是比较充足的，\r\n\r\n所以我请求了场外援助，让 DBA 帮我导出一下服务的慢查询 SQL，因为我想可能是从数据库里面一次性取的数据太多了，而程序里面也没有做控制导致的。\r\n\r\n我之前就踩过类似的坑。\r\n\r\n一个根据客户号查询客户有多少订单的内部使用接口，接口的返回是 List<订单>，看起来没啥毛病，对不对？\r\n\r\n一般来说一个个人客户就几十上百，多一点的上千，顶天了的上万个订单，一次性拿出来也不是不可以。\r\n\r\n但是有一个客户不知道咋回事，特别钟爱我们的平台，也是我们平台的老客户了，一个人居然有接近 10w 的订单。\r\n\r\n然后这么多订单对象搞到到项目里面，本来响应就有点慢，上游再发起几次重试，直接触发 Full gc，降低了服务响应时间。\r\n\r\n所以，经过这个事件，我们定了一个规矩：用 List、Map 来作为返回对象的时候，必须要考虑一下极端情况下会返回多少数据回去。即使是内部使用，也最好是进行分页查询。\r\n\r\n好了，话说回来，我拿到慢查询 SQL 之后，根据几个 Full gc 时间点，对比之后提取出了几条看起来有点问题的 SQL。\r\n\r\n然后拿到数据库执行了一下，发现返回的数据量其实也都不大。\r\n\r\n此刻我还是一点都不慌，反正内存够用，而且针对这类问题，我还有一个场外援助没有使用呢。\r\n\r\n第二天我开始找运维同事帮我每隔 8 小时 Dump 一次内存文件，然后第三天我开始拿着内存文件慢慢分析。\r\n\r\n但是第二天我也没闲着，根据现有的线索反复分析、推理可能的原因。\r\n\r\n然后在观看 GC 回收内存大小监控的时候，发现了一点点端倪。因为触发 Full GC 之后，发现被回收的堆内存也不是特别多。\r\n\r\n当时就想到了除了大对象之外，还有一个现象有可能会导致这个现象：内存泄露。\r\n\r\n巧的是在第二天又发生了一次 Full gc，这样我拿到的 Dump 文件就更有分析的价值了。基于前面的猜想，我分析的时候直接就冲着内存泄漏的方向去查了。\r\n\r\n我拿着 5 个 Dump 文件，分析了在 5 个 Dump 文件中对象数量一直在增加的对象，这样的对象也不少，但是最终定位到了 FutureTask 对象，就是它：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e48a56a9bda41418be5a66bc123ebc0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n找到这玩意了再回去定位对应部分的代码就比较容易。\r\n\r\n但是你以为定位了代码就完事了吗？\r\n\r\n不是的，到这里才刚刚开始，朋友。\r\n\r\n因为我发现这个代码对应的 Bug 隐藏的还是比较深的，而且也不是我最开始假象的内存泄露，就是一个纯粹的内存溢出。\r\n\r\n所以值得拿出来仔细嗦一嗦。\r\n\r\n## 示例代码\r\n\r\n为了让你沉浸式体验找 BUG 的过程，我高低得给你整一个可复现的 Demo 出来，你拿过去就可以跑的那种。\r\n\r\n首先，我们得搞一个线程池：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95abd76d62374fa6bf3912daf8efbab6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n需要说明一下的是，上面这个线程池的核心线程数、最大线程数和队列长度我都取的 1，只是为了方便演示问题，在实际项目中是一个比较合理的值。\r\n\r\n然后重点看一下线程池里面有一个自定义的叫做 MyThreadFactory 的线程工厂类和一个自定义的叫做 MyRejectedPolicy 的拒绝策略。\r\n\r\n在我的服务里面就是有这样一个叫做 product 的线程池，用的也是这个自定义拒绝策略。\r\n\r\n其中 MyThreadFactory 的代码是这样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfed8a4c11ed4476ac9495dae82dd8da~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n它和默认的线程工厂之间唯一的区别就是我加了一个 threadFactoryName 字段，方便给线程池里面的线程取一个合适的名字。\r\n\r\n更直观的表示一下区别就是下面这个玩意：\r\n\r\n> 原生：pool-1-thread-1  \r\n> 自定义：product-pool-1-thread-1\r\n\r\n接下来看自定义的拒绝策略：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cef2d0177f4e4e74b4ec1de904e08a2b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里的逻辑很简单，就是当 product 线程池满了，触发了拒绝策略的时候打印一行日志，方便后续定位。\r\n\r\n然后接着看其他部分的代码：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f48f83ddd1457ab15bcd029cb0ad7d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n标号为 ① 的地方是线程池里面运行的任务，我这里只是一个示意，所以逻辑非常简单，就是把 i 扩大 10 倍。实际项目中运行的任务业务逻辑，会复杂一点，但是也是有一个 Future 返回。\r\n\r\n标号为 ② 的地方就是把返回的 Future 放到 list 集合中，在标号为 ③ 的地方循环处理这个 list 对象里面的 Future。\r\n\r\n需要注意的是因为实例中的线程池最多容纳两个任务，但是这里却有五个任务。我这样写的目的就是为了方便触发拒绝策略。\r\n\r\n然后在实际的项目里面刚刚提到的这一坨逻辑是通过定时任务触发的，所以我这里用一个死循环加手动开启线程来示意：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82eac54c4659431cb54bef048bbf6bc8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n整个完整的代码就是这样的，你直接粘过去就可以跑，这个案例就可以完全复现我在生产上遇到的问题：\r\n\r\n```\r\npublic class MainTest {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        ThreadPoolExecutor productThreadPoolExecutor = new ThreadPoolExecutor(1,\r\n                1,\r\n                1,\r\n                TimeUnit.SECONDS,\r\n                new LinkedBlockingQueue<>(1),\r\n                new MyThreadFactory(\\\"product\\\"),\r\n                new MyRejectedPolicy());\r\n\r\n        while (true){\r\n            TimeUnit.SECONDS.sleep(1);\r\n            new Thread(()->{\r\n                ArrayList<Future<Integer>> futureList = new ArrayList<>();\r\n                //从数据库获取产品信息\r\n                int productNum = 5;\r\n                for (int i = 0; i < productNum; i++) {\r\n                    try {\r\n                        int finalI = i;\r\n                        Future<Integer> future = productThreadPoolExecutor.submit(() -> {\r\n                            System.out.println(\\\"Thread.currentThread().getName() = \\\" + Thread.currentThread().getName());\r\n                            return finalI * 10;\r\n                        });\r\n                        futureList.add(future);\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                for (Future<Integer> integerFuture : futureList) {\r\n                    try {\r\n                        Integer integer = integerFuture.get();\r\n                        System.out.println(integer);\r\n                        System.out.println(\\\"future.get() = \\\" + integer);\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }).start();\r\n        }\r\n\r\n    }\r\n\r\n    static class MyThreadFactory implements ThreadFactory {\r\n        private static final AtomicInteger poolNumber = new AtomicInteger(1);\r\n        private final ThreadGroup group;\r\n        private final AtomicInteger threadNumber = new AtomicInteger(1);\r\n        private final String namePrefix;\r\n        private final String threadFactoryName;\r\n\r\n        public String getThreadFactoryName() {\r\n            return threadFactoryName;\r\n        }\r\n\r\n        MyThreadFactory(String threadStartName) {\r\n            SecurityManager s = System.getSecurityManager();\r\n            group = (s != null) ? s.getThreadGroup() :\r\n                    Thread.currentThread().getThreadGroup();\r\n            namePrefix = threadStartName + \\\"-pool-\\\" +\r\n                    poolNumber.getAndIncrement() +\r\n                    \\\"-thread-\\\";\r\n            threadFactoryName = threadStartName;\r\n        }\r\n\r\n        public Thread newThread(Runnable r) {\r\n            Thread t = new Thread(group, r,\r\n                    namePrefix + threadNumber.getAndIncrement(),\r\n                    0);\r\n            if (t.isDaemon())\r\n                t.setDaemon(false);\r\n            if (t.getPriority() != Thread.NORM_PRIORITY)\r\n                t.setPriority(Thread.NORM_PRIORITY);\r\n            return t;\r\n        }\r\n    }\r\n\r\n    public static class MyRejectedPolicy implements RejectedExecutionHandler {\r\n\r\n        @Override\r\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\r\n            if (e.getThreadFactory() instanceof MyThreadFactory) {\r\n                MyThreadFactory myThreadFactory = (MyThreadFactory) e.getThreadFactory();\r\n                if (\\\"product\\\".equals(myThreadFactory.getThreadFactoryName())) {\r\n                    System.out.println(THREAD_FACTORY_NAME_PRODUCT + \\\"线程池有任务被拒绝了,请关注\\\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n你跑的时候可以把堆内存设置的小一点，比如我设置为 10m：\r\n\r\n> -Xmx10m -Xms10m\r\n\r\n然后用 jconsole 监控，你会发现内存走势图是这样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efac9c09f8b04a88a09fca7f9d33f2a4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n哦，我的老天爷啊，这个该死的图，也是我的老伙计了，一个缓慢的持续上升的内存趋势图， 最后疯狂的触发 gc，但是并没有内存被回收，最后程序直接崩掉：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f39a168b95144389e3e39e6174750bc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这绝大概率就是内存泄漏了啊。\r\n\r\n但是在生产上的内存走势图完全看不出来这个趋势，我前面说了，主要因为 GC 情况的数据只会保留一周时间，所以就算把整个图放出来也不是那么直观。\r\n\r\n其次不是因为我牛逼嘛，萌芽阶段就干掉了这个问题，所以没有遇到最后频繁触发 gc，但是没啥回收的，导致 OOM 的情况。\r\n\r\n所以我再带着你看看另外一个视角，这是我真正定位到问题的视角。就是分析内存 Dump 文件。\r\n\r\n分析内存 Dump 文件的工具以及相关的文章非常的多，我就不赘述了，你随便找个工具玩一玩就行。我这里主要是分享一个思路，所以就直接使用 idea 里面的 Profiler 插件了，方便。\r\n\r\n我用上面的代码，启动起来之后在四个时间点分别 Dump 之后，观察内存文件。内存泄露的思路就是找文件里面哪个对象的个数和占用空间是在持续上升嘛，特别是中间还发生过 full gc，这个过程其实是一个比较枯燥且复杂的过程，在生产项目中可能会分析出很多个这样的对象，然后都要到代码里面去定位相关逻辑。\r\n\r\n但是我这里极大的简化了程序，所以很容易就会发现这个 FutureTask 对象特别的抢眼，数量在持续增加，而且还是名列前茅的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2373d79dda64e1dadafb0ce149f01b7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n然后这个工具还可以看对象占用大小，大概是这个意思：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecfcfa1cea834d84a8acc9a8c1213450~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以我还可以看看在这几个文件中 FutureTask 对象大小的变化，也是持续增加：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a0150fa9b554fe7a0a342e8727cdf7c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n就它了，准没错。\r\n\r\n好，问题已经能复现了，GC 图和内存 Dump 的图也都给你看了。\r\n\r\n到这里，如果有人已经看出来问题的原因了，可以直接拉到文末点个赞，感谢大佬阅读我的文章。\r\n\r\n如果你还没看出端倪来，那么我先给你说问题的根本原因：\r\n\r\n> 问题的根本原因就出在 MyRejectedPolicy 这个自定义拒绝策略上。\r\n\r\n在带你细嗦这个问题之前，我先问一个问题：\r\n\r\n> JDK 自带的线程池拒绝策略有哪些？\r\n\r\n这玩意，老八股文了，存在的时间比我从业的时间都长，得张口就来：\r\n\r\n-   AbortPolicy：丢弃任务并抛出 RejectedExecutionException 异常，这是默认的策略。\r\n-   DiscardOldestPolicy：丢弃队列最前面的任务，执行后面的任务\r\n-   CallerRunsPolicy：由调用线程处理该任务\r\n-   DiscardPolicy：也是丢弃任务，但是不抛出异常，相当于静默处理。\r\n\r\n然后你再回头看看我的自定义拒绝策略，是不是和 DiscardPolicy 非常像，也没有抛出异常。只是比它更高级一点，打印了一点日志。\r\n\r\n当我们使用默认的策略的时候：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a230a16b5e6741a8a02510530b201860~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n或者我们把框起来这行代码粘到我们的 MyRejectedPolicy 策略里面：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b0a28895dd74b68a8f11ab285b5e2f6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n再次运行，不管是观察 gc 情况，还是 Dump 内存，你会发现程序正常了，没毛病了。\r\n\r\n下面这个走势图就是在拒绝策略中是否抛出异常对应的内存走势对比图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d505db7d004715bb6ac65debfb8a66~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在拒绝策略中抛出异常就没毛病了，为啥？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e36dbf6a0f0945e4a136dc2cc29671a4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 探索\r\n\r\n首先，我们来看一下没有抛出异常的时候，发生了什么事情。\r\n\r\n没有抛出异常时，我们前面分析了，出现了非常多的 FutureTask 对象，所以我们就找程序里面这个对象是哪里出来的，定位到这个地方：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f89ca0eb079d4a03b2bb4d37debdecd5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nfuture 没有被回收，说明 futureList 对象没有被回收，而这两个对象对应的 GC Root 都是new 出来的这个线程，因为一个活跃线程是 GC Root。\r\n\r\n进一步说明对应 new 出来的线程没有被回收。\r\n\r\n所以我给你看一下前面两个案例对应的线程数对比图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc3293675a4478bb11fddaa21e412f4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n没有在拒绝策略中抛出异常的线程非常的多，看起来每一个都没有被回收，这个地方肯定就是有问题的。\r\n\r\n然后随机选一个查看详情，可以看到线程在第 39 行卡着的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cb8056f5cf748c4a06dcaf9c256ece6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是这样一行代码：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b441197dd2514245be79c3235374d2f2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这个方法大家应该熟悉，因为也没有给等待时间嘛，所以如果等不到 Future 的结果，线程就会在这里死等。\r\n\r\n也就导致线程不会运行结束，所以不会被回收。\r\n\r\n对应着源码说就是有 Future 的 state 字段，即状态不正确，导致线程阻塞在这个 if 里面：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/358d356446cc4cf69215ff1e294079c3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nif 里面的 awaitDone 逻辑稍微有一点点复杂，这个地方其实还有一个 BUG，在 JDK 9 进行了修复，这一点我在之前的文章中写过，所以就不赘述了，你有兴趣可以去看看：[《Doug Lea在J.U.C包里面写的BUG又被网友发现了。》](https://mp.weixin.qq.com/s/B3PrMiR4_Ghg9ROQj0ks0Q)\r\n\r\n总之，在我们的案例下，最终会走到我框起来的代码：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be685c407424ad5a49fd5df7a8b9039~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是当前线程会在这里阻塞住，等到唤醒。\r\n\r\n那么问题就来了，谁来唤醒它呢？\r\n\r\n巧了，这个问题我之前也写过，在这篇文章中，有这样一句话：[《关于多线程中抛异常的这个面试题我再说最后一次！》](https://mp.weixin.qq.com/s/aOlScg5sfQ4JvHzcRFqeyQ)\r\n\r\n> 如果子线程捕获了异常，该异常不会被封装到 Future 里面。是通过 FutureTask 的 run 方法里面的 setException 和 set 方法实现的。在这两个方法里面完成了 FutureTask 里面的 outcome 变量的设置，同时完成了从 NEW 到 NORMAL 或者 EXCEPTIONAL 状态的流转。\r\n\r\n带你看一眼 FutureTask 的 run 方法：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269cbe55848c4258bf7cfd47531acb49~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是说 FutureTask 状态变化的逻辑是被封装到它的 run 方法里面的。\r\n\r\n知道了它在哪里等待，在哪里唤醒，揭晓答案之前，还得带你去看一下它在哪里诞生。\r\n\r\n它的出生地，就是线程池的 submit 方法：\r\n\r\n> java.util.concurrent.AbstractExecutorService#submit\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed90ea8470b54877854ad64e0ab31834~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是，朋友，注意，我要说但是了。\r\n\r\n首先，我们看一下当线程池的 execute 方法，当线程池满了之后，再次提交任务会触发 reject 方法，而当前的任务并不会被放到队列里面去：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c4e2cff9d4489693235b3e49197dab~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是说当 submit 方法不抛出异常就会把正常返回的这个状态为 NEW 的 future 放到 futureList 里面去，即下面编号为 ① 的地方。然后被标号为 ② 的循环方法处理：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1b7b526c4004d05bc6b5fe04728f5b2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n那么问题就来了：被拒绝了的任务，还会被线程池触发 run 方法吗？\r\n\r\n肯定是不会的，都被拒绝了，还触发个毛线啊。\r\n\r\n不会被触发 run 方法，那么这个 future 的状态就不会从 NEW 变化到 EXCEPTION 或者 NORMAL。\r\n\r\n所以调用 Future.get() 方法就一定一直阻塞。又因为是定时任务触发的逻辑，所以导致 Future 对象越来越多，形成一种内存泄露。\r\n\r\nsubmit 方法如果抛出异常则会被标号为 ② 的地方捕获到异常。\r\n\r\n不会执行标号为 ① 的地方，也就不会导致内存泄露：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/741498a870aa48538c7b85139e350de0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n道理就是这么一个道理。\r\n\r\n## 解决方案\r\n\r\n知道问题的根本原因了，解决方案也很简单。\r\n\r\n定位到这个问题之后，我发现项目中的线程池参数配置的并不合理，每次定时任务触发之后，因为数据库里面的数据较多，所以都会触发拒绝策略。\r\n\r\n所以首先是调整了线程池的参数，让它更加的合理。当时如果你要用这个案例，这个地方你也可以包装一下，动态线程池，高大上，对吧，以前讲过。\r\n\r\n然后是调用 Future.get() 方法的时候，给一个超时时间，这样至少能帮我们兜个底。资源能及时释放，比死等好。\r\n\r\n最后就是一个教训：自定义线程池拒绝策略的时候，一定一定记得要考虑到这个场景。\r\n\r\n比如我前面抛出异常的自定义拒绝策略其实还是有问题的，我故意留下了一个坑：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06afa05603354fe8a2369481313fe295~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n抛出异常的前提是要满足最开始的 if 条件：\r\n\r\n> e.getThreadFactory() instanceof MyThreadFactory\r\n\r\n如果别人误用了这个拒绝策略，导致这个 if 条件不成立的话，那么这个拒绝策略还是有问题。\r\n\r\n所以，应该把抛出异常的逻辑移到 if 之外。\r\n\r\n同时在排查问题的过程中，在项目里面看到了类似这样的写法：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f3d4bd0faab4513a7de6583d9c21f1e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n不要这样写，好吗？\r\n\r\n一个是因为 submit 是有返回值的，你要是不用返回值，直接用 execute 方法不香吗？\r\n\r\n另外一个是因为你这样写，如果线程池里面的任务执行的时候出异常了，会把异常封装到 Future 里面去，而你又不关心 Future，相当于把异常给吞了，排查问题的时候你就哭去吧。\r\n\r\n这些都是编码过程中的一些小坑和小注意点。\r\n\r\n## 反转\r\n\r\n这一小节的题目为什么要叫反转？\r\n\r\n因为以上的内容，除了技术原理是真的，我铺垫的所有和背景相关的东西，全部都是假的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82f0b5dc5d354106a8c655b623286bb9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n整篇文章从第二句开始就是假的，我根本就没有遇到过这样的一个生产问题，也谈不上扼杀在摇篮里，更谈不上是我去解决的了。\r\n\r\n但是我在开始的时候说了这样一句话，也是全文唯一一句加粗的话：\r\n\r\n> 虽然现在不是你的，但是你看完之后就是你的了，你明白我意思吧？\r\n\r\n所以这个背景其实我前几天看到了“严选技术”发布的这篇文章[《严选库存稳定性治理系列：一个线程池拒绝策略引发的血案》](https://mp.weixin.qq.com/s/SZ8gpKG6IPCdIr4MFWf65g)。\r\n\r\n看完他们的这篇文章之后，我想起了我之前写过的这篇文章：[《看起来是线程池的BUG，但是我认为是源码设计不合理。》](https://mp.weixin.qq.com/s/NUGtJCUHXLgKgOtoffRWDw)\r\n\r\n我写的这篇就是单纯从技术角度去解析的这个问题，而“严选技术”则是从真实场景出发，层层剥茧，抵达了问题的核心。\r\n\r\n但是这两篇文章遇到的问题的核心原因其实是一模一样的。\r\n\r\n我在我的文章中的最后就有这样一段话：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1bd9272b0a943fe923b84590dc17ac1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n巧了，这不是和“严选技术”里面这句话遥相呼应起来了吗：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7891e0dd66c24f0d8467428d2b6e3989~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在我反复阅读了他们的文章，了解到了背景和原因之后，我润色了一下，写了这篇文章来“骗”你。\r\n\r\n如果你有那么几个瞬间被我“骗”到了，那么我问你一个问题：假设你是面试官，你问我工作中有没有遇到过比较棘手的问题？\r\n\r\n而我是一个只有三年工作经验的求职者。\r\n\r\n我用这篇文章中我假想出来的生产问题处理过程，并辅以技术细节，你能看出来这是我“包装”的吗？\r\n\r\n然后在描述完事件之后，再体现一下对于事件的复盘，可以说一下基于这个事情，后面自己对监控层面进行了丰富，比如接口超时率监控、GC 导致的 STW 时间监控啥的。然后也在公司内形成了“经验教训”文档，主动同步给了其他的同事，以防反复踩坑，巴拉巴拉巴拉...\r\n\r\n反正吧，以后看到自己觉得好的案例，不要看完之后就完了，多想想怎么学一学，包装成自己的东西。\r\n\r\n这波包装，属于手摸手教学了吧？\r\n\r\n求个赞，不过分吧？"
    },
    {
        "article_id": "7187214655314460709",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03330c5cbc834d499d9d97ddbd0a11fd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022转转技术年货发布啦",
        "preview": "在2023年春节来临之际，我们精选了其中46篇，整理制作成⼀本厚达400多⻚的电⼦书，作为新年礼物赠送给⼤家。这本电⼦书内容涉及前端、后端、测试、算法、数据等多个⽅向，希望能对⼤家有所帮助。",
        "author": "转转技术团队",
        "view_count": 2405,
        "collect_count": 6,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5569c2276ef448736bde1221ea5fc846~300x300.image",
        "category": "后端",
        "content": "寒⻛凛冽，旭⽇融融；时光荏苒，⽩驹过隙，很快已到2022年底。2022年注定是不平凡的⼀年，我们的抗疫取得了阶段性成果，周边明显多了些欢乐的⽓息。虽然还没彻底消散，但我们坚信胜利就在不远的将来，寒冬终将过去，春天就要到来，静待花开。\r\n\r\n今年，也是转转研发中⼼总结沉淀和⾛出去的⼀年。在这⼀年⾥，研发中⼼三个公众号《转转技术》、《⼤转转FE》和《转转QA》共计发表130余篇技术⽂章，涉及各个部⻔的⼀线实践经验。\r\n\r\n在2023年春节来临之际，我们精选了其中**46**篇，整理制作成⼀本厚达**400**多⻚的电⼦书，作为新年礼物赠送给⼤家。这本电⼦书内容涉及前端、后端、测试、算法、数据等多个⽅向，希望能对⼤家有所帮助。也欢迎⼤家转给周边感兴趣的朋友们，⼀起交流，共同成⻓。\r\n\r\n最后祝我们伟⼤的祖国⼭河⽆恙，国泰⺠安，也祝⼤家新年快乐，阖家欢乐，身体健康，⼯作顺利！\r\n\r\n**电子书获取方式**：关注「转转技术」公众号，并回复“2022转转技术年货”即可。\r\n\r\n\r\n![技术年货封面.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1336b402a8bd4a31880d27b9ac373ae9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![目录1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c2acc218384572b425a2a492a75cc6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![目录2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ce0e6009d54809b50afe08dbe2a134~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。 \r\n> 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~"
    },
    {
        "article_id": "7160962909332307981",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c86643798fb4843b11181ac5e479e23~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我的面试万字总结（Vue3+TS）",
        "preview": "又到了金九银十季，最近我也是奔波于各种面试。我自己总结整理了很多方向的前端面试题。借着国庆这个假期，也把这些题目总结分享给大家，也祝正在面试的朋友们能够拿到满意的offer。",
        "author": "逍丶",
        "view_count": 13624,
        "collect_count": 813,
        "comment_count": 30,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a87f08adcd0dad907726396180915552~300x300.image",
        "category": "前端",
        "content": "\r\n\r\n# 往期文章\r\n（1）[ 2022年我的面试万字总结（浏览器网络篇）](https://juejin.cn/post/7149438206419664927)\r\n\r\n（2）[ 2022年我的面试万字总结（CSS篇）](https://juejin.cn/post/7149716216167268366)\r\n\r\n（3）[  2022年我的面试万字总结（HTML篇）](https://juejin.cn/post/7150109570609152014)\r\n\r\n（4）[ 2022年我的面试万字总结（JS篇上） ](https://juejin.cn/post/7150462512817782815)\r\n\r\n（5）[ 2022年我的面试万字总结（JS篇下）](https://juejin.cn/editor/drafts/7150847615263834119)\r\n\r\n （6） [2022年我的面试万字总结（代码篇）](https://juejin.cn/post/7151221875224346637)\r\n \r\n （7） [2022年我的面试万字总结（Vue上）](https://juejin.cn/post/7151597651719356446)\r\n \r\n （8）[ 2022年我的面试万字总结（Vue下）](https://juejin.cn/post/7151604799077613599)\r\n \r\n （10）[ 2022年我的面试万字总结（Node、webpack、性能优化）](https://juejin.cn/post/7161292246526984228)\r\n  \r\n（11）[ 2022年我的面试万字总结（小程序、git）](https://juejin.cn/post/7161584249898795045)\r\n# 一、Vue3\r\n # 1. vue2和vue3的区别\r\n\r\n1.  监测机制的改变\r\n\r\n    -   vue3 中使用了ES6 的 `Proxy`API 对数据代理，监测的是整个对象，而不再是某个属性。\r\n    -   消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制\r\n\r\n    -   vue3可以监测到对象属性的添加和删除，可以监听数组的变化；\r\n    -   vue3支持 Map、Set、WeakMap 和 WeakSet。\r\n\r\n0.  `Vue3支持碎片(Fragments)`\r\n\r\n    -   Vue2在组件中只有一个根节点。\r\n    -   Vue3在组件可以拥有多个根节点。\r\n\r\n0.  API模式不同\r\n\r\n    -   Vue2与Vue3 `最大的`区别：Vue2使用`选项式`API（Options API）对比Vue3`组合式`API（Composition API）\r\n\r\n0.  建立数据的方式不同\r\n\r\n    -   Vue2：这里把数据放入data属性中\r\n\r\n    -   Vue3：需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。\r\n\r\n    -   使用以下三步来建立响应式数据:\r\n\r\n        -   从vue`引入ref或reactive`\r\n        -   简单数据类型使用`ref()`方法处理，复杂类型数据用`reactive()`处理\r\n        -   使用`setup()`方法来`返回`我们的响应性数据，从而我们的`template`可以`获取`这些响应性数据\r\n\r\n0.  生命周期钩子不同 — `Lifecyle Hooks`\r\n\r\n    -   setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method\r\n    -   onBeforeMount() : 组件挂载到节点上之前执行的函数。\r\n    -   onMounted() : 组件挂载完成后执行的函数。\r\n    -   onBeforeUpdate(): 组件更新之前执行的函数。\r\n    -   onUpdated(): 组件更新完成之后执行的函数。\r\n    -   onBeforeUnmount(): 组件卸载之前执行的函数。\r\n    -   onUnmounted(): 组件卸载完成后执行的函数\r\n\r\n    若组件被`<keep-alive>`包含，则多出下面两个钩子函\r\n\r\n    -   onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。\r\n    -   onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。\r\n\r\n0.  `父子传参不同`，子组件通过`defineProps()`进行接收，并且接收这个函数的返回值进行数据操作。\r\n\r\n**总结： vue3 性能更高, 体积更小, 更利于复用, 代码维护更方便**\r\n\r\n# 2. defineProperty和proxy的区别\r\n\r\nVue 在实例初始化时遍历 data 中的所有属性，并使用 `Object.defineProperty` 把这些属性全部转为 getter/setter。并 劫持各个属性 getter 和 setter，在数据变化时发布消息给订阅者，触发相应的监听回调，而这之间存在几个问题\r\n\r\n  -   初始化时需要遍历对象所有 key，如果对象层次较深，性能不好\r\n  -   通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多\r\n  -   Object.defineProperty 无法监听到数组元素的变化，只能通过劫持重写数方法\r\n  -   动态新增，删除对象属性无法拦截，只能用特定 set/delete API 代替\r\n  -   不支持 Map、Set 等数据结构\r\n\r\nVue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于`Object.defineProperty()`，其有以下特点：\r\n\r\n1.  **Proxy 直接代理整个对象而非对象属性**，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。\r\n0.  它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。\r\n0.  Proxy 可以监听数组的变化。\r\n\r\n# 3. Vue3 Diff算法和 Vue2 的区别\r\n\r\n我们知道在数据变更触发页面重新渲染，会生成虚拟 DOM 并进行 patch 过程，这一过程在 Vue3 中的优化有如下\r\n\r\n**编译阶段的优化：**\r\n\r\n-   事件缓存：将事件缓存(如: @click)，可以理解为变成静态的了\r\n-   静态提升：第一次创建静态节点时保存，后续直接复用\r\n-   添加静态标记：给节点添加静态标记，以优化 Diff 过程\r\n\r\n由于编译阶段的优化，除了能更快的生成虚拟 DOM 以外，还使得 Diff 时可以跳过\\\"永远不会变化的节点\\\"，\r\n\r\n**Diff 优化如下**\r\n\r\n-   Vue2 是全量 Diff，Vue3 是静态标记 + 非全量 Diff\r\n-   使用最长递增子序列优化了对比流程\r\n\r\n根据尤大公布的数据就是 Vue3 `update` 性能提升了 `1.3~2 倍`\r\n\r\n# 4. composition API 与 options API的区别\r\n\r\n1.  vue2 采用的就是 `optionsAPI`\r\n\r\n    (1) 优点:**`易于学习和使用`**, 每个代码有着明确的位置 (例如: 数据放 data 中, 方法放 methods中)\r\n\r\n    (2) 缺点: 相似的逻辑, 不容易复用, 在大项目中尤为明显\r\n\r\n    (3) 虽然 optionsAPI 可以通过mixins 提取相同的逻辑, 但是也并不是特别好维护\r\n\r\n0.  vue3 新增的就是 `compositionAPI`\r\n\r\n    (1) compositionAPI 是基于 **逻辑功能** 组织代码的, 一个功能 api 相关放到一起\r\n\r\n    (2) 即使项目大了, 功能多了, 也能快速定位功能相关的 api\r\n\r\n    (3) 大大的提升了 `代码可读性` 和 `可维护性`\r\n\r\n0.  vue3 推荐使用 composition API, 也保留了options API\r\n\r\n    即就算不用composition API, 用 vue2 的写法也完全兼容!!\r\n\r\n# 5. Composition API与React Hook很像，区别是什么\r\n\r\n从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制\r\n\r\n-   不能在循环、条件、嵌套函数中调用Hook\r\n-   必须确保总是在你的React函数的顶层调用Hook\r\n-   useEffect、useMemo等函数必须手动确定依赖关系\r\n\r\n而Composition API是基于Vue的响应式系统实现的，与React Hook的相比\r\n\r\n-   声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢\r\n-   Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用\r\n-   响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。\r\n\r\n虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。\r\n\r\n# 6. setup 函数\r\n\r\n`setup()` 函数是 vue3 中，专门为组件提供的新属性。它为我们使用 vue3的 `Composition API` 新特性提供了统一的入口, `setup` 函数会在 `beforeCreate` 、`created` 之前执行, vue3也是取消了这两个钩子，统一用`setup`代替, 该函数相当于一个生命周期函数，vue中过去的`data`，`methods`，`watch`等全部都用对应的新增`api`写在`setup()`函数中\r\n\r\n`setup()` 接收两个参数 `props` 和 `context`。它里面不能使用 `this`，而是通过 context 对象来代替当前执行上下文绑定的对象，context 对象有四个属性：`attrs`、`slots`、`emit`、`expose`\r\n\r\n里面通过 `ref` 和 `reactive` 代替以前的 data 语法，`return` 出去的内容，可以在模板直接使用，包括变量和方法\r\n\r\n```\r\n<template>\r\n  <div class=\\\"container\\\">\r\n    <h1 @click=\\\"say()\\\">{{msg}}</h1>\r\n  </div>\r\n</template>\r\n​\r\n<script>\r\nexport default {\r\n  setup (props,context) {\r\n    console.log('setup执行了')\r\n    console.log(this)  // undefined\r\n    // 定义数据和函数\r\n    const msg = 'hi vue3'\r\n    const say = () => {\r\n      console.log(msg)\r\n    }\r\n    // Attribute (非响应式对象，等同于 $attrs)\r\n    context.attrs\r\n    // 插槽 (非响应式对象，等同于 $slots)\r\n    context.slots\r\n    // 触发事件 (方法，等同于 $emit)\r\n    context.emit\r\n    // 暴露公共 property (函数)\r\n    context.expose\r\n​\r\n    return { msg , say}\r\n  },\r\n  beforeCreate() {\r\n    console.log('beforeCreate执行了')\r\n    console.log(this)  \r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n# 7. setup语法糖 （script setup语法）\r\n\r\nscript setup是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的 script 语法更加简洁\r\n\r\n要使用这个语法，需要将 `setup` attribute 添加到 `<script>` 代码块上：\r\n\r\n格式：\r\n\r\n```\r\n<script setup>\r\nconsole.log('hello script setup')\r\n</script>\r\n```\r\n\r\n顶层的绑定会自动暴露给模板，所以定义的变量，函数和import导入的内容都可以直接在模板中直接使用\r\n\r\n```\r\n<template>\r\n  <div>\r\n    <h3>根组件</h3>\r\n    <div>点击次数：{{ count }}</div>\r\n    <button @click=\\\"add\\\">点击修改</button>\r\n  </div>\r\n</template>\r\n​\r\n<script setup>\r\nimport { ref } from 'vue'\r\n​\r\nconst count = ref(0)\r\nconst add = () => {\r\n  count.value++\r\n}\r\n</script>\r\n```\r\n\r\n使用 `setup` 语法糖时，不用写 `export default {}`，子组件只需要 `import` 就直接使用，不需要像以前一样在 components 里注册，属性和方法也不用 return。\r\n\r\n并且里面不需要用 `async` 就可以直接使用 `await`，因为这样默认会把组件的 `setup` 变为 `async setup`\r\n\r\n用语法糖时，props、attrs、slots、emit、expose 的获取方式也不一样了\r\n\r\n3.0~3.2版本变成了通过 import 引入的 API：`defineProps`、`defineEmit`、`useContext`(在3.2版本已废弃)，useContext 的属性 `{ emit, attrs, slots, expose }`\r\n\r\n3.2+版本不需要引入，而直接调用：`defineProps`、`defineEmits`、`defineExpose`、`useSlots`、`useAttrs`\r\n\r\n# 8. reactive、 shallowReactive 函数\r\n\r\n**reactive**\r\n\r\n`reactive()` 函数接收一个普通对象，返回一个响应式的数据对象, 相当于 `Vue 2.x` 中的 `Vue.observable()` API，响应式转换是“深层”的——它影响所有嵌套属性。基于proxy来实现，想要使用创建的响应式数据也很简单，创建出来之后，在`setup`中`return`出去，直接在`template`中调用即可\r\n\r\n**shallowReactive**\r\n\r\n创建一个响应式代理，它跟踪其自身属性的响应性`shallowReactive`生成非递归响应数据，只监听第一层数据的变化，但不执行嵌套对象的深层响应式转换 (暴露原始值)。\r\n\r\n# 9. ref、 shallowRef 、isRef、toRefs 函数\r\n\r\n**ref**\r\n\r\n`ref()` 函数用来根据给定的值创建一个响应式的数据对象，`ref()` 函数调用的返回值是一个对象，这个对象上只包含一个 `value` 属性, 只在setup函数内部访问`ref`函数需要加`.value`，其用途创建独立的原始值\r\n\r\n`reactive` 将解包所有深层的 `refs`，同时维持 ref 的响应性。当将 `ref`分配给 `reactive` property 时，ref 将被自动解包\r\n\r\n\r\n![a1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9cc17c3983d423e833219ba6a7f1b2f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**shallowRef**\r\n\r\n`ref()` 的浅层作用形式。`shallowRef()` 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成\r\n\r\n**isRef**\r\n\r\n`isRef()` 用来判断某个值是否为 `ref()` 创建出来的对象\r\n\r\n**toRefs**\r\n\r\n**使用场景: 如果对一个响应数据, 进行解构 或者 展开, 会丢失他的响应式特性!**\r\n\r\n原因: vue3 底层是对 对象 进行监听劫持\r\n\r\n作用: 对一个响应式对象的所有内部属性, 都做响应式处理\r\n\r\n1.  reactive/ref的响应式功能是赋值给对象的, 如果给对象解构或者展开, 会让数据丢失响应式的能力\r\n0.  **使用 toRefs 可以保证该对象展开的每个属性都是响应式的**\r\n\r\n# 10. readonly、isReadonly、shallowReadonly函数\r\n\r\n**readonly**\r\n\r\n传入`ref`或 `reactive`对象,并返回一个原始对象的只读代理,对象内部任何嵌套的属性也都是只读的、 并且是递归只读。\r\n\r\n**isReadonly**\r\n\r\n检查对象是否是由 `readonly` 创建的只读对象\r\n\r\n**shallowReadonly**\r\n\r\n`shallowReadonly` 作用只处理对象最外层属性的响应式（浅响应式）的只读，但不执行嵌套对象的深度只读转换 (暴露原始值)\r\n\r\n## `readonly`和`const`有什么区别？\r\n\r\n-   `const`是赋值保护，使用`const`定义的变量，该变量不能重新赋值。但如果`const`赋值的是对象，那么对象里面的东西是可以改的。原因是`const`定义的变量不能改说的是，对象对应的那个地址不能改变\r\n-   而`readonly`是属性保护，不能给属性重新赋值\r\n\r\n# 11.computed、watch函数\r\n\r\n**computed**\r\n\r\n该函数用来创造计算属性，和过去一样，它返回的值是一个ref对象。 里面可以传方法，或者一个对象，对象中包含`set()`、`get()`方法\r\n\r\n**watch**\r\n\r\n`watch` 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源数据变更时才执行回调。\r\n\r\n```\r\n// 监听单个ref\r\nconst money = ref(100)\r\nwatch(money, (value, oldValue) => {\r\n  console.log(value)\r\n})\r\n​\r\n// 监听多个ref\r\nconst money = ref(100)\r\nconst count = ref(0)\r\nwatch([money, count], (value) => {\r\n  console.log(value)\r\n})\r\n​\r\n// 监听ref复杂数据\r\nconst user = ref({\r\n  name: 'zs',\r\n  age: 18,\r\n})\r\nwatch(\r\n  user,\r\n  (value) => {\r\n    console.log('user变化了', value)\r\n  },\r\n  {\r\n    // 深度监听，，，当ref的值是一个复杂数据类型，需要深度监听\r\n    deep: true,\r\n    immediate: true\r\n  }\r\n)\r\n​\r\n// 监听对象的某个属性的变化\r\nconst user = ref({\r\n  name: 'zs',\r\n  age: 18,\r\n})\r\nwatch(\r\n  () => user.value.name,\r\n  (value) => {\r\n    console.log(value)\r\n  }\r\n)\r\n```\r\n\r\n# 11. watch 和 watchEffect 的区别\r\n\r\n`watch` 作用是对传入的某个或多个值的变化进行监听；触发时会返回新值和老值；也就是说第一次不会执行，只有变化时才会重新执行\r\n\r\n`watchEffect` 是传入一个函数,会立即执行，所以**默认第一次也会执行一次**；不需要传入监听内容，会**自动收集函数内的数据源作为依赖**，在依赖变化的时候又会重新执行该函数，如果没有依赖就不会执行；而且不会返回变化前后的新值和老值\r\n\r\n共同点是 `watch` 和 `watchEffect` 会共享以下四种行为：\r\n\r\n-   `停止监听`：组件卸载时都会自动停止监听\r\n-   `清除副作用`：onInvalidate 会作为回调的第三个参数传入\r\n-   `副作用刷新时机`：响应式系统会缓存副作用函数，并异步刷新，避免同一个 tick 中多个状态改变导致的重复调用\r\n-   `监听器调试`：开发模式下可以用 onTrack 和 onTrigger 进行调试\r\n\r\n# 12. Vue3 的生命周期\r\n\r\n基本上就是在 Vue2 生命周期钩子函数名基础上加了 `on`；beforeDestory 和 destoryed 更名为 onBeforeUnmount 和 onUnmounted；然后用setup代替了两个钩子函数 beforeCreate 和 created；新增了两个开发环境用于调试的钩子\r\n\r\n\r\n![Snipaste_2022-08-18_20-03-05.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8832a11723a4c9e9d495fcfa336a6c9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 13. setup语法下怎么设置name属性\r\n\r\n1.  安装插件\r\n\r\n    yarn add vite-plugin-vue-setup-extend -D\r\n\r\n0.  配置 vite.config.ts\r\n\r\n```\r\nimport vueSetupExtend from 'vite-plugin-vue-setup-extend'\r\n​\r\nexport default defineConfig({\r\n  plugins: [vue(), vueSetupExtend()],\r\n})\r\n```\r\n\r\n3.  在标签中使用\r\n\r\n```\r\n<script setup name=\\\"MyCom\\\">\r\n    // 必须在script标签里面写一点类容，这个插件才会生效,哪怕是注释\r\n</script>\r\n```\r\n\r\n# 14. Vue3怎么让全局组件有提示\r\n\r\nvue3中如果注册的是局部组件，那么props是有类型提示的,但是如果注册的是全局组件，props就没有类型提示了\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37e98dc55fe7433d890be0a651120cd7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**解决办法**\r\n\r\n```\r\n// 在src目录下新建一个文件 global.d.ts\r\nimport XtxSkeleton from '@/components/XtxSkeleton/XtxSkeleton.vue'\r\n// 参考：\r\ndeclare module 'vue' {\r\n  export interface GlobalComponents {\r\n    XtxSkeleton: typeof XtxSkeleton\r\n  }\r\n}\r\nexport {}\r\n```\r\n\r\n# 15. Vue3怎么注册全局自定义指令\r\n\r\n```\r\napp.directive('lazy'，{  // app.directive('指令名‘，配置对象)\r\n    mounted(el){\r\n        .......\r\n    }\r\n})\r\n```\r\n\r\n# 16. Vite 和Webpack的区别\r\n\r\n-   都是现代化打包工具\r\n-   启动方式不一样。vite在启动的时候不需要打包，所以不用分析模块与模块之间的依赖关系，不用进行编译。这种方式就类似于我们在使用某个UI框架的时候，可以对其进行按需加载。同样的，vite也是这种机制，当浏览器请求某个模块时，再根据需要对模块内容进行编译。按需动态编译可以缩减编译时间，当项目越复杂，模块越多的情况下，vite明显优于webpack.\r\n-   热更新方面，效率更高。当改动了某个模块的时候，也只用让浏览器重新请求该模块，不需要像webpack那样将模块以及模块依赖的模块全部编译一次。\r\n\r\n**缺点**\r\n\r\n-   vite相关生态没有webpack完善，vite可以作为开发的辅助。\r\n\r\n# 17. pinia的好处\r\n\r\n-   pinia和vuex4一样，也是vue **官方** 状态管理工具(作者是 Vue 核心团队成员）\r\n\r\n-   pinia相比vuex4，对于vue3的 **兼容性** 更好\r\n\r\n-   pinia相比vuex4，具备完善的 **类型推荐** => 对 TS 支持很友好\r\n\r\n-   pinia同样支持vue开发者工具\r\n\r\n-   **Pinia** 的 API 设计非常接近 Vuex 5 的提案\r\n\r\n    **pinia核心概念**\r\n\r\n    -   state: 状态\r\n    -   actions: 修改状态（包括同步和异步，pinia中没有mutations）\r\n    -   getters: 计算属性\r\n\r\n    vuex只能有一个根级别的状态, pinia 直接就可以定义多个根级别状态\r\n\r\n# 18. Vue3的v-model语法\r\n\r\n0.  父组件给子组件传入一个modelValue的属性\r\n0.  子组件通知父组件的update:modelValue事件，将修改后的值传给父组件\r\n0.  父组件监听 update:modelValue，修改对应的值\r\n\r\n```\r\n// 父组件\r\n// 原生写法\r\n<son :model-value=\\\"money\\\" @update:modelValue=\\\"val=>money = val\\\" />\r\n// v-mode语法糖写法\r\n<son v-model=\\\"money\\\" v-mode:house=\\\"house\\\" />\r\n    \r\n    \r\n // 子组件\r\n<button @click=\\\"$emit('update:modelValue',modelValue+100)\\\">点我加钱 </button>\r\n```\r\n\r\n**好处是什么**\r\n\r\n为了整合 .sync和v-model\r\n\r\n在Vue2中，v-mode只能绑定一个属性，如果需要绑定多个属性则需要借助.sync修饰符\r\n\r\n.sync修饰符在Vue3中已被移除，直接被v-model取代。\r\n\r\n# 二、TS\r\n\r\n# 1. TypeScript 是什么\r\n\r\nTypeScript，简称 ts，是微软开发的一种静态的编程语言，它是 JavaScript 的超集。 那么它有什么特别之处呢?\r\n\r\n1.  简单来说，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。\r\n0.  ts 支持类型支持，ts = type +JavaScript。\r\n\r\n\r\n![Snipaste_2022-08-18_20-15-54.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c2918a13b2f44108fc35c6033fb6577~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 2. TypeScript 与 JavaScript 的区别\r\n\r\n\r\n![Snipaste_2022-08-18_20-16-41.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e7d666a20b42939d300e8cd1a2ef71~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 3.TypeScript的类型\r\n\r\n## ①、 基础类型\r\n\r\n### 1.1 Boolean 、Number 、String 、Symbol\r\n\r\n```\r\nlet isDone: boolean = false;\r\n// ES5：var isDone = false;\r\n```\r\n\r\n```\r\nlet count: number = 10;\r\n// ES5：var count = 10;\r\n```\r\n\r\n```\r\nlet name: string = \\\"semliker\\\";\r\n// ES5：var name = 'semlinker';\r\n```\r\n\r\n```\r\nconst sym = Symbol();\r\nlet obj = {\r\n  [sym]: \\\"semlinker\\\",\r\n};\r\n​\r\nconsole.log(obj[sym]); // semlinker \r\n```\r\n\r\n### 1.2 Array、Tuple (元组)\r\n\r\n```\r\nlet list: number[] = [1, 2, 3];\r\n// ES5：var list = [1,2,3];\r\n​\r\nlet list: Array<number> = [1, 2, 3]; // Array<number>泛型语法\r\n// ES5：var list = [1,2,3];\r\n​\r\n```\r\n\r\n**Tuple**\r\n\r\n**数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组**。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。\r\n\r\n元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。\r\n\r\n```\r\nlet position: [number, number] = [39.5427, 116.2317]\r\n```\r\n\r\n### 1.3 undefined 、 null\r\n\r\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。\r\n\r\n```\r\nlet age: number = null\r\nlet realName: string = undefined\r\n```\r\n\r\n### 1.4 any、unknown 、never\r\n\r\n**any**\r\n\r\n在 TypeScript 中，任何类型都可以被归为 `any` 类型。这让`any`类型成为了类型系统的顶级类型（也被称作全局超级类型）。但是不建议使用 any，不然就丧失了 TS 提供的保护机制，失去了使用TS的意义。\r\n\r\n**unknown**\r\n\r\n所有类型也都可以赋值给 `unknown`。这使得 `unknown` 成为 TypeScript 类型系统的另一种顶级类型（另一种是 `any`）。它的定义和 `any` 定义很像，但是它是一个安全类型，使用 `unknown` 做任何事情都是不合法的。\r\n\r\n**never**\r\n\r\n`never`类型表示的是那些永不存在的值的类型。\r\n\r\n有些情况下值会永不存在，比如，\r\n\r\n-   如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。\r\n\r\n-   函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。\r\n\r\n    never 类型是任何类型的子类型，也可以赋值给任何类型。\r\n\r\n    **没有类型是 never 的子类型**，没有类型可以赋值给 never 类型（除了 never 本身之外）。 即使 `any`也不可以赋值给 never 。\r\n\r\n## ②、 函数类型\r\n\r\n-   函数的类型实际上指的是：`函数参数`和`返回值`的类型\r\n\r\n-   为函数指定类型的两种方式：\r\n\r\n    1.  单独指定参数、返回值的类型\r\n    0.  同时指定参数、返回值的类型\r\n\r\n**单独指定参数、返回值的类型**：\r\n\r\n```\r\n// 函数声明\r\nfunction add(num1: number, num2: number): number {\r\n  return num1 + num2\r\n}\r\n​\r\n// 箭头函数\r\nconst add = (num1: number, num2: number): number => {\r\n  return num1 + num2\r\n}\r\n```\r\n\r\n**同时指定参数、返回值的类型:**\r\n\r\n```\r\ntype AddFn = (num1: number, num2: number) => number\r\n​\r\nconst add: AddFn = (num1, num2) => {\r\n  return num1 + num2\r\n}\r\n```\r\n\r\n### 2.2 void 类型\r\n\r\n如果函数没有返回值，那么，函数返回值类型为：`void`\r\n\r\n```\r\nfunction greet(name: string): void {\r\n  console.log('Hello', name)\r\n}\r\n```\r\n\r\n注意：\r\n\r\n-   如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 `void` 类型\r\n\r\n```\r\n// 如果什么都不写，此时，add 函数的返回值类型为： void\r\nconst add = () => {}\r\n// 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同\r\nconst add = (): void => {}\r\n​\r\n// 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以\r\nconst add = (): undefined => {\r\n  // 此处，返回的 undefined 是 JS 中的一个值\r\n  return undefined\r\n}\r\n```\r\n\r\n### **2.3 可选参数**\r\n\r\n-   使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到**可选参数**了\r\n-   比如，数组的 slice 方法，可以 `slice()` 也可以 `slice(1)` 还可以 `slice(1, 3)`\r\n\r\n```\r\nfunction mySlice(start?: number, end?: number): void {\r\n  console.log('起始索引：', start, '结束索引：', end)\r\n}\r\n```\r\n\r\n-   可选参数：在可传可不传的参数名称后面添加 `?`（问号）\r\n-   注意：**可选参数只能出现在参数列表的最后**，也就是说可选参数后面不能再出现必选参数\r\n\r\n### 2.4 默认参数\r\n\r\n跟 JS 的写法一样，在入参里定义初始值。\r\n\r\n和可选参数不同的是，默认参数可以不放在函数入参的最后面\r\n\r\n### 2.5 函数重载\r\n\r\n函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。\r\n\r\n不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。\r\n\r\n## ③、 对象类型\r\n\r\nJS 中的对象是由属性和方法构成的，而 **TS 对象的类型就是在描述对象的结构**（有什么类型的属性和方法）\r\n\r\n对象类型的写法:\r\n\r\n```\r\n// 空对象\r\nlet person: {} = {}\r\n​\r\n// 有属性的对象\r\nlet person: { name: string } = {\r\n  name: '同学'\r\n}\r\n​\r\n// 既有属性又有方法的对象\r\n// 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔\r\nlet person: { name: string; sayHi(): void } = {\r\n  name: 'jack',\r\n  sayHi() {}\r\n}\r\n​\r\n// 对象中如果有多个类型，可以换行写：\r\n// 通过换行来分隔多个属性类型，可以去掉 `;`\r\nlet person: {\r\n  name: string\r\n  sayHi(): void\r\n} = {\r\n  name: 'jack',\r\n  sayHi() {}\r\n}\r\n​\r\n// 方法的类型也可以使用箭头函数形式\r\n{\r\n    greet(name: string):string,\r\n    greet: (name: string) => string\r\n}\r\n```\r\n\r\n### 3.2 对象可选属性\r\n\r\n-   对象的属性或方法，也可以是可选的，此时就用到**可选属性**了\r\n-   比如，我们在使用 `axios({ ... })` 时，如果发送 GET 请求，method 属性就可以省略\r\n-   可选属性的语法与函数可选参数的语法一致，都使用 `?` 来表示\r\n\r\n```\r\ntype Config = {\r\n  url: string\r\n  method?: string\r\n}\r\n​\r\nfunction myAxios(config: Config) {\r\n  console.log(config)\r\n}\r\n```\r\n\r\n## ④、 interface 接口类型\r\n\r\n当一个对象类型被多次使用时，一般会使用接口（`interface`）来描述对象的类型，达到复用的目的\r\n\r\n-   解释：\r\n\r\n    0.  使用 `interface` 关键字来声明接口\r\n    0.  接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 `I` 开头\r\n    0.  声明接口后，直接使用接口名称作为变量的类型\r\n    0.  因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号)\r\n\r\n```\r\ninterface IPerson {\r\n  name: string\r\n  age: number\r\n  sayHi(): void\r\n}\r\n​\r\n​\r\nlet person: IPerson = {\r\n  name: 'jack',\r\n  age: 19,\r\n  sayHi() {}\r\n}\r\n```\r\n\r\n### 4.2 接口继承\r\n\r\n-   如果两个接口之间有相同的属性或方法，可以将**公共的属性或方法抽离出来，通过继承来实现复用**\r\n-   比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐\r\n\r\n```\r\ninterface Point2D { x: number; y: number }\r\n// 继承 Point2D\r\ninterface Point3D extends Point2D {\r\n  z: number\r\n}\r\n```\r\n\r\n### 4.3 interface 和 type的区别\r\n\r\n-   interface（接口）和 type（类型别名）的对比：\r\n\r\n-   相同点：都可以给对象指定类型\r\n\r\n-   不同点:\r\n\r\n    -   **interface** ：\r\n\r\n        -   只能为对象指定类型\r\n        -   可以使用extends继承\r\n        -   多个同名的interface会合并\r\n\r\n    -   **type**：\r\n\r\n        -   不仅可以为对象指定类型，实际上可以为任意类型指定别名\r\n        -   可以使用&运算符实现继承效果\r\n        -   多个同名的type会报错\r\n\r\n## ⑤、 联合类型\r\n\r\n```\r\nlet arr: (number | string)[] = [1, 'a', 3, 'b']\r\n```\r\n\r\n-   解释：`|`（竖线）在 TS 中叫做**联合类型**，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种\r\n-   注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了\r\n\r\n## ⑥、字面量类型、枚举(enum)类型\r\n\r\n**字面量类型**\r\n\r\n```\r\nconst str = 'Hello TS'\r\n```\r\n\r\n  str 是一个常量(const)，它的值不能变化只能是 'Hello TS'，所以，它的类型为:'Hello TS'\r\n\r\n-   注意：此处的 'Hello TS'，就是一个**字面量类型**，也就是说某个特定的字符串也可以作为 TS 中的类型\r\n\r\n-   任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用\r\n\r\n    -   字面量：`{ name: 'jack' }` `[]` `18` `20` `'abc'` `false` `function() {}`\r\n\r\n**枚举类型**\r\n\r\n在任何项目开发中，我们都会遇到定义常量的情况，常量就是指不会被改变的值。\r\n\r\nTS 中我们使用 `const` 来声明常量，但是有些取值是在一定范围内的一系列常量，比如一周有七天，比如方向分为上下左右四个方向。\r\n\r\n这时就可以使用枚举（Enum）来定义。\r\n\r\n```\r\n// 创建枚举\r\nenum Direction { Up, Down, Left, Right }\r\n​\r\n// 使用枚举类型\r\nfunction changeDirection(direction: Direction) {\r\n  console.log(direction)\r\n}\r\n​\r\n// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个\r\n// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员\r\nchangeDirection(Direction.Up)\r\n```\r\n\r\n**枚举实现原理**\r\n\r\n-   枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一\r\n-   因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)\r\n-   也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，**枚举类型会被编译为 JS 代码**\r\n\r\n```\r\nenum Direction {\r\n  Up = 'UP',\r\n  Down = 'DOWN',\r\n  Left = 'LEFT',\r\n  Right = 'RIGHT'\r\n}\r\n​\r\n// 会被编译为以下 JS 代码：\r\nvar Direction;\r\n​\r\n(function (Direction) {\r\n  Direction['Up'] = 'UP'\r\n  Direction['Down'] = 'DOWN'\r\n  Direction['Left'] = 'LEFT'\r\n  Direction['Right'] = 'RIGHT'\r\n})(Direction || Direction = {})\r\n```\r\n\r\n-   说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表\r\n-   一般情况下，**推荐使用字面量类型+联合类型组合的方式**，因为相比枚举，这种方式更加直观、简洁、高效\r\n\r\n# 4. TS中的class类的关键字\r\n\r\n**extends**\r\n\r\n在 TypeScript 中，我们可以通过 `extends` 关键字来实现继承\r\n\r\n**super**\r\n\r\n子类没有定义自己的属性，可以不写 super ，但是如果子类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。\r\n\r\n**public**\r\n\r\n`public`，公有的，一个类里默认所有的方法和属性都是 public。\r\n\r\n**private**\r\n\r\n`private`，私有的，只属于这个类自己，它的实例和继承它的子类都访问不到。\r\n\r\n**protected**\r\n\r\n`protected` 受保护的，继承它的子类可以访问，实例不能访问。\r\n\r\n**static**\r\n\r\n`static` 是静态属性，可以理解为是类上的一些常量，实例不能访问。\r\n\r\n**abstract**\r\n\r\n`abstract` 关键字来定义抽象类和抽象方法\r\n\r\n抽象类，是指**只能被继承，但不能被实例化的类**，就这么简单。\r\n\r\n抽象类有两个特点：\r\n\r\n-   抽象类不允许被实例化\r\n-   抽象类中的抽象方法必须被子类实现\r\n\r\n**# （私有字段）**\r\n\r\n私有字段与常规属性（甚至使用 `private` 修饰符声明的属性）不同，私有字段要牢记以下规则：\r\n\r\n-   私有字段以 `#` 字符开头，有时我们称之为私有名称；\r\n-   每个私有字段名称都唯一地限定于其包含的类；\r\n-   不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；\r\n-   私有字段不能在包含的类之外访问，甚至不能被检测到。\r\n\r\n# 5. 类型推断、类型断言、非空断言\r\n\r\n## 5.1 **类型推断**\r\n\r\n在 TS 中，某些没有明确指出类型的地方，**TS 的类型推论机制会帮助提供类型** 换句话说：由于类型推论的存在，有些场合下的类型注解可以省略不写\r\n\r\n发生类型推论的 2 种常见场景:\r\n\r\n0.  声明变量并初始化时\r\n0.  决定函数返回值时\r\n\r\n```\r\n// 变量 age 的类型被自动推断为：number\r\nlet age = 18\r\n​\r\n// 函数返回值的类型被自动推断为：number\r\nfunction add(num1: number, num2: number) {\r\n  return num1 + num2\r\n}\r\n```\r\n\r\n## 5.2 **类型断言**\r\n\r\n有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定**更具体**的类型。\r\n\r\n类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\r\n\r\n```\r\nconst aLink = document.getElementById('link') as HTMLAnchorElement\r\n```\r\n\r\n另一种语法，使用 `<>` 语法，这种语法形式不常用，知道即可:\r\n\r\n```\r\n// 尖括号语法，知道即可：\r\nconst aLink = <HTMLAnchorElement>document.getElementById('link')\r\n```\r\n\r\n## 5.3 **非空断言**\r\n\r\n在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 `!` 可以用于断言操作对象是非 null 和非 undefined 类型。**具体而言，x! 将从 x 值域中排除 null 和 undefined 。**\r\n\r\n```\r\nconst aLink = document.getElementById('link')! \r\n //如果没有非空断言，使用aLink时会报错，因为页面可能没有link这个标签，得到的就是undefined\r\n```\r\n\r\n# 6. 泛型\r\n\r\n## 6.1 泛型-基本介绍\r\n\r\n-   **泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用**，常用于：函数、接口、class 中\r\n-   需求：创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同)\r\n\r\n```\r\nfunction id(value: number): number { return value }\r\n```\r\n\r\n-   比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型\r\n-   为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全\r\n\r\n```\r\nfunction id(value: any): any { return value }\r\n```\r\n\r\n-   **泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用**\r\n-   实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一\r\n\r\n## 6.2 泛型函数\r\n\r\n定义泛型函数\r\n\r\n```\r\nfunction id<Type>(value: Type): Type { return value }\r\n​\r\nfunction id<T>(value: T): T { return value }\r\n```\r\n\r\n-   解释:\r\n\r\n    1.  语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中添加类型变量**，比如此处的 Type\r\n    0.  **类型变量 Type，是一种特殊类型的变量，它处理类型而不是值**\r\n    0.  **该类型变量相当于一个类型容器**，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定)\r\n    0.  因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型\r\n    0.  类型变量 Type，可以是任意合法的变量名称\r\n\r\n调用泛型函数\r\n\r\n```\r\nconst num = id<number>(10)\r\nconst str = id<string>('a')\r\n```\r\n\r\n-   解释：\r\n\r\n    1.  语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中指定具体的类型**，比如，此处的 number\r\n    0.  当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到\r\n    0.  此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number\r\n\r\n-   同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string\r\n\r\n-   这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，**实现了复用的同时保证了类型安全**\r\n\r\n**简化泛型函数调用**\r\n\r\n```\r\n// 省略 <number> 调用函数\r\nlet num = id(10)\r\nlet str = id('a')\r\n```\r\n\r\n-   解释:\r\n\r\n    1.  在调用泛型函数时，**可以省略 `<类型>` 来简化泛型函数的调用**\r\n    0.  此时，TS 内部会采用一种叫做**类型参数推断**的机制，来根据传入的实参自动推断出类型变量 Type 的类型\r\n    0.  比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型\r\n\r\n-   推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读\r\n\r\n-   说明：**当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数**\r\n\r\n## 6.3 泛型约束\r\n\r\n-   默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性\r\n-   比如，id('a') 调用函数时获取参数的长度：\r\n\r\n```\r\nfunction id<Type>(value: Type): Type {\r\n  console.log(value.length)\r\n  return value\r\n}\r\n​\r\nid('a')\r\n```\r\n\r\n-   解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length\r\n-   此时，就需要**为泛型添加约束来`收缩类型`(缩窄类型取值范围)**\r\n-   添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束\r\n\r\n**指定更加具体的类型**\r\n\r\n比如，将类型修改为 `Type[]`(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了\r\n\r\n```\r\nfunction id<Type>(value: Type[]): Type[] {\r\n  console.log(value.length)\r\n  return value\r\n}\r\n```\r\n\r\n**添加约束**\r\n\r\n```\r\n// 创建一个接口\r\ninterface ILength { length: number }\r\n​\r\n// Type extends ILength 添加泛型约束\r\n// 解释：表示传入的 类型 必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性\r\nfunction id<Type extends ILength>(value: Type): Type {\r\n  console.log(value.length)\r\n  return value\r\n}\r\n```\r\n\r\n-   解释:\r\n\r\n    1.  创建描述约束的接口 ILength，该接口要求提供 length 属性\r\n    0.  通过 `extends` 关键字使用该接口，为泛型(类型变量)添加约束\r\n    0.  该约束表示：**传入的类型必须具有 length 属性**\r\n\r\n-   注意:传入的实参(比如，数组)只要有 length 属性即可（类型兼容性)\r\n\r\n## 6.4 多个类型变量\r\n\r\n泛型的类型变量可以有多个，并且**类型变量之间还可以约束**(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值：\r\n\r\n```\r\nfunction getProp<Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet person = { name: 'jack', age: 18 }\r\ngetProp(person, 'name')\r\n```\r\n\r\n-   解释:\r\n\r\n    1.  添加了第二个类型变量 Key，两个类型变量之间使用 `,` 逗号分隔。\r\n    0.  **keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型**。\r\n    0.  本示例中 `keyof Type` 实际上获取的是 person 对象所有键的联合类型，也就是：`'name' | 'age'`\r\n    0.  类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性\r\n\r\n```\r\n// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错\r\n// 如果要用到 对象 类型，应该用 object ，而不是 Object\r\nfunction getProperty<Type extends object, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\n```\r\n\r\n\r\n\r\n## 6.5 泛型接口\r\n\r\n泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性\r\n\r\n```\r\ninterface IdFunc<Type> {\r\n  id: (value: Type) => Type\r\n  ids: () => Type[]\r\n}\r\n​\r\nlet obj: IdFunc<number> = {\r\n  id(value) { return value },\r\n  ids() { return [1, 3, 5] }\r\n}\r\n```\r\n\r\n-   解释:\r\n\r\n    1.  在接口名称的后面添加 `<类型变量>`，那么，这个接口就变成了泛型接口。\r\n    0.  接口的类型变量，对接口中所有其他成员可见，也就是**接口中所有成员都可以使用类型变量**。\r\n    0.  使用泛型接口时，**需要显式指定具体的类型**(比如，此处的 IdFunc<nunber>)。\r\n    0.  此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。\r\n\r\n# 7. TS内置的常用工具类型\r\n\r\n## 7.1 typeof\r\n\r\n在 TypeScript 中，`typeof` 操作符可以用来获取一个变量声明或对象的类型。\r\n\r\n```\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\n​\r\nconst sem: Person = { name: 'semlinker', age: 33 };\r\ntype Sem= typeof sem; // -> Person\r\n​\r\nfunction toArray(x: number): Array<number> {\r\n  return [x];\r\n}\r\n​\r\ntype Func = typeof toArray; // -> (x: number) => number[]\r\n​\r\n```\r\n\r\n## 7.2 keyof\r\n\r\n`keyof` 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。\r\n\r\n```\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\n​\r\ntype K1 = keyof Person; // \\\"name\\\" | \\\"age\\\"\r\ntype K2 = keyof Person[]; // \\\"length\\\" | \\\"toString\\\" | \\\"pop\\\" | \\\"push\\\" | \\\"concat\\\" | \\\"join\\\" \r\ntype K3 = keyof { [x: string]: Person };  // string | number\r\n​\r\n```\r\n\r\n## 7.3 in\r\n\r\n`in` 用来遍历枚举类型：\r\n\r\n```\r\ntype Keys = \\\"a\\\" | \\\"b\\\" | \\\"c\\\"\r\n​\r\ntype Obj =  {\r\n  [p in Keys]: any\r\n} // -> { a: any, b: any, c: any }\r\n```\r\n\r\n## 7.4 infer\r\n\r\n在条件类型语句中，可以用 `infer` 声明一个类型变量并且对它进行使用。\r\n\r\n```\r\ntype ReturnType<T> = T extends (\r\n  ...args: any[]\r\n) => infer R ? R : any;\r\n```\r\n\r\n以上代码中 `infer R` 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\r\n\r\n## 7.5 extends\r\n\r\n有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。\r\n\r\n```\r\ninterface Lengthwise {\r\n  length: number;\r\n}\r\n​\r\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\r\n  console.log(arg.length);\r\n  return arg;\r\n}\r\n​\r\n```\r\n\r\n## 7.6 Partial、Readonly、Required\r\n\r\n`Partial<T>` 的作用就是将某个类型里的属性全部变为可选项 `?`。\r\n\r\n```\r\ntype Partial<T> = {\r\n  [P in keyof T]?: T[P];\r\n};\r\n```\r\n\r\n在以上代码中，首先通过 `keyof T` 拿到 `T` 的所有属性名，然后使用 `in` 进行遍历，将值赋给 `P`，最后通过 `T[P]` 取得相应的属性值。中间的 `?` 号，用于将所有属性变为可选。\r\n\r\n\r\n`Readonly<T>`\r\n\r\n将 T 中的所有属性设置为只读\r\n\r\n\r\n`Required<T>`\r\n\r\n将 T 中的所有属性设置为必须\r\n\r\n## 7.7 Omit\r\n\r\n`Omit<T, U>`从类型 `T` 中剔除 `U` 中的所有属性\r\n\r\n```\r\ninterface IPerson {\r\n    name: string\r\n    age: number\r\n}\r\n​\r\ntype IOmit = Omit<IPerson, 'age'>\r\n// 这样就剔除了 IPerson 上的 age 属性。\r\n```\r\n\r\n# 8. Vue3中父子传值 , 用TS怎么写，怎么设置默认值\r\n\r\n```\r\n// 用泛型来约束收到的数据\r\n// TS的defineProps写法 , defineProps<....>()\r\nconst {msg='123'}defineProps<{  //设置默认值需要解构，并且添加全局配置\r\n  msg？: string,\r\n  arr: { name: string }[]\r\n}>()\r\n// 用TS来子传父  defineEmits<(...):void>()\r\nconst emit = defineEmits<{\r\n  (e: 'changeMsg', val: string): void\r\n  (e: 'addMsg'): void\r\n}>()\r\n```\r\n\r\n**默认值的全局配置**\r\n\r\n\r\n![Snipaste_2022-08-23_14-52-51.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49e51ed60ae145ee916b2ca490a293ef~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 9. TS怎么给引入的第三方库设置类型声明文件\r\n\r\n-   目前，几乎所有常用的第三方库都有相应的类型声明文件\r\n\r\n-   第三方库的类型声明文件有两种存在形式：\r\n\r\n    -   1 、库自带类型声明文件\r\n    -   2、 由 TS官方给它写的（DefinitelyTyped 提供）\r\n\r\n**库自带类型声明文件**：比如，axios\r\n\r\n这种情况下，正常导入该库，**TS 就会自动加载库自己的类型声明文件**，以提供该库的类型声明。\r\n\r\n**由 DefinitelyTyped 提供**：\r\n\r\n-   DefinitelyTyped 是一个 github 仓库，用来提供高质量 TypeScript 类型声明\r\n-   可以通过 npm/yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为:`@types/*`比如，@types/react、@types/lodash 等\r\n-   在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示\r\n\r\n# 10. 说说你对 TypeScript 装饰器的理解？\r\n\r\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上\r\n\r\n是一种在不改变原类和使用继承的情况下，动态地扩展对象功能\r\n\r\n同样的，本质也不是什么高大上的结构，就是一个普通的函数，`@expression` 的形式其实是`Object.defineProperty`的语法糖\r\n\r\n`expression`求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\r\n\r\n# 11. 说说对 TypeScript 中命名空间与模块的理解\r\n\r\n**模块**\r\n\r\n`TypeScript` 与`ECMAScript` 2015 一样，任何包含顶级 `import` 或者 `export` 的文件都被当成一个模块\r\n\r\n相反地，如果一个文件不带有顶级的`import`或者`export`声明，那么它的内容被视为全局可见的\r\n\r\n**命名空间**\r\n\r\n命名空间一个最明确的目的就是解决重名问题\r\n\r\n命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的\r\n\r\n这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中\r\n\r\n# 12. TS怎么自定义类型声明文件\r\n\r\n**如下两种场景需要提供类型声明文件**\r\n\r\n0.  项目内共享类型\r\n0.  为已有 JS 文件提供类型声明\r\n\r\n## 12.1 项目内共享类型\r\n\r\n将公共的类型定义提取出来，写在index.d.ts文件中 , 并导出\r\n\r\n```\r\nexport interface Token {\r\n  token: string\r\n  refreshToken: string\r\n}\r\n```\r\n\r\n导入接口并使用\r\n\r\n```\r\n<script setup lang='ts'>\r\nimport {Token} from '.' \r\nfunction fn(token:Token){\r\n  \r\n}\r\n</script>\r\n```\r\n\r\n## 12.2 为已有 JS 文件提供类型声明\r\n\r\n**编写同名的.d.ts文件**\r\n\r\n```\r\ndemo.ts\r\nutils/index.js\r\nutils/index.d.ts // 这里是重点\r\n```\r\n\r\n**定义类型声明文件**\r\n\r\n1.  它的作用是提供声明，不需要提供逻辑代码；\r\n0.  declare 关键字:用于类型声明，为其他地方(比如，.js 文件)已存在的变量声明类型，而不是创建一个新的变量。\r\n0.  - 对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。\r\n    - 对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指定此处用于类型声明。\r\n0.  ```\r\n    export declare let count = number\r\n    export declare let songName = string\r\n    export declare let position = {\r\n      x: number,\r\n      y: number\r\n    }\r\n    export declare function add(x: number, y: number): number {\r\n    ​\r\n    }\r\n    enum Direction {\r\n      'top',\r\n      'right',\r\n      'bottom',\r\n      'left'\r\n    }\r\n    export declare function changeDirection(direction: Direction): void\r\n    type FomatPoint = (point: number) => void\r\n    export declare const fomatPoint: FomatPoint\r\n    ```\r\n\r\n"
    },
    {
        "article_id": "7187788994736816184",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c20eebb9ea8407eadb69a38e8c4ca34~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022，拔剑四顾心茫然",
        "preview": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」我是红雪, 大三在读学生，希望大家能支持我的文章，谢谢!",
        "author": "红雪",
        "view_count": 982,
        "collect_count": 3,
        "comment_count": 16,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/af19737ba19d742a54eae905955a62b8~300x300.image",
        "category": "代码人生",
        "content": "---\r\ntheme: qklhk-chocolate\r\n---\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n### 一. 2022, 我在做什么\r\n\r\n#### 个人简介\r\n我是一名电子信息工程大三在读学生，双非本科。\r\n\r\n对硬件毫无兴趣，甚至可以说得上讨厌，原因: 感觉硬件不太优雅(仅个人感受)。总之内核以下的知识，除非万不得已，我是不会主动学习的。\r\n\r\n于是毅然决定了自学计算机科学，然后跨考。在大一升大二的暑假看完\\t&lt;&lt;head first java&gt;&gt; 之后，对于该决心便不再动摇。\r\n\r\n#### 大二上学期\r\n大二的上个学期，先是看完了一本&lt;&lt;head first java&gt;&gt;, 再就是看完了b站上韩顺平老师的**javaSE**视频(好像有1000集来着? 目前看过的最长的教学视频)。不得不说，韩老师讲的javaSE有广度有深度，竟然能在基础课视频里看到各种容器的底层扩容机制，对当时还是初学者的我来说，真是难上加难。\r\n\r\n#### 大二下学期(2022年上半年\r\n这个学期里，javaSE的学习暂告一段落，开始学习**javaEE**。从最原始的servlet、最原始的jdbc，进化到了SSM、Springboot等。第一次体会到框架的便利。这整个学期都在与javaEE打交道。期间也遇到过一些疑难杂症，自己无法解决，便在互联网上四处求医，也得到了不少无私的帮助。印象最深的一次就是我使用**mybatis**时，...dao之前的**小鸟logo**与...dao.xml之前的小鸟logo消失了，导致我无法在两者之间快速跳转。于是自己顺藤摸瓜的找到了一个mybatis官方建立的微信群，去里面求医。其中一个mybatis的开发成员听到我的问题之后，立即联系了我，与我建立远程协助，费时一个下午，两只小鸟logo终于出现了。然后他把他的弟弟推给了我，说以后有什么学习上的问题可以与他弟弟交流，他弟弟很热心。是的，后续我也陆陆续续请教过他的弟弟一些问题，他弟弟也十分热心，在工作之余，花时间与我交流问题。\r\n\r\n这种无私的、无关利益的帮助，也是我**热爱**这个专业、这个行业的一个原因。后来、直到现在，我也在陆陆续续尽己所能，为身边一些学计算机的朋友提供些微不足道的**帮助**。希望这种精神，能够一直流传下去，如此这般，这个行业才能蓬勃发展。\r\n\r\n#### 大三上学期(2022年下半年\r\n这个学期刚开始，两个室友已经开始第一轮的高数复习，另一个室友也加入了学校的电子信息工程实验室。我的跨考决心仍然没有一丝动摇。此时的我刷过算法题、拿过蓝桥杯java组省二，能够独立利用Springboot与Vue开发一个前后端分离的网站。我反复质问自己，是不是要暂时放下这些，开始准备考研、开始准备11408了? 我不想，我还想再多学一点课外知识，现在还不想一门心思投身到考研中。\r\n\r\n##### 操作系统\r\n于是在这个学期里，我为了学习**操作系统**，看完了一本&lt;&lt;Operating Systems: Three Easy Pieces&gt;&gt;,作为一本OS入门书籍来说，这本的确不错，翻译有些许问题，中英文结合起来看完的。\r\n\r\n<table>\r\n    <tr>\r\n        <td><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e31b5ba04484aa69958c1d55fdd66ae~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"C1BB370D22DC29ABD23C2BBF924362A1.png\\\"/></td>\r\n        <td><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0c5ee7db8304b33b1004b6a8d122644~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"F92812EB62AEEC3E94B5B38F01F908E5.png\\\"/></td>\r\n    </tr>\r\n</table>\r\n\r\n##### linux内核\r\n为了学习**linux内核**，看完了一本&lt;&lt;Linux内核设计与实现&gt;&gt;，内核入门书籍，内容并不全面，但十分精炼。看起来还是有难度的，我应该只吸收了60%的知识😢\r\n\r\n<table>\r\n    <tr>\r\n        <td><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288034b28481433c86959131c037e445~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"363735030DC4E2A75359707DE872BF9C.png\\\"/></td>\r\n        <td><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2797c971ecb44d188cad6ff9e685ad8f~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"098D3348619575487159231B99337AE6.png\\\"/></td>\r\n    </tr>\r\n</table>\r\n\r\n##### 黑客体验卡\r\n看完&lt;&lt;Linux内核设计与实现&gt;&gt;以后，就开始了我的**黑客**生涯,没错，我成为了一个黑客🤣\r\n\r\nAlright，其实只是学习了一两个月的**网络安全与渗透测试**。其实2022年暑假发生的一件趣事为我学习渗透埋下了伏笔: 我部署web服务的阿里云ECS被注入了**挖矿脚本**。\r\n\r\n<table>\r\n    <tr>\r\n        <td><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc7c37380fe4447ad15932640c930cc~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"363735030DC4E2A75359707DE872BF9C.png\\\"/></td>\r\n        <td><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4023ee38e7e1406ab7d2a2dd499bd19c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"098D3348619575487159231B99337AE6.png\\\"/></td>\r\n    </tr>\r\n</table>\r\n\r\n下面是我截取的挖矿脚本的一部分:\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd6fd8cea0e4bbc93c6eb0356e982c0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n😇\r\n\r\n首先是学了**kali**，然后按照教学视频给word加宏病毒、给.apk文件加后门、实现ARP欺骗与泛洪等，学习成果就是恶搞了一下室友。此时我对实现原理一窍不通。\r\n\r\n然后不小心接触了Hack the Box，便在里面慢慢学习了一些渗透与反渗透的原理, 包括但不限于**sql注入**、**javascript反混淆**、如何获取**reverseShell**、**ffuf爆破**以及好用的**metasploit框架**\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08835996a65a49d99b1dc05728fc3cf7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后学习了**dos命令**准备在windows上大战身手\r\n\r\n又学习了**python**准备定制自己的渗透工具，同时也学习了一点**爬虫**\r\n\r\n...\r\n\r\n碰壁, 暂时放弃渗透学习，黑客体验卡到期。\r\n\r\n##### 朝花夕拾——javaEE\r\n\r\n其实可以发现，2022年下半年我都没怎么碰javaEE了，主要是觉得写javaEE总是在机械化的CRUD，都没怎么动脑思考，不会让我进步。\r\n\r\n但当我学习渗透碰壁之后，我还是拾起老本，开始学习**微服务**了。\r\n\r\n由于疫情，学校十二月初就放假了。正好在放假之时，我的微服务也学的差不多了。\r\n\r\n便决定写一个自己的武侠网站(很早之前就有这个想法\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99b0268ac87343daa62cf6adcd9ca15d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n赶在年关之前我做出来了一个半成品(前端实在是献丑，我只专门学了7天html+css\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d59538821b04f2fa9188f51cde8b354~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5493ed682eb495894306b3b8cb02d32~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dddcd1ec7223458b987c199ae6aaab4a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n##### OpenAi与小程序\r\n\r\n下面非广告非广告非广告!!! 我连小程序名字都没有贴上去!(保命\r\n\r\n我承认我只是想利用OpenAi赚点零花钱...但现在我觉得我100元都赚不到😊\r\n\r\n当前小程序已经被我停止服务，我还需要再测试一段时间再重新发布，想与我交流或者试用体验版可以掘金私信我🤩\r\n\r\n<table>\r\n    <tr>\r\n        <td><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d067675d30be44f084dd0a8050725b5a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"363735030DC4E2A75359707DE872BF9C.png\\\"/></td>\r\n        <td><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9226aefadda34d09b15b3c9bc43e0535~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"098D3348619575487159231B99337AE6.png\\\"/></td>\r\n        <td><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78515a01ab434109bffdb1d374656fc0~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"098D3348619575487159231B99337AE6.png\\\"/></td>\r\n    </tr>\r\n</table>\r\n\r\n### 二. 2022, 新Get的知识与技能\r\n\r\n#### 1. 操作系统、linux内核\r\n\r\n阅读的书籍: \r\n1. &lt;&lt;Operating Systems: Three Easy Pieces&gt;&gt; \r\n2. &lt;&lt;Linux内核设计与实现&gt;&gt;\r\n\r\n用三个词概述操作系统:\r\n1. Virtualization\r\n2. Concurrency\r\n3. Persistence\r\n\r\n日后如果有机会想跟一遍**MIT6.828**，渴望动手实操内核\r\n\r\n#### 2. 分布式与微服务\r\n\r\n利用Dubbo + Zookeeper 实现服务的注册与发布\r\n\r\n我的个人武侠网站就是使用的该微服务架构\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ae8c024dd6342c08a8cac4c1c8af132~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n\r\n\r\n#### 3. openAi与微信小程序联动，后端使用Flask\r\n\r\n为什么选择**python + flask**, 而不是javaEE + springBoot呢?\r\n\r\n因为openAi官方没有提供java的API🤣\r\n\r\n其实后端很简单写，主要就是接受小程序用户的问题，然后调用openAi的API获取人工智能答复，然后返回给小程序用户即可。\r\n\r\n真正让我恼火与烦躁的是小程序前端: 首先是个体无法调用微信Pay，再就是非要走https(对此我保持理解，但就是很恼火)。 所以我就去申请域名、ICP备案、SSL证书了。\r\n\r\n从ICP备案申请到通过应该过了5天左右吧?\r\n\r\n然后在这5天中我已经把小程序部署好了...\r\n\r\n用了**微信云托管**...就不用走https了。\r\n\r\nwx.cloud.callContainer()也是个极其不友好的接口，最长时限是15s，也就是部署在云托管上的后端如果15s未给出响应，微信云托管就会擅作主张给我前端返回500\r\n\r\n可是有的问题人工智能需要思考15s以上呀!\r\n\r\n然后我就在前端采取了**三次质询**，每次最长可以等待15s，就给了人工智能45s的思考时间\r\n\r\n后端采用了**多线程实现异步**，将与openAi交互的任务新开了一个线程\r\n\r\n具体实现可以看我的这篇: https://juejin.cn/post/7187011039391645733\r\n\r\n前端三次质询 + 后端异步任务 + redis 解决的wx.cloud.callContainer()15s最长时限问题，这种方法应该很不规范，是我突然想出来的一个野路子。\r\n\r\n要是大家有别的解决办法，欢迎**私信我**或者在 https://juejin.cn/post/7187011039391645733 下留言😁\r\n\r\n反正我觉得微信小程序前端写起来浑身不自在，太多局限性。\r\n\r\n#### 4. 网安与渗透测试\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8c85d638f934a329e91d1fe196beda2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我应该很长时间都不会学这方面知识了，因为学了快两个月，除了捉弄室友，就是捉弄室友。\r\n\r\n**学习成本太高了**(指成为一个真正的**灰帽黑客**\r\n\r\n如果早10年入这行，我会接受这个成本，但现在的我肯定无法接受。\r\n\r\n### 三. 2022的感悟: 学习计算机要趁早——无关内卷\r\n\r\n前几天在github上浏览chatGpt资料时，发现了一个外国高中生。\r\n\r\n他的一个repository的README.md里有这样一句话:\r\n\r\n> Connect with me on Linkedin to support this project. I'm graduating high school soon and knowing some people might help my chances at finding employment.\r\n\r\n我寻思高中毕业就敢直接找工作?\r\n\r\n看了下该仓库:&nbsp;&nbsp; fork数: 1.2k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;star数: 9.3k\r\n\r\n考虑到我的各个repo的fork数与star数都是挂零的存在，他对我来说就是可望不可及。\r\n\r\n他的主页:\r\n\r\n<table>\r\n    <tr>\r\n        <td><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342227154be54ed8a64ab9209c444d34~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"363735030DC4E2A75359707DE872BF9C.png\\\"/></td>\r\n        <td><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8846434042b6416293b0a264ef0bfb7a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"098D3348619575487159231B99337AE6.png\\\"/></td>\r\n    </tr>\r\n</table>\r\n\r\n查询到他建立这个repo的时间:\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6ff2a7e336749ba9099cd2690b42b27~tplv-k3u1fbpfcp-watermark.image?)\r\n再加上README.md中说自己高中即将毕业，以及github已经注册了4年\r\n\r\n可以推断出**他在初中就已经拥有了github**\r\n\r\n(我在初中应该连什么是编程都不知道)\r\n\r\n作为一个大三学生，我真的很建议趁早开始学习计算机、学习编程\r\n\r\n**\\\"趁早\\\"并不是说先人一步**，而是尽早看看孩子有没有计算机、编程方面的兴趣或者说可以尝试培养一下兴趣。如果有兴趣，那就可以尽早引导孩子开始学习这些技能。如果没有兴趣，那就不必逼迫孩子学习这方面知识了。\r\n\r\n**\\\"趁早\\\"是为了避免像我这样，直到大二才发现自己对编程有些许兴趣，大三才发现自己对编程有浓厚的兴趣**。前些日子，我还真的在学习渗透知识、研读渗透书籍，幻想成为一个黑客。可当我学习了两个月之后，才发现真的太晚了。\r\n\r\n**因为\\\"太晚\\\"，导致我现在的时间无法让我为兴趣买单。**\r\n\r\n如果我早那么几年发现自己对编程有兴趣，早那么几年开始学习编程，那么也许我现在会不一样，不会整天为考研、就业焦头烂额。\r\n\r\n但木已成舟，无法改变。\r\n\r\n**\\\"趁早\\\"，而不是内卷。**\r\n\r\n### 四. 2022, 拔剑四顾心茫然\r\n\r\n可以看到，2022年我的确get了好多新技能：内核、渗透、微服务、小程序...\r\n\r\n但是我也十分**茫然**\r\n\r\n学了这么多这么杂，目前好像也无法转化为一份工作。\r\n\r\n我还是得面对考研。\r\n\r\n那天与一个北京邮电大学的研究生学长对话：\r\n\r\n - 我: “学长，我年过完了再开始准备11408来得及嘛”\r\n\r\n - 学长: \\\"有点晚了，有的同学大三上学期就开始了\\\"\r\n\r\n - 我: \\\"可是我现在想先把我的武侠网站和小程序完善，差不多到过年就可以结束了\\\"\r\n \r\n - 学长: \\\"你现在做的这些项目**根本没用**，考研复试不会看这些的，只需要按固定套路刷题背题就可以了。而且就算你需要项目经验，初试结束后还有3个月给你准备，时间完全充足。**每个时间段，有每个时间段需要做的事**\\\"\r\n \r\n - 我: \\\"\\\"\r\n\r\n学长泼的冷水，对我打击还是蛮大的，但他说的也确实在理。现在自己捣鼓的这些，又有什么用呢? \r\n\r\n### 五. 2023，考研\r\n\r\n码字码了几个小时，终于，码到了最后一个小标题。\r\n\r\n就像我逃避了许久，终于，还是要面对2023年的考研。\r\n\r\n\\\"每个时间段，有每个时间段需要做的事\\\"\r\n\r\n这几天我应该就会正式开始第一轮高数的复习, 往后也会将重心更多的放在书本理论知识与刷题上面\r\n\r\n但我仍然会抽空输出一些内容，不过可能大多数时候是在沸点分享一些备考心情吧😄\r\n********\r\n2022年，我在忙碌，也在茫然。\r\n\r\n2023年，我仍会忙碌，但不想再茫然。\r\n\r\n2023年，我只给自己定一个目标: **备考11408**\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7160944469796192263",
        "snapshot": "",
        "title": "发生森么事了，表格还能 “下钻” 😱",
        "preview": "导读 在《一图带你看懂四川疫情》中，本川娃子使用 KPI 趋势表 展现了四川疫情走势。针对四川及其下属市州，KPI 趋势表能清晰地展示疫情指标（新增无症状，新增本土）走势，并配合折线图（下图右侧）强化",
        "author": "蚂蚁集团数据体验技术",
        "view_count": 1837,
        "collect_count": 11,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/0eefd5510e2b17cea4eece86d473a77a~300x300.image",
        "category": "前端",
        "content": "# 导读\r\n在[《一图带你看懂四川疫情》](https://juejin.cn/post/7145284353780613133)中，本川娃子使用 [KPI 趋势表](https://s2.antv.vision/zh/examples/case/kpi-strategy#covid-trend) 展现了四川疫情走势。针对四川及其下属市州，KPI 趋势表能清晰地展示疫情指标（新增无症状，新增本土）走势，并配合折线图（下图右侧）强化走势分析能力。\r\n\r\n\r\n![1666579124496-b7e9dd71-3126-42b6-a1a8-3a71543ef581.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04ebca9577c46f6960d35df1cae8304~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n当我把表格发送到团队群里后，有小伙伴坐不住了，说也想看看周围省市的疫情明细数据，并且还希望：\r\n\r\n- 默认只看省级数据，不在首屏展示其他多余的节点\r\n- 当查看市州数据时，不想一次性看所有数据，如 只想看省下面有新增的城市\r\n\r\n<image width=\\\"180\\\" src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2acaabfb0c4ac1af0518c267e7ddb9~tplv-k3u1fbpfcp-watermark.image?\\\">\r\n\r\n这还能难倒我？马上使用 [**S2 的下钻分析能力**](https://s2.antv.vision/zh/examples/react-component/drill-dwon#for-pivot) 安排 🚀\r\n    \r\n# 一起来下钻\r\n团队小伙伴大多来自周围省份，于是我收集了云贵川渝的 21 日当日疫情统计数据，配合 [S2 下钻 API 文档](https://s2.antv.vision/zh/docs/api/components/drill-down#drilldownprops)，三下五除二搞定了表格：\r\n    \r\n\r\n![2.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55eb1efea5414018b37d953f3833cf6b~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n表格初始化状态下很简单，行头仅有省一个维度，满足了大家想看全局汇总的诉求。\r\n与普通树状结构展示不同的是，当鼠标移动到省份单元格上，省名称的右侧会出现一个 **下钻的图标**，点击后出现下钻菜单，里面配置了三种不同的下钻方式：\r\n\r\n\r\n- 查看所有的市州\r\n- 仅查看有新增确诊病例的市州\r\n- 仅查看风险区域大于 10 个市州\r\n\r\n\r\n<image width=\\\"180\\\" src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5d886c70df047fdb339705784c70ff7~tplv-k3u1fbpfcp-watermark.image?\\\" />\r\n    \r\n如此一来，整个表格的行头数据变得更加灵活了，在省一级下面，可以根据用户的操作，实时切换需要展示的数据。\r\n例如在下面的动图中，我们先下钻查看四川的新增确诊，再下钻查看贵州的高风险区，最后下钻查看重庆的所有市州。各个省下的数据切片逻辑互不干扰。如想切换下钻的逻辑，只需要呼出下钻菜单，清除已有结果后重新下钻。\r\n    \r\n![3.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786bb9d970e74c0cb624c9e2be829f8e~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n    \r\n<image width=\\\"120\\\" src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237db0f63a8849db80ed668b90c27b4b~tplv-k3u1fbpfcp-watermark.image?\\\" />\r\n    \r\n在上例中，由于省市数据本身存在嵌套的关系，对 “市” 维度的下钻更多是在做切片、过滤。**实际的 BI 数据分析下钻场景，也更多是在不同维度下进行。**如疫情原始数据能包含更多的维度，那么能更好地展示下钻能力。\r\n\r\n![CleanShot 2022-11-01 at 15.18.40@2x.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476b9c10a29f42f59588d1d0ad8023ed~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n# 结语\r\n以上就是 S2 下钻分析能力的 “实战”，有任何问题欢迎在评论区或钉钉群沟通。\r\n\r\n欢迎社区的同学和我们一起共建 [AntV/S2](https://github.com/antvis/s2)，打造最强的开源大数据表格引擎。如果看完这篇文章你有所收获，欢迎给我们的 [仓库](https://github.com/antvis/s2) [Star⭐️](https://github.com/antvis/s2) 鼓励。\r\n\r\n**S2 的相关链接：** \r\n\r\n- [GitHub](https://github.com/antvis/s2)\r\n- [官网](https://s2.antv.vision/)\r\n- 核心层: [@antv/s2](https://www.npmjs.com/package/@antv/s2)\r\n- 组件层: [@antv/s2-react](https://www.npmjs.com/package/@antv/s2-react)\r\n\r\n**往期文章：**\r\n\r\n- [一图带你看懂四川疫情](https://juejin.cn/post/7145284353780613133)\r\n- [你不知道的 Canvas 表格交互](https://juejin.cn/post/7080471587249455135)\r\n- [让你的表格更多彩 - AntV/S2 主题介绍](https://juejin.cn/post/7094509003241160712)\r\n- [AntV/S2 和 Antd Table 有什么区别？](https://juejin.cn/post/7084064083279872014)\r\n- [我用 AntV/S2 买了一套房](https://juejin.cn/post/7106314606150156324)\r\n- [如何基于 AntV S2 打造大数据表格组件](https://juejin.cn/post/7072926133859123236#comment)\r\n"
    },
    {
        "article_id": "7187755633456726075",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52fb7ceb2f7d4237a62bd4d5d4177583~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3.2: Ref操作Dom为何既易用又高效？ ",
        "preview": "在开发一个项目之前，我们往往都是先做下需求分析，针对前端而言，就是可以调研或者选择一个基础组件库，来提高我们的工作效率。毕竟，对比较计较时间成本的公司来说，不会给你拿看电视剧玩游戏的时间去专门开",
        "author": "糖墨夕",
        "view_count": 1901,
        "collect_count": 33,
        "comment_count": 11,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f2be119aeaeb919175de9aa398141dbd~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: orange\r\nhighlight: atelier-seaside-light\r\n---\r\n\r\n# 缘起\r\n\r\n在开发一个项目之前，我们往往都是先做下需求分析，针对前端而言，就是可以调研或者选择一个基础组件库，来提高我们的工作效率。毕竟，对比较计较时间成本的公司来说，不会给你拿看电视剧玩游戏的时间去专门开发一个类似日历的组件。但在市面上的组件库，并不能都能满足我们的需求。这个时候，我们就需要自己手写组件，来应用到项目中。\r\n\r\n而这就是我想说的: **如何设计组件，让其既能易于应用（或者说减少代码量），又能提高扩展性，方便需求变更和后续维护？**\r\n\r\n> 可以有很多种方式，而利用Ref操作Dom的特性随是其中之一，但这个方式却让我们在维护和操作Modal、Popup以及频繁操作Dom显示和隐藏交互的组件的时候，却发挥得很大优势。\r\n\r\n就对Ref操作Dom的相关知识点以及应用实例分几个方面来做下剖析\r\n\r\n- Ref获取Dom的本质\r\n- Ref操作Dom在Vue2.x和Vue3.x的不同\r\n- Ref操作组件Dom和父子组件单向传递对比\r\n\r\n# 详说\r\n\r\n## Ref获取Dom的本质\r\n\r\nVue2.x中Vue的对象属性$refs，其实就是所有注册过的ref的一个集合，而ref对应着template模版中，不同组件或普通Dom元素上关联的ref=\\\"xx\\\"; 源码中ref的实际获取方式也是通过原生方式getElementById而得到的Dom节点；\r\n**可以说ref是`document.getElementById`的语法糖。vue3的ref延续了vue2的用法，还增加了一个作用就是创建响应式数据**\r\n\r\n>也许有人会问了，既然ref和getElementById都能获取到Dom，那么在项目开发中，我选择哪种方式都没什么区别呢？\r\n\r\n\r\n关于这个问题，经过数据表明，$refs相对document.getElementById的方法，会减少获取dom节点的消耗；而具体原因，等下一篇文章再详细探讨。\r\n\r\n\r\n## Ref操作Dom在Vue2.x和Vue3.x的不同\r\n\r\n### Vue2.x\r\n\r\n我们只需要在相应的Dom元素或者组件加上ref=\\\"xx\\\"属性,然后在Vue对象中使用this.$refs.xx,就可以直接获取到该Dom并操作其方法属性,\r\n\r\n```html\r\n<user-and-dep-tree-select-modal\r\n  ref=\\\"avaUserTreeSelect\\\"\r\n  title=\\\"選擇可見範圍\\\"\r\n  :project-id=\\\"currentProjectId\\\"\r\n  :visible.sync=\\\"avaUserModalVisible\\\"\r\n  @ok=\\\"editAvailableUser\\\"\r\n/>\r\n或者\r\n<div class=\\\"user\\\" ref=\\\"user\\\">dd</div>\r\n```\r\n```js\r\n// $refs\r\nshowManagerModal () {\r\n  this.$refs.avaUserTreeSelect.showModal(this.form.managers)\r\n  console.log(this.$refs.user.text)\r\n},\r\n```\r\n### Vue3.2\r\n在Vue3.2版本使用的方式 \r\n```html\r\n//普通Dom\r\n<div class=\\\"user\\\" ref=\\\"user\\\"></div>\r\n//组件\r\n<batch-adjust-department-modal ref=\\\"batchAdjustDepartmentRef\\\" />\r\n```\r\n```ts\r\n<script setup lang=\\\"ts\\\">\r\nimport { ref } from 'vue';\r\n// modal调整部门弹层Dom\r\nconst batchAdjustDepartmentRef = ref(null);\r\nconst user = ref(null);\r\n</script>\r\n```\r\n>也许这里有人疑问，为什么声明了一个和template的ref中同名的常量变量就绑定了对应的dom?\r\n在这里再补充说明一下：\r\n\r\n-   Vue3 在早期版本（ 3.0.0-beta.21 之前）中对 composition api 的支持，只能在组件选项 `setup` 函数中使用。而相应式的变量都是通过在setup()方法中return {写入需要在模版中使用的变量或方法}\r\n```javascript\r\n<script>\r\nimport { defineComponent, ref } from 'vue'\r\n\r\nexport default defineComponent({\r\n  name: 'HelloWorld',\r\n  setup(props, ctx) {\r\n    const count = ref(0)\r\n    function add() {\r\n      count.value++\r\n    }\r\n    // 使用return {} 把变量、方法暴露给模板\r\n    return {\r\n      count,\r\n      add,\r\n    }\r\n  },\r\n})\r\n</script>\r\n```\r\n-   在 3.0.0-beta.21 版本中增加了 `<script setup>` 的实验特性。如果使用了，会提示 `<script setup>` 还处在实验特性阶段。\r\n-   在 3.2.0 版本中移除 `<script setup>` 的实验状态，从此，宣告 `<script setup>` 正式转正使用，成为框架稳定的特性之一\r\n与组件选项 `setup` 函数对比， `<script setup>` 我们只需要写更少、更简洁的代码，不需要使用 `return {}` 暴露变量和方法了，使用组件时不需要主动注册了，会自动帮你绑定\r\n\r\n所以在`<script setup>`中声明的变量会自动被加到该Vue对象的本身this中，如\r\n\r\n\r\n| ` <script setup>`  | `<script>`  |\r\n| --- | --- |\r\n| `const user = ref(null);` | `this.$ref.user` |\r\n\r\n## Ref操作组件Dom和父子组件单向传递\r\nprops父传子，子通过emits传父，这样单方向传递，在控制弹层组件的显示和隐藏方面也可以实现，但是如此一来，我们就会像下面一样\r\n父组件\r\n```html\r\n<template>\r\n  <exchange-valid-modal-vue v-model:visible=\\\"visibleExchange\\\" />\r\n</template>\r\n<script setup lang=\\\"ts\\\">\r\n// 转让管理员组件\r\nimport ExchangeValidModalVue from './modal/ExchangeValidModal.vue';\r\n// modal弹层\r\nconst visibleExchange = ref(false); // 转让管理员可视化\r\nconst onExchangeAdmin = () => {\r\n  visibleExchange.value = true;\r\n};\r\n</script>\r\n```\r\n子组件`ExchangeValidModalVue.vue`\r\n```html\r\n<template>\r\n    <t-dialog\r\n      v-model:visible=\\\"visibleExchange\\\"\r\n      header=\\\"转让主管理员\\\"\r\n      attach=\\\"body\\\"\r\n      width=\\\"384px\\\"\r\n      :confirm-on-enter=\\\"true\\\"\r\n      :on-close=\\\"onCloseExchange\\\"\r\n    />\r\n</template>\r\n<script setup lang=\\\"ts\\\">\r\nconst visibleExchange = ref(false);\r\nconst props = defineProps({\r\n  data: {\r\n    type: Object,\r\n    default: () => {},\r\n  },\r\n  visible: {\r\n    type: Boolean,\r\n    default: false,\r\n  },\r\n});\r\nwatch(\r\n  () => props.visible,\r\n  (cur, pre) => {\r\n    visibleExchange.value = cur;\r\n    if (cur) {\r\n      firstTag.value = 1;\r\n    }\r\n  },\r\n);\r\nwatch(\r\n  () => visibleExchange.value,\r\n  (cur, pre) => {\r\n    emits('update:visible', cur);\r\n  },\r\n);\r\n</script>\r\n```\r\n从代码里面我们就可以发现通过用父子组件单向传递的方式去实现一个组件的显示和隐藏功能，我们需要如此费劲地声明多个变量，还要做两次监听，万一后面不止一个这样的参数进行传递，那么代码量可想而知，而且也不易维护。\r\n\r\n其实显示和隐藏的功能可以直接在内部中进行值的响应即可，并不需要在父级别中操作，如下将上面代码改变一下：\r\n\r\n子组件`ExchangeValidModalVue.vue`\r\n```html\r\n<template>\r\n    <t-dialog\r\n      v-model:visible=\\\"visible\\\"\r\n      header=\\\"转让主管理员\\\"\r\n      attach=\\\"body\\\"\r\n      width=\\\"384px\\\"\r\n      :confirm-on-enter=\\\"true\\\"\r\n      :on-close=\\\"onCloseExchange\\\"\r\n    />\r\n</template>\r\n<script setup lang=\\\"ts\\\">\r\nimport { ref } from 'vue';\r\nconst visible = ref(false);\r\nconst emits = defineEmits(['call']);\r\nconst onEmitSelectSuperiod = () => { // 省略\r\n  emits('call');\r\n}；\r\nconst onOpen = () => {\r\n  visible.value = true;\r\n};\r\nconst onClose = () => {\r\n  visible.value = false;\r\n};\r\n\r\ndefineExpose({\r\n  onOpen,\r\n  onClose,\r\n});\r\n</script>\r\n```\r\n那么在父组件中，我们只需要通过ref得到该组件Dom，然后操作Dom内部的方法即可；\r\n\r\n如：父组件改写\r\n```js\r\n<template>\r\n  <exchange-valid-modal-vue ref=\\\"exchangeRef\\\" />\r\n</template>\r\n<script setup lang=\\\"ts\\\">\r\n// 转让管理员组件\r\nimport ExchangeValidModalVue from './modal/ExchangeValidModal.vue';\r\n// modal弹层\r\nconst exchangeRef = ref(null); // 转让管理员可视化\r\nconst onExchangeOpen = () => {\r\n   exchangeRef.value.onOpen() // 直接操作dom里defineExpose暴露出来的方法\r\n};\r\n</script>\r\n```\r\n如此，是不是比父子单向数据传递的方式更加高效易用？当然上面所说的只是我举的一个例子，当后续需要在组件内扩展功能也可按类似的方法代替单向数据流的方式扩展\r\n\r\n但，请注意；这种操作dom方式，并不是什么场景下都是最佳的选择；我们可以分情况选择，**比如当一些数据只需要在子组件的范畴中实现，而不需要父组件外加干涉的情况下，选择ref操作dom更为高效；**\r\n\r\n## 补充知识点：\r\n### `defineExpose`\r\n\r\n在 Vue3.2 中，默认不会暴露任何在 `<script setup>` 中声明的绑定，即不能通过模板 `ref` 获取到组件实例声明的绑定。\r\n\r\nVue3.2 提供了 `defineExpose` 编译器宏，可以显式地暴露需要暴露的组件中声明的变量和方法\r\n\r\n\r\n## 往期回顾\r\n\r\n[Vue3: CSS Modules和 Scope深度剖析](https://juejin.cn/post/7185828978362417208)\r\n"
    },
    {
        "article_id": "7165539003465531399",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba96103d9044be29bb31587360694dc~tplv-k3u1fbpfcp-watermark.image?",
        "title": "WebRTC 从实战到未来！前端如何实现一个最简单的音视频通话？🔥",
        "preview": "音视频通话实战与原理，支持内外网，《WebRTC 从实战到未来！》第二篇，迎接风口，前端必学的技术！",
        "author": "荣顶",
        "view_count": 6526,
        "collect_count": 211,
        "comment_count": 34,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/26f254d4ee2f1e58081b5f503fd01dda~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: smartblue\r\nhighlight: atom-one-dark\r\n---\r\n\r\n>作者：[荣顶](https://github.com/wangrongding) 、[github](https://github.com/wangrongding)  \r\n声明：文章为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n\r\n\r\n- [WebRTC 从实战到未来！迎接风口，前端必学的技术 🔥](https://juejin.cn/post/7151932832041058340)\r\n\r\n看到上一篇文章很受大家的欢迎 👏🏻，短短的几天就有好几百的点赞，🥳 非常开心，你们的点赞支持就是我继续好好写下去的动力，谢谢大家。🌸\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30e518e8ecdb49d59b02aa84f258a57b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上一篇文章主要讲解了如何通过 `WebRTC` 的一些 api 对 摄像头，话筒，屏幕的媒体流进行采集并加以`处理`，实现了几个小 demo，秉持着实战为王的原则，这一篇文章我们仍然是以这种方式为主,不过这一篇需要了解的概念会比上一篇多一些，但是我并不会为它大书特书，所以当有一些概念性的东西，你在看的时候觉得自己不是特别理解的话，聪明的你，一定要记得多借助搜索引擎来帮助自己 ~ ），我主要会讲一些在示例中必须要了解概念，以便让大家不会看到大量的协议或者名词概念直接劝退，目的是快速上手。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9e65737ddad4a23be008f959fc71db2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第一篇文章中，我并没有很好的介绍`WebRTC`，因为上一篇我们只是用它的一点获取媒体流等 api 来做了一些小 demo，但那都不是它的重点，`WebRTC` (Web Real-Time Communications)，是一个由 Google 发起的实时通讯解决方案，其中包含视频音频采集，编解码，数据传输，音视频展示等功能，通过它，我们可以非常方便且快速地构建出一个音视频通讯应用。\r\n\r\n它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间`点对点（Peer-to-Peer）的连接`，实现视频流和（或）音频流或者其他`任意数据`的传输。\r\n\r\n所以它的重点在于通信~ 上一篇主要是讲的采集和处理媒体流相关的内容，这次我们主要讲解如何使用 `WebRTC`一些 api 配合 `信令服务` 来 `建立连接`，以及如何将获取到的媒体流进行`传输`。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced7322632b84b3297575261059760ae~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 一对一实时音视频通话实战（不通过信令服务）\r\n\r\n首先，我们从最简单的 `1v1` 的`\\\"手动\\\"` `点对点连接`开始，这样可以更好帮助我们理解 `WebRTC`是怎么建立连接的，第二节中再来讲解如何通过`信令服务`来来帮助我们`\\\"自动\\\"` 建立 `点对点连接`实现 `1v1` 或者`多人`的音视频通话。\r\n\r\n这样，我们就只使用了两篇文章就能让大家简单的了解到 如何从媒体流的`采集`，`处理`，建立 p2p（Peer-to-Peer） 对等`连接`，再到数据`传输`这一个整个过程的实现方法。🥳🥳🥳\r\n\r\n[👉🏻 本文示例源代码地址](https://github.com/wangrongding/frontend-park)  \r\n[👉🏻 本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/p2p)\r\n\r\n你可以开两个浏览器 tab 或者用不同的设备，根据说明即可体验音视频通话的实现，本文将会从实战出发，讲解 WebRTC 的音视频通话原理。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fdb83809a59405d9b7db4a4e889a0cc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 开始之前，一起来思考一个问题\r\n\r\n两个设备，在互相不知道对方的情况下，如何建立连接？\r\n\r\n我把这个问题换成更接地气一点：有一天，你在一个地方旅行，在旅行的途中，遇到了一个很喜欢的女孩子，一起拍了照片，假期结束后，你回家朝思暮想，想要再次见到她，但是你们忘记了互相留联系方式，我擦~好后悔，怎么办？后来你发的朋友圈被你同事评论了，说她认识这个女生，哇塞，你欣喜若狂，这个时候，你们是不是就可以通过你的同事来联系到对方呢？（有点土味的例子 😅， 相信大家应该已经能理解了~）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c781bc9c994343c2a04e2f8d6a122c25~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这样你们就可以相互建立连接了。你开心的起飞了，然后开始学起了 WebRTC。😅\r\n\r\n### 实现简单模型，必须要知道的几个概念\r\n\r\n#### 1. SDP\r\n\r\n`SDP`：`Session Description Protocol`，它是一种用于描述多媒体会话的协议，它可以帮助我们描述媒体流的信息，比如媒体流的类型，编码格式，分辨率等等。WebRTC 通过`SDP`来交换端与端之间的`网络`和`媒体`信息。\r\n\r\n下图中就是一个`SDP`信息的示例：从中你能大概的看到一些你的内网 IP 信息，外网 IP 信息，以及一些媒体流的信息。\r\n\r\n```sh\r\nv=0 # SDP版本号\r\no=- 0 0 IN IP4 120.24.99.xx # 会话标识信息\r\ns=- # 会话名称\r\nt=0 0 # 会话的有效时间\r\na=group:BUNDLE audio video # 媒体流类型\r\na=msid-semantic: WMS * # 媒体流标识符\r\nm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126 # 音频媒体流\r\nc=IN IP4 120.24.99.xx # 连接信息\r\na=rtcp:9 IN IP4 0.0.0.0 # RTCP 的 IP 地址\r\na=candidate:0 1 UDP 2122252543 120.24.99.xx 9 typ host # 候选 IP 地址\r\n# ...等等等\r\n```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acae046b6862482d8e46d6b6995d2ef2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n一开始我们只需要知道，`SDP`是用来干什么的就行了，不需要过多的关注这些信息，后面用到了再深入了解。（我认为学习大多数技能的时候，如果上来就把各种概念性的东西先全部搞透再开始去动手，是效率很低的一种学习方式，应当了解一个大概后，在实战中去边做边学习，不懂什么概念再去获取，遇到问题再去解决，这样才能更快的上手一门技术，然后深入或者进阶的时候，在系统的去学习概念。）\r\n\r\n#### 2. NAT\r\n\r\n`NAT`：`Network Address Translation`，网络地址转换，它可以将私有 IP 地址转换为公共 IP 地址，从而实现私有网络与公共网络之间的通信。\r\n\r\n因为 IPv4 的地址空间比较有限，所以我们大多数设备都部署在 `NAT` 网络内部。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dfcc465af274d7786335ecc32fd33fe~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n（比较贴切的例子就是当你连接 wifi 的时候，我们就处于 `NAT` 网络内，或者网吧，公司的电脑大多都处在 `NAT` 网络内，它们共用一个路由器，然后在这些机子的上层，或上 n 层才会有一个有效的全球 IP 公网地址）\r\n\r\n<!-- [为什么局域网 IP 通常以 192.168 开头而不是 1.2 或者 193.169？](https://www.zhihu.com/question/442794368/answer/1724041004) -->\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5968b3f811da4babbf0c72c505eb0361~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nIPv6 正在逐步普及，等我们彻底用上了 IPv6，`NAT` 存在的意义就不大了。\r\n\r\n总而言之，NAT 的存在就是因为 IPv4 的地址数量有限，我太多的设备因此只能部署在 NAT 网络内部，所以就引出了我们的内网 IP 地址是不可被外网访问的问题，\r\n\r\n关于 NAT 的详细说明和原理可以看 [这篇](https://sspai.com/post/68037?ivk_sa=1024320u)，时间为王，我们暂时就不深入了解了，只需要把它理解为一个可以帮助我们实现内网与外网通信的工具就行。我常说的 `NAT 打洞`，`内网穿透`，就是利用 `NAT` 的这些特性和一些相关技术来实现的。\r\n\r\n#### 3. ICE\r\n\r\n`ICE`：`Interactive Connectivity Establishment`，交互式连接建立协议，用于在两个主机之间建立连接，它可以在两个主机之间建立连接，即使它们之间的防火墙阻止了直接连接。(可以不借助一个公网 server 完成端到端（Peer to peer，P2P）的通信)。\r\n\r\n更多关于 WebRTC 相关协议的介绍可以看 [MDN 的详细介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Protocols)，本篇文章不做重点介绍，将会在后续文章中跟着`信令服务器`等相关内容一起进行详细的介绍。\r\n\r\n### 建立连接的几个关键步骤\r\n\r\n一般来说，一个 WebRTC 应用架构是这样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64cdd8716be44e5a8ef26c606745385f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而这篇文章，我们主要为了入门`P2P`的连接，传输过程，所以我把上面的架构简化了一下，只保留了一些必要的部分：\r\n\r\n其中`蓝色`部分是`用户和信令服务器`的交互，`红色`部分是`用户和用户`之间的交互。\r\n\r\n而蓝色的部分我也进行了简化，我们将通过人工拷贝黏贴的形式，来模拟信令服务器的帮助用户传递关键信息的过程。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/515dd1624b794dc79699b64f77b02da4~tplv-k3u1fbpfcp-zoom-1.image\\\"/>\r\n\r\n这样，我们通过一个`最简单的模型`就能实现并理解 `WebRTC` 从建立连接到传输数据的整个过程了。🥳🥳🥳\r\n\r\n下面我把 WebRTC 建立连接的几个关键步骤总结了一下，方便大家理解。主要为：\r\n\r\n- 创建一个用于连接控制的 `RTCPeerConnection` 对象\r\n- 采集媒体流并添加到`RTCPeerConnection` 实例中\r\n- 建立连接，传输媒体流。\r\n\r\nok，我们来逐一分解：\r\n\r\n#### 1. 创建本地的 `RTCPeerConnection` 对象\r\n\r\n在 WebRTC 中 ，由`RTCPeerConnection` api 负责创建，保持，监控，关闭连接。我认为它是 WebRTC 的核心 api。\r\n\r\n为了让 WebRTC 的相关 api 在各个浏览器中都能够正常的运行，强烈推荐使用 [adapter.js](https://www.npmjs.com/package/webrtc-adapter),adapter.js 是一个垫片，用于将应用程序与 WebRTC 中的规范更改和前缀差异隔离开来。如今，前缀差异大多消失了，但浏览器之间的行为差异仍然存在。 而且，WebRTC 仍在快速发展，因此 adapter.js 是非常有用的。\r\n\r\n```sh\r\n# 安装它\r\nnpm install webrtc-adapter\r\n```\r\n\r\n```typescript\r\n// 你只需要引入它即可，不需要做任何配置和多余的操作。\r\nimport 'webrtc-adapter'\r\n```\r\n\r\n完事之后，首先我们需要创建一个 `RTCPeerConnection`对象，用于后面实现本地计算机到远端的 WebRTC 连接。\r\n\r\n如果你的应用需要在公网中使用，那么你需要在创建 `RTCPeerConnection` 对象的时候，传入一个配置对象，配置对象中包含了 STUN 和 TURN 服务器的地址。\r\n\r\n这两个服务器的作用是什么呢？我们先来看看 STUN 服务器。  \r\n`STUN`：`Session Traversal Utilities for NAT`，用来帮助我们获取本地计算机的公网 IP 地址，以及端口号。  \r\n`TURN`：`Traversal Using Relays around NAT`，用来帮助我们穿越 NAT 网关，实现公网中的 WebRTC 连接。一般来说它用来做兜底的，当所有方法都无法穿越 NAT 网关或者无法直接简历 P2P 连接的时候，我们才会使用到它。这时，TURN 服务器会作为一个中继服务器，然后用户的媒体流会通过它来中转传输。\r\n\r\n```typescript\r\n// 公网中使用\r\nconst pc = new RTCPeerConnection({\r\n  iceServers: [\r\n    // 目前我在用的，免费STUN 服务器\r\n    {\r\n      urls: 'stun:stun.voipbuster.com ',\r\n    },\r\n    // 谷歌的好像都失效了，不过你们可以试试\r\n    {\r\n      urls: 'stun:stun.l.google.com:19301',\r\n      // urls: 'stun:stun.l.google.com:19302',\r\n      // urls: 'stun:stun.l.google.com:19303',\r\n      // ...\r\n    },\r\n    // TURN 服务器,这个对服务器压力太大了，目前没找到免费的，后续我在自己的服务器上弄一个\r\n    {\r\n      urls: 'turn:turn.xxxx.org',\r\n      username: 'webrtc',\r\n      credential: 'turnserver',\r\n    },\r\n    {\r\n      urls: 'turn:turn.ap-southeast-1.aliyuncs.com:443?transport=tcp',\r\n      username: 'test',\r\n      credential: 'test',\r\n    },\r\n  ],\r\n})\r\n```\r\n\r\n搭建 STUN 服务器和 TURN 服务器的教程，我会在下一篇文章中和信令服务一起分享。\r\n\r\n这篇文章中，我们暂时只实现一个能在内网使用的音视频通话，所以我们暂时不需要配置 STUN，TURN 服务器。如果你想在公网中使用，那么你完全可以暂时使用上面的免费 STUN 服务器，但是 TURN 服务器就需要你自己搭建了。\r\n\r\n我的这个 👉🏻[DEMO](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d909af240d0460ebfc50b6e9c92ca7a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n就是用的上面的 免费 STUN 服务器 + 信令服务来实现 内外网的 P2P 连接。可以提前体验一下，这会在第三篇文章中详细介绍。\r\n\r\nok,不扯远了，我们继续，先创建一个 `RTCPeerConnection` 对象。\r\n\r\n```typescript\r\n// 内网中使用\r\nconst pc = new RTCPeerConnection()\r\n```\r\n\r\n然后我们创建好 `RTCPeerConnection` 对象之后，通过 `RTCPeerConnection` 对象的 `addTrack` 方法来媒体流添加到 `RTCPeerConnection` 对象中。\r\n\r\n#### 2. 采集媒体流\r\n\r\n采集和处理的方法在第一篇文章中已经做了很详细的介绍，下面我们直接使用。\r\n\r\n设置好媒体流需要挂载的音视频元素。\r\n\r\n```html\r\n<!-- 给自己本地的视频播放设置静音，防止产生回音 -->\r\n<video id=\\\"local\\\" autoplay playsinline muted></video>\r\n<video id=\\\"remote\\\" autoplay playsinline></video>\r\n```\r\n\r\n然后通过 `navigator.mediaDevices.getUserMedia` 方法来获取媒体流。\r\n\r\n一般这里的逻辑都是在我们项目加载完成的时候，或者让用户自己手动点击按钮来采集媒体流。\r\n\r\n采集完后，我们就可以通过 `RTCPeerConnection` 对象的 `addTrack` 方法来添加媒体流。\r\n\r\n将媒体流添加到 `RTCPeerConnection` 对象的方法还有一个，就是 `addStream` 方法，但是这个方法已经被废弃了，虽然现在很多教程仍然是使用的它，这里我们不推荐使用。\r\n\r\n添加完后我们也需要监听远程的媒体流是否也添加进来，当远程的媒体流也在这样我们才能够将远程的媒体流播放出来。 这里 WebRTC 为我们提供了一个 `ontrack` 事件，当远程的媒体流添加进来的时候，就会触发这个事件。\r\n\r\n第二部的初始化完整代码如下：\r\n\r\n```typescript\r\n// 初始化\r\nasync function init(params: type) {\r\n  // 获取本地端视频标签\r\n  const localVideo = document.getElementById('local') as HTMLVideoElement\r\n  // 获取远程端视频标签\r\n  const remoteVideo = document.getElementById('remote') as HTMLVideoElement\r\n\r\n  // 采集本地媒体流\r\n  const localStream = await navigator.mediaDevices.getUserMedia({\r\n    video: true,\r\n    audio: true,\r\n  })\r\n  // 设置本地视频流\r\n  localVideo.srcObject = localStream\r\n\r\n  // 不推荐使用：已经过时的方法 [addStream API](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream)\r\n  // pc.addStream(localStream);\r\n\r\n  // 添加本地媒体流的轨道都添加到 RTCPeerConnection 中\r\n  localStream.getTracks().forEach((track) => {\r\n    pc.addTrack(track, localStream)\r\n  })\r\n\r\n  // 监听远程流，方法一：\r\n  pc.ontrack = (event) => {\r\n    remoteVideo.srcObject = event.streams[0]\r\n  }\r\n\r\n  // 方法二：你也可以使用 addStream API，来更加详细的控制流的添加\r\n  // const remoteStream: MediaStream = new MediaStream()\r\n  // pc.ontrack = (event) => {\r\n  //   event.streams[0].getTracks().forEach((track) => {\r\n  //     remoteStream.addTrack(track)\r\n  //   })\r\n  //   // 设置远程视频流\r\n  //   remoteVideo.srcObject = remoteStream\r\n  // }\r\n}\r\n```\r\n\r\nok，下一步就到了我们的第 3 步，也就是建立连接\r\n\r\n#### 3. 建立连接\r\n\r\n建立连接的主要过程，就是通过 `RTCPeerConnection` 对象的 `createOffer` 方法来创建本地的 `SDP` 描述，然后通过 `RTCPeerConnection` 对象的 `setLocalDescription` 方法来设置本地的 `SDP` 描述，最后通过 `RTCPeerConnection` 对象的 `setRemoteDescription` 方法来设置远程的 `SDP` 描述。\r\n\r\n- 创建 offer（提案）\r\n\r\n```typescript\r\n// 创建本地/远程 SDP 描述, 用于描述本地/远程的媒体流\r\nlet offerSdp = ''\r\nlet answerSdp = ''\r\n\r\nconst createOffer = async () => {\r\n  // 创建 offer\r\n  const offer = await pc.createOffer()\r\n  // 设置本地描述\r\n  await pc.setLocalDescription(offer)\r\n  // await pc.setLocalDescription()\r\n  // 到这里，我们本地的 offer 就创建好了，一般在这里通过信令服务器发送 offerSdp 给远端\r\n\r\n  // 监听 RTCPeerConnection 的 onicecandidate 事件，当 ICE 服务器返回一个新的候选地址时，就会触发该事件\r\n  pc.onicecandidate = async (event) => {\r\n    if (event.candidate) {\r\n      offerSdp.value = JSON.stringify(pc.localDescription)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n其中的 `onicecandidate` 事件，是用来监听 ICE 服务器返回的候选地址，当 ICE 服务器返回一个新的候选地址时，就会触发该事件，这里我们需要将这个候选地址发送给远端，这样远端才能够和我们建立连接。\r\n\r\n当然，你也可以在`peerConnection.setLocalDescription()`时，不传参数，这样 WebRTC 会默认调用`peerConnection.createOffer()`来创建 offer。\r\n\r\n```typescript\r\nconst offer = await peerConnection.createOffer()\r\nawait peerConnection.setLocalDescription(offer)\r\nconsole.log(peerConnection)\r\n```\r\n\r\n```typescript\r\n// 不传参数，默认调用 peerConnection.createOffer()\r\nawait peerConnection.setLocalDescription()\r\nconsole.log(peerConnection)\r\n```\r\n\r\n我们可以把它打印一下，可以看到一样是能够创建出 offer 并设置到本地描述中的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33c717b9d8e14d01afe9a8ee21f7c205~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a4be4a51164d2db6ea039a2e55174c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7a95368859450fba7cd9ed462ce424~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是不推荐这么做，WebRTC 还在不断的更新中，本身就存在很多实验性的 API，所以我们还是要遵循规范来。该传就传。😅\r\n\r\nok，下一步就到了我们的第 3 步，也就是创建 offer 并发送给远程端。并监听远程端的 answer。拿到 answer 后，我们就可以设置到远程端的描述中。\r\n\r\n- 创建 answer\r\n\r\n作为接收方，在拿到 offer 后，我们就可以创建 answer 并设置到本地描述中，然后通过信令服务器发送 answer 给对端。\r\n\r\n```typescript\r\nconst createAnswer = async () => {\r\n  // 解析字符串\r\n  const offer = JSON.parse(offerSdp)\r\n  pc.onicecandidate = async (event) => {\r\n    // Event that fires off when a new answer ICE candidate is created\r\n    if (event.candidate) {\r\n      answerSdp = JSON.stringify(pc.localDescription)\r\n    }\r\n  }\r\n  await pc.setRemoteDescription(offer)\r\n  const answer = await pc.createAnswer()\r\n  await pc.setLocalDescription(answer)\r\n}\r\n```\r\n\r\n- 添加 answer\r\n\r\n接收方拿到 answer 后，就可以设置到远程端的描述中。\r\n\r\n```typescript\r\n// 添加 answer(应答)\r\nconst addAnswer = async () => {\r\n  const answer = JSON.parse(answerSdp)\r\n  if (!pc.currentRemoteDescription) {\r\n    pc.setRemoteDescription(answer)\r\n  }\r\n}\r\n```\r\n\r\n一个最简单的 WebRTC 通信流程就完成了。\r\n\r\n[👉🏻 本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/p2p)\r\n\r\n你可以开两个浏览器 tab 或者用不同的设备，根据说明即可体验音视频通话的实现。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99949ed78d234bb78842e87d1cfbbfe7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n是不是感觉形似 TCP 的三次握手？  这样，我们就完成了从采集媒体流，建立连接，传输的全过程。只是这里的建立连接，需要我们手动将 offer 和 answer 传输给对端，如果我们想要实现自动建立连接，那么就需要使用到信令服务器了。这将会在下一篇文章中详细介绍。下一篇文章，我们会从实战出发，讲解 WebRTC 的音视频通话中如何通过信令服务器进行通信，自动建立连接，以及如何搭建一个 STUN，TURN 服务器等。\r\n\r\n## 最后\r\n\r\n[👉🏻 本文示例源代码地址](https://github.com/wangrongding/frontend-park)  \r\n[👉🏻 本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/p2p)\r\n\r\n你也可以提前体验一下[👉🏻 下一篇文章的示例](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p) ,通过信令服务器自动建立连接的 1v1 音视频通话，支持内外网。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe50b89e9eb24c7aa50bd585a3f80602~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这篇文章的概念比较多，有很多地方我并没有花大量的篇幅去讲解它是什么以及原理是什么样的，比如 SDP，ICE 等等，为什么呢？我认为作为一个入门篇讲这些概念，上来就灌输大量的这类概念，会让文章非常乏味，就像是直接搬文档，因为聪明的读者肯定也会在看这篇文章遇到不理解的概念性的东西，或者看完对感兴趣的地方进行查阅。不过大家如果有遇到哪一块非常不理解又没找到什么好的方案的时候，可以在评论区留言，我也会尽快回复。🫶\r\n\r\n本文是 WebRTC 系列的第二篇，后续还会有很多篇，如果你觉得本文对你有帮助，你的点赞支持就是我的动力 🌸 ~\r\n"
    },
    {
        "article_id": "7164175171358556173",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b43847957944e2da5dac558d04d06d2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【中级/高级前端】为什么我建议你一定要读一读 Tapable 源码？",
        "preview": "所有人都知道 Webpack 很复杂，但 Webpack 的源码却很优雅，是一个典型的可插拔架构，不仅逻辑清晰，而且灵活好扩展。近几年出来的一些构建工具，大多也都参考了 Webpack 的这种架构方式",
        "author": "不要秃头啊",
        "view_count": 17416,
        "collect_count": 608,
        "comment_count": 50,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5db9ef9c19e9f3cbbf4fb73e0e283a7a~300x300.image",
        "category": "前端",
        "content": "---\r\nhighlight: zenburn\r\ntheme: devui-blue\r\n---\r\n## 一、前言\r\n\r\n本文是 [从零到亿系统性的建立前端构建知识体系✨](https://juejin.cn/post/7145855619096903717)\r\n中的第六篇，整体难度 ⭐️⭐️⭐️。\r\n\r\n> 回应标题：为什么我建议你一定要读一读 Tapable 源码？\r\n\r\n所有人都知道 [Webpack](https://webpack.js.org/) 很复杂，但 Webpack 的源码却很优雅，是一个典型的**可插拔架构**，不仅逻辑清晰，而且灵活好扩展。近几年出来的一些构建工具，大多也都参考了 Webpack 的这种架构方式。\r\n\r\n而实现这一切的核心就是借助了 [Tapable](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable \\\"https://www.npmjs.com/package/tapable\\\")。\r\n\r\n关于 [Tapable](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable \\\"https://www.npmjs.com/package/tapable\\\") 的源码其实并没有多少代码量，学习它的原理首当其冲的一定是可以让你在日常 [Webpack Plugin](https://webpack.js.org/concepts/plugins/) 开发中更得心应手，解决相关问题更加顺畅。\r\n\r\n其次，Tapable 的内部以特别巧妙的方式实现了**发布订阅模式**，这之中会有非常多的知识点：比如**懒编译或者叫动态编译**，关于**类与继承抽象类的面向对象思想**以及 **this 指向的升华**等等...\r\n\r\n在我个人看来， Tapable 源代码中的设计原则和实现过程是非常值得每一个前端开发者去阅读的。\r\n\r\n> 回到正文\r\n\r\n在本文中我们将会抛开 Webpack，在第 1 ～ 5 节主要是讲解基本原理和使用方式（奈何官方文档实在太简陋...），第 6 节则会以图文的形式深度分析 [Tapable ](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable \\\"https://www.npmjs.com/package/tapable\\\")的实现原理，熟悉使用的同学可跳过前面几节。\r\n\r\n通篇将会采用**结论先行、自顶向下**的方式进行讲解，`注重实现思路，注重设计思想`，与 Webpack 完全解耦，可放心食用。\r\n\r\n文中所涉及到的代码均放到个人 github 仓库中：https://github.com/noBaldAaa/my-tapable\r\n\r\n![852d0881-fca6-4faa-b281-50d378b099b1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47117e5271e04dfc8cb0cab3ca10ca13~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 二、Tapable是什么？\r\n\r\n[Tapable](https://www.npmjs.com/package/tapable)是一个类似于 Node.js 中的 [EventEmitter](https://www.npmjs.com/package/events) 的库，但它**更专注于自定义事件的触发和处理**。通过 Tapable 我们可以注册自定义事件，然后在适当的时机去执行自定义事件。\r\n\r\n![0f6a5dc1-229f-496c-a630-b7e724acef28.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be77329e409a45d5bd184965ce8f5760~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n举个例子🌰：类比到 `Vue` 和 `React` 框架中的生命周期函数，它们就是到了固定的时间节点就执行对应的生命周期，`tapable` 做的事情就和这个差不多，我们可以通过它先注册一系列的生命周期函数，然后在合适的时间点执行。\r\n\r\n概念了解的差不多了，接下来去实操一下。初始化项目，安装依赖：\r\n\r\n```js\r\nnpm init //初始化项目\r\nyarn add tapable -D //安装依赖\r\n```\r\n\r\n安装完项目依赖后，根据以下目录结构来添加对应的目录和文件：\r\n```\r\n├── node_modules\r\n├── package-lock.json\r\n├── package.json\r\n└── src # 源码目录\r\n     └── syncHookDemo.js\r\n```\r\n\r\n根据官方介绍，[tapable](https://www.npmjs.com/package/tapable) 使用起来还是挺简单的，只需三步：\r\n\r\n1. 实例化钩子函数（ [tapable](https://www.npmjs.com/package/tapable)会暴露出各种各样的 Hook，这里先以同步钩子`Synchook`为例）\r\n2. 注册事件\r\n3. 触发事件\r\n\r\n**src/syncHookDemo.js**\r\n```js\r\nconst SyncHook = require(\\\"../my/SyncHook\\\"); //这是一个同步钩子\r\n\r\n//第一步：实例化钩子函数，可以在这里定义形参\r\nconst syncHook = new SyncHook([\\\"author\\\", \\\"age\\\"]);\r\n\r\n//第二步：注册事件1\r\nsyncHook.tap(\\\"监听器1\\\", (name, age) => {\r\n  console.log(\\\"监听器1:\\\", name, age);\r\n});\r\n\r\n//第二步：注册事件2\r\nsyncHook.tap(\\\"监听器2\\\", (name) => {\r\n  console.log(\\\"监听器2\\\", name);\r\n});\r\n\r\n//第三步：注册事件3\r\nsyncHook.tap(\\\"监听器3\\\", (name) => {\r\n  console.log(\\\"监听器3\\\", name);\r\n});\r\n//第三步：触发事件，这里传的是实参，会被每一个注册函数接收到\r\nsyncHook.call(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n\r\n运行 `node ./src/syncHookDemo.js`，拿到执行结果：\r\n\r\n```\r\n监听器1 不要秃头啊 99\r\n监听器2 不要秃头啊\r\n监听器3 不要秃头啊\r\n```\r\n\r\n![63c7e8b4-11bd-4cc5-a96d-be8bcc486365.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0877aad167f241b49348be60056f7730~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从上面的例子中可以看出 [tapable](https://www.npmjs.com/package/tapable) 采用的是**发布订阅模式**，`通过 tap 函数注册监听函数，然后通过 call 函数按顺序执行之前注册的函数`。\r\n\r\n大致原理（**真实源码中并不是这样，第六节会分析源码中的实现，这里帮助大家理解**）：\r\n\r\n```js\r\nclass SyncHook {\r\n  constructor() {\r\n    this.taps = [];\r\n  }\r\n\r\n  //注册监听函数，这里的name其实没啥用\r\n  tap(name, fn) {\r\n    this.taps.push({ name, fn });\r\n  }\r\n\r\n  //执行函数\r\n  call(...args) {\r\n    this.taps.forEach((tap) => tap.fn(...args));\r\n  }\r\n}\r\n```\r\n\r\n## 三、按照同步/异步分类\r\n\r\n另外，[tapable](https://www.npmjs.com/package/tapable) 中不仅有 `Synchook`，还有其他 八个 `Hook` :\r\n\r\n```js\r\nconst {\r\n  SyncHook,\r\n  SyncBailHook,\r\n  SyncWaterfallHook,\r\n  SyncLoopHook,\r\n  AsyncParallelHook,\r\n  AsyncParallelBailHook,\r\n  AsyncSeriesHook,\r\n  AsyncSeriesBailHook,\r\n  AsyncSeriesWaterfallHook,\r\n} = require(\\\"tapable\\\");\r\n```\r\n\r\n![583a28ed-ca3a-4436-8d3b-a440550b3c04.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce82751ba4d147a7aa406129ebe57026~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在这九个 `Hook` 中所注册的事件可以分为**同步、异步**两种执行方式，正如名称表述的那样：\r\n\r\n- 同步表示注册的事件函数会同步进行执行\r\n- 异步表示注册的事件函数会异步进行执行\r\n    \r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd77ce17371d4122b85d28d65453cd16~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n对同步钩子来说， `tap` 方法是唯一注册事件的方法，通过 `call` 方法触发同步钩子的执行。\r\n\r\n对异步钩子来说，可以通过 `tap`、`tapAsync`、`tapPromise`三种方式来注册，通过对应的 `callAsync`、`promise` 这两种方式来触发注册的函数。\r\n\r\n同时异步钩子中还可以分为两类：\r\n\r\n- 异步串行钩子( `AsyncSeries` )：可以被串联（连续按照顺序调用）执行的异步钩子函数。    \r\n- 异步并行钩子( `AsyncParallel` )：可以被并联（并发调用）执行的异步钩子函数。\r\n\r\n***虽然这里分类分来分去，但是其实大家可以不用死记硬背，需要用到的时候查文档就好。***\r\n\r\n## 四、按照执行机制分类\r\n\r\nTapable 同时也可以按照**执行机制**进行分类，这里说一下这几个类型的概念，后面会通过案例细讲：\r\n\r\n-   **Basic Hook** : 基本类型的钩子，执行每一个注册的事件函数，并不关心每个被调用的事件函数返回值如何。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67a33823852547b7a4695ec7f5e21755~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n-   **Waterfall** : 瀑布类型的钩子，如果前一个事件函数的结果 `result !== undefined`，则 result 会作为后一个事件函数的第一个参数（也就是上一个函数的执行结果会成为下一个函数的参数）\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53af372ec754f22937061112646c001~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n-   **Bail** : 保险类型钩子，执行每一个事件函数，遇到第一个结果 `result !== undefined` 则返回，不再继续执行（也就是只要其中一个有结果了，后面的就不执行了）\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5f261e0f7f249f495ccdca094b9e437~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n-   **Loop** : 循环类型钩子，不停的循环执行事件函数，直到所有函数结果 `result === undefined`（有点像我们小时候打单机游戏一样，只要哪一关不小心死了，就得从头再来一遍，直到所有的关卡都打过才算通关）。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b999053b1e84918a5e3634f939d17ef~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edf64f69c5b9404e981422799aa7e4bc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在最开始的案例中我们用的`SyncHook`，它就是一个同步的钩子。又因为并不关心返回值，所以也算是一个基本类型的 `Hook`。\r\n\r\n## 五、基本使用\r\n\r\n### 5.1、SyncHook\r\n\r\n开头所用的案例就是基于 `SyncHook`，就不再赘述。\r\n\r\n### 5.2、SyncBailHook\r\n\r\n`SyncBailHook` 是一个同步的、保险类型的 `Hook`，意思是只要其中一个有返回了，后面的就不执行了。\r\n\r\n**src/syncBailHookDemo.js**\r\n\r\n```js\r\nconst { SyncBailHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new SyncBailHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\n\r\n//通过tap函数注册事件\r\nhook.tap(\\\"测试1\\\", (param1, param2) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n});\r\n\r\n//该监听函数有返回值\r\nhook.tap(\\\"测试2\\\", (param1, param2) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  return \\\"123\\\";\r\n});\r\n\r\nhook.tap(\\\"测试3\\\", (param1, param2) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n});\r\n\r\n//通过call方法触发事件\r\nhook.call(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n\r\n运行 `node ./src/syncBailHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 不要秃头啊 99\r\n```\r\n### 5.3、SyncWaterfallHook\r\n\r\n`SyncWaterfallHook` 是一个同步的、瀑布式类型的 `Hook`。瀑布类型的钩子就是如果前一个事件函数的结果 `result !== undefined`，则 `result` 会作为后一个事件函数的第一个参数（也就是上一个函数的执行结果会成为下一个函数的参数）\r\n\r\n**src/syncWaterfallHookDemo.js**\r\n\r\n```js\r\nconst { SyncWaterfallHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new SyncWaterfallHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\n\r\n//通过tap函数注册事件\r\nhook.tap(\\\"测试1\\\", (param1, param2) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n});\r\n\r\nhook.tap(\\\"测试2\\\", (param1, param2) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  return \\\"123\\\";\r\n});\r\n\r\nhook.tap(\\\"测试3\\\", (param1, param2) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n});\r\n\r\n//通过call方法触发事件\r\nhook.call(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n\r\n运行 `node ./src/syncWaterfallHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 不要秃头啊 99\r\n测试3接收的参数： 123 99\r\n```\r\n\r\n### 5.4、SyncLoopHook\r\n\r\n`SyncLoopHook` 是一个同步、循环类型的 `Hook`。循环类型的含义是不停的循环执行事件函数，直到所有函数结果 `result === undefined`，不符合条件就调头重新开始执行。\r\n\r\n**src/syncLoopHookDemo.js**\r\n\r\n```js\r\nconst { SyncLoopHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new SyncLoopHook([]); //先实例化，并定义回调函数的形参\r\n\r\nlet count = 5;\r\n\r\n//通过tap函数注册事件\r\nhook.tap(\\\"测试1\\\", () => {\r\n  console.log(\\\"测试1里面的count:\\\", count);\r\n  if ([1, 2, 3].includes(count)) {\r\n    return undefined;\r\n  } else {\r\n    count--;\r\n    return \\\"123\\\";\r\n  }\r\n});\r\n\r\nhook.tap(\\\"测试2\\\", () => {\r\n  console.log(\\\"测试2里面的count:\\\", count);\r\n  if ([1, 2].includes(count)) {\r\n    return undefined;\r\n  } else {\r\n    count--;\r\n    return \\\"123\\\";\r\n  }\r\n});\r\n\r\nhook.tap(\\\"测试3\\\", () => {\r\n  console.log(\\\"测试3里面的count:\\\", count);\r\n  if ([1].includes(count)) {\r\n    return undefined;\r\n  } else {\r\n    count--;\r\n    return \\\"123\\\";\r\n  }\r\n});\r\n\r\n//通过call方法触发事件\r\nhook.call();\r\n```\r\n\r\n运行 `node ./src/syncLoopHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1里面的count: 5\r\n测试1里面的count: 4\r\n测试1里面的count: 3\r\n测试2里面的count: 3\r\n测试1里面的count: 2\r\n测试2里面的count: 2\r\n测试3里面的count: 2\r\n测试1里面的count: 1\r\n测试2里面的count: 1\r\n测试3里面的count: 1\r\n```\r\n\r\n### 5.5、AsyncParallelHook\r\n\r\n前面四个都是同步的 `Hook`，接下来开始看看异步的 `Hook`。\r\n\r\n`AsyncParallelHook`是一个异步并行、基本类型的 `Hook`，它与同步 `Hook` 不同的地方在于：\r\n\r\n- 它会同时开启多个异步任务，而且需要通过 `tapAsync` 方法来注册事件（同步 `Hook` 是通过 `tap` 方法）\r\n- 在执行注册事件时需要使用 `callAsync` 方法来触发（同步 `Hook` 使用的是 `call` 方法）\r\n\r\n同时，在每个注册函数的回调中，会多一个 `callback` 参数，它是一个函数。执行 `callback` 函数相当于告诉 `Hook` 它这一个异步任务执行完成了。\r\n\r\n**src/asyncParallelHookDemo.js**\r\n\r\n```js\r\nconst { AsyncParallelHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new AsyncParallelHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\nconsole.time(\\\"time\\\");\r\n//异步钩子需要通过tapAsync函数注册事件,同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成\r\nhook.tapAsync(\\\"测试1\\\", (param1, param2, callback) => {\r\n  setTimeout(() => {\r\n    console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n    callback();\r\n  }, 2000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试2\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  callback();\r\n});\r\n\r\nhook.tapAsync(\\\"测试3\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n  callback();\r\n});\r\n\r\n//call方法只有同步钩子才有，异步钩子得使用callAsync\r\nhook.callAsync(\\\"不要秃头啊\\\", \\\"99\\\", (err, result) => {\r\n  //等全部都完成了才会走到这里来\r\n  console.log(\\\"这是成功后的回调\\\", err, result);\r\n  console.timeEnd(\\\"time\\\");\r\n});\r\n```\r\n\r\n运行 `node ./src/asyncParallelHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试2接收的参数： 不要秃头啊 99\r\n测试3接收的参数： 不要秃头啊 99\r\n测试1接收的参数： 不要秃头啊 99\r\n这是成功后的回调 undefined undefined\r\ntime: 2.008s\r\n```\r\n\r\n### 5.6、AsyncParallelBailHook\r\n\r\n`AsyncParallelBailHook` 是一个异步并行、保险类型的 `Hook`，只要其中一个有返回值，就会执行 `callAsync` 中的回调函数。\r\n\r\n**src/asyncParallelBailHookDemo.js**\r\n\r\n```js\r\nconst { AsyncParallelBailHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new AsyncParallelBailHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\nconsole.time(\\\"time\\\");\r\n//异步钩子需要通过tapAsync函数注册事件,同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成\r\nhook.tapAsync(\\\"测试1\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 1000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试2\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"测试2有返回值啦\\\");\r\n  }, 2000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试3\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"测试3有返回值啦\\\");\r\n  }, 3000);\r\n});\r\n\r\nhook.callAsync(\\\"不要秃头啊\\\", \\\"99\\\", (err, result) => {\r\n  //等全部都完成了才会走到这里来\r\n  console.log(\\\"这是成功后的回调\\\", result);\r\n  console.timeEnd(\\\"time\\\");\r\n});\r\n```\r\n\r\n运行 `node ./src/asyncParallelBailHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 不要秃头啊 99\r\n测试3接收的参数： 不要秃头啊 99\r\n这是成功后的回调 测试2有返回值啦\r\ntime: 2.007s\r\n```\r\n\r\n### 5.7、AsyncSeriesHook\r\n\r\n`AsyncSeriesHook` 是一个异步、串行类型的 `Hook`，只有前面的执行完成了，后面的才会一个接一个的执行。\r\n\r\n**src/asyncSeriesHookDemo.js**\r\n\r\n```js\r\nconst { AsyncSeriesHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new AsyncSeriesHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\nconsole.time(\\\"time\\\");\r\n//异步钩子需要通过tapAsync函数注册事件,同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成\r\nhook.tapAsync(\\\"测试1\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 1000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试2\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 2000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试3\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 3000);\r\n});\r\n\r\nhook.callAsync(\\\"不要秃头啊\\\", \\\"99\\\", (err, result) => {\r\n  //等全部都完成了才会走到这里来\r\n  console.log(\\\"这是成功后的回调\\\", err, result);\r\n  console.timeEnd(\\\"time\\\");\r\n});\r\n```\r\n\r\n运行 `node ./src/asyncSeriesHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 不要秃头啊 99\r\n测试3接收的参数： 不要秃头啊 99\r\n这是成功后的回调 undefined undefined\r\ntime: 6.017s\r\n```\r\n### 5.8、AsyncSeriesBailHook\r\n\r\n`AsyncSeriesBailHook` 是一个异步串行、保险类型的 `Hook`。在串行的执行过程中，只要其中一个有返回值，后面的就不会执行了。\r\n\r\n**src/asyncSeriesBailHookDemo.js**\r\n\r\n```js\r\nconst { AsyncSeriesBailHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new AsyncSeriesBailHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\nconsole.time(\\\"time\\\");\r\n//异步钩子需要通过tapAsync函数注册事件,同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成\r\nhook.tapAsync(\\\"测试1\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 1000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试2\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"123\\\");\r\n  }, 2000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试3\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback();\r\n  }, 3000);\r\n});\r\n\r\nhook.callAsync(\\\"不要秃头啊\\\", \\\"99\\\", (err, result) => {\r\n  //等全部都完成了才会走到这里来\r\n  console.log(\\\"这是成功后的回调\\\", result);\r\n  console.timeEnd(\\\"time\\\");\r\n});\r\n```\r\n运行 `node ./src/asyncSeriesBailHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 不要秃头啊 99\r\n这是成功后的回调 123\r\ntime: 3.010s\r\n```\r\n\r\n### 5.9、AsyncSeriesWaterfallHook\r\n\r\n`AsyncSeriesWaterfallHook` 是一个异步串行、瀑布类型的 `Hook`。如果前一个事件函数的结果 `result !== undefined`，则 `result` 会作为后一个事件函数的第一个参数（也就是上一个函数的执行结果会成为下一个函数的参数）。\r\n\r\n**src/asyncSeriesWaterfallHookDemo.js**\r\n\r\n```js\r\nconst { AsyncSeriesWaterfallHook } = require(\\\"tapable\\\");\r\n\r\nconst hook = new AsyncSeriesWaterfallHook([\\\"author\\\", \\\"age\\\"]); //先实例化，并定义回调函数的形参\r\nconsole.time(\\\"time\\\");\r\n//异步钩子需要通过tapAsync函数注册事件,同时也会多一个callback参数，执行callback告诉hook该注册事件已经执行完成\r\nhook.tapAsync(\\\"测试1\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试1接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"2\\\");\r\n  }, 1000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试2\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试2接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"3\\\");\r\n  }, 2000);\r\n});\r\n\r\nhook.tapAsync(\\\"测试3\\\", (param1, param2, callback) => {\r\n  console.log(\\\"测试3接收的参数：\\\", param1, param2);\r\n  setTimeout(() => {\r\n    callback(null, \\\"4\\\");\r\n  }, 3000);\r\n});\r\n\r\nhook.callAsync(\\\"不要秃头啊\\\", \\\"99\\\", (err, result) => {\r\n  //等全部都完成了才会走到这里来\r\n  console.log(\\\"这是成功后的回调\\\", err, result);\r\n  console.timeEnd(\\\"time\\\");\r\n});\r\n```\r\n\r\n运行 `node ./src/asyncSeriesWaterfallHookDemo.js`，拿到执行结果：\r\n\r\n```js\r\n测试1接收的参数： 不要秃头啊 99\r\n测试2接收的参数： 2 99\r\n测试3接收的参数： 3 99\r\n这是成功后的回调 null 4\r\ntime: 6.012s\r\n```\r\n\r\n## 六、具体实现\r\n\r\n在开始读源码之前，我们先得弄清楚如何调试源码，以及如何在 IDE 中快速的执行代码文件。\r\n\r\n### 6.1、工欲善其事，必先利其器\r\n\r\n> （1）调试源码：\r\n\r\n第一步：修改 `Hook` 的引用路径：\r\n\r\n**syncHookDemo.js**\r\n\r\n```js\r\n//之前\r\nconst { SyncHook } = require(\\\"tapable\\\");\r\n\r\n//修改后\r\nconst SyncHook = require(\\\"../node_modules/tapable/lib/SyncHook\\\");\r\n```\r\n\r\n第二步：打开 Vscode 调试工具，在代码中打上断点：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80db468f99e14f2cb03057c3fd66ddb9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第三步：点击 Run and Debug，选择 Node.js 环境\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df1784efb5ef40539f9c0f6edf1b2ab8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> （2）在 IDE 中快速的执行代码文件\r\n\r\n第一步：在 IDE 的应用商店中下载插件 [Code Runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd800382790b4d0ea04e39128e5af8d3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第二步：选择想要运行的文件，点击右键，选择 Run Code 选项：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185944ed923842f3a72db88a155b3c54~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第三步：在控制台中查看结果：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4df7e67a1ce8438994b04c611b9940f4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 6.2、核心思想\r\n\r\n这里以 `SyncHook` 的实现原理为例，其他的 `Hook` 也会整理一下思路，大家举一反三，重点在于理解思想。\r\n\r\n![417eb28e-eeef-4bc8-9ec9-66b18f28cdca.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb6fc1ee1e794a0e8760793457594f79~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们再回过头来看看 `SyncHook` 的用法，也就是这三步：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/867ad31ffdac43329f2b81c6faee0441~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n核心思想：\r\n\r\n其实 `tap` 函数就是一个收集器，当调用 `tap` 函数时需要将传入的这些信息进行收集，并转换成一个数组，数组里面存放着注册函数的`类型type`、`回调函数(fn)`等信息：\r\n\r\n```js\r\nthis.taps = [\r\n  {\r\n    name: \\\"监听器1\\\",\r\n    type: \\\"sync\\\",\r\n    fn: (param1, param2) => {\r\n      console.log(\\\"监听器1接收参数：\\\", name, age);\r\n    },\r\n  },\r\n  {\r\n    name: \\\"监听器2\\\",\r\n    type: \\\"sync\\\",\r\n    fn: (param1, param2) => {\r\n      console.log(\\\"监听器2接收参数：\\\", name);\r\n    },\r\n  },\r\n]; //用来存放我们的回调函数基本信息\r\n```\r\n\r\n调用 `call` 函数的本质就是 **`按指定的类型`** 去执行 `this.taps`中的注册函数 `fn`，比如这里的 `type: sync`，就是得按同步的方式执行，那我们只需将运行代码改造成这样：\r\n\r\n```js\r\nfunction anonymous(param1, param2) {\r\n  const taps = this.taps;\r\n  \r\n  let fn0 = taps[0].fn;\r\n  fn0(param1, param2);\r\n\r\n  let fn1 = taps[1].fn;\r\n  fn1(param1, param2);\r\n}\r\nanonymous(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n如果要按照`SyncBailHook`（同步、保险类型：只要其中一个有返回值，后面的就不执行了 ）执行，那我们只需将运行代码改造成这样：\r\n\r\n```js\r\nfunction anonymous(param1, param2) {\r\n  const taps = this.taps;\r\n  \r\n  let fn0 = taps[0].fn;\r\n  let result0 = fn0(param1, param2);\r\n\r\n  if (result0 !== undefined) {\r\n    return result0;\r\n  } else {\r\n    let fn1 = taps[1].fn;\r\n    let result1 = fn1(param1, param2);\r\n\r\n    if (result1 !== undefined) {\r\n      return result1;\r\n    }\r\n  }\r\n}\r\nanonymous(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n\r\n如果得按照 `AsyncSeriesHook`（异步、串行类型：只有前面的执行完成了，后面的才会一个接一个的执行 ）执行，那我们需要将运行代码改造成这样：\r\n\r\n```js\r\nfunction anonymous(param1, param2, callback) {\r\n  const taps = this.taps;\r\n  \r\n  let fn0 = taps[0].fn;\r\n  fn0(param1, param2, function (err) {\r\n    if (err) {\r\n      //如果运行过程中报错，则直接结束\r\n      callback(err);\r\n    } else {\r\n      next0();\r\n    }\r\n  });\r\n\r\n  function next0() {\r\n    let fn1 = taps[1].fn;\r\n    fn1(param1, param2, function (err) {\r\n      if (err) {\r\n        callback(err);\r\n      } else {\r\n        callback(); //在末尾执行最终的回调函数\r\n      }\r\n    });\r\n  }\r\n}\r\nanonymous(\\\"不要秃头啊\\\", \\\"99\\\", (err,result)=>\\\"最终的回调函数\\\");\r\n```\r\n剩下的类型大家可以举一反三，就不类举了。\r\n\r\n--------------------------------------------\r\n\r\n### 6.3、如何生成运行函数\r\n\r\n有了可行的思路之后，现在的问题就变成了怎么样生成这些运行函数？\r\n\r\n这里官方的源码中是通过 [new Function()](https://zh.javascript.info/new-function) 进行创建的，先了解一下 `new Function` 的语法：\r\n\r\n```js\r\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\r\n```\r\n\r\n-   `arg1, arg2, ... argN（参数名称）`：是一个有效的 JavaScript 字符串（例如：\\\"a , b\\\"），或者是一个字符串列表（例如：[\\\"a\\\"，\\\"b\\\"]）。\r\n-   `functionBody（函数体）`：可执行的JavaScript字符串。\r\n\r\n举个例子：\r\n\r\n```js\r\nconst sum = new Function(\\\"a,b\\\", \\\"return a + b\\\");\r\nconsole.log(sum(2, 6));\r\n//output: 8\r\n```\r\n\r\n这里大家可以仔细观察一下上面我们所需要的目标函数体，以 `SyncHook` 所需要的函数体为例：\r\n\r\n```js\r\nfunction anonymous(param1, param2) {\r\n  const taps = this.taps;\r\n  \r\n  let fn0 = taps[0].fn;\r\n  fn0(param1, param2);\r\n\r\n  let fn1 = taps[1].fn;\r\n  fn1(param1, param2);\r\n}\r\nanonymous(\\\"不要秃头啊\\\", \\\"99\\\");\r\n```\r\n该函数体其实可以分为两部分：\r\n\r\n - 第一部分（header）：获取存放着注册函数信息的数组 `taps`：\r\n\r\n```js\r\n const taps = this.taps;\r\n```\r\n\r\n - 第二部分（content）：可以通过对 `taps` 进行遍历生成：\r\n\r\n```js\r\n  let fn0 = taps[0].fn;\r\n  fn0(param1, param2);\r\n\r\n  let fn1 = taps[1].fn;\r\n  fn1(param1, param2);\r\n```\r\n\r\n现在通过`new Function()`生成我们想要的执行函数，就很简单了：\r\n\r\n- 第一步：生成形参字符串（`\\\"param1 , param2\\\"`）\r\n- 第二步：生成函数体中 `header` 部分\r\n- 第三步：遍历 taps，生成 `content` 部分\r\n\r\n```js\r\nnew Function(this.args().join(\\\",\\\"), this.header() + this.content());\r\n```\r\n核心思路就是这些，接下来我们就去实操一下！\r\n\r\n### 6.4、手撕代码\r\n\r\n按照上面的思路，首先需要通过 `tap` 函数进行收集工作，并将收集到的函数格式化成这样：\r\n\r\n```js\r\nthis.taps = [\r\n  {\r\n    name: \\\"监听器1\\\",\r\n    type: \\\"sync\\\",\r\n    fn: (param1, param2) => {\r\n      console.log(\\\"监听器1接收参数：\\\", name, age);\r\n    },\r\n  },\r\n  {\r\n    name: \\\"监听器2\\\",\r\n    type: \\\"sync\\\",\r\n    fn: (param1, param2) => {\r\n      console.log(\\\"监听器2接收参数：\\\", name);\r\n    },\r\n  },\r\n]; //用来存放我们的回调函数基本信息\r\n```\r\n\r\n大致结构搭建：\r\n\r\n```js\r\nclass SyncHook {\r\n  constructor(args) {\r\n    this.args = Array.isArray(args) ? args : []; //形参列表\r\n    this.taps = []; //这是一个数组，用来存放注册函数的基本信息\r\n  }\r\n}\r\n```\r\n这里定义了两个变量：`this.args 用来存放实例化过程中传入的形参数组`，`this.taps` 用来存放注册函数的基本信息。\r\n\r\n> （1）taps 的收集工作\r\n\r\n这里分成两个小步骤，先对传入参数进行格式化。\r\n\r\n我们之前在使用 `tap` 方法时是这么使用的：\r\n\r\n```js\r\nhook.tap(\\\"监听器1\\\", callback);\r\n```\r\n这里其实是一个语法糖，写完整了是这样：\r\n\r\n```js\r\nhook.tap({name:\\\"监听器1\\\",后面还可以有其他参数}, callback);\r\n```\r\n因此先要做一层格式化处理：\r\n\r\n```js\r\nclass SyncHook {\r\n  //省略其他\r\n\r\n+ tap(option, fn) {\r\n+   //如果传入的是字符串，包装成对象\r\n+   if (typeof option === \\\"string\\\") {\r\n+     option = { name: option };\r\n+   }\r\n+ }\r\n}\r\n```\r\n\r\n接着定义 `tap` 函数，收集注册函数信息：\r\n\r\n```js\r\nclass SyncHook {\r\n  //省略其他\r\n  \r\n  tap(option, fn) {\r\n    //如果传入的是字符串，包装成对象\r\n    if (typeof option === \\\"string\\\") {\r\n      option = { name: option };\r\n    }\r\n\r\n+   const tapInfo = { ...option, type: \\\"sync\\\", fn }; //type=sync fn是注册函数\r\n+   this.taps.push(tapInfo);\r\n  }\r\n}\r\n```\r\n\r\n> （2）动态生成执行代码\r\n\r\n当调用 `call` 方法时，会走两个关键的步骤：**先动态生成执行代码，再执行生成的代码**。\r\n\r\n最终我们要通过 `this.taps` 生成如下格式的运行代码：\r\n\r\n```js\r\nnew Function(\r\n  \\\"param1 , param2\\\",\r\n  `  \r\n  const taps = this.taps;\r\n  let fn0 = taps[0].fn;\r\n  fn0(param1, param2);\r\n  let fn1 = taps[1].fn;\r\n  fn1(param1, param2);\r\n `\r\n);\r\n```\r\n\r\n这一步需要遍历 `this.taps` 数组，然后生成对应的函数体字符串，这里封装成一个函数 `compiler` 来做：\r\n\r\n```js\r\nclass SyncHook {\r\n  //省略其他\r\n\r\n+ compile({ args, taps, type }) {\r\n+   const getHeader = () => {\r\n+     let code = \\\"\\\";\r\n+     code += `var taps=this.taps;\\\r\n`;\r\n+     return code;\r\n+   };\r\n\r\n+   const getContent = () => {\r\n+     let code = \\\"\\\";\r\n+     for (let i = 0; i < taps.length; i++) {\r\n+       code += `var fn${i}=taps[${i}].fn;\\\r\n`;\r\n+       code += `fn${i}(${args.join(\\\",\\\")});\\\r\n`;\r\n+     }\r\n+     return code;\r\n+   };\r\n\r\n+   return new Function(args.join(\\\",\\\"), getHeader() + getContent());\r\n  }\r\n}\r\n```\r\n\r\n> （3）执行生成的代码\r\n\r\n这里是最后一步，定义 `call` 方法，然后执行生成的函数体：\r\n\r\n```js\r\nclass SyncHook {\r\n  //省略其他\r\n  \r\n  call(...args) {\r\n    this._call = this.compile({\r\n      taps: this.taps, //tapInfo的数组 [{name,fn,type}]\r\n      args: this.args, //形参数组\r\n      type: \\\"sync\\\",\r\n    }); //动态创建一个call方法 这叫懒编译或者动态编译，最开始没有，用的时候才去创建执行\r\n    return this._call(...args);\r\n  }\r\n}\r\n```\r\n完整代码在文章开头的 github 链接中。\r\n\r\n### 6.5、为什么这么设计？\r\n\r\n看到这里，估计有不少小伙伴要懵了，为啥这么设计啊？我们开头讲的实现不是更简单吗？\r\n\r\n像这样：\r\n```js\r\nclass SyncHook {\r\n  constructor() {\r\n    this.taps = [];\r\n  }\r\n\r\n  //注册监听函数，这里的name其实没啥用\r\n  tap(name, fn) {\r\n    this.taps.push({ name, fn });\r\n  }\r\n\r\n  //执行函数\r\n  call(...args) {\r\n    this.taps.forEach((tap) => tap.fn(...args));\r\n  }\r\n}\r\n```\r\n\r\n这么做一部分原因是为了极佳的性能考虑，比如只有在执行 `call` 方法时才会去动态生成执行函数，如果不执行则不处理（**懒编译或者叫动态编译**）。\r\n\r\n还有一部分原因则是为了更加灵活。别忘了，该库里面还有其他类型的 `Hook`，如果我们想要实现其他 `Hook`，只需要定义好各自的 `compiler` 函数就可以了。\r\n\r\n另外，Webpack作者也提到过为什么采用 `new Function` 的方案，一切都是为了性能考虑，链接在这里：https://github.com/webpack/tapable/issues/162 ，有兴趣的可以去看看。\r\n\r\n## 七、总结\r\n\r\n本文从一个基础案例出发，先依次讲解了[ Tapable ](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable \\\"https://www.npmjs.com/package/tapable\\\")中各种类型 Hook 的基本用法和运行机制，接着再次回到最初的案例中，花了大量篇幅讲解 Tapable 的核心思想和实现思路。在这过程中不仅讲清楚了怎么去实现，更重要的是授人以渔，分析了为什么这么做。\r\n\r\n最后在手撕代码环节，我们通过大约40行代码手写了 mini 版的 `SyncHook` 来加深印象，帮助大家在读源码的过程中会更加顺畅。\r\n\r\n整体学习曲线较为平滑，如果文章中有地方出现纰漏或者认知错误，希望大家积极指正。\r\n\r\n> 参考：\r\n\r\n- https://juejin.cn/post/7040982789650382855\r\n- https://juejin.cn/post/6974573181356998669\r\n\r\n## 八、推荐阅读\r\n\r\n1. [线上崩了？一招教你快速定位问题！](https://juejin.cn/post/7166031357418668040)\r\n2. [从零到亿系统性的建立前端构建知识体系✨](https://juejin.cn/post/7145855619096903717)\r\n3. [我是如何带领团队从零到一建立前端规范的？🎉🎉🎉](https://juejin.cn/post/7085257325165936648)\r\n4. [【Webpack Plugin】写了个插件跟喜欢的女生表白，结果......😭😭😭](https://juejin.cn/post/7160467329334607908)\r\n5. [前端工程化基石 -- AST（抽象语法树）以及AST的广泛应用🔥](https://juejin.cn/post/7155151377013047304)\r\n6. [Webpack深度进阶：两张图彻底讲明白热更新原理！](https://juejin.cn/post/7176963906844246074#comment)\r\n7. [学会这些自定义hooks，让你摸鱼时间再翻一倍🐟🐟](https://juejin.cn/post/7095396322643017742)\r\n8. [浅析前端异常及降级处理](https://juejin.cn/post/6979564690787532814)\r\n9. [前端重新部署后，领导跟我说页面崩溃了...](https://juejin.cn/post/6981718762483679239)\r\n10. [前端场景下的搜索框，你真的理解了吗？](https://juejin.cn/post/7042332309449605127)\r\n"
    },
    {
        "article_id": "7170878262061563941",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e7e95768fb4393b6eefde6fdbcb4f6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "嘿，vue中keep-alive有个「大坑」你可能还不知道",
        "preview": "背景 背景是这样的，我们使用vue2开发一个在线客服使用的IM应用，基本布局是左边是访客列表，右边是访客对话，为了让对话加载更友好，我们将对话的路由使用<keep-alive>缓存起来。但是如果将所有",
        "author": "wuwhs",
        "view_count": 2108,
        "collect_count": 48,
        "comment_count": 6,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/25/17249b292384151d~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n## 背景\r\n背景是这样的，我们使用`vue2`开发一个在线客服使用的IM应用，基本布局是左边是访客列表，右边是访客对话，为了让对话加载更友好，我们将对话的路由使用`<keep-alive>`缓存起来。但是如果将所有对话都缓存，未必会造成缓存过多卡顿的问题。自然，就使用上了`<keep-alive>`提供的`max`属性，设置一个缓存对话内容组件上限，按照`LRU`算法，会销毁最旧访问的组件，保留最近使用的组件。本以为美好如期而至，直到上线后翻大车了，真实对话量大了，内存飙升卡顿。后来具体分析内存增长点，通过`vue`的`devtool`查看组件树，发现对话内容组件一直是递增，并非维持在`max`设置的数量上限！\r\n各位看官稍安勿躁，下面就具体分析造成这个「大坑」的原理，以及解决它的方案。\r\n## 情景模拟\r\n为了方便模拟背景案例，这里就用`vue2`简单的写一个demo。\r\n对话列表组件 `APP.vue`，点击列表中的某个访客，加载与访客对话内容。\r\n```html\r\n<template>\r\n  <div id=\\\"app\\\">\r\n    <section class=\\\"container\\\">\r\n      <aside class=\\\"aside\\\">\r\n        <ul>\r\n          <li :class=\\\"{ active: active === index }\\\" v-for=\\\"(user, index) in userList\\\" :key=\\\"index\\\"\r\n            @click=\\\"selectUser(index, user)\\\">\r\n            {{ user.name }}\r\n          </li>\r\n        </ul>\r\n      </aside>\r\n      <section class=\\\"main\\\">\r\n        <keep-alive :max=\\\"3\\\">\r\n          <chat-content :key=\\\"currentUser.id\\\" :user-info=\\\"currentUser\\\"></chat-content>\r\n        </keep-alive>\r\n      </section>\r\n    </section>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport ChatContent from './views/ChatContent.vue';\r\nexport default {\r\n  components: {\r\n    ChatContent\r\n  },\r\n  data() {\r\n    return {\r\n      active: -1,\r\n      currentUser: {},\r\n      userList: [{ id: 1, name: \\\"张三\\\" },\r\n      { id: 2, name: \\\"李四\\\" },\r\n      { id: 3, name: \\\"王五\\\" },\r\n      { id: 4, name: \\\"老六\\\" },\r\n      { id: 5, name: \\\"老八\\\" },\r\n      { id: 6, name: \\\"老九\\\" },\r\n    ]\r\n    }\r\n  },\r\n  methods: {\r\n    selectUser(index) {\r\n      this.active = index\r\n      this.currentUser = this.userList[index];\r\n    }\r\n  },\r\n}\r\n</script>\r\n```\r\n这里使用`keep-alive`组件包裹的对话内容组件，需要加上`key`唯一标志，这样才会缓存相同名称（不同`key`）的组件，否则不会缓存。\r\n对话内容组件`ChatContent.vue`，简单加一个计数器验证组件缓存了。\r\n```html\r\n<template>\r\n  <div>\r\n    <h2>{{ userInfo.name }}</h2>\r\n    <h3>{{ num }}</h3>\r\n    <button @click=\\\"increament\\\">+1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {\r\n    userInfo: Object,\r\n  },\r\n\r\n  data() {\r\n    return {\r\n      num: 0,\r\n    };\r\n  },\r\n\r\n  methods: {\r\n    increament() {\r\n      this.num += 1;\r\n    },\r\n  },\r\n};\r\n</script>\r\n```\r\n### 情景模拟结果\r\n实验发现，虽然缓存组件个数上限`max`为3，实际是逐个缓存了全部内容组件，看来设置`max`属性失效了。\r\n![2022-11-27 11-12-20.2022-11-27 11_23_07.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6656d2439bca46e48cdc31e0df184989~tplv-k3u1fbpfcp-zoom-1.image)\r\n## Vue2中<keep-alive>组件实现原理\r\n为什么缓存相同名称的组件，`max`属性会失效呢？这里就要从`Vue2`中`<keep-alive>`组件实现原理来看。\r\n### <keep-alive>LRU算法\r\n\r\n- `vue`会将`VNode`及组件实例（`componentInstance`）存到缓存（`cache`），`cache`是一个`Object`，同时还会维护一个`keys`队列；\r\n- 根据`LRU`算法对`cache`和`keys`的管理：当前激活组件已存在缓存中，将组件对应`key`先删除，再插入的方式往前移动；\r\n- 当前激活组件没有再缓存中，直接存入缓存，此时判断是否超过了缓存个数上限，如果超过了，使用`pruneCacheEntry`清理`keys`第一个位置（最旧）的组件对应的缓存。\r\n```javascript\r\nif (cache[key]) {\r\n  vnode.componentInstance = cache[key].componentInstance;\r\n  // make current key freshest\r\n  remove(keys, key);\r\n  keys.push(key);\r\n} else {\r\n  cache[key] = vnode;\r\n  keys.push(key);\r\n  // prune oldest entry\r\n  if (this.max && keys.length > parseInt(this.max)) {\r\n    \r\n    pruneCacheEntry(cache, keys[0], keys, this._vnode);\r\n    console.log('cache: ', cache)\r\n    console.log('keys: ', keys)\r\n  }\r\n}\r\n```\r\n### <keep-alive>清理缓存函数实现\r\n下面再来看清理缓存函数`pruneCacheEntry`的实现：比对当前传入组件和在缓存中的组件`tag`是否相同，如果不同，就去销毁组件实例，否则不销毁。\r\n```javascript\r\nfunction pruneCacheEntry (\r\n  cache,\r\n  key,\r\n  keys,\r\n  current\r\n) {\r\n  var cached$$1 = cache[key];\r\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\r\n    cached$$1.componentInstance.$destroy();\r\n  }\r\n  cache[key] = null;\r\n  remove(keys, key);\r\n}\r\n```\r\n看到这里似乎也没有毛病，究竟是哪里出问题了呢？\r\n### <keep-alive>源码调试发现问题\r\n不妨我们打印一下`cache`（`VNode`缓存）和`keys`\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc381998fbe24bd4be66f71d3cc13344~tplv-k3u1fbpfcp-zoom-1.image)\r\n发现也没什么问题，按照`URL`算法得到正确结果。\r\n再看看清理缓存函数里`cached$$1.tag`和`current.tag`的打印\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/726ad1f487da4138bef7863a8ddcb49f~tplv-k3u1fbpfcp-zoom-1.image)\r\n真相了！他两由于组件名称相同，导致相等，没有进入销毁组件实例的判断里，这就是问题来源！为什么针对相同组件名称不去销毁实例呢？可能是为了某些情景下组件复用吧。\r\n## 解决方案\r\n既然问题症结我们已经找到，从源头上去解决问题当然最佳，但是现实是`vue2`源码层面是没有去解决的（`vue3`有解决，这个后面再说），只能从我们应用侧再去想想办法。这里我想到的有两种方案。\r\n### 方案一：剪枝法\r\n维护一个全局状态（比如`vuex`）对话`ids`队列，最大长度为`max`，类似`vue`中`LRU`算法中的`keys`，在组件`activated`钩子函数触发时更新`ids`队列。对话内容组件的子组件判断当前对话`id`是否在`ids`队列中，不在那么就会`v-if`剔除，否则缓存起来，这样很大程度程度上释放缓存。类似剪去树的枝丫，减轻重量，这里叫做「剪枝法」好了。\r\n### 方案二：自定义清理缓存函数\r\n我们不再使用`keep-alive`提供的`max`属性来清理缓存，让其将组件实例全部缓存下来，当前激活组件，`activated`钩子函数触发，此时通过`this.$vnode.parent.componentInstance`获取组件实例，进而可以获取挂载在上面的`cache`和`keys`。这样我们就可以通过`LRU`算法，根据`key`自定义精准清理缓存了。\r\n```javascript\r\nactivated() {\r\n  const { cache, keys } = this.$vnode.parent.componentInstance;\r\n  console.log('activated cache: ', cache)\r\n  console.log('activated keys: ', keys)\r\n\r\n  let cacheLen = 0\r\n  const max = 3\r\n  Object.keys(cache).forEach(key => {\r\n    if (cache[key]) {\r\n      cacheLen += 1\r\n      if (cacheLen > max) {\r\n        const key = keys.shift()\r\n        cache[key].componentInstance.$destroy()\r\n        cache[key] = null\r\n      }\r\n    }\r\n  })\r\n},\r\n```\r\n下面对照 `vue`的`devtool`工具查看效果\r\n![2022-11-27 12-31-03.2022-11-27 12_32_04.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b11008f29c7a4af5bf3449c13f0beaec~tplv-k3u1fbpfcp-zoom-1.image)\r\n完全符合预期！方式二从`<keep-alive>`组件根就清理了缓存组件，更彻底，对业务代码侵染性也更小。\r\n你以为这样就完了？上面我还提到在`vue3`中已经解决了这个问题。\r\n## vue3中<KeepAlive>组件实现原理\r\n话不多说，先来看上面相同的案例在使用`vue3`写的效果如何呢？这里就不“重复”贴代码了，直接看`devtool`组件树的表现。\r\n![2022-11-27 11-18-30.2022-11-27 11_20_06.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b90d64f565574d8a8e2aae352e24da63~tplv-k3u1fbpfcp-zoom-1.image)\r\n没有冗余缓存组件，奈斯！\r\n### vue3中<KeepAlive>LRU算法\r\n`vue3`中`LRU`算法实现思路一样，只不过`cache`和`keys`分别使用`Map`和`Set`数据结构实现，数据更干净简洁。\r\n```javascript\r\nconst cache = new Map();\r\nconst keys = new Set();\r\n// ...\r\nif (cachedVNode) {\r\n    // copy over mounted state\r\n    vnode.el = cachedVNode.el;\r\n    \r\n    // ...\r\n    // make this key the freshest\r\n    keys.delete(key);\r\n    keys.add(key);\r\n}\r\nelse {\r\n    keys.add(key);\r\n    // prune oldest entry\r\n    if (max && keys.size > parseInt(max, 10)) {\r\n        pruneCacheEntry(keys.values().next().value);\r\n    }\r\n}\r\n```\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2ac37b672c4124835730ef39b6070b~tplv-k3u1fbpfcp-zoom-1.image)\r\n### vue3中<KeepAlive>清理缓存函数实现\r\n`vue3`中清理组件实例缓存函数也是`pruneCacheEntry`，不同的是，比对当前传入组件和在缓存中的组件`type`是否相同，决定是否销毁组件实例。\r\n```javascript\r\nfunction pruneCacheEntry(key) {\r\n  const cached = cache.get(key);\r\n  if (!current || cached.type !== current.type) {\r\n      unmount(cached);\r\n  }\r\n  else if (current) {\r\n      // current active instance should no longer be kept-alive.\r\n      // we can't unmount it now but it might be later, so reset its flag now.\r\n      resetShapeFlag(current);\r\n  }\r\n  cache.delete(key);\r\n  keys.delete(key);\r\n}\r\n```\r\n再来看看`cache.type`和`current.type`到底是什么\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94ad74c0d6d4d5185b8d0d3f96512d3~tplv-k3u1fbpfcp-zoom-1.image)\r\n对比我们会发现，不再是简单的组件名称字符标志，而是一个对象描述，包含了很多属性，因为在初始化组件实例时，会给每个实例加上属性：`props`、`render`、`setup`、`__hmrId`等。\r\n```javascript\r\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\r\n  const props = {};\r\n  const attrs = {};\r\n  def(attrs, InternalObjectKey, 1);\r\n  instance.propsDefaults = /* @__PURE__ */ Object.create(null);\r\n  setFullProps(instance, rawProps, props, attrs);\r\n  // ...  \r\n  instance.attrs = attrs;\r\n}\r\nfunction isInHmrContext(instance) {\r\n  while (instance) {\r\n    if (instance.type.__hmrId)\r\n      return true;\r\n    instance = instance.parent;\r\n  }\r\n}\r\n```\r\n即使是对象中所有属性相同，但是对象不是同一个引用地址，造成`cache.type`和`current.type`不相等，因此会销毁实例对象`unmount(cached)`。以上就是`vue3`对这个问题解决方案。\r\n## 总结\r\n最后，在`vue2`中会出现`<keep-alive>`缓存相同名称组件，`max`失效的问题，推荐使用自定义清理缓存函数，在获取组件实例基础上，对缓存实例销毁。下图是我在真实项目中优化的成果。完~\r\n![151f9354fea44e2d9fafb322e20df814.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1529cc3dd5b848b68b1830318d5cbf18~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7146776738888941575",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01577e2d63494aa8961f37aac3e4f79e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用户行为录制技术方案",
        "preview": "用户行为录制是一个定性分析工具，记录用户整个会话的每一个点击、滑动、输入等行为，并支持以录像的方式来回放这些操作，既然要录制用户的完整操作流程，那么我们从前端视角来看看，分别都有哪些技术方案。",
        "author": "Aloudata前端技术团队",
        "view_count": 2784,
        "collect_count": 72,
        "comment_count": 9,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/b7dca56264a18a679164ce9cbf6c9a32~300x300.image",
        "category": "前端",
        "content": "## 前言\r\n\r\n作为 web 开发工程师，为了保障页面的质量，我们会去做单测，E2E 测试，同时也会有专门的测试工程师介入，来帮我们扫清页面中的bug，但是你永远不能保证自己的代码在用户电脑上百分之百靠谱，于是在前端工程化方面，我们有各式各样的埋点方案，全链路监控、用户行为上报、接口状态监控等等。\r\n\r\n看起来是很齐全了，但这些都是针对用户行为的瞬间采样，虽然看起来很完备，但是当实际遇到问题时，很多时候还需要开发者自己去思考上下文。\r\n\r\n作为产品经理，我的产品推广出去了，虽然埋点记录能捕获大部分的用户行为，但是有时候我还是想观察用户的真实使用链路。在不涉及隐私的前提下，想要对用户行为进行深度理解，进一步对用户行为进行定性分析。\r\n\r\n作为测试同学，看到线上出了一部分的 bug，我是很想穿越回用户身边，想看看用户到底是通过什么样的操作手段触发了这个问题，很有可能这是一个未曾考虑到的测试用例。\r\n\r\n以上种种问题，都跟我们今天聊的用户行为录制有很大的关系，有了这个玩意，我们可以详细的回归用户的所有操作，既可以复原用户操作排查问题，也可以帮助产品上观察用户使用行为，测试也可以基于这个录制形成自动化回归用例。\r\n\r\n用户行为录制是一个定性分析工具，记录用户整个会话的每一个点击、滑动、输入等行为，并支持以录像的方式来回放这些操作，既然要录制用户的完整操作流程，那么我们从前端视角来看看，分别都有哪些技术方案可以帮助我们完成这一功能。\r\n\r\n## 方案：快照截图\r\n\r\n首先我们可以想到是否能利用Canvas截图，不停的画页面然后不停的截图，做过一些营销活动的同学一定对这个方案不会陌生，它是用户记录和分享页面信息的有效手段。\r\n\r\n那么这个方案能否满足我们的需求呢？\r\n\r\n依据图片是否由设备本地生成，快照可分为前端处理和后端处理两种方式，由于后端生成的方案依赖于网络通信，同时需要启动无头浏览器，不可避免地存在通信开销和等待时延，同时对于模板和数据结构变更也有一定的维护成本，我们这里暂时只考虑前端生成方案。\r\n\r\n### 原理\r\n\r\n前端侧对于快照的处理过程，实质上是将 DOM 节点包含的视图信息转换为图片信息的过程。这个过程可以借助 Canvas 的原生 API 实现，这也是方案可行性的基础。\r\n\r\n具体来说，转换过程是将目标 DOM 节点绘制到 canvas 画布，然后 canvas 画布以图片形式导出。可简单标记为绘制阶段和导出阶段两个步骤：\r\n\r\n-   绘制阶段：选择希望绘制的 DOM 节点，根据 nodeType 调用 canvas 对象的对应 API，将目标 DOM 节点绘制到 canvas 画布（例如对于<img>的绘制使用 drawImage 方法)。\r\n-   导出阶段：通过 canvas 的 toDataURL 或 getImageData 等对外接口，最终实现画布内容的导出。\r\n\r\n以上方案说起来比较容易，但是实际开发需要处理的内容比较多，比如：\r\n\r\n-   canvas 的drawImage方法只接受 CanvasImageSource，而CanvasImageSource并不包括文本节点、普通的div等，将非<img>的元素绘制到 canvas 需要特定处理。\r\n-   当 DOM 复杂时，层级优先级处理较为复杂。\r\n-   需要关注浮动，绝对定位等布局定位的处理。\r\n-   很多新的 css 属性无法处理。\r\n\r\n这里我们选择了社区中比较出名的方案：HTML2Canvas，官方地址为：<https://github.com/niklasvh/html2canvas>\r\n\r\n这里我们主要考虑 4 个点：\r\n\r\n-   页面动画是否能绘制？  no \r\n-   页面样式是否不错位？ no  \r\n-   交互性的行为是否能记录？\r\n-   跨域的图片资源能否记录，播放的视频能否记录？\r\n\r\n### Canvas demo\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12477c586b4145b69b394f4bc30f8d77~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### Canvas 总结\r\n\r\n从上面 demo 中我们可以看到 html2canvas 并不是一个完美的录制方案，从技术上来讲\r\n\r\n-   布局会有偏差，input 框中样式产生了错位\r\n-   部分 CSS 样式不支持：<https://html2canvas.hertzen.com/features>\r\n-   无法绘制动画，demo 中 css 动画的状态无法绘制\r\n-   如果有 video 的话，视频播放状态等无法记录\r\n\r\n另外就算上面方案的技术问题可以解决，这种方案的弊端也非常明显：性能太差了，无论是绘制的性能还是传输的性能，所以这个方案不太符合我们的需求。\r\n\r\n## 方案：视频录制\r\n\r\n既然截图效果差，性能也不好，那么我们可以直接录制我们当前的页面，将视频流存储起来，那么现在有相应的能力来满足我们的需求吗，哎，好像 webRTC 可以啊。\r\n\r\n首先简单了解一下webRTC：浏览器上的音视频通信相关的能力叫做 WebRTC（real time communication），是随着网速越来越快，音视频需求越来越多，而被浏览器所实现的音视频的标准 API。\r\n\r\n音视频通信的流程有五步：采集、编码、通信、解码、渲染。\r\n\r\n其不仅可以用于「音视频录制、视频通话」，还可以用在「照相机、音乐播放器、共享远程桌面、即时通信工具、P2P 网络加速、文件传输、实时人脸识别」等场景上。\r\n\r\n但我们来看下它的兼容性情况：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbb33718b5f048dcb1bb0cc96065f653~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### webRTC demo\r\n\r\n\r\n![iShot_2022-09-24_10.56.46.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d419950efb542e9a7aa628741712382~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### webRTC 总结\r\n\r\n通过上面的 demo，我们发现 webrtc 效果上是能满足我们的需求，但是其有一个最大的弊端：那就是因为安全性策略，在启动 webRTC之前，会有弹窗询问用户，需要获得用户的同意，同时在开启之后会有一个录制的状态条，所以在整个的过程对于用户而言会有一些侵入性，用户会有明显的感知。\r\n\r\n同时 webrtc 需要部署在 https 环境下，这也是一个额外的要求。\r\n\r\n显然这个技术点更适合用在一些明确的监控场景下，比如面试、上课等，所以不太符合我们的需求。\r\n\r\n## 方案： dom 序列化\r\n\r\n接下来就是我们今天的主角了，也是目前最流行的解决方案，\r\n\r\n从效果上讲，它可以媲美 webrtc 的录制，基本上我们的操作都能被正确录制下来，同时因为它存储了完整的网页信息，所以可以将页面布局做到很好地还原。\r\n\r\n从性能上讲，因为它是 dom 序列化以后的结构，同时是做的增量存储，所以它的传输量比 webrtc 或者是截图的方式都要低一些。\r\n\r\n### 原理\r\n\r\n网页本质上是一个 DOM 节点形式存在，通过浏览器渲染出来。我们是否可以把 DOM 以某种方式保存起来，并且在不同时间节点持续记录 DOM 变更状态，再将数据还原成 DOM 节点渲染出来完成回放呢？\r\n\r\n从技术设计上，大致都可以拆分为 DOM 序列化、构建快照序列、回放重演以及沙箱环境等四个方向。\r\n\r\n### 元素序列化\r\n\r\n需要保存某一时刻的页面状态时，最直观的就是将那一刻的页面 dom 结构做个快照，然后在浏览器中重新渲染出来就能达到回溯的效果了。\r\n\r\n```\r\nconst cloneDoc  = document.documentElement.cloneNode(true); // 录制   \r\ndocument.replaceChild(cloneDoc, document.documentElement); // 回放  \r\n```\r\n\r\n这样我们就实现了某一时刻 DOM 快照的功能。但是这个录制的 cloneDoc 还只是内存中的一个对象，并没有实现远程存储，所以我们需要有一种办法将页面中的所有元素序列化成一个普通对象，这样就能像保存一个字符串或者是 json 文本一样将相关数据传到后台服务器中。\r\n\r\n为了实现这个功能，我们需要将 cloneDoc 这个对象序列化成字符串，保存到服务端，然后在回放的时候从服务器上取出来，交给浏览器重新渲染。\r\n\r\n```\r\n// XMLSerializer 是浏览器自带的 api，可以将 dom 对象序列化成 string   \r\nconst serializer = new XMLSerializer(); \r\nconst str = serializer.serializeToString(cloneDoc);   \r\ndocument.documentElement.innerHTML = str;   \r\n```\r\n\r\n但是我们的目的是录制视频，只有一个 dom 快照显然是不够的。了解动画的同学都应该知道，动画是由每秒至少 24 帧的画面按顺序播放而产生的，那简单，我们就每秒钟clone 24次呗。\r\n\r\n稍微细想便可知道这种方法根本行不通，原因有以下几点：\r\n\r\n-   每秒 clone 24 次整个页面内容，对性能损耗巨大，严重影响用户体验\r\n-   每秒要将 24 帧的页面内容上传到服务端，对网络开销也是巨大的\r\n-   回放时，每秒要渲染 24 个完整的 html 内容，浏览器根本做不到这么快\r\n-   还有，要是页面没变动，那么 24 帧的数据可能是完全一样的，根本没必要 clone 这个多次。\r\n\r\n综上问题，我们面临着 2 个比较大的挑战，\r\n\r\n-   一个是页面 dom 结构无法序列化，所谓不可序列化是指虽然我们可以通过 innerHTML 等⽅式获取到描述 DOM 的⽂本格式，但其中会丢失⼀些视图状态，例如  元素的 value 就不⼀定会记录在 HTML 中。\r\n-   页面记录的方式有问题，存在大量的冗余记录，同时传输消耗大\r\n\r\n基于以上缺点，我们需要设计一套可序列化的页面结构，同时只有等到页面有变动的时候，做增量记录，即只记录变化的部分。这样一来，好处就显而易见了\r\n\r\n-   页面结构的状态可以保留下来\r\n-   只记录变化的部分，比起记录整个网页要小的多。这样对网页的性能、网络的开销都会小很多。\r\n-   我们只在页面有变动的时候才记录，这样一来，大量重复数据的问题也给解决了。\r\n-   回放时，我们只需要首先将第一帧（完整的页面内容）先渲染出来，然后在按照记录的时间，按顺序将变化的部分渲染到页面。这样就可以像看视频一样来回溯用户的操作流程了。\r\n\r\n目前市面上较为出名的 DOM 结构描述库有 [parse5](https://github.com/inikulin/parse5)，大家可以参考一下。\r\n\r\n在线演示地址：<https://astexplorer.net/#/1CHlCXc4n4>\r\n\r\nps：我们后面介绍的 rrweb 并未采用这个解析库，而是自己实现了一套，具体的原因我们待会再说。\r\n\r\n### 监听变化\r\n\r\n在上一步中，我们已经从理论上实现了录制和回放的功能，但是具体实现呢？我们怎么才能知道页面什么时候变化呢？\r\n\r\n可能有的同学就想到了我们的主角：MutationObserver。\r\n\r\n该接口提供了监视对 DOM 树所做更改的能力，当 DOM 发生变化时，通过批量异步的方式去触发回调，并将 DOM 变化通过 MutationRecord 数组传给回调方法，我们可以利用这个接口，保存每次变化的DOM数据，并把这些数据转换成可视化的数据结构，然后分别保存起来。接着使用特定的方式对之前保存起来的DOM数据进行还原并重新渲染出来。DOM节点的变化也就意味了页面轨迹发生了变化，这样就可以把这些轨迹记录下来。\r\n\r\n但是它没法跟踪像 input、textarea、select 这类可交互元素的输入。\r\n\r\n对于这种可交互的元素，我们主要靠监听 input 和 change 来记录输入的过程。\r\n\r\n但是有些元素的值是通过程序直接设置的，这样是不会触发 input 和 change 事件的。这种情况下我们可以通过劫持对应属性的 setter 来达到监听的目的。\r\n\r\n记录增量数据有很多种方法，比如 dom diff ，最开始 rrweb 团队也尝试过这个方案，但是发现在 dom 复杂的场景下页面开销太高了，所以放弃了方案。\r\n\r\n最终他们采用的快照+OPlog 的方式，他们把引发视图变更的操作归为以下⼏类：\r\n\r\n-   DOM 变动\r\n\r\n    -   节点创建、销毁\r\n    -   节点属性变化\r\n    -   ⽂本变化\r\n\r\n-   ⿏标交互\r\n\r\n-   ⻚⾯或元素滚动\r\n\r\n-   视窗⼤⼩改变\r\n\r\n-   输⼊\r\n\r\n-   ⿏标移动（特指⿏标的视觉位置）\r\n\r\n对于每个操作只需要记录其操作类型和相关的数据，就可以在回放时重现对应的操作，也就回放了该操作对视图的改变。\r\n\r\n这样只需要在开始录制时制作⼀个完整的 DOM 快照，之后则记录所有的操作数据，这些操作数据我们称之为 Oplog（operations log），这⼀思路和 log-structured file system 是类似的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07b7f30cc63d4811ade35bfcbea7f587~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 回放重演\r\n\r\n简单来说，重演就是将收集到的数据按照顺序依次“播放”一遍，视频文件的播放需要音视频解码器，而我们的重演环节要做的工作就可以简单理解成一个 Web 应用解码器，从用户端收集上来的数据结构除了要做清洗和存储外，还不能直接被回放侧使用，其中有不少需要考虑的细节。\r\n\r\n我们举几个详细的例子\r\n\r\n-   页面中的 JS 脚本要不要执行？如果执行，那不是所有的接口交互意味着都会在发生一次，那对于用户数据是有破坏性的，如果不执行？那么这些操作如果禁止？\r\n\r\n    -   改写 script 为 noScript ，同时通过沙箱阻止 JS 的行为\r\n\r\n-   如何校准回放时的定时器偏差？\r\n\r\n    -   使用 requestAnimationFrame 替代 settimeout，同时不停地做矫正\r\n\r\n-   如何过滤用户隐私？\r\n\r\n    -   约定部分类名的结构不做具体 value 存储\r\n\r\n### 沙箱\r\n\r\n上面我们提到了回放的一些问题点，其中 js 执行是最大的一个挑战，而沙箱就可以帮助我们解决该问题，它是为了给回放提供一个安全可控的运行环境，既然采用 DOM 快照方案，那么便需要考虑如何禁止一些“不安全”的 DOM 操作。例如应用内链接跳转、我们不太可能会直接给用户打开一个新的 tab，为了保证快照状态依次回放，我们还需要考虑如何安全准确的反序列化构建 DOM。\r\n\r\nrrweb在重建快照时将被录制的 DOM 重建在⼀个 iframe 元素中，通过设置它的 [sandbox](https://www.runoob.com/tags/att-iframe-sandbox.html) 属性，我们可以禁⽌以下⾏为：\r\n\r\n-   表单提交\r\n-   window.open 等弹出窗\r\n-   JS 脚本（包含 inline script , event handler 和 url 操作 ）\r\n\r\n### rrweb\r\n\r\n上面我们提到过很多次 rrweb 了，现在让我们好好来介绍下它，其官方地址是： <https://github.com/rrweb-io/rrweb>\r\n\r\n这是一个开源的 Web 会话回放库，提供了易于使用的 API 来记录用户的交互并远程回放。rrweb 主要由 rrweb 、 rrweb-player 和 rrweb-snapshot 三个库组成：\r\n\r\n-   rrweb：提供了 record 和 replay 两个方法；record 方法用来记录页面上 DOM 的变化，replay 方法支持根据时间戳去还原 DOM 的变化。\r\n-   rrweb-player：基于 svelte 模板实现，为 rrweb 提供了回放的 GUI 工具，支持暂停、倍速播放、拖拽时间轴等功能。内部调用了 rrweb 提供的 replay 等方法。\r\n-   rrweb-snapshot：包括 snapshot 和 rebuilding 两大特性，snapshot 用来序列化 DOM 为增量快照，rebuilding 负责将增量快照还原为 DOM。\r\n\r\n上面我们有提到 rrweb 的 dom 序列化方案是自己实现的，这点其官方文章也给出了解释：\r\n\r\n> 我们不使⽤⼀些开源⽅案例如 parse5的原因包含两个⽅⾯：\r\n> \r\n> 1.  我们需要实现⼀个“⾮标准”的序列化⽅法。\r\n> 1.  此部分代码需要运⾏在被录制的⻚⾯中，要尽可能的控制代码量，只保留必要功能。\r\n> \r\n> 之所以说我们的序列化⽅法是⾮标准的是因为我们还需要做以下⼏部分的处理：\r\n> \r\n> 1.  去脚本化，被录制⻚⾯中的所有 JavaScript 都不应该被执⾏。\r\n> 1.  记录没有反映在 HTML 中的视图状态。例如  输⼊后的值不会反映在其 HTML中，我们需要读取其 value 值并加以记录。\r\n> 1.  相对路径转换为绝对路径。回放时⻚⾯ URL为重放⻚⾯的地址，如果被录制⻚⾯中有⼀些相对路径就会产⽣错误。\r\n> 1.  尽量记录 CSS 样式表的内容。如果被录制⻚⾯加载了⼀些同源的样式表，我们则可以获取到解析好的 CSS rules，录制时将能获取到的样式都 inline 化，这样可以让⼀些内⽹环境（如 localhost）的录制也有⽐较好的回放效果。\r\n\r\n### rrweb demo\r\n\r\n\r\n![iShot_2022-09-24_10.59.34.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77bd8bdb93e14c349aa8c086875e076b~tplv-k3u1fbpfcp-watermark.image?)\r\n### 沙箱回放还是录制视频存储？\r\n\r\n在我们的录制数据中，有许多的外链资源，比如 cdn 的文件，外链的图片等等，也就是说在我们利用录制的数据进行回放的时候，需要依赖这张图片。但是随着项目的迭代，这张图片很可能早已不在，这时我们在回放时，页面中的图片就会加载不出来。比如一个保险场景，保额信息就在网站内的一张海报上，客户可能会说：“我当时看到的保额明明是 150 万，怎么现在变成 100 万了？”，这时你要怎么证明当时海报上写的就是 100 万保额呢？\r\n\r\n所以最稳妥的方案还是将 rrweb 录制的原始数据转换成视频，这样一来，不管网站怎么变化，迭代了多少版本，视频是不受影响的。我的做法是通过 puppeteer 在服务端运行无头浏览器，在无头浏览器中回放录制的数据，然后每秒截取一定数量的图片，最后通过 ffmpeg 合成视频。\r\n\r\n当然这里 rrweb官方也有提供一些解决方案，比如后端可以在每次数据上传以后将外链资源扫描出来，然后存在本地服务器端，这样子可以保证拥有对资源的控制权。这里就按照各自的具体场景决定了。\r\n\r\n## 总结\r\n\r\n以上便是我们今天所有的分享内容了，我们从最简单的定时截图到 webrtc 录制，再到最后的 dom 序列化录制方案，一步步地讲解了用户录制的技术方案选型和挑战，希望能帮助大家对这一技术点有所启发和帮助。\r\n\r\n## 参考资料\r\n\r\n-   [rrweb：打开 web 页面录制与回放的黑盒子](https://zhuanlan.zhihu.com/p/60639266)\r\n-   [rrweb 浏览器录制及转视频方案](https://mp.weixin.qq.com/s?__biz=MzU4MTc2NTc5NQ==&mid=2247486089&idx=1&sn=40117c79804dfcd8b13b41ba4c62dc19)\r\n\r\n\r\n## 团队介绍\r\n\r\n以上便是本次分享的全部内容，来自团队 @少和 分享，希望对你有所帮助^_^\r\n\r\n喜欢的话别忘了 **分享、点赞、收藏** 。\r\n\r\n> 我们是来自大应科技（Aloudata, [www.aloudata.com](https://link.juejin.cn?target=https%3A%2F%2Fwww.aloudata.com \\\"https://link.juejin.cn?target=https%3A%2F%2Fwww.aloudata.com\\\") ）的前端团队，负责大应科技全线产品前端开发工作。在一家初创公司，前端团队不仅要快速完成业务迭代，还要同时建设前端工程化的落地和新技术的预研，我们会围绕产品品质、开发效率、创意与前沿技术等多方向对大前端进行探索和分享，包括但不限于性能监控、组件库、前端框架、可视化、3D 技术、在线编辑器等等。\r\n"
    },
    {
        "article_id": "7176832643797876791",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb3acbd0f6be40ee90dd1e0bc9f60ad4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "探索小程序底层架构原理",
        "preview": "从小程序的定位来讲，它就不可能用纯原生技术来进行开发，因为那样它的编译以及发版都得跟随微信，所以需要像Web技术那样，有一份随时可更新的资源包放在远程，通过下载到本地，动态执行后即可渲染出界面。",
        "author": "前端南玖",
        "view_count": 1372,
        "collect_count": 31,
        "comment_count": 2,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/3afd4a350eac1690e6e0165f081456d8~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\nhighlight: atelier-dune-dark\r\n---\r\n## 双线程架构\r\n\r\n在这之前，我们先来思考一个问题，小程序在架构上为什么会选择双线程？\r\n\r\n### 为什么是双线程？\r\n\r\n#### 加载及渲染性能\r\n\r\n小程序的设计之初就是要求快速，这里的快指的是加载以及渲染。\r\n\r\n目前主流的渲染方式有以下3种：\r\n\r\n- Web技术渲染\r\n- Native技术渲染\r\n- Hybrid技术渲染（同时使用了webview和原生来渲染）\r\n\r\n从小程序的定位来讲，它就不可能用纯原生技术来进行开发，因为那样它的编译以及发版都得跟随微信，所以需要像Web技术那样，有一份随时可更新的资源包放在远程，通过下载到本地，动态执行后即可渲染出界面。\r\n\r\n但如果用纯`web`技术来开发的话，会有一个很致命的缺点那就是在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源，这也就跟设计之初要求的**快**相违背了。\r\n\r\n因此微信小程序选择了Hybrid 技术，界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。\r\n\r\n**微信小程序是以webview渲染为主，原生渲染为辅的混合渲染方式**\r\n\r\n#### 管控安全\r\n\r\n由于web技术的灵活开放特点，如果基于纯web技术来渲染小程序的话，势必会存在一些不可控因素和安全风险。\r\n\r\n为了解决安全管控的问题，小程序从设计上就阻止了开发者去使用一些浏览器提供的开放性api，比如说跳转页面、操作DOM等等。如果把这些东西一个一个地去加入到黑名单，那么势必会陷入一个非常糟糕的循环，因为浏览器的接口也非常丰富，那么就很容易遗漏一些危险的接口，而且就算是禁用掉了所有的接口，也防不住浏览器内核的下次更新。\r\n\r\n所以要彻底解决这个问题，必须提供一个沙箱环境来运行开发者的`JavaScript` 代码。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。那么像`HTML5`中的`ServiceWorker`、`WebWorker`特性就符合这样的条件，这两者都是启用另一线程来执行 `javaScript`。\r\n\r\n这就是小程序双线程模型的由来：\r\n\r\n- **渲染层：** 界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView。\r\n\r\n- **逻辑层：** 创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码。\r\n\r\n### 双线程模型\r\n\r\n**小程序的架构模型有别与传统web单线程架构，小程序为双线程架构。**\r\n\r\n微信小程序的渲染层与逻辑层分别由两个线程管理，渲染层的界面使用 `webview` 进行渲染；逻辑层采用 `JSCore`运行`JavaScript`代码。\r\n\r\n![小程序双线程.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9811621adc1a4dc89607c76032dc2963~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n#### webview渲染线程\r\n\r\n**如何找到渲染层？**\r\n\r\n1. 我们可以通过调试微信开发者工具：`微信开发者工具 ->调试 ->调试微信开发者工具`\r\n\r\n\r\n![wx-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bfb751346564f7090e276a5e00e30c6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2. 然后我们会再看到一个调试界面，看起来跟我们平时用的浏览器调试界面几乎一摸一样\r\n\r\n![wx-2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d746423c014cdbab56a0896d9f77d1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但这并不是小程序的渲染层，而是开发者工具的结构。但我们在里面可以发现有一些`webview`标签，在第一个`webview`上的src属性看着是不是有点眼熟，没猜错的话它就是我们当前小程序打开页面的路径。所以这个`webview`才是小程序真正的渲染层。这里你会发现它里面并不只有一个`webview`，其实里面包含着`视图层的webview`，`业务逻辑层webview`，`开发者工具的webview`\r\n\r\n**开发者工具的逻辑层跑在`webview`中主要是为了模拟真机上的双线程**\r\n\r\n3. 打开渲染层一探究竟\r\n\r\n通过`showdevTools`方法来打开调试此webview界面的调试器\r\n\r\n```js\r\ndocument.querySelectorAll('webview')[0].showDevTools(true)\r\n```\r\n\r\n\r\n![wx-3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/212ee1f6ed734875b90c4c4c61d09298~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这里我们看到的才真正是小程序的渲染层，也就是小程序代码编译后的样子，我们会发现这里的标签都与我们开发时写的不一样，都统一加了`wx-`前缀。了解过`webComponent`的同学相信一眼就能看出他们非常相似，但小程序并没有直接使用`webComponent`，而是自行搭建了一套组件系统`Exparser`。\r\n\r\n`Exparser`的组件模型与`WebComponents`标准中的`Shadow DOM`高度相似。`Exparser`会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的`Shadow DOM`实现。\r\n\r\n**为什么不直接使用`webComponent`，而是选择自行搭建一套组件系统？**\r\n\r\n<details>     \r\n<summary>点击查看</summary>     \r\n- 管控与安全：web技术可以通过脚本获取修改页面敏感内容或者随意跳转其它页面<br/>\r\n- 能力有限：会限制小程序的表现形式<br/>\r\n- 标签众多：增加理解成本 </details>\r\n\r\n#### JSCore逻辑线程\r\n\r\n逻辑层我们直接在小程序开发者工具的调试器中输入`document`就能看到\r\n![wx-逻辑线程.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/635f86c9c5b34996861f07acbaa8c31a~tplv-k3u1fbpfcp-watermark.image?)\r\n小程序将所有业务代码置于同一个线程中运行，在小程序开发者工具中逻辑线程同样是跑在一个webview中；webview中的appservice.html除了引入业务代码js之外，还有后台服务内嵌的一些基础功能代码。\r\n\r\n## 编译原理\r\n\r\n了解完小程序的双线程架构，我们再来看一下小程序的代码是如何编译运行的，微信开者工具模拟器运行的代码是经过本地预处理、本地编译，而微信客户端运行的代码是额外经过服务器编译的。这里我们还是以微信开发者工具为例来探索一番。\r\n\r\n在开发者工具输入`openVendor()`，会帮我们打开微信开发者工具的`WeappVendor`文件夹\r\n\r\n\r\n![wx-4.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7018b2b597df4d45b30f619ccce1f032~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在这里我们我们会看到一些`wxvpkg`文件，这是小程序的各个版本的基础库文件，还有两个值得我们注意的文件：`wcc`、`wcsc`，这两个文件是小程序的编译器，分别用来编译`wxml`和`wxss`文件。\r\n\r\n### 编译wxml\r\n\r\n这里我们可以将开发者工具中的`wcc`编译器拷贝一份出来，尝试去用它编译一下`wxml`文件，看看最后的产物是什么？\r\n\r\n\r\n![wx-5.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b780b41dee224da5b45f78a4bfc51473~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们在终端执行一下以下命令\r\n\r\n```shell\r\n./wcc -b index.wxml >> wxml_output.js\r\n```\r\n\r\n然后它会在当前目录下生成一个`wxml_output.js`文件，文件中有一个非常重要的方法`$gwx`，该方法会返回一个函数。该函数的具体作用我们可以尝试执行一下看看结果。\r\n\r\n我们打开渲染层`webview`搜索一下该方法（为了方便查看，这里会用个小项目来演示）\r\n\r\n![wx-6.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab38696421d4d03b14fd6cf199697fd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从这里我们可以看到该方法会传入一个小程序页面的路径，返回的依然是一个函数\r\n\r\n```js\r\nvar decodeName = decodeURI(\\\"./index/index.wxml\\\")\r\nvar generateFunc = $gwx(decodeName)\r\n```\r\n\r\n我们尝试按这里流程执行一下`$gwx`返回的函数，看看返回的内容是什么？\r\n\r\n```xml\r\n<!--compiler-test/index.wxml-->\r\n<view class=\\\"qd_container\\\" >\r\n  <text name=\\\"title\\\">wxml编译</text>\r\n  <view >{{ name }}</view>\r\n</view>\r\n```\r\n\r\n```js\r\nconst func = $gwx(decodeURI('index.wxml'))\r\nconsole.log(func())\r\n```\r\n\r\n\r\n![wx-7.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13f195be046e49a2aa97cc8bafcd5419~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n没错，这个函数正是用来生成`Virtual DOM `\r\n\r\n#### 思考：为什么`$gwx`不直接生成`Virtual DOM`？\r\n\r\n<details>     \r\n<summary>点击查看</summary>     \r\n- 双线程，需要动态注入数据\r\n</details>\r\n\r\n### 编译wxss\r\n\r\n我们同样可以用微信开发者工具中的`wcsc`来编译一下`wxss`文件。\r\n\r\n(大家认为这里应该是会生成`css`文件还是`js`文件呢？)\r\n\r\n我们在终端执行一下以下命令来编译wxss文件\r\n\r\n```shell\r\n./wcsc -js index.wxss >> wxss_output.js\r\n```\r\n\r\n\r\n![wx-8.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3f05b9b34c41f0a460f65fab53737a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n相比之前的`wcc`编译`wxml`文件来说，这次的编译相对来说比较简单，它主要完成了以下内容：\r\n\r\n- rpx单位的换算，转换成px\r\n- 提供`setCssToHead`方法将转换好的css添加到head中\r\n\r\n#### rpx动态适配\r\n\r\n小程序提供`rpx`单位来适配各种尺寸的设备\r\n\r\n\r\n![wx-9.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1118eda8832c48029967ae05effaa926~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n比如：\r\n\r\n```css\r\n/*index.wxss */\r\n.qd_container {\r\n  width: 100rpx;\r\n  background: skyblue;\r\n  border: 1rpx solid salmon;\r\n}\r\n.qd_reader {\r\n  font-size: 20rpx;\r\n  color: #191919;\r\n  font-weight: 400;\r\n}\r\n```\r\n\r\n经过编译之后会生成`setCssToHead`方法并执行\r\n\r\n```js\r\nsetCssToHead([\\\".\\\",[1],\\\"qd_container { width: \\\",[0,100],\\\"; background: skyblue; border: \\\",[0,1],\\\" solid salmon; }\\\r\n.\\\",[1],\\\"qd_reader { font-size: \\\",[0,20],\\\"; color: #191919; font-weight: 400; }\\\r\n\\\",])( typeof __wxAppSuffixCode__ == \\\"undefined\\\"? undefined : __wxAppSuffixCode__ );\r\n```\r\n\r\n里面会调用`transformRPX`方法将`rpx`转成`px`\r\n\r\n```js\r\nvar transformRPX = window.__transformRpx__ || function(number, newDeviceWidth) {\r\nif ( number === 0 ) return 0;\r\nnumber = number / BASE_DEVICE_WIDTH * ( newDeviceWidth || deviceWidth );\r\nnumber = Math.floor(number + eps);\r\nif (number === 0) {\r\nif (deviceDPR === 1 || !isIOS) {\r\nreturn 1;\r\n} else {\r\nreturn 0.5;\r\n}\r\n}\r\nreturn number;\r\n}\r\n```\r\n\r\n```js\r\n// 主要公式\r\nnumber = number / BASE_DEVICE_WIDTH * (newDeviceWidth || deviceWidth);\r\nnumber = Math.floor(number + eps);  //为了精确\r\n// rpx值 / 基础设备宽750 * 真实设备宽\r\n```\r\n\r\n## 渲染流程\r\n\r\n上面了解完`wxml`与`wxss`的编译过程，我们再来整体了解一下页面的渲染流程。\r\n\r\n### 先来了解渲染层模版\r\n\r\n从上面的渲染层`webview`我们可以找到这两个webview\r\n\r\n\r\n![wx-10.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2903745a6444b8b125e8cf7fff6274~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第一个`index/index`webview我们上面说了它就是对应我们的小程序的渲染层，也就是真正的小程序页面。\r\n\r\n那么下面这个`instanceframe.html`是什么呢？\r\n\r\n这个webview其实是小程序渲染模版，打开查看一番\r\n\r\n\r\n![wx-11.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7abc566e52648f98f1ce8c1464489c9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n它其实就是提前注入了一些页面所需要的公共文件，以及红框内的一些页面独立的文件占位符，这些占位符会等小程序对应页面文件编译完成后注入进来。\r\n\r\n**如何保证代码的注入是在渲染层webview的初始化之后执行？**\r\n\r\n在刚刚渲染模版`webview`的下方有这样一段脚本：\r\n\r\n```js\r\nif (document.readyState === 'complete') {\r\n    alert(\\\"DOCUMENT_READY\\\")\r\n  } else {\r\n    const fn = () => {\r\n      alert(\\\"DOCUMENT_READY\\\")\r\n      window.removeEventListener('load', fn)\r\n    }\r\n    window.addEventListener('load', fn)\r\n  }\r\n```\r\n\r\n很明显，这里在页面初始化完成后，通过`alert`来进行通知。此时的`native/nw.js`会拦截这个`alert`，从而知道此时的webview已经初始化完成。\r\n\r\n### 整体渲染流程\r\n\r\n了解了上面这个重要过程，我们就可以将整个流程串联起来了\r\n\r\n1. 打开小程序，创建视图层页的webview时，此时会初始化渲染层`webview`，并且会将该web view地址设置为`instanceframe.html`，也就是我们的渲染层模版\r\n2. 然后进入页面`/index/index`，等`instanceframe`webview初始化完成，会将页面`index/index`编译好的代码注入进来并执行\r\n\r\n```js\r\n// 将webview src路径修改为页面路径\r\nhistory.pushState('', '', 'http://127.0.0.1:26444/__pageframe__/index/index')\r\n\r\n/*\r\n... \r\n这里还有一些 wx config及wxss编译后的代码\r\n*/\r\n\r\n// 这里是\r\nvar decodeName = decodeURI(\\\"./index/index.wxml\\\")\r\nvar generateFunc = $gwx(decodeName)\r\nif (decodeName === './__wx__/functional-page.wxml') {\r\n  generateFunc = function () {\r\n    return {\r\n      tag: 'wx-page',\r\n      children: [],\r\n    }\r\n  }\r\n}\r\nif (generateFunc) {\r\n  var CE = (typeof __global === 'object') ? (window.CustomEvent || __global.CustomEvent) : window.CustomEvent;\r\n  document.dispatchEvent(new CE(\\\"generateFuncReady\\\", {\r\n    detail: {\r\n      generateFunc: generateFunc\r\n    }\r\n  }))\r\n  __global.timing.addPoint('PAGEFRAME_GENERATE_FUNC_READY', Date.now())\r\n} else {\r\n  document.body.innerText = decodeName + \\\" not found\\\"\r\n  console.error(decodeName + \\\" not found\\\")\r\n}\r\n```\r\n\r\n3. 此时通过`history.pushState`方法修改webview的src但是webview并不会发送页面请求，并且将调用`$gwx`为生成一个`generateFun`方法，前面我们了解到该方法是用来生成虚拟dom的\r\n4. 然后会判断该方法存在时，通过`document.dispatchEvent` 派发发自定义事件`generateFuncReady` 将generateFunc当作参数传递给底层渲染库\r\n5. 然后在底层渲染库`WAWebview.js`中会监听自定义事件`generateFuncReady` ，然后通过 WeixinJSBridge 通知 JS 逻辑层视图已经准备好()\r\n\r\n\r\n![wx-12.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac1106daed4dfd9b52e9ddb5664706~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n6. 最后 JS 逻辑层将数据给 Webview 渲染层，`WAWebview.js`在通过`virtual dom`生成真实dom过程中，它会挂载到页面的`document.body`上，至此一个页面的渲染流程就结束了\r\n\r\n## 数据更新\r\n\r\n小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。\r\n\r\n在架构上，WebView 和 JS Core 都是独立的模块，并不具备数据直接共享的通道。所以在更新数据时必须调用`setData`来通知渲染层做更新。\r\n\r\n### setData\r\n\r\n- 逻辑层虚拟 DOM 树的遍历和更新，触发组件生命周期和 observer 等；\r\n- 将 data 从逻辑层传输到视图层；\r\n- 视图层虚拟 DOM 树的更新、真实 DOM 元素的更新并触发页面渲染更新。\r\n\r\n这里第二步由于WebView 和 JS Core 都是独立的模块，数据传输是通过 `evaluateJavascript` 实现的，还会有额外 JS 脚本解析和执行的耗时因此数据到达渲染层是异步的。\r\n\r\n**因此切记**\r\n\r\n- 不要频繁的去setData\r\n- 不要每次 setData 都传递大量新数据（单次stringify后不超过256kb）\r\n- 不要对后台态页面进行setData，会抢占正在执行的前台页面的资源\r\n\r\n### 与Vue对比（再来看看Vue）\r\n\r\n整体来讲，小程序身上或多或少都有着vue的影子...(模版文件，data，指令，虚拟dom，生命周期等)\r\n\r\n但在数据更新这里，小程序却与Vue表现的截然不同。\r\n\r\n#### 1.页面更新DOM是同步的还是异步的？\r\n\r\n#### 2.既然更新DOM是个同步的过程，为什么Vue中还会有nextTick钩子？\r\n\r\n```js\r\nmounted() {\r\n  this.name = '前端南玖'\r\n  console.log('sync',this.$refs.title.innerText) // 旧文案\r\n  // 新文案\r\n  Promise.resolve().then(() => {\r\n    console.log('微任务',this.$refs.title.innerText)\r\n  })\r\n  setTimeout(() => {\r\n    console.log('宏任务',this.$refs.title.innerText)\r\n  }, 0)\r\n  this.$nextTick(() => {\r\n    console.log('nextTick',this.$refs.title.innerText)\r\n  })\r\n}\r\n```\r\n\r\n![nexttick5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c6403a0259491fbe1d21fba66b4055~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n这里推荐阅读这篇了解更多：[Vue异步更新机制以及$nextTick原理](https://juejin.cn/post/7089980191329484830)\r\n\r\n然而小程序却没有这个队列概念，频繁调用，视图会一直更新，阻塞用户交互，引发性能问题。\r\n\r\n而Vue 每次赋值操作并不会直接更新视图，而是缓存到一个数据更新队列中，异步更新，再触发渲染，在同一个`tick`内多次赋值，也只会渲染一次。\r\n\r\n> 原文首发地址[点这里](https://mp.weixin.qq.com/s/ZoaQz5uxt8UKTN5YnmvDCw)，欢迎大家关注公众号 **「前端南玖」**，如果你想进前端交流群一起学习，[请点这里](https://juejin.cn/pin/7072217320155775007)\r\n\r\n**我是南玖，我们下期见！！！**\r\n\r\n"
    },
    {
        "article_id": "7189204282715930684",
        "snapshot": "",
        "title": "写个简易版秒杀系统练练手",
        "preview": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 不写文章还有点不自在，完了😂（有点懒了，同步文章~） 今天来分享下这段时间学习的一个秒杀项目，黑马点评。 好久没跟着学这些，感觉",
        "author": "4ye酱",
        "view_count": 1125,
        "collect_count": 10,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/660c03d23f4baaafe8075bcf36cced8c~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: v-green\r\n---\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n不写文章还有点不自在，完了😂（有点懒了，同步文章~）\r\n\r\n今天来分享下这段时间学习的一个秒杀项目，黑马点评。\r\n\r\n好久没跟着学这些，感觉非常非常好玩，又想捣鼓点项目玩玩了 哈哈。\r\n\r\n我也简单搭建了一个，用到了这些技术。\r\n\r\n> **Springboot2 + Redis7 + Lua + Redisson + MySQL8 + RabbitMQ3.9 + MybatisPlus + Hutool**\r\n\r\n其中 **Redis** 和 **MySQL** 都是之前搭建在云端的 **K8S** 上的 主从 结构，用 **Traefik** 做总网关。\r\n\r\n**RabbitMQ** 则是之前在本地虚拟机上用 docker 搭建的 ，还有 **Prometheus** + **Grafana** 监控。\r\n\r\n### 思路\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/138624974a1548a09c3e94615e345268~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 隐藏秒杀地址\r\n\r\n这个就是实现一个用户一个地址，给脚本工具加点难度。\r\n\r\n根据需要生成这个 path，比如用 md5 混淆下 。\r\n\r\n然后放到 Redis 中 key ：秒杀活动ID+’path‘ + 秒杀商品ID+用户ID , value ：path\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e7fdbe038a48e1b6d11d117ce77ae0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n真实的秒杀地址如下\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d816e26712463387ddc3f5e614424e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### lua 脚本预扣库存\r\n\r\n用 lua 脚本来保证这个操作的原子性，判断 库存key 存不存在，数量够不够，够的话执行扣减操作\r\n\r\n![bug](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f57f90f60e654a6bb219151f3823d37d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我这样写的脚本是有问题的，没有进行 **重复订单校验** ， 以及 set 这个 订单信息 到 redis 中。\r\n\r\n这 3 步操作应该是原子性的，**校验，扣减，设置**\r\n\r\n所以即便 lua 脚本能保证操作的原子性，但是并发情况下会出现 **少卖** 的情况。\r\n\r\n![模拟同个用户 50 个并发 100个库存](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43238f901a14d8aa13cdc7f9ce5fc06~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4e0e13173bd41738de0f5763feed5a4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![改正版](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a89275684e5e482eabb5872e0b98f91d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n改正后也就正常了，之前我是老想着 订单ID 的生成要从 **分布式ID** 中获取，想尽量较少这个 网络请求 的，一不小心就疏忽了。（**以后得先把 核心思路 写下，再思考优化，不能边写边想优化了**🐷）\r\n\r\n**分布式ID** ，我之前研究这个 **美团Leaf** 也是想简单搭建一个，奈何总喜欢偷懒🐷，这里我是用 **Hutool** 的 **雪花算法** 简单生成的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ee98c88db97428887b35e349c18a256~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 保存订单信息到 Redis\r\n\r\n出 **大bug** 之前，我以为这里只是做 **重复订单校验** 的，没想到，还有这种情况 👇\r\n\r\n**MQ 挂了**，消息还没发送出去，甚至一开始就**没连接上**的情况。\r\n\r\n比如 我这个本机和虚拟机 休眠后得重启下 **虚拟网络vm8**，不然连不上去。\r\n\r\n![意料之外~](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f112ec355dae41988aa3cad51c18eacf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以，这里得写个小脚本，将 订单信息 发送到 MQ 中，在紧急情况下能快速补救。\r\n\r\n### 分布式锁\r\n\r\n目前用 jvm 级别的锁其实就足够了，但后面上集群还得改代码，干脆一鼓作气。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef506545bf7040059f11c38220c2a43d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n锁的粒度，不能太大，主要防止用户重复下单。\r\n\r\n比如\r\n\r\n0.  第一版 错误的 lua 脚本中，就会出现 **重复下单** 的情况\r\n0.  集群模式下，多个消费者的情况，此时谁先拿到分布式锁，谁就可以消费这个订单，**避免重复下单**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d35207d336c41ff971525fa44ca969c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过分布式锁，保证这个订单只有一个消费者消费，即便在多个消费者模式下，也不会出现 **重复下单** 的情况。\r\n\r\n同时，也可以防止使用 Redis 出现意外，就像上面 **错误使用 lua 脚本的案例**，以及 可能存在的 key 过期等问题导致的重复下单问题。\r\n\r\n当然，这还不是 **兜底方案** ，万一这个 **分布式锁** 也出现意外了呢，所以保险起见，还需要给 订单表 建立 **唯一索引**（用户id+商品id)，靠数据库本身保证了。\r\n\r\n这里如果不用分布式锁，那就得从数据库层面去保证了，得用 select …… for update 开启 **悲观锁**，那效率会进一步降低的。\r\n\r\n> 注意，这里也是 **缓存击穿** 的常见解决思路，分布式锁，双重检查锁模式。\r\n\r\n### 事务\r\n\r\n我这里是简易版的，没有涉及到 分库分表，所以也谈不上这个 分布式事务。\r\n\r\n这里我用的 **编程式事务** ，毕竟 扣减库存和保存订单 要在一个事务里，用注解的话还得考虑这个**失效**的场景，获取这个代理对象去执行，没有这个 **编程式事务** 来得方便。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705dad358c0848cea4e265e9c0bd060b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n假设 订单在订单库中，商品在商品库中，那这种情况下，是不是还得考虑这个 **分布式事务** 呢？\r\n\r\n我可能还是不会选择这个 **分布式事务** ，我会直接往 商品库 中 建立一个 **秒杀订单表** 或者在 **订单库** 中建立这个 秒杀商品库存表，甚至专门弄一个 **秒杀库** ， **冗余** 一下，事后如果需要同步到相应的 库表 中，再进行相关的操作。\r\n\r\n那假如还有个积分系统呢 ?\r\n\r\n比如 支付回调后，更新订单状态的同时，还要更新这个用户积分。\r\n\r\n这我还是会选择 MQ ，通过 MQ 的可靠性 来达到这个 **最终一致性**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2842ef341af4bb0b1279bddbd936b33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n先发送消息到积分系统，更新订单信息单独在事务中。\r\n\r\n这是分布式事务中常见的一种解决方案 **基于MQ可靠性消息的最终一致性方案**。\r\n\r\n有时间可以学习下 Seata\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe94dd20b0cf4173b227a741f2526312~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 重试机制\r\n\r\n上图将 MySQL 和 MQ 的操作放一起，还得小心这个 MQ 的异常，导致这个 **事务回滚**，但是 ACK 还是正常发出去的情况。\r\n\r\n这里我最后还将异常抛出去，是为了触发这个 **重试机制** ，配置文件中 开启 RabbitMQ 消费者重试机制即可。\r\n\r\n> ACK 前发生异常，事务回滚，触发重试机制。\r\n\r\n> ACK 中发生异常，捕获，丢弃异常，提交事务。再次消费时，发现是重复订单。\r\n\r\n> ACK 后还有异常，未捕获，事务回滚，但消息已经被 ACK，触发了重试机制，在重试期间没有异常，则正常处理。如果重试后还有异常，则会出现 消息丢失 的情况，这又得 **紧急处理** 了。\r\n\r\n### 防止超卖\r\n\r\n有两个扣减动作\r\n\r\nRedis 预扣库存，这里得在 **lua 脚本**中操作。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4bd03eb3ca42809077550c80a3828e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nMySQL 扣减库存，这里核心就是 **乐观锁的方式** a=a-1 where a > 0;\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76441128047c45a6bab6638cdc6b14ac~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 缓存\r\n\r\n这里再简短啰嗦下\r\n\r\n#### 缓存穿透\r\n\r\n> 针对不存在的 key ，可以用 **布隆过滤器**\r\n\r\n#### 缓存击穿\r\n\r\n> key 刚好过期，或者 **商品成了爆款**\r\n\r\n用 **分布式锁** ， **双重检查锁模式** 能解决上面这两种情况，锁的粒度也是这个 商品。\r\n\r\n针对 key 刚好过期 的情况，我了解到一种新的处理思路：**逻辑过期**\r\n\r\n不在 Redis 中判断是否过期，在 代码 中进行判断，过期的话获取锁，开线程去更新，但实现起来比较复杂。\r\n\r\n#### 缓存雪崩\r\n\r\n> 大量 key 同时过期，可以 **给不同的Key的TTL添加随机值** ，**给业务添加多级缓存** ，**降级限流策略安排上**\r\n\r\n### 总结\r\n\r\n到这里，这个简易秒杀系统就介绍完了，至于 限流，用户鉴权，标记 ，订单支付，超时处理，消息的顺序性 …… 再到大一点的 集群，缓存一致性 等等东西，得抽空再完善下了。\r\n\r\n搭建过程中，最有意思的是，一直防着 **超卖**，结果还出现了 **少卖** 的场景😂\r\n\r\n所以这 Redis 预扣库存 也得谨慎呀，**lua脚本** 三合一疗程：查，扣，存 😂\r\n\r\nMySQL 也一样，**分布式锁**，**事务** ，查，扣，存\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0f50cb4563a4a118a0acaf5d11dbf66~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n希望到时能把笔记中的技术都过一遍。\r\n\r\n![学习笔记](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1af887a07f6340f1857d80e7cfdeab40~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n下面是我用 JMeter 测试的一些数据情况👇\r\n\r\n### JMeter\r\n\r\n这里两个 http 请求分别模拟，**获取秒杀地址**，**开始秒杀**。\r\n\r\n![jmeter 500 个并发，100 件库存](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932307bdeea5479ab79783d146ce2965~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### 报告一\r\n\r\n这个 平均响应 是 326 ms ， 50 % 的请求是 245 ms，99% 是 1342 ms ，最小是 21 ms，最大是 1359 ms ，吞吐量是 605/s 。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2a00974d3f4d5598ce41d6c3d1fccc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这个成绩。。一言难尽，这还是用了 **MQ 异步下单** ，还有 **内存标记**，**Redis 预扣库存** 的结果，而且是 **预热了 JVM** 的情况😱\r\n\r\n这最大的开销应该是网络问题，要访问 云服务器 K8S 中的 Redis 以及 本地虚拟机上的 MQ。\r\n\r\n或者是我的老伙计性能问题，又得跑项目，还得测试，这 CPU ，内存，网卡 估计也忙坏了。\r\n\r\n简单分析下 👇\r\n\r\n**获取秒杀地址** ， 这里就访问一次 Redis ，执行 Set 命令。\r\n\r\n**开始秒杀** 中，涉及的网路操作有\r\n\r\n0.  校验地址\r\n0.  是否重复下单\r\n0.  预扣库存 lua 脚本\r\n0.  发送订单信息到 MQ（虚拟机上）\r\n\r\n后面把项目搭建到云服务器上再来测下。\r\n\r\n#### 报告二\r\n\r\n这里看到 第一个请求 的 RT 都比第二个请求的 小。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bca1f96e66548bcb7007e71952676fb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### Redis\r\n\r\n![Redis 内存使用情况（测试前）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25e5b6b0a94fbf892f405d7fa677ec~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![Redis 内存使用情况（使用后）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb2f5c6d9034f688860f922a79341ab~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到，内存多了 0.1M 左右，这是多了 601 个 key\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d96f3c01504786a7e2983324f9b351~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n至于怎么多了 32 条 client connection ， 只能做个简单的推测先了\r\n\r\n项目中使用了这个 redisson 做分布式锁，占用了 25 条\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24ba9f25e237425c9ab970b1a5011c16~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n简单看下源码\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6dbbca0186548c0889c1e13f3a974ed~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n拿到服务器上的所有连接，排掉之前的 5 条，刚好剩下 32 条。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a1282308d64a4ab251b032ebf531fe~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里看到使用 resp3 的有 7 条，刚好符合，应该是 RedisTemplate 相关创建的。\r\n\r\n这里简单看下源码， Redis 6 开始默认使用 RESP3 的协议的\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05322fd8ee4847c79f3792069d54761e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n* * *\r\n\r\n### RabbitMQ\r\n\r\n下面是从 Prometheus + Grafana 监控截取的\r\n\r\n![RabbitMQ 使用情况（测试前）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f60a0fd296f1478c89c364f45ed973a9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![RabbitMQ 使用情况（测试中）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c31852c5b9694dc09fb8078cf141acf1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里 发送端和消费端 在一个应用上，共用一条 connection， 发送端创建了 24 个 channel ， 消费端 2 个。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0219779e822404f8a64d1755f9dd4d3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![发送端第一条 MQ 数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4447a5e5f84b589d490a8bcdc9634d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![发送端第一条 MQ 数据被 ACK](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a689005e3a4da8bdcadfc8bb969945~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n从这个监控图可以看到，消费端开始消费的时间点大概是 16:47:00\r\n\r\n而生产者发送第一条消息和被confirm 的时间大概是 16:46:30 ； 这个有误差是因为这个监控自动刷新的频率是 15s ，目前是最小的了（可能是我挑的模板问题，或者是这并发太小😂）\r\n\r\n![消费者消费能力，大概每秒 2 个 ack](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6c77581f35438ca5ed5b438b663288~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![channel ](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4fb4892aee4ed787ee6db27b518f79~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n* * *\r\n\r\n### K8S\r\n\r\nminikube 节点，上面运行了 Redis 主从 , MySQL 主从。\r\n\r\n![K8S的情况（测试前）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a135dda2da840749de180558c53f652~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![K8S的情况（测试后）](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8111056a68e14b99b389c918fb92442e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n基本没变化。\r\n\r\n后面再把 MQ 和 镜像仓库搭建一下，然后再把项目丢上去跑跑看看 ，到时再看看这个测试报告。\r\n\r\nover！"
    },
    {
        "article_id": "7123922714200375332",
        "snapshot": "",
        "title": "一个30+大龄前端的2022年中总结（还贷，还情，还我金铲铲）",
        "preview": "作为一名30多岁的前端，并且只会前端的我来说，2022要总结的东西有很多，但总结起来其实就是一句话：工资不见往上涨，我还不敢往外闯",
        "author": "末世未然",
        "view_count": 77440,
        "collect_count": 182,
        "comment_count": 440,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f0468eddaf02ec1ab8284257e0e5880d~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: cyanosis\r\nhighlight: atom-one-dark\r\n---\r\n「时光不负，创作不停，本文正在参加[2022年中总结征文大赛](https://juejin.cn/post/7108989863126368286 \\\"https://juejin.cn/post/7108989863126368286\\\")」\r\n\r\n作为一名30多岁的前端，并且只会前端的我来说，2022要总结的东西有很多，但总结起来其实就是一句话：工资不见往上涨，我还不敢往外闯。\r\n\r\n# 房贷下来了\r\n 去年1月份，我跟老婆商量着在市区买套房，但是看了看自己的腰包，以及首付4成需要准备太多钱了，咱们就放弃了，打算去郊区看看，没办法，实力不允许，只能退而求其次。于是几个周末都在了解各个楼盘，看了3个盘吧，咱们最后选择了第一个盘，并在去年6月签了购房合同。首付透支了我们的全部积蓄，还借了10w。我跟老婆工资都不高，但是在之后的半年里，竟然积攒了10w，是我们没有想到的，说是省吃俭用吧，也没有那么夸张，但是就比平时多攒了钱。做做兼职，写写页面，小的活500-1000，大点的3000-5000。那段时间确实攒了一些钱。\r\n \r\n 今年房贷下来了，每月交6000。对于我们这种普通家庭的人来说，压力是相当大的。但30多岁了，老婆怀孕快生了，每天还得做饭洗衣拖地，兼职的活也不敢接太难的，当然太难的我也不会...\r\n \r\n# 老婆快生了\r\n老婆怀孕期间，说实话，是欠了一些陪伴的，虽说每天都在一起，但是为了多攒一些钱，晚上吃完饭刷完碗我就栽进书房写代码了。周末偶尔出门在附近逛逛，也仅限于附近。最让我后悔的还是没带老婆去拍孕妇照，虽说她嘴上说不要，我应该硬拗她去的。只有少量视频与照片存在手机里，但这些和艺术照还是有相当大的差距的，在坐的大老爷们以后另一半说不要的时候，你也得去，这是一种仪式感。\r\n\r\n老婆生之前，每晚睡前会给宝宝做胎教，买了2本故事书，来来回回念，心想宝宝也许还能想起来这个故事好像听过，增加Ta的记忆力（好吧，单纯就是为了省点钱 捂脸ing）\r\n\r\n孕期千万不要让老婆干家务，提重物！孕期千万不要让老婆干家务，提重物！孕期千万不要让老婆干家务，提重物！别说孕期，平时家务这种事，作为大老爷们也应该承包了，研究表明，家庭中男性做家务幸福指数更高。\r\n# 孩子出生了\r\n在五月的某个周一早上5点多，老婆羊水破了要生了，我真的紧张了，紧张到拨打120都按错号码，按对后对方问我地址，我大脑都空白了几秒，后面才想起来在哪。孩子也真会挑时候，选择在周一早上我还没去上班的时候发动。\r\n\r\n老婆去医院待产这件事，我要跟大家分享下经验\r\n1. 在老婆预产期前一周最好把核酸做了，以免因为核酸没过被卡在外面。\r\n2. 提前一个月把待产包准备好（我们是准备了一个大行李箱，里面装宝宝出生后用的衣物用品奶粉还有妈妈的东西也要准备好，具体可以在抖音搜索`待产包`），宝宝发动直接拎包去医院。\r\n3. 如果需要打无痛分娩的，打之前不能进食。\r\n4. 进产房跟老婆在一起，这种钱不能省。\r\n\r\n我老婆是顺产不出转剖宫产的，很多人会说直接选择剖，我在老婆顺不出来的时候也后悔没有直接剖，但是这边顺还是剖，最好还是听从医嘱，毕竟剖宫也是存在风险的，医生也不敢打包票。所以能顺还是尽量顺，这样身体也恢复的更快。\r\n\r\n老婆从产房出来，生了个女宝宝，母女平安，我当爸爸了！都说女儿是爸爸前世的情人，这份情我要还\r\n## 疫情下的90后父母\r\n由于疫情期间医院只允许一个人陪护，所以在接下来的5天时间里，宝宝的吃喝拉撒，老婆的饮食与护理，全落在我身上。也是这几天，让我从一个无知小子变身一个超级奶爸：喂奶，抱娃，换尿不湿，哄睡等等。虽说一个人确实辛苦，但回想起来，那几天却是幸福的回忆。\r\n# 我却躺平了\r\n整个上半年其实重心主要还是在家庭，工作上确实有点摸鱼了。\r\n\r\n## 一次创意大赛让我重回掘金\r\n\r\n早在2017年我就加入了掘金，但是直到2021年才在掘金写了第一篇文章，也没来由，就瞎写，啥活动也不知道，签到也不懂。直到今年4月份，在一次偶然的机会，遇到[大帅](https://juejin.cn/user/2955079655898093)，他发起了一次掘金创意大赛组队参赛的邀请，我抱着试试看的态度报名了。并在之后疯狂参加掘金活动（羊毛撸起来）。在掘金，目前已收集奖品如下：\r\n- [x] 小黄鸭\r\n- [x] 马克杯\r\n- [x] 空调毯\r\n- [x] 太空人风扇\r\n- [x] 拖鞋\r\n- [x] 榨汁机\r\n- [x] 电饭煲\r\n- [x] 小爱音箱\r\n\r\n获奖文章链接：\r\n\r\n[从零开始做一个贪吃蛇游戏，会vue就行](https://juejin.cn/editor/drafts/7085285244743450638)\r\n\r\n[我用一个div就画出了一个大西瓜~](https://juejin.cn/post/7109729038981136391)\r\n\r\n## 背单词\r\n曾几何时大学不需要过英语4级就能毕业的时候，在裸考参加了4次4级考试，一次比一次考得低的时候，果断就放弃了，反正不影响毕业~\r\n\r\n现在后悔啊，英语真的很重要，不会英语或者英语不好做程序员是非常吃亏的，且不说看英文文档了，就写代码命个名都得百度翻译一下，无形中效率变低。\r\n\r\n推荐大家一款背单词的app：墨墨背单词。\r\n我坚持打卡666天，从刚开始每天50个到每天30个到现在每天10个单词。因为太多了真的坚持不下来，`如果你发现自己坚持不下来一件事的时候，一定要降低点标准`，毕竟每天走一步总比不走强。背10个单词花不了你3分钟。这就是我坚持打卡了快2年的原因。\r\n\r\n![b6bbabf63d15ce4e296783a38208193.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b94e19d7f344619b6acea31f2cebb46~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 打游戏\r\n大学时候沉迷英雄联盟。后来沉迷云顶之弈，现在沉迷金铲铲之战。\r\n\r\n中午午休都不要了，上分要紧，毕竟回家就得带娃了。附一下我的战绩，赛季大师是最低标准：\r\n\r\n![cf2eb2612724ed5e331d2c248afdd41.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e663e58a83184ab9842b5c6548b9beec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 2022下半年立flag\r\n来个谐音梗（3-8）的flag清单\r\n- [ ] 学会three\r\n- [ ] 掘金等级到4级\r\n- [ ] 看5本书（非小说）\r\n- [ ] 游戏场次降到60把以内\r\n- [ ] 多陪妻子\r\n- [ ] 教会宝宝喊爸爸~\r\n\r\n\r\n就这么多吧，躺平人不该立太多flag。点个赞表示你也玩金铲铲呀：giegie,这个赞可以给我吗？"
    },
    {
        "article_id": "7151590970889338893",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d200f91d6f5436f9f6ee6af663ff612~tplv-k3u1fbpfcp-watermark.image?",
        "title": "呀！原来这就是前端监控系统",
        "preview": "在刚开始学前端的时候，那时候开发的应用总是在用户的设备中出现一些报错，开发者只知道这个型号的设备出现这个问题，但对其他信息却全然不知，比如说其他操作系统、其他设备型号、其他页面会有这个报错吗，这个报错",
        "author": "plutoLam",
        "view_count": 25269,
        "collect_count": 347,
        "comment_count": 19,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b7894061b6d017bfbfaf38ab17285e44~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: channing-cyan\r\nhighlight: a11y-dark\r\n---\r\n在刚开始学前端的时候，那时候开发的应用总是在用户的设备中出现一些报错，开发者只知道这个型号的设备出现这个问题，但对其他信息却全然不知，比如说其他操作系统、其他设备型号、其他页面会有这个报错吗，这个报错出现的频率又是多少。每次出问题只能等待用户反馈，不能第一时间去解决问题，甚至用户没反馈的话永远也无法发现某些报错。\r\n\r\n后来了解到前端监控这个东西，才知道原来可以这样去监控用户设备上的应用。“前端监控”不单单包括`web`性能和JS异常的监听，还包括处理日志的平台。下面就来总结一下打造一个完整的前端监控系统的过程。\r\n\r\n## 了解业务需求\r\n\r\n首先要了解自己所在的团队或者公司的具体需求。\r\n\r\n-   如果是一个小团队，可能只需要简单的几个数据即可，业务也只有一两种，这样的话整个系统会简单很多，不用划分很多模块\r\n-   如果是中厂或者大厂，很多个前端部门都需要用到这个平台，那么就需要划分成很多模块，而且需要很多通用的特性（比如说维度，下面会讲到）\r\n\r\n了解完这个产品覆盖的范围后，就要开始调查开发者们需要在用户手机中需要收集的数据，根据这些字段设计日志的数据结构和数据库的设计\r\n\r\n这里提到的数据可以包含以下几个点和无数小点\r\n\r\n1.  性能统计\r\n\r\n<!---->\r\n    a.  基础数值（首次渲染时间、白屏时间等）\r\n    b.  可交互（首次加载时页面卡顿、操作时的js加载情况等）\r\n    c.  资源（包括资源大小和资源的加载时间）\r\n\r\n\r\n2.  异常统计\r\n<!---->\r\n    a.  JS异常\r\n    b.  ajax异常\r\n    c.  资源文件\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a15a3960ce8843cd8768763c5202b9f2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其中大点需要一开始就确定，大点下面的小点我把他成为分组，分组可以被每个业务方根据自己的业务自定义，这样可以极大增加系统的灵活性。\r\n\r\n## 确定日志格式\r\n\r\n1.  type：首先要有一个`type`字段区分日志的类型，`value`比如`performance`（性能统计），`abnormal`（异常统计），除了这两种比较常见的`type`，自己也可以根据团队或公司业务来拓展`value`。\r\n1.  module：然后我们需要根据`module`字段区分各业务方，如商业研发部、基础架构部，考虑到部门的名字用英文表示太长且容易误会，可以用数字（分为前标和后标）映射来表示，如\\\"1_1\\\"表示商业研发部，\\\"1_2\\\"表示商业技术研发部，\\\"2_1\\\"表示基础架构部，按申请的部的顺序顺延，相同的大部门可以使用相同的“前标”，“后标”也可以表示不同的项目，这些都可以根据自己的部门自定义。\r\n1.  group：使用`group`表示分组，比如可以将一个项目中不同的落地页分成不同的组，将一个落地页中不同的组件分为不同组，还是根据自己的业务自行调整。\r\n1.  dim：即`dimension`维度，这个比较重要，简单说就是将每个数据都分为多个模块来统计，常见的dim如操作系统（Android or iOS）、浏览器类型、是否落地页、网络类型等等。\r\n1.  info：性能或异常的具体信息，一个“大点”中的`info`要求一样，这样方便统计，如异常统计的`info`可以分为“异常信息”、“异常时间”、“异常类型”、“具体的异常位置（行数）”。还包括一些诸如操作系统和浏览器类型的公共信息。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e45a7456294366986cfd16ad91c169~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n数据结构如下\r\n\r\n```js\r\n{\r\n      type: String,\r\n      module: String,\r\n      group: String,\r\n      dim: {\r\n        // 各个维度的信息\r\n      },\r\n      info: {\r\n        // 具体信息\r\n      }\r\n}\r\n```\r\n\r\n\r\n## 打造日志接收平台\r\n\r\n-   接收日志的接口可以设置在前端监控平台的`server`端，暴露一个接口即可，通过`type`来调用不同的处理函数。\r\n-   可以同时接收`get`请求和`post`请求。\r\n-   支持`get`请求主要是方便发送日志，只需要把日志信息转为`query`放在`url`后面就可以发送，后面会出具体的教程。\r\n-   支持`post`请求是因为可以支持[sendBeacon](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon)的`post`请求，可以优先采用，该`api`可以在会话结束后发送打点日志，降低打点丢失率。\r\n\r\n\r\n\r\n在发送和接收日志的时候有几点要注意的\r\n\r\n1.  若此网站的用户访问量很大，频繁地发送日志会造成`server`端的压力很大，可以参考一下以下两个解决方法。\r\n\r\n-   前端发送日志时抽样发送。\r\n\r\n```js\r\nconst randomNum = Math.random();\r\nif(randomNum < 0.1) {  // 设置10%的抽样\r\n  send()  // 发送日志\r\n}\r\n```\r\n\r\n-   前端可以将数据临时保存在`Storage`中并合并起来，隔一段时间发送一次日志（类似节流）。\r\n\r\n2.  受网络和设备老化的影响，有一些数据并不能反映网站的性能，这时候可以过滤极值来保证数据的可靠性。\r\n2.  即使抽样检测，日志数据依旧十分庞大，`server`端可以暴露一个`delete`的接口，服务器自动删除老数据。\r\n\r\n## 监控平台\r\n\r\n监控平台主要包括可视化和异常报警两个方面。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5307d82b14e45849db401950891cbc7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 可视化\r\n\r\n1.  我们收集数据的一大目的就是为了方便地观察数据的趋势变化，可以结合表格、柱状图、饼图、折线图来展示。通过选择分组和维度、日期来观察不同状态下的数据。这点和普通的管理系统并无两样。\r\n1.  为了观察数据随时间的变化，我们可以以小时、天、周来定义时间颗粒度，设置一个对比模式来比较不同时间颗粒度的数据，包括环比和上升下降值。\r\n1.  自定义设置时间间隔区间，观察指定区域内的数据。\r\n\r\n### 异常报警\r\n\r\n顾名思义，异常报警就是当项目中某些异常的数量跟用户设置的模式一致时，就会自动触发报警，异常报警可以从以下几个方面考虑。\r\n\r\n1.  支持小时级、天级选项，在小时级里面支持`前后小时`、`上一天和当前天的同一小时`、`上一周和当前周的同一小时内`的数据的对比；在天级里面支持`上一天和当前天`、`上一周的同一天和当前天`的数据的对比。\r\n1.  数据对比时支持环比（百分比）、数量的增减，支持`大于`、`大于等于`、`小于`、`小于等于`等比较方式，可以根据部门的业务情况来定义。\r\n1.  可以设置当前报警人的手机号或邮箱，还可以设置邮箱组，触发报警时发送短信或邮件。\r\n1.  暴露一个触发报警的接口，服务器按时请求该接口。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c01ca2eeaa844029cb5a2ac311ed5ac~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 维度\r\n\r\n在前端监控系统中维度是一个重要的概念，而自定义维度更能体现系统的自由度，他可以针对不同的业务自定义一套专属的维度划分，并且可以通过比较不同的维度情况去理解项目。自定义维度可以让这套系统覆盖绝大部分的业务统计需求。\r\n\r\n### 怎么设计维度\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70898039be874dc6be6601c74516fd4c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n比如说`B站`的首页，性能指标可以有“顶部`banner`的视频加载时间”、“首屏加载时间”、“后端数据加载时间”，当我们查看这几个指标时，我们可能想对比一下未登录状态和已登录状态的指标，又或者想区分一下进入点是哪里（是从搜索结果页点进来的还是从其他地方进来），还可能想看一下有缓存状态和无缓存状态的指标区别。\r\n\r\n这样就确定了三个维度，`登录状态`、`进入点`、`缓存状态`。\r\n\r\n确定维度后就可以确定维度的取值，进入点可以取三个值：直接输入`url`、搜索结果页点进、其他，登录状态和缓存状态都是两个值，每个维度的每个取值可以组成一个组合，这样的话总共有12种组合，也就是说可以看到这个页面12种情况下的指标情况。如果你发现此页面有一些性能问题，但是又排查不出来，可以试着尝试不同的维度组合，最后发现在已登录和未登录两种状态之间的数值相差很大，那么就可以定点排查登录模块的问题。\r\n\r\n但是维度的组合太多不一定是好事，比如12个组合，发送一次打点，数据库就会存入12条数据，如果是小时级的一天就会存入`12×24`条数据，若是维度组合数太多，就会非常浪费数据库资源，所以在自定义维度时需要按需设置。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9a7a10fc4c749e08b77d6e7b84d60ad~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以避免打点的时候维度组合太多将系统搞崩溃，发送打点日志之前需要先配置维度信息，发送日志时会将维度和配置好的维度进行`diff`，如果有`diff`，则视为攻击，放弃这个日志数据。\r\n\r\n### 维度提取\r\n\r\n像操作系统os、浏览器类型这种取值太多了，一般不会直接作为维度，但是像移动端的操作系统只有`ios`、`Android`、`other`就可以直接作为默认维度，在解析日志时可以自动解析出当前站点、移动`os`、`cookie`、`http`类型等数据，并与自定义的维度进行合并。\r\n\r\n\r\n\r\n当我们用英文或者`url`等复杂的字符串来作为维度的取值时，那么长一串确实不太合适，我们可以在设置维度时增加正则匹配，比如针对`url`就默认匹配它的站点值当维度的取值，针对如`os`这种可能需要翻译成英文的维度，可以定义一个`map`来将英文转为中文显示在可视化界面中。\r\n\r\n## 如何快速打点\r\n\r\n关于快速打点，内容有点多，之后会再出一篇文章详细介绍。\r\n\r\n### 总结\r\n\r\n看完这篇文章，相信你心里对前端监控系统的搭建也有自己的理解，希望能给你带来一些启示。\r\n\r\n此文章只是简单地概括一下搭建前端监控系统的步骤，并不涉及具体的代码，更多具体的解决方案未来会在更多文章中体现，可以关注一下呀！\r\n"
    },
    {
        "article_id": "7182184496517611576",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fa034373f71420d80e1864a745f08da~tplv-k3u1fbpfcp-watermark.image?",
        "title": "90%的Java开发人员都会犯的5个错误",
        "preview": "如果本文对你有帮助的话，救救孩子吧，可以投很多票，投票通道 ，万分感谢呀~~ 前言 作为一名java开发程序员，不知道大家有没有遇到过一些匪夷所思的bug。这些错误通常需要您几个小时才能解决。当你找到",
        "author": "JAVA旭阳",
        "view_count": 13213,
        "collect_count": 73,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e7ff7e07aaf9c553f05da5741e7badfa~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: cyanosis\r\n---\r\n如果本文对你有帮助的话，救救孩子吧，**可以投很多票**，[投票通道](https://rank.juejin.cn/rank/2022/writer/3438928100329646 \\\"https://rank.juejin.cn/rank/2022/writer/3438928100329646\\\") ，万分感谢呀~~\r\n\r\n## 前言\r\n\r\n作为一名java开发程序员，不知道大家有没有遇到过一些匪夷所思的bug。这些错误通常需要您几个小时才能解决。当你找到它们的时候，你可能会默默地骂自己是个傻瓜。是的，这些可笑的bug基本上都是你忽略了一些基础知识造成的。其实都是很低级的错误。今天，我总结一些常见的编码错误，然后给出解决方案。希望大家在日常编码中能够避免这样的问题。\r\n\r\n## 1. 使用Objects.equals比较对象\r\n\r\n这种方法相信大家并不陌生，甚至很多人都经常使用。是JDK7提供的一种方法，可以快速实现对象的比较，有效避免烦人的空指针检查。但是这种方法很容易用错，例如：\r\n\r\n```\r\nLong longValue = 123L;\r\nSystem.out.println(longValue==123); //true\r\nSystem.out.println(Objects.equals(longValue,123)); //false\r\n```\r\n\r\n为什么替换`==`为`Objects.equals()`会导致不同的结果？这是因为使用`==`编译器会得到封装类型对应的基本数据类型`longValue`，然后与这个基本数据类型进行比较，相当于编译器会自动将常量转换为比较基本数据类型, 而不是包装类型。\r\n\r\n使用该`Objects.equals()`方法后，编译器默认常量的基本数据类型为`int`。下面是源码`Objects.equals()`，其中`a.equals(b)`使用的是`Long.equals()`会判断对象类型，因为编译器已经认为常量是`int`类型，所以比较结果一定是`false`。\r\n\r\n```\r\npublic static boolean equals(Object a, Object b) {\r\n    return (a == b) || (a != null && a.equals(b));\r\n}\r\n    \r\npublic boolean equals(Object obj) {\r\n    if (obj instanceof Long) {\r\n        return value == ((Long)obj).longValue();\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n知道了原因，解决方法就很简单了。直接声明常量的数据类型，如`Objects.equals(longValue,123L)`。其实如果逻辑严密，就不会出现上面的问题。我们需要做的是保持良好的编码习惯。\r\n\r\n## 2. 日期格式错误\r\n\r\n在我们日常的开发中，经常需要对日期进行格式化，但是很多人使用的格式不对，导致出现意想不到的情况。请看下面的例子。\r\n\r\n```\r\nInstant instant = Instant.parse(\\\"2021-12-31T00:00:00.00Z\\\");\r\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\\\"YYYY-MM-dd HH:mm:ss\\\")\r\n.withZone(ZoneId.systemDefault());\r\nSystem.out.println(formatter.format(instant));//2022-12-31 08:00:00\r\n```\r\n\r\n以上用于`YYYY-MM-dd`格式化, 年从`2021` 变成了 `2022`。为什么？这是因为 `java` 的`DateTimeFormatter` 模式`YYYY`和`yyyy`之间存在细微的差异。它们都代表一年，但是`yyyy`代表日历年，而`YYYY`代表星期。这是一个细微的差异，仅会导致一年左右的变更问题，因此您的代码本可以一直正常运行，而仅在新的一年中引发问题。12月31日按周计算的年份是2022年，正确的方式应该是使用`yyyy-MM-dd`格式化日期。\r\n\r\n这个`bug`特别隐蔽。这在平时不会有问题。它只会在新的一年到来时触发。我公司就因为这个bug造成了生产事故。\r\n\r\n## 3. 在 ThreadPool 中使用 ThreadLocal\r\n\r\n如果创建一个`ThreadLocal` 变量，访问该变量的线程将创建一个线程局部变量。合理使用`ThreadLocal`可以避免线程安全问题。\r\n\r\n但是，如果在线程池中使用`ThreadLocal` ，就要小心了。您的代码可能会产生意想不到的结果。举个很简单的例子，假设我们有一个电商平台，用户购买商品后需要发邮件确认。\r\n\r\n```\r\nprivate ThreadLocal<User> currentUser = ThreadLocal.withInitial(() -> null);\r\n\r\nprivate ExecutorService executorService = Executors.newFixedThreadPool(4);\r\n\r\npublic void executor() {\r\n    executorService.submit(()->{\r\n        User user = currentUser.get();\r\n        Integer userId = user.getId();\r\n        sendEmail(userId);\r\n    });\r\n}\r\n```\r\n\r\n如果我们使用`ThreadLocal`来保存用户信息，这里就会有一个隐藏的bug。因为使用了线程池，线程是可以复用的，所以在使用`ThreadLocal`获取用户信息的时候，很可能会误获取到别人的信息。您可以使用会话来解决这个问题。\r\n\r\n## 4. 使用HashSet去除重复数据\r\n\r\n在编码的时候，我们经常会有去重的需求。一想到去重，很多人首先想到的就是用`HashSet`去重。但是，不小心使用 `HashSet` 可能会导致去重失败。\r\n\r\n```\r\nUser user1 = new User();\r\nuser1.setUsername(\\\"test\\\");\r\n\r\nUser user2 = new User();\r\nuser2.setUsername(\\\"test\\\");\r\n\r\nList<User> users = Arrays.asList(user1, user2);\r\nHashSet<User> sets = new HashSet<>(users);\r\nSystem.out.println(sets.size());// the size is 2\r\n```\r\n\r\n细心的读者应该已经猜到失败的原因了。`HashSet`使用`hashcode`对哈希表进行寻址，使用`equals`方法判断对象是否相等。如果自定义对象没有重写`hashcode`方法和equals方法，则默认使用父对象的`hashcode`方法和`equals`方法。所以`HashSet`会认为这是两个不同的对象，所以导致去重失败。\r\n\r\n## 5. 线程池中的异常被吃掉\r\n\r\n```\r\nExecutorService executorService = Executors.newFixedThreadPool(1);\r\nexecutorService.submit(()->{\r\n    //do something\r\n    double result = 10/0;\r\n});\r\n```\r\n\r\n上面的代码模拟了一个线程池抛出异常的场景。我们真正的业务代码要处理各种可能出现的情况，所以很有可能因为某些特定的原因而触发`RuntimeException` 。\r\n\r\n但是如果没有特殊处理，这个异常就会被线程池吃掉。这样就会导出出现问题你都不知道，这是很严重的后果。因此，最好在线程池中`try catch`捕获异常。\r\n\r\n## 总结\r\n\r\n本文总结了在开发过程中很容易犯的5个错误，希望大家养成良好的编码习惯。\r\n\r\n如果本文对你有帮助的话，救救孩子吧，**可以投很多票**，[投票通道](https://rank.juejin.cn/rank/2022/writer/3438928100329646 \\\"https://rank.juejin.cn/rank/2022/writer/3438928100329646\\\") ，万分感谢呀~~\r\n"
    },
    {
        "article_id": "7160491601679089694",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04f173e6e03a491c97a5081871a50629~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022前端开发知识总结归纳",
        "preview": "前端开发jsavascript基础; React;闭包；原型链；this；http/https；前端性能优化；js设计模式",
        "author": "大流星",
        "view_count": 4221,
        "collect_count": 179,
        "comment_count": 12,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/2fa645188333863ce130edfd9c909032~300x300.image",
        "category": "前端",
        "content": "[查看原文链接目录](https://www.yuque.com/yopai/pp6bv5)\r\n## js基础\r\n### 数据类型5+1\r\n基本类型：`number`、`string`、`undefined`、`boolean`、`null`;\r\n\r\n引用类型：`Object`;\r\n\r\n基本类型添加了两个新成员：`symbol`、`BigInt`; \r\n\r\n基本类型和引用类型区别：前者按值访问，因此为我们操作的就是存储在变量中的实际值；后者不能直接操作对象所在的内存空间，在操作对象时，实际操作的是该对象的引用。\r\n基本类型存储在`栈`中；引用类型的 ‘变量’名称 存储在`栈`中，同时存储指针，该指针指向`堆`中的真实的值；（`栈`、`堆`概念可以直接搜索  \\\"js中栈和堆的概念和区别\\\"）\r\n\r\n参考：[阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版](https://www.bookstack.cn/read/es6-3rd/spilt.9.docs-number.md)\r\n\r\n参考书：[犀牛书](https://book.douban.com/subject/35396470/)\r\n\r\n### this指向\r\n箭头函数：this继承包裹箭头函数的第一个普通函数中的this；\r\n\r\n普通函数：new（this指向新对象）——bind/apply/call（this是强制指向的this）——this指向函数上下文对象——this指向window；\r\n\r\n参考文章：[https://juejin.cn/post/6844903941021384711](https://juejin.cn/post/6844903941021384711)\r\n\r\n参考书：[红宝书](https://book.douban.com/subject/35175321/)\r\n### 闭包\r\n一个函数引用另外一个函数内部变量就会形成闭包，闭包在平时开发中非常的多见；**理解作用域链创建和使用的细节对理解闭包非常重要**；\r\n\r\n参考文章：[https://juejin.cn/post/6844903747957719053](https://juejin.cn/post/6844903747957719053)\r\n\r\n参考书：[红宝书](https://book.douban.com/subject/35175321/)\r\n\r\n### 原型\r\n每个对象被创建开始，就与另一个对象关联，从另一个对象上继承其属性，这里的另一个对象就是**原型**；\r\n\r\n原型存在的意义就是组成原型链。当范文一个对象属性时，先从对象本身找，找不到就去对象原型上找，如果还找不到，就去对象原型的原型上找，如此类推，直到找到为止；这条由对象及原型组成的查找链条就是原型链；\r\n\r\n参考文章：[https://juejin.cn/post/6844903936365690894](https://juejin.cn/post/6844903936365690894)\r\n\r\n参考书：[红宝书](https://book.douban.com/subject/35175321/)\r\n\r\n### 继承\r\n组合继承：通过 `call`修改子类`this`，将子类原型指向 `new 父类()`;\r\n寄生组合继承：通过  `call` 修改子类`this`，将子类原型指向父类原型（Object.create(父类.prototype)） ,并将子类原型构造函数指向子类；\r\n\r\n参考书：[红宝书](https://book.douban.com/subject/35175321/)\r\n\r\n### 模块化\r\n模块化特点：复用性、可维护性；\r\n`commonJs`最早作为标准在NodeJs中引入， 作为NodeJs模块化标准；在`commonJs`中，`require`首次加载就会执行整个脚本，在内存中生成一个对象缓存下来，下次加载时可直接从缓存获取；\r\n对于循环加载，只输出已执行的部分。还未执行部分不输出；\r\n最新ES6的 ES Module，是静态加载；脚本被加载时，成为一个指向被加载模块的引用，不会缓存；\r\n\r\n### 并发和并行\r\n区别：并发是两个或多个事件在同一时间间隔内发生；并行是指两个或多个事件在同一时刻内发生；\r\n并行通过提升硬件能力，只需要多核CPU即可达到；\r\n并发中最常听到的就是高并发，在一定时间，服务器的吞吐量和QPS每秒响应请求数都是一定的。而在这样的情况下，要解决高并发的问题，最简单当然是提升机器性能，加内存，加硬盘，升级网速。当然，通过架构层面设计，也可以做点东西，部署多台机器，添加负载均衡层，将请求均匀；将数据库分库分表并读写分离；引入消息中间件等；缓存集群引入；\r\n\r\n### 异步方案\r\n回调函数：在浏览器端，异步问题就是Ajax网络请求响应异步，而回调函数可以一定程度解决这个响应异步的问题，缺点是：不易维护、不易读、不能直接return；\r\n\r\n**Generator**：封装多个内部状态的异步解决方案，生成器函数；会返回一个迭代器，配合next()函数，可以控制开始、暂停和恢复代码；\r\n场景：控制流管理、异步操作；\r\n\r\n**Promise**：解决异步操作方案，包含异步操作结果的对象；内部存在三种状态，一旦开始不可更改状态；问题：无法取消，错误需要回调捕获；Promise是链式调用，每次调用then之后返回一个Promise，并且是一个全新的Promise；\r\nPromise实现依据Promise/A+规范——\r\n三种状态：pedding、fulfilled、rejected；\r\n（Promise封装的Ajax为例子）进行异步处理流：执行Promise回调函数，由于异步操作，内部状态未变化。继续执行then回调，内部状态未变化，回调队列中then回调暂时不执行。此时，异步执行完成（网络请求响应），状态变化，Promise内部调用resolve函数，回调队列执行；\r\n\r\n**async/await**：异步解决方案，需要配套使用；函数添加async后，函数会返回一个Promise；await内部实现了**Generator，await是异步操作，后来的表达式不返回Promise的话，就会包装成Promise.resolve(返回值 )，然后去执行函数外的同步代码；**\r\n\r\n## 事件循环\r\n> 一个事件循环又一个货多个任务队列；一个任务队列是一组任务；\r\n\r\n```\r\n1. 每个事件循环是一个正在运行的任务，它可以是一个任务或null；\r\n\r\n2. 每个事件循环具有microtask队列（微任务队列），最初为空；\r\n\r\n3. 每个事件循环都有一个执行微任务检查点的布尔值，该布尔值最初为false；\r\n```\r\n\r\n#### 1. js的事件循环如何环执行？\r\n浏览器事件循环执行顺序：\r\n> 1. 首先执行script脚本同步代码，属于宏任务；\r\n> 2. 当执行完当前所有同步任务后，执行栈为空，查询是否有异步任务代码需要执行；\r\n> 3. 执行当前宏任务下的所有微任务；\r\n> 4. 微任务执行完之后，如有必要会渲染页面；\r\n> 5. 然后开始下一轮事件循环；\r\n\r\n\r\n---\r\n\r\n#### 2. 宏任务和微任务有哪些？\r\n宏任务：script、setTimeout、setInterval、setImmediate、I/O、UI Render；\r\n微任务：process.nextTick、promise、MutationObsever；\r\n\r\n---\r\n\r\n#### 3. Nodejs的事件循环和浏览器事件循环区别？\r\nNodejs和浏览器端，宏任务和微任务交替执行，调用顺序基本相同。Nodejs执行会进行阶段区分，分为6个阶段：[参考：Node.js 事件循环文档](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)，每进入某个阶段，会从回调队列中取出函数执行。当队列为空或回调函数达到系统设定阈值，就进入下一个阶段。\r\n\r\n---\r\n\r\n## 异步方案\r\n可以把ajax异步回调作为浏览器端的最初的异步解决方案，`异步回调 ———> Promise实例 ——> Generator ——> async/await`，大致是一个这样的线，我们需要关注的可能主要就是Promise 和 async/await的方案。\r\n#### 1. Promise内部实现了解嘛？它的具体工作流程是怎么样的？\r\nPromise是异步解决方案，包含异步操作结果的对象，特点：`内部存在三种状态，状态一旦变化不可更改状态；Promise是链式调用，每次调用then回调函数都会返回一个新的Promise，并且是一个全新的Promise；`\r\nPromise异步处理流：`执行Promise实例回调函数，由于异步请求或者操作，此时状态未变化。继续执行then回调，由于状态未变化回调会被放入回调数组中。直到Promise实例中异步请求或者操作完成，状态发生变化，调用resolve函数，回调数组遍历执行，then回调函数拿到相关数据`。\r\n\r\n---\r\n\r\n#### 2. 说一说async/await\r\n参考：\r\n\r\n[Promise原理解析](https://juejin.cn/post/6844903954514444295)\r\n\r\n[图解Promise流程](https://juejin.cn/post/6930859627961647117)\r\n\r\n## 浏览器渲染原理\r\n浏览器是多进程应用，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。浏览器进程有：Browser进程(主进程)、插件进程、GPU进程、渲染进程(浏览器内核)。主进程只有一个是负责协调应用，同时默认每个Tab页面一个渲染进程，互不影响。我们常说的Js线程、GUI渲染线程就包含在渲染进程之中，还包括异步http请求线程、事件触发线程等。\r\n#### 1. 地址栏输入域名地址之后发生了什么？\r\n```\r\n1. DNS服务查询域名对应的目标服务IP地址；\r\n2. 根据目标IP地址查找到目标服务器，并建立TCP连接；\r\n3. 服务器响应返回数据或文本信息等；\r\n4. 客户端获取到数据之后进行页面渲染；\r\n```\r\n#### 2. 浏览器渲染的流程？\r\n```\r\n1. 请求html文件处理html标记构建DOM树；\r\n2. 请求css文件处理css标记构建CSSOM树；\r\n3. 将DOM和CSSOM合并成一个渲染树；\r\n4. 根据渲染树布局，以计算每个节点的几何信息；\r\n5. 将各节点绘制在屏幕上；\r\n```\r\n存在阻塞的css资源时，浏览器会延迟JS的执行和DOM的构建；\r\n#### 3. 重绘和回流？\r\n`重绘`是当节点需要更改外观而不影响布局；`回流`是布局或几何属性需要改变；\r\n\r\n[参考：渲染性能](https://developers.google.cn/web/fundamentals/performance/rendering)\r\n\r\n参考：\r\n\r\n[从浏览器多进程到JS单线程](https://juejin.cn/post/6844903553795014663)\r\n\r\n[你不知道的浏览器页面渲染机制](https://juejin.cn/post/6844903815758479374)\r\n\r\n## 网络协议\r\n![tcp_ip.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/239341779399432e9cd1b479f717c875~tplv-k3u1fbpfcp-zoom-1.image)\r\n关于TCP和UDP的介绍、TCP的三次握手和四次挥手就不细说，相关文章可以参考：[**传输层协议TCP和UDP**\r\n](https://juejin.cn/post/6844903905306886151)，[**TCP三次握手和四次挥手**](https://juejin.cn/post/6844903918334377991)；\r\n\r\nhttp协议是常用的网络传输协议，全称是超文本传输协议，它规定了http请求和响应的具体结构，当然还包含其他东西，例如：缓存、文件类型、参数、请求类型、状态等。它是建立在传输层TCP协议之上的，TCP握手成功之后，才可以进行网络数据传输。\r\n\r\n### HTTP/HTTPS\r\n#### 1. 什么是http协议？它是怎么样的？\r\nhttp是TCP/IP协议应用层协议，主要负责数据或文本图片等内容的传输，它是建立在传输层TCP协议之上的。http分为请求报文和响应报文，`从Web客户端发往Web服务器的HTTP报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文`，报文分为：起始行、 首部字段、主体等；\r\n\r\n---\r\n\r\n#### 2. http和https的区别？\r\nhttp和https从字面的区别就是一个s，这个s就是SSL/TCL加密协议。说到加密协议就绕不开加密技术，在SSL/TCL加密协议中既有用到非对称加密，也有用到对称加密。SSL/TCL加密协议相当于是在应用层和传输层之间加了一层，可称为加密层。\r\n大致流程：客户端向服务器端索要加密证书获取公钥等证书信息；双方协商生成\\\"对话密钥\\\"；双方采用\\\"对话密钥\\\"进行加密通信。非对称加密保证\\\"对话密钥\\\"的安全传输，对称加密保证客户端和服务端对数据的加解密。\r\n\r\n---\r\n\r\n#### 3. http网络缓存如何配置？\r\n如果需要开启强缓存和协商缓存，可在服务端nginx web服务器进行对应的配置，开启对应的网络缓存。其他服务端web服务器也可配置。(配置细节网上一大堆)\r\n\r\n---\r\n\r\n#### 4. 强缓存和协商缓存的区别？\r\n**强缓存**：Cache-Control，常用属性有max-age、no-cache、no-store等。max-age表示相对时间内的缓存，在这个相对时间内不会再去请求对应资源；no-cache表示不意味着不缓存，它的意思是在使用缓存资源之前，它必须经过服务器的检查；\r\nno-store表示不缓存。\r\n\r\n**协商缓存**：Last-modified 和 ETag，这两个类似，可以理解为文件标识。也可以将ETag（你选择的版本ID）或者Last-modified日期添加到响应首部中。客户端下次获取资源时，他会分别通过If-None-Match（与ETage对应）和If-Modified-Since（与Last-Mofied对应）两个请求首部将值发送给服务器。如果服务器发现两次值都是对等的，就是返回一个HTTP 304。它们之间的区别：ETag 只要资源变化，它就会改变；Last-modified 不识别秒单位里的修改。\r\n\r\n**如何使用** ————— 前端中保证HTML资源是最新的，设置如：max-age=300、ETag、Last-modified，当然也可考虑使用no-cache、ETag、Last-modified配合。而CSS和JS找资源已经被注入到HTML中，资源文件地址通常使用哈希值加入文件名中保证资源是最新，css和js文件可设置：max-age=31536000或last-modified 配合使用。\r\n\r\n---\r\n\r\n#### 5. 了解http2.0嘛？为什么说http2.0更好？\r\nhttp2.0基于二进制分帧层，http2.0可以在共享TCP连接的基础上同时发送请求和响应。在http1.x中，是通过文本的方式传输数据，基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。\r\n\r\n为了保证http不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，http2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中http1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。在传输中会共用一个TCP流（TCP连接中的一个虚拟通道，可以承载双向的消息），不至于重复连接。\r\n\r\n---\r\n\r\n参考：\r\n\r\n[书籍：HTTP权威指南](https://book.douban.com/subject/10746113/)\r\n\r\n[SSL/TLS协议运行机制的概述](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\r\n\r\n## 前端框架\r\n前端框架目前市面主流就是React和Vue，对于框架的使用和学习，前期建议多翻翻文档，中期根据自己在使用过程中遇到的问题学习，后期就可以考虑翻源码了。由于工作原因，我对react了解更多，所以分享主要就是React。\r\nReact和Vue作为前端框架在本质上做的是相同的事，在浏览器和开发操作之间加了一个中间层，来进项目的辅助管理和开发。\r\n### React框架\r\n#### 1. JSX本质是什么，它和JS的关系是什么？为什么使用JSX？\r\n`JSX`是类HTML的语法结构，实质是`JS`的语法扩张。它语法结构简洁，通俗易懂，对于研发效率和体验有大的提升。\r\n\r\n---\r\n\r\n#### 2. JSX背后的功能模块是什么，这个功能模块做了哪些事情？\r\n`JSX`通过`babel`语法转换之后，实际就是通过`React.createElement`函数来创建React元素。`createElement`接收三个参数`type`类型，`config`配置，`children`子元素。通过`createElement`就可创建出虚拟`DOM`对象。\r\n\r\n---\r\n\r\n#### 3. react16.3新旧生命周期，消失的旧生命周期有哪些？\r\n去掉`ComponentWillMount`和`CompoentWillReceiveProps`\r\n升级为`getDeicvedStateFromProps`，保证生命周期更加单一，更可控；去掉ComponentWillUpdate新增getSnapshotDeforeUpdate；\r\n\r\n---\r\n\r\n#### 4. React团队为什么要去掉旧的生命周期函数？\r\nReact16+引入`Fiber`架构，`Fiber`会将一个大的更新任务拆解为多个小任务，而且它是可中止，可恢复的。React16+生命周期被划分为`render`和`commit`两个阶段。`render`阶段在执行过程中允许被打断，而commit阶段操作涉及真实DOM渲染，是不可打断的。\r\n```\r\n`ComponentWillMount`、\r\n`ComponentWillUpdate`、\r\n`ComponentWillReceiveProps`\r\n```\r\n这些生命周期，它们都处于`render`阶段，而在`Fiber`架构中，`render`阶段会被打断，重复被执行。在这些生命周期可能习惯做的事情可能有：setState、异步请求、操作真实DOM等。而在Fiber异步渲染控制下，这些生命周期可能会导致非常严重的bug（例如在这些废弃的生命周期中调用支付接口）。\r\n\r\n---\r\n\r\n#### 5. React组件数据如何流动？实现数据通信的方案有哪些？\r\nreact是自上而下的单向组件数据流\r\n```\r\n1.父-子组件通过prop属性传递数据，子-父组件可通过函数；\r\n2.兄弟组件共享同一个父组件，达到兄弟组件通信；\r\n3.Context API实现全局通信；（目前还没试过）\r\n4.redux数据状态容，进行可预测的状态管理；\r\n5.发布/订阅模式实现任意组件通信；\r\n```\r\n\r\n---\r\n\r\n#### 6. 为什么是React Hooks？\r\n相对于`Class`组件，函数组件更加轻量，更加符合UI=render(data)特点。同时在Fiber架构的加持下，Hooks的实现不是问题。配合函数组件的发展，Hooks应运而生，从而是函数组件真正把数据和渲染绑定到一起。当然Hooks也还是存在部分不足：部分周期不存在；不能很好的消化“复杂”，组件的拆分和组织是一个大的挑战，不易把握。\r\n\r\n---\r\n\r\n#### 7. 为什么Hooks执行顺序如此重要？\r\nHooks本质是链表。例如 使用useText、useState创建state时，hook创建的state会以单链表形式保存，更新时，函数组件重新调用，hooks会依次遍历单链表，读取数据并更新，这一过程完全按照创建时的顺序来的。因此当更新时，位置一旦改变，执行顺序被替换，运行就会出现bug。\r\n\r\n---\r\n\r\n#### 8. 调和(协调)和diff的关系或区别？\r\n调和指的是虚拟DOM映射到真实DOM的过程。调和过程并不能和diff画等号。调和是“使一致”的过程，而diff是“找不同”的过程，它只是“使一致”过程中的一个环节。(当然常说的调和相关问题多半就是diff过程的)\r\n\r\n---\r\n\r\n#### 9. react的diff逻辑和思路？\r\n```\r\n1.因为时间复杂度的原因，diff过程只针对同层的节点作比较；\r\n2.对于同类型的组件，才有进一步对比的必要性；\r\n3.对于列表组件，通过key属性来维持节点的稳定性，避免总是生产新节点；\r\n```\r\n\r\n---\r\n\r\n#### 10. setState的工作流是怎么样的？\r\n非并发(`concurrent`)模式：`setState`会出现异步和同步的现象。在生命周期和合成事件中是同步，而在setTimeout、setInterval、DOM原生函数等函数中是同步的。那么这是为什么尼？在合成事件或生命周期执行时，批量更新的任务锁就被开启了，我们所做的setState操作会被放入到批量更新队列中，直到函数执行完，批量更新的任务锁才会被关闭。批量更新的任务锁是一个同步操作，而一旦你在setTimeout函数使用setState，此时setTimeout函数回调会被放入下一个宏任务执行，而当setState执行时，批量更新的任务锁时关闭的，它就不会放入到批量更新队列中，而是直接执行。\r\n\r\n并发(`concurrent`)模式：`setState`不会出现异步和同步的现象。因为存在时间切片，只要当前时间片没有结束，依旧可以将多个 setState 合并成一个，即使是在setTimeout中被调用。而对于超过当前时间片的操作，会通过`MessageChannel`放入到下一个宏任务中继续执行。（`MessageChannel`接收消息的时机比 Promise 所在的 microTask 要晚，但是早于 setTimeout）\r\n\r\n---\r\n\r\n#### 11. Stack Reconciler栈调和 有怎么样的局限性？\r\n浏览器中Js线程和渲染线程是互斥的。这两个线程不能穿插执行，必须串行。而当Js线程长时间占用主线程，那么渲染线程的更新就不得不长时间的等待，这时就会导致页面卡顿。\r\n\r\n`Stack Reconciler`栈调和是一个同步递归过程，虚拟DOM树diff算法遍历是深度优先遍历。由于它是同步的，不可在被打断。当处理结构复杂，体量庞大的虚拟DOM树时，`Stack Reconciler`时间会很长，以为这Js主线程长时间占用主线程，进而导致上述中说道的渲染卡顿/页面卡死。\r\n\r\n---\r\n\r\n#### 12. 说一说Fiber架构？\r\n特点：可中断、可恢复、存在优先级。\r\n```\r\n Scheduler ————> Reconciler ————> Renderer\r\n 更新优先级         找不同         渲染不同\r\n```\r\n\r\n在`Fiber`架构模式下，每个更新任务会被赋予一个优先级。当然有任务A进入调度器，这个任务优先级更高，而`Reconciler`中已有任务B在执行，那么，`Reconciler`会将任务B终止，更高优先级的任务A被推入`Reconciler`。当A任务完成之后，新一轮调度会将之前中断的任务B重新推入`Reconciler`，继续它的渲染之旅。\r\n\r\n```\r\nrender开始 ——————> (工作单元| 工作单元 | 工作单元) ——————> commit提交渲染\r\n```\r\n\r\n#### 13. ReactDOM.render调用栈的初始化阶段、render阶段\r\n初始化阶段：会创建root对象这个对象挂载`_internalRoot`属性，而`_internalRoot`也就是`FiberRoot`。`FiberRoot`的本质是一个`FiberRootNode`对象，其中包含current属性，current对象是一个FiberNode实例。current对象就是一个Fiber节点，并是Fiber树的头部节点；确定Fiber的优先级，结合优先级创建当前Fiber的update对象，并将其入队调度FiberRoot；接下来进入render阶段；(此时相当于只有一个Fiber头部节点)\r\n\r\nrender阶段：通过createWorkInProgress函数，创建rootFiber节点的副本workInProgress节点树(即current节点的副本节点)，他们通过alternate互相引用；接着会触发beginWork函数，进而实现对新的Fiber节点的创建。循环遍历，组件元素Fiber会不断被创建(每个元素节点对应一个Fiber节点)，直到创建到最后一个为止，此时Fiber树(单链表)基本完成；\r\n\r\n**重点**: 此时已经遍历到了单链表的最底部节点，然后会**由下自上**的依次生成真实DOM节点，同时被它的父组件副作用链，这个副作用链也是一个单链表，直遍历到根节点，此时的根节点上的副作用链就包含的全部的DOM更新。那么剩下的只需要拿到root下的副作用链更新即可了。\r\n\r\n---\r\n\r\n参考：\r\n\r\n[修言 深入浅出搞定 React](https://kaiwu.lagou.com/course/courseInfo.htm?courseId=510#/content)\r\n\r\n[React 架构的演变 - 从同步到异步](https://segmentfault.com/a/1190000024560483)\r\n\r\n[React 架构的演变 - 从递归到循环](https://segmentfault.com/a/1190000025177720)\r\n\r\n[React 架构的演变 - 更新机制](https://segmentfault.com/a/1190000037447202)\r\n\r\n[React 架构的演变 - Hooks 的实现](https://segmentfault.com/a/1190000037618578)\r\n\r\n## 性能优化\r\n可使用Chrome Lighthouse进行性能测评，根据测评结果也可以得出一些改进的点：\r\nreact框架层面可以做的优化方向核心点：**减少重新 render 的次数**；**减少计算的量，主要是减少重复计算**。有下列具体方案：\r\n```\r\n1. 拆分公共组件和业务组件，根据具体业务分离，降低组件颗粒度；\r\n2. shouldComponentUpdate中拦截非不要渲染；\r\n3. 对于简单的数据类型，可考虑使用React.PureComponent；\r\n4. 函数组件考虑使用React.meno，React.memo 与 React.PureComponent 非常相似；(版本React 16.6.0)\r\n5. React Hooks组件使用useCallback缓存函数，避免每次返回一个新的函数；(版本React v16.8)\r\n6. React Hooks组件使用useMemo缓存计算值；(版本React v16.8)\r\n```\r\n一个前端项目下通用的优化技巧：使用缓存、节流、压缩、按需加载、全局管理等方法或技巧。如下：\r\n```\r\n1. 避免频繁渲染更新，即使必须的情况下，也需要考虑是否使用节流函数；\r\n2. 对于长列表页面，考虑翻页加载、点击下一页或者虚拟长列表，避免数据量过大，渲染卡顿；\r\n3. 统一控制项目中的定时器函数，避免定时器偷跑；\r\n4. 拆分Js文件，可考虑按需加载，提升加载速度；\r\n5. 保证首屏必要数据渲染，可增加过渡图片，提升用户体验；\r\n6. 对于后端接口多余数据可考虑清洗数据，只保留必要数据；\r\n7. 避免过多的数据请求，可考虑使用数据缓存，提升用户体验；\r\n8. 对于大图考虑CDN图片加载，也可考虑图片懒加载；\r\n9. 避免使用过多css选择器嵌套；\r\n10. 代码文件gzip压缩等，服务器相关缓存配置；\r\n```\r\n\r\n**以上更多的是各种技巧和原则，如果要知道具体的标准，可以参考google为Web性能表现提供的文档**[**developers.google.cn/Web Performance**](https://developers.google.cn/web/fundamentals/performance/get-started)\r\n## 设计模式\r\n\r\n参考文章：\r\n[JavaScript设计模式](https://www.yuque.com/yopai/pp6bv5/mtu8xy)\r\n"
    },
    {
        "article_id": "7165675789885636616",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/214566d6d733445383a31f730da12afe~tplv-k3u1fbpfcp-watermark.image?",
        "title": "靓仔，说一下keep-alive缓存组件后怎么更新及原理？",
        "preview": "keep-alive怎么缓存组件的，是性能优化常见的一点，面试中我们怎么去回答比较好，缓存可用keep-alive，说一下它的作用与用法、使用细节，如缓存指定/排除、更新activated、原理阐述",
        "author": "Dignity_呱",
        "view_count": 3720,
        "collect_count": 178,
        "comment_count": 30,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c6084ef8bfcf6e37087a1455a905668~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\nhighlight: arduino-light\r\n\r\n---\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")*** \r\n\r\n\r\n## 前言\r\n\r\n- [常网IT](http://zhengzemin.cn:3000)戳我呀！\r\n- [常网IT源码](https://github.com/git-Dignity/vueAndTsAndKoa2)上线啦！\r\n- 本篇录入[吊打面试官](https://juejin.cn/column/7163273718213378055)专栏，希望能祝君拿下Offer一臂之力，各位看官感兴趣可移步🚶。\r\n- 这段时间面了很多家公司，被问到的题我感觉不重复不止100道，将会挑选觉得常见且有意义的题目进行分析及回答。\r\n- 有人说面试造火箭，进去拧螺丝；其实个人觉得问的问题是项目中涉及的点 || 热门的技术栈都是很好的面试体验，不要是旁门左道冷门的知识，实际上并不会用到的。\r\n- 请问Vue中的keep-alive怎么缓存组件的，缓存后又是怎么更新的，背后的原理你造吗？\r\n\r\n---\r\n\r\n> 这两天屁股感觉有点微疼，这不周六就去看了一下，说是痔疮，没想到也中招了。<br />\r\n> 说手术只会让你长的这块地方不会长，但会从别处长起，不会消失，只会转移。<br />\r\n> 都说十人九人会，我是没机会做那其中的一人了。<br />\r\n> 避免久坐，多摸鱼才能有好转。\r\n\r\n![未命名图片.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38bcdee335264d83aac03d97bd86612c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 若面试着急用，最后面有回答示例~\r\n\r\n\r\n## 一、问题剖析\r\n\r\nkeep-alive怎么缓存组件的，缓存后又是怎么更新的？\r\n\r\n其实这个问题在项目实战中很常见，因为`keep-alive`可以很好的缓存我们的组件，是性能优化常见的一点，面试中我们怎么去回答比较好✍，我个人觉得可以从以下四个方面去回答这个面试题。\r\n\r\n* 缓存可用keep-alive，说一下它的作用与用法\r\n* 使用细节，如缓存指定/排除、结合router和transition\r\n* 组件缓存后更新可以利用activated或者beforeRouteEnter\r\n* 原理阐述\r\n\r\n\r\n\r\n## 二、回\r\n\r\n### 第一\r\n\r\n\r\n开发中缓存组件使用keep-alive组件，keep-alive是vue内置组件，keep-alive包裹动态组件`component`时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\r\n\r\n用法如下：\r\n\r\n```javascript\r\n<keep-alive>\r\n  <component :is=\\\"view\\\"></component>\r\n</keep-alive>\r\n```\r\n\r\n### 第二\r\n\r\n结合属性`include`和`exclude`可以明确指定缓存哪些组件或排除缓存指定组件。vue3中结合vue-router时变化较大，之前是keep-alive包裹router-view，现在需要反过来用router-view包裹keep-alive。\r\n\r\n```javascript\r\n<router-view v-slot=\\\"{ Component }\\\">\r\n  <keep-alive>\r\n    <component :is=\\\"Component\\\"></component>\r\n  </keep-alive>\r\n</router-view>\r\n```\r\n\r\nkeep-alive的中缓存的时候还运用了`LRU`(Least Recently Used)算法。\r\n\r\n#### 面试官有一次问我，Vue中用到哪些算法？\r\n\r\n在这里就可以说：在keep-alive中，他底层实现用到LRU算法进行组件的缓存机制。\r\n\r\n> 我这里给大家分享一个我简历的一行：<br />\r\n> 使用LRU算法实现对应接口缓存，减少请求量。<br />\r\n> 大家如果感兴趣简历的，可以留言，后期看看出一篇简历中项目难点怎么写。\r\n\r\n`LRU`算法详细实现在文章的最后。（大家看完，可以运用到项目中、简历中💖）\r\n\r\n好啦，我们继续往下回答正题。\r\n\r\n\r\n### 第三\r\n\r\n缓存后如果要获取数据，解决方案可以有以下两种：\r\n\r\n#### beforeRouteEnter\r\n\r\n在有vue-router的项目，每次进入路由的时候，都会执行beforeRouteEnter。\r\n\r\n```javascript\r\nbeforeRouteEnter(to, from, next){\r\n  next(vm=>{\r\n    console.log(vm)\r\n    // 每次进入路由执行\r\n    vm.getData()  // 获取数据\r\n  })\r\n}\r\n```\r\n\r\n#### actived\r\n\r\n在keep-alive缓存的组件被激活的时候，都会执行actived钩子。\r\n\r\n```javascript\r\nactivated(){\r\n   this.getData() // 获取数据\r\n}\r\n```\r\n\r\n\r\n### 第四\r\n\r\nkeep-alive是一个通用组件，它内部定义了一个`map`，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的component组件对应组件的`vnode`，如果该组件在map中存在就直接返回它。由于component的is属性是个**响应式**数据，因此只要它变化，keep-alive的`render`函数就会重新执行。\r\n\r\n> 面试官心里想：哎哟，细狗，回答得真细，有点意思。\r\n\r\n\r\n## 追问：说说keep-alive的原理？\r\n\r\n小伙子还不错，基底还是可以的，让我继续看看你的深根扎实不。\r\n\r\n其实，上面回答之后，这个问题就告一段落了，但也有面试官抓着问题不放，继续追问下去。\r\n\r\n🙋那你说说keep-alive的原理是什么？\r\n\r\n面试官说：不把你难倒，我就对不起我刁难官的称号。\r\n\r\n\r\n![4.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec2f080a1ba41fbba79890a5aec0633~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 场景\r\n\r\n回答原理之前，我们先来看看一个场景。\r\n\r\n可能大家在平时的开发中会经常遇到这样的场景：有一个可以进行筛选的列表页List.vue，点击某一项时进入相应的详情页面，等到你从详情页返回List.vue时，发现列表页居然刷新了！刚刚的筛选条件都没了！！！\r\n\r\n> 双十一来了，第一就想到某宝，搜索宝贝列表，进入详情页，回退的操作。\r\n\r\n### keep-alive是什么？\r\n\r\n* keep-alive本身不会渲染出来，也不会出现在父组件链中\r\n\r\n* keep-alive包裹动态组件时，会缓存不活动的组件，而不是销毁它们\r\n\r\n* **缓存组件**，可提升性能（比如某宝的宝贝，进入详情页，每次都是同一个物品，那不需要请求接口，直接缓存组件，当然，如果不是同一个就调接口）\r\n\r\n\r\n### 怎么用？\r\n\r\n知己知彼百战百胜。\r\n\r\n知道keep-alive的用法，我们才能更好的去设计这个缓存组件的规则。\r\n\r\n#### 参数\r\n\r\nkeep-alive接收三个参数：\r\n\r\n* `include`：可传字符串、正则表达式、数组，名称匹配成功的组件会被缓存\r\n\r\n* `exclude`：可传字符串、正则表达式、数组，名称匹配成功的组件不会被缓存\r\n\r\n* `max`：可传数字，限制缓存组件的最大数量，超过max则按照LRU算法进行置换\r\n\r\ninclude和exclude，传数组情况居多。\r\n\r\n\r\n#### 生命周期\r\n\r\n生命周期有：`activated`激活、`deactivated`离开\r\n\r\n* activated： 页面第一次进入的时候\r\n\r\n钩子触发的顺序是created->mounted->activated\r\n\r\n* deactivated: 页面退出的时候会触发deactivated\r\n\r\n当再次前进或者后退的时候只触发activated。\r\n\r\n使用`keep-alive`会将数据保留在**内存中**，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来`created`钩子中获取数据的任务。\r\n\r\n\r\n那么，我们一般会在动态组件、路由组件去用到keep-alive组件。\r\n\r\n#### 动态组件\r\n\r\n```javascript\r\n<keep-alive :include=\\\"allowList\\\" :exclude=\\\"noAllowList\\\" :max=\\\"amount\\\"> \r\n    <component :is=\\\"currentComponent\\\"></component> \r\n</keep-alive>\r\n```\r\n\r\n#### 路由组件\r\n\r\n```javascript\r\n<keep-alive :include=\\\"allowList\\\" :exclude=\\\"noAllowList\\\" :max=\\\"amount\\\">\r\n    <router-view></router-view>\r\n</keep-alive>\r\n```\r\n\r\n### 底层原理\r\n\r\n暴风雨来临的前兆，总是很**安静**。\r\n\r\n突然就哼起：\r\n```\r\n给你的爱一直很安静，来交换你偶尔给的关心。  \r\n明明是三个人的电影，我却始终不能有姓名。\r\n```\r\n\r\n各位靓仔知道的，我不是真的想唱歌，主要是给下面沉重的知识活跃气氛。\r\n\r\n\r\n先说一下，keep-alive在各个生命周期里都做了啥吧。\r\n\r\n-   `created`：初始化一个`cache、keys`，cache用来存缓存组件的虚拟dom集合，keys用来存缓存组件的key集合。\r\n\r\n-   `mounted`：实时监听include、exclude这两个的变化，并执行相应操作。\r\n\r\n-   `destroyed`：删除掉所有缓存相关的东西。\r\n\r\n> 之前说了，keep-alive不会被渲染到页面上，所以abstract这个属性至关重要！\r\n\r\n#### keep-alive源码\r\n\r\n```\r\n// src/core/components/keep-alive.js\r\n\r\nexport default {\r\n  name: 'keep-alive',\r\n  abstract: true, // 判断此组件是否需要在渲染成真实DOM\r\n  props: {\r\n    include: patternTypes,\r\n    exclude: patternTypes,\r\n    max: [String, Number]\r\n  },\r\n  created() {\r\n    this.cache = Object.create(null) // 创建对象来存储  缓存虚拟dom\r\n    this.keys = [] // 创建数组来存储  缓存key\r\n  },\r\n  mounted() {\r\n    // 实时监听include、exclude的变动\r\n    this.$watch('include', val => {\r\n      pruneCache(this, name => matches(val, name))\r\n    })\r\n    this.$watch('exclude', val => {\r\n      pruneCache(this, name => !matches(val, name))\r\n    })\r\n  },\r\n  destroyed() {\r\n    for (const key in this.cache) { // 删除所有的缓存\r\n      pruneCacheEntry(this.cache, key, this.keys)\r\n    }\r\n  },\r\n  render() {\r\n      // 下面讲\r\n  }\r\n}\r\n```\r\n\r\n上段代码，结合前面分析的：keep-alive在各个生命周期里都做了啥。不难理解😁。\r\n\r\n\r\n#### pruneCacheEntry函数\r\n\r\n上面**keep-alive源码**中，在`destroyed`销毁生命周期中for循环执行pruneCacheEntry函数，看看该函数内部做了什么？\r\n\r\n```\r\n// src/core/components/keep-alive.js\r\n\r\nfunction pruneCacheEntry (\r\n  cache: VNodeCache,\r\n  key: string,\r\n  keys: Array<string>,\r\n  current?: VNode\r\n) {\r\n  const cached = cache[key]\r\n  if (cached && (!current || cached.tag !== current.tag)) {\r\n    cached.componentInstance.$destroy() // 执行组件的destory钩子函数\r\n  }\r\n  cache[key] = null  // 设为null\r\n  remove(keys, key) // 删除对应的元素\r\n}\r\n```\r\n\r\n-   1：遍历集合，执行所有缓存组件的$destroy方法\r\n-   2：将cache对应key的内容设置为null\r\n-   3：删除keys中对应的元素\r\n\r\n\r\n#### render函数\r\n\r\n上面**keep-alive源码**中，在最后保留了render空函数，我们在这里分析。\r\n\r\n以下称`include`为白名单，`exclude`为黑名单。\r\n\r\n`render`函数里主要做了这些事：\r\n\r\n-   第一步：获取到keep-alive包裹的第一个组件以及它的**组件名称**\r\n-   第二步：判断此**组件名称**是否能被**白名单、黑名单**匹配，如果**不能被白名单匹配 || 能被黑名单匹配**，则直接返回`VNode`，不往下执行，如果不符合，则往下执行**第三步**\r\n-   第三步：根据组件`ID、tag`生成缓存key，并在缓存集合中查找是否已缓存过此组件。如果已缓存过，直接取出缓存组件，并更新**缓存key**在keys中的位置（这是LRU算法的关键），如果没缓存过，则继续**第四步**\r\n-   第四步：分别在`cache、keys`中保存**此组件**以及他的**缓存key**，并检查数量是否超过`max`，超过则根据LRU算法进行删除\r\n-   第五步：将此组件实例的keepAlive属性设置为true，这很重要哦，下面会讲到的！\r\n\r\n\r\n**再详细分析：**\r\n\r\n在第二步的时候，只要**不能被白名单匹配**或者**能被黑名单匹配**满足其实一个，那我们就不对该组件进行缓存，直接返回他的`VNode`。\r\n\r\n白名单就是我们需要缓存的组件，黑名单就是我们不需要缓存的组件。\r\n\r\n认真看流程，可以理解的。（请再多看一遍）\r\n\r\n\r\n#### 渲染\r\n\r\n咱们先来看看Vue一个组件是怎么渲染的，咱们从render开始说：\r\n\r\n-   `render`：此函数会将组件转成`VNode`\r\n\r\n-   `patch`：此函数在初次渲染时会直接渲染根据拿到的`VNode`直接渲染成**真实DOM**，第二次渲染开始就会拿`VNode`会跟**旧VNode**对比，打补丁（diff算法对比发生在此阶段），然后渲染成**真实DOM**\r\n\r\nnew Vue阶段图解（可以看看这篇[面试官问我new Vue阶段做了什么？](https://juejin.cn/post/7164563220714225695)）：包括咱这里提到的渲染。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4fbb14490a43cc8ec3d32e0730506b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n`patch`阶段会涉及到`diff`算法（面试被问过几次），这个后期会出一篇，会尽量讲详细一点。\r\n\r\n> 不要打瞌睡，这是面试官想看你的内功。\r\n\r\n##### keep-alive本身渲染\r\n\r\n刚刚说了，keep-alive自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的`abstract`的属性值，如果是true的话，就跳过该实例，该实例也不会出现在父级链上。\r\n\r\n```\r\n// src/core/instance/lifecycle.js\r\n\r\nexport function initLifecycle (vm: Component) {\r\n  const options = vm.$options\r\n  // 找到第一个非abstract的父组件实例\r\n  let parent = options.parent\r\n  if (parent && !options.abstract) {\r\n    while (parent.$options.abstract && parent.$parent) {\r\n      parent = parent.$parent\r\n    }\r\n    parent.$children.push(vm)\r\n  }\r\n  vm.$parent = parent\r\n  // ...\r\n}\r\n```\r\n\r\n##### 包裹组件渲染\r\n\r\n咱们再来说说被keep-alive包裹着的组件是如何使用缓存的吧。\r\n\r\n刚刚说了**VNode -> 真实DOM**是发生在`patch`的阶段，而其实这也是要细分的：**VNode -> 实例化 -> _update -> 真实DOM**，而组件使用缓存的判断就发生在**实例化**这个阶段，而这个阶段调用的是`createComponent`函数，那我们就来说说这个函数吧：\r\n\r\n```javascript\r\n// src/core/vdom/patch.js\r\n\r\nfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\r\n  let i = vnode.data\r\n  if (isDef(i)) {\r\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\r\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\r\n      i(vnode, false /* hydrating */)\r\n    }\r\n\r\n    if (isDef(vnode.componentInstance)) {\r\n      initComponent(vnode, insertedVnodeQueue)\r\n      insert(parentElm, vnode.elm, refElm) // 将缓存的DOM（vnode.elm）插入父元素中\r\n      if (isTrue(isReactivated)) {\r\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\r\n      }\r\n      return true\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n-   在第一次加载被包裹组件时，因为keep-alive的`render`先于包裹组件加载之前执行，所以此时`vnode.componentInstance`的值是undefined，而keepAlive是true，则代码走到i(vnode, false /*hydrating */)就不往下走了\r\n\r\n-   再次访问包裹组件时，`vnode.componentInstance`的值就是已经缓存的组件实例，那么会执行`insert`(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的DOM插入到了父元素中。\r\n\r\n\r\n\r\n面试官摸了摸胡子，拍了拍我，明天来报道。\r\n\r\n![3.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25022a80acab41f58ed1050e34ea037c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n\r\n## LRU缓存函数\r\n\r\n[代码传送👉](https://github.com/git-Dignity/npm/blob/develop-1.1/src/Storage/LRUCache.js)\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4d47cf925634b8f80a0d8281711b8ae~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 后记\r\n\r\n我们再来总结一下回答：\r\n\r\n🙋🏻‍♂️我个人主要从四个方面回答\r\n\r\n* 缓存用keep-alive，它的作用与用法\r\n\r\n     * keep-alive包裹动态组件component时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 \r\n\r\n\r\n* 使用细节，例如缓存指定/排除、结合router和transition\r\n\r\n    * 结合属性include和exclude可以明确指定缓存哪些组件或排除缓存指定组件。vue3中结合vue-router时变化较大，之前是keep-alive包裹router-view，现在相反。\r\n\r\n* 组件缓存后更新可以利用activated或者beforeRouteEnter\r\n\r\n* 原理阐述\r\n\r\n    * 它内部定义了一个map，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的component组件对应组件的vnode，如果该组件在map中存在就直接返回它。由于component的is属性是个**响应式**数据，因此只要它变化，keep-alive的render函数就会重新执行。\r\n\r\n\r\n\r\n其实按照这个思路回答不算难，但可能面试官想让你回答背后的原理。（可反复多看几次）\r\n\r\n回答面试题的时候，尽量形成一个结构化的回答，大体，再细化，由浅而深。\r\n\r\n\r\n\r\n\r\n\r\n> 👍 如果对您有帮助，您的点赞是我前进的润滑剂。\r\n\r\n\r\n\r\n## 以往推荐\r\n\r\n [面试官问我new Vue阶段做了什么？](https://juejin.cn/post/7164563220714225695)\r\n\r\n [面试官问我watch和computed的区别以及选择？](https://juejin.cn/post/7163447762053251109)\r\n\r\n [前端仔，快把dist部署到Nginx上](https://juejin.cn/post/7022812216848023560)\r\n \r\n [多图详解，一次性啃懂原型链（上万字）](https://juejin.cn/post/7010942653915201543)\r\n\r\n [Vue-Cli3搭建组件库](https://juejin.cn/post/6890116253449453575)\r\n\r\n [Vue实现动态路由（和面试官吹项目亮点）](https://juejin.cn/post/6872344841293037582)\r\n\r\n [项目中你不知道的Axios骚操作（手写核心原理、兼容性）](https://juejin.cn/post/6863745313711226887)\r\n\r\n [VuePress搭建项目组件文档](https://juejin.cn/post/6854573219773415437)\r\n\r\n\r\n \r\n \r\n \r\n\r\n\r\n\r\n## 原文链接\r\n\r\n[https://juejin.cn/post/7165675789885636616/](https://juejin.cn/post/7165675789885636616/)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7187695113597321275",
        "snapshot": "",
        "title": "一个企业级的文件上传组件应该是什么样的",
        "preview": "前言 大家好这里是阳九,一个中途转行的野路子码农,热衷于研究和手写前端工具. 我的宗旨就是 万物皆可手写 新手创作不易,有问题欢迎指出和轻喷,谢谢 本文适合有一定node后端基础的前端同学,如果对后端",
        "author": "不月阳九",
        "view_count": 1447,
        "collect_count": 86,
        "comment_count": 16,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/c7fa744177836c117ccc5806fae5218f~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: hydrogen\r\nhighlight: agate\r\n---\r\n------\r\n## 前言\r\n大家好这里是阳九,一个中途转行的野路子码农,热衷于研究和手写前端工具.\r\n\r\n**我的宗旨就是 万物皆可手写**\r\n\r\n新手创作不易,有问题欢迎指出和轻喷,谢谢\r\n\r\n**本文适合有一定node后端基础的前端同学,如果对后端完全不了解请恶补前置知识。**\r\n\r\n废话不多说,直接进入正题。\r\n\r\n----\r\n\r\n我们来看一下,各个版本的文件上传组件大概都长什么样\r\n\r\n| 等级 | 功能 |\r\n| --- | --- |\r\n| 青铜-垃圾玩意 | 原生+axios.post |\r\n| 白银-体验升级 | 粘贴,拖拽,进度条 |\r\n| 黄金-功能升级 | 断点续传,秒传,类型判断 |\r\n| 铂金-速度升级 | web-worker,时间切片,抽样hash |\r\n| 钻石-网络升级 | 异步并发数控制,切片报错重试 |\r\n| 王者-精雕细琢 | 慢启动控制,碎片清理等等 |\r\n\r\n\r\n## 1.最简单的文件上传\r\n文件上传,我们需要获取文件对象,然后使用formData发送给后端接收即可\r\n\r\n```ts\r\nfunction upload(file){\r\n    let formData = new FormData();\r\n    formData.append('newFile', file);\r\n    \r\n    axios.post(\r\n    'http://localhost:8000/uploader/upload',\r\n    formData, \r\n    { headers: { 'Content-Type': 'multipart/form-data' } }\r\n    )\r\n}\r\n\r\n```\r\n\r\n## 2.拖拽+粘贴+样式优化\r\n懒得写,你们网上找找库吧,网上啥都有,或者直接组件库解决问题\r\n\r\n\r\n## 3.断点续传+秒传+进度条\r\n### 文件切片\r\n我们通过将一个文件分为多个小块,保存到数组中.逐个发送给后端,实现断点续传。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f657c18a82f42bea825d9d07ac09faa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n```js\r\n// 计算文件hash作为id\r\nconst { hash } = await calculateHashSample(file)\r\n//todo 生成文件分片列表 \r\n// 使用file.slice()将文件切片\r\nconst fileList = [];\r\nconst count = Math.ceil(file.size / globalProp.SIZE);\r\nconst partSize = file.size / count;\r\nlet cur = 0  // 记录当前切片的位置\r\nfor (let i = 0; i < count; i++) {\r\n\r\n    let item = { \r\n    chunk: file.slice(cur, cur + partSize), \r\n    filename: `${hash}_${i}`\r\n    };\r\n    \r\n    fileList.push(item);\r\n}\r\n```\r\n### 计算hash\r\n为了让后端知道,这个切片是某个文件的一部分,以便聚合成一个完整的文件。 我们需要计算完整file的唯一值(md5),作为切片的文件名。\r\n\r\n```js\r\n// 通过input的event获取到file\r\n<input type=\\\"file\\\" @change=\\\"getFile\\\">\r\n// 使用SparkMD5计算文件hash,读取文件为blob,计算hash\r\nlet fileReader = new FileReader();\r\n\r\nfileReader.onload = (e)=>{\r\nlet hexHash = SparkMD5.hash(e.target.result)\r\n; console.log(hexHash); \r\n};\r\n```\r\n\r\n### 断点续传+秒传(前端)\r\n我们此时有保存了100个文件切片的数组,遍历切片连续向后端发送axios.post请求即可\r\n设置一个开关,实现启动-暂停功能。\r\n\r\n\r\n**如果我们传了50份,关掉了浏览器怎么办？**\r\n\r\n此时我们需要后端配合,**在上传文件之前,先检查一下后端接收了多少文件**。\r\n\r\n**当然,如果发现后端已经上传过这个文件,直接显示上传完毕(秒传)**\r\n\r\n\r\n```js\r\n// 解构出已经上传的文件数组 文件是否已经上传完毕 \r\n// 通过文件hash和后缀查询当前文件有多少已经上传的部分\r\nconst {isFileUploaded, uploadedList} = await axios.get(\r\n`http://localhost:8000/uploader/count \r\n?hash=${hash}         \r\n&suffix=${fileSuffix}\r\n`)\r\n```\r\n\r\n### 断点续传+秒传(后端)\r\n至于后端的操作,就比较简单了\r\n\r\n1. 根据文件hash创建文件夹,保存文件切片\r\n2. 检查某文件的上传情况,通过接口返回给前端\r\n\r\n**例如以下文件切片文件夹**\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811ffd78d75549379b46ec569aa45b9f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n```ts\r\n//! --------通过hash查询服务器中已经存放了多少份文件(或者是否已经存在文件)------\r\nfunction checkChunks(hash, suffix) { \r\n//! 查看已经存在多少文件 获取已上传的indexList \r\nconst chunksPath = `${uploadChunksDir}${hash}`;\r\nconst chunksList = (fs.existsSync(chunksPath) && fs.readdirSync(chunksPath)) || []; \r\nconst indexList = chunksList.map((item, index) =>item.split('_')[1]) \r\n//! 通过查询文件hash+suffix 判断文件是否已经上传 \r\nconst filename = `${hash}${suffix}`\r\nconst fileList = (fs.existsSync(uploadFileDir) && fs.readdirSync(uploadFileDir)) || []; \r\nconst isFileUploaded = fileList.indexOf(filename) === -1 ? false : true \r\n\r\nconsole.log('已经上传的chunks', chunksList.length); \r\nconsole.log('文件是否存在', isFileUploaded); \r\n\r\nreturn { \r\n    code: 200,\r\n    data: { \r\n        count: chunksList.length, \r\n        uploadedList: indexList, \r\n        isFileUploaded: isFileUploaded\r\n        }\r\n      }\r\n    }\r\n```\r\n\r\n### 进度条\r\n  实时计算一下已经成功上传的片段不就行了,自行实现吧\r\n  \r\n\r\n## 4.抽样hash和webWorker\r\n因为上传前,我们需要计算文件的md5值,作为切片的id使用。\r\n\r\nmd5的计算是一个非常耗时的事情,如果文件过大,js会卡在计算md5这一步,造成页面长时间卡顿。\r\n\r\n我们这里提供三种思路进行优化\r\n\r\n\r\n### 抽样hash(md5)\r\n抽样hash是指,我们截取整个文件的一部分,计算hash,提升计算速度.\r\n\r\n**1. 我们将file解析为二进制buffer数据,**\r\n\r\n**2. 抽取文件头尾2mb, 中间的部分每隔2mb抽取2kb**\r\n\r\n**3. 将这些片段组合成新的buffer,进行md5计算。**\r\n    \r\n图解:\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba712deb18844433b23d7ee65b6458b2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n样例代码\r\n\r\n```js\r\n//! ---------------抽样md5计算-------------------\r\nfunction calculateHashSample(file) {\r\n\r\n    return new Promise((resolve) => {\r\n        //!转换文件类型（解析为BUFFER数据 用于计算md5）\r\n        const spark = new SparkMD5.ArrayBuffer();\r\n        const { size } = file;\r\n        const OFFSET = Math.floor(2 * 1024 * 1024); // 取样范围 2M\r\n        const reader = new FileReader();\r\n        let index = OFFSET;\r\n        // 头尾全取，中间抽2字节\r\n        const chunks = [file.slice(0, index)];\r\n        while (index < size) {\r\n            if (index + OFFSET > size) {\r\n                chunks.push(file.slice(index));\r\n            } else {\r\n                const CHUNK_OFFSET = 2;\r\n                chunks.push(file.slice(index, index + 2),\r\n                    file.slice(index + OFFSET - CHUNK_OFFSET, index + OFFSET));\r\n            }\r\n            index += OFFSET;\r\n        }\r\n        // 将抽样后的片段添加到spark\r\n        reader.onload = (event) => {\r\n            spark.append(event.target.result);\r\n            resolve({\r\n                hash: spark.end(),//Promise返回hash\r\n            });\r\n        }\r\n        reader.readAsArrayBuffer(new Blob(chunks));\r\n    });\r\n}\r\n```\r\n\r\n### webWorker\r\n \r\n 除了抽样hash,我们可以另外开启一个webWorker线程去专门计算md5.\r\n \r\n webWorker: **就是给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。**\r\n \r\n 具体使用方式可以参考MDN或者其他文章\r\n \r\n [使用 Web Workers - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\r\n \r\n [一文彻底学会使用web worker - 掘金 (juejin.cn)](https://juejin.cn/post/7139718200177983524)\r\n \r\n \r\n ### 时间切片\r\n \r\n 熟悉React时间切片的同学也可以去试一试,**不过个人认为这个方案没有以上两种好。**\r\n \r\n 不熟悉的同学可以自行掘金一下,文章还是很多的。\r\n \r\n 这里就不多做论述,只提供思路\r\n \r\n 时间切片也就是传说中的`requestIdleCallback,requestAnimationCallback`\r\n 这两个API了,或者高级一点自己通过messageChannel去封装。\r\n \r\n 切片计算hash,将多个短任务分布在每一帧里,减少页面卡顿。\r\n \r\n ## 5.文件类型判断\r\n \r\n - 简单一点,我们可以通过input标签的accept属性,或者截取文件名来判断类型\r\n \r\n```js\r\n<input id=\\\"file\\\" type=\\\"file\\\" accept=\\\"image/*\\\" />\r\n\r\nconst ext = file.name.substring(file.name.lastIndexOf('.') + 1);\r\n```\r\n\r\n当然这种限制可以简单的通过修改文件后缀名来突破,并不严谨。\r\n\r\n\r\n- 通过文件头判断文件类型\r\n\r\n**我们将文件转化为二进制blob,文件的前几个字节就表示了文件类型,我们读取进行判断即可。**\r\n\r\n**比如如下代码**\r\n```js\r\n// 判断是否为 .jpg \r\nasync function isJpg(file) {\r\n  // 截取前几个字节,转换为string\r\n  const res = await blobToString(file.slice(0, 3))\r\n  return res === 'FF D8 FF'\r\n}\r\n// 判断是否为 .png \r\nasync function isPng(file) {\r\n  const res = await blobToString(file.slice(0, 4))\r\n  return res === '89 50 4E 47'\r\n}\r\n// 判断是否为 .gif \r\nasync function isGif(file) {\r\n  const res = await blobToString(file.slice(0, 4))\r\n  return res === '47 49 46 38'\r\n}\r\n```\r\n\r\n**当然咱们有现成的库可以做这件事情,比如 file-type 这个库**\r\n\r\n[file-type - npm (npmjs.com)](https://www.npmjs.com/package/file-type)\r\n\r\n\r\n \r\n ## 6.异步并发数控制(重要)\r\n 我们需要将多个文件片段上传给后端,总不能一个个发送把？\r\n 我们这里使用TCP的并发+实现控制并发进行上传。\r\n \r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a5155ec0104cc1af81714d5ca0c0c2~tplv-k3u1fbpfcp-watermark.image?)\r\n \r\n 1. 首先我们将100个文件片段都封装为axios.post函数,存入任务池中\r\n 2. 创建一个并发池,同时执行并发池中的任务,发送片段\r\n 3. 设置计数器i,当i<并发数时,才能将任务推入并发池\r\n 4. 通过promise.race方法 最先执行完毕的请求会被返回 即可调用其.then方法 传入下一个请求(递归)\r\n 5. 当最后一个请求发送完毕  向后端发起请求 合并文件片段\r\n \r\n 图解\r\n \r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/169f8846c7144036ac1ad985b1c028f7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n代码\r\n\r\n```ts\r\n//! 传入请求列表  最大并发数  全部请求完毕后的回调\r\nfunction concurrentSendRequest(requestArr: any, max = 3, callback: any) {\r\n    let i = 0 // 执行任务计数器\r\n    let concurrentRequestArr: any[] = [] //并发请求列表\r\n\r\n    let toFetch: any = () => {\r\n        // (每次执行i+1) 如果i=arr.length 说明是最后一个任务  \r\n        // 返回一个resolve 作为最后的toFetch.then()执行\r\n        // (执行Promise.all() 全部任务执行完后执行回调函数  发起文件合并请求)\r\n        if (i === requestArr.length) {\r\n            return Promise.resolve()\r\n        }\r\n\r\n        //TODO 执行异步任务  并推入并发列表(计数器+1)\r\n        let it = requestArr[i++]()\r\n        concurrentRequestArr.push(it)\r\n\r\n        //TODO 任务执行后  从并发列表中删除\r\n        it.then(() => {\r\n            concurrentRequestArr.splice(concurrentRequestArr.indexOf(it), 1)\r\n        })\r\n\r\n        //todo 如果并发数达到最大数，则等其中一个异步任务完成再添加\r\n        let p = Promise.resolve()\r\n        if (concurrentRequestArr.length >= max) {\r\n            //! race方法 返回fetchArr中最快执行的任务结果 \r\n            p = Promise.race(concurrentRequestArr)\r\n        }\r\n        //todo race中最快完成的promise,在其.then递归toFetch函数\r\n        if (globalProp.stop) { return p.then(() => { console.log('停止发送') }) }\r\n        return p.then(() => toFetch())\r\n    }\r\n\r\n    // 最后一组任务全部执行完再执行回调函数(发起合并请求)(如果未合并且未暂停)\r\n    toFetch().then(() =>\r\n        Promise.all(concurrentRequestArr).then(() => {\r\n            if (!globalProp.stop && !globalProp.finished) { callback() }\r\n        })\r\n    )\r\n}\r\n```\r\n## 7.并发错误重试\r\n1. 使用catch捕获任务错误,上述axios.post任务执行失败后,重新把任务放到任务队列中\r\n2. 给每个任务对象设置一个tag,记录任务重试的次数\r\n3. 如果一个切片任务出错超过3次,直接reject。并且可以直接终止文件传输\r\n \r\n ## 8.慢启动控制\r\n 由于文件大小不一，我们每个切片的大小设置成固定的也有点略显笨拙，我们可以参考TCP协议的`慢启动`策略， \r\n \r\n . 设置一个初始大小，根据上传任务完成的时候，来**动态调整下一个切片的大小**， 确保文件切片的大小和当前网速匹配\r\n \r\n 1.  chunk中带上size值，不过进度条数量不确定了，修改createFileChunk， 请求加上时间统计\r\n1.  比如我们理想是30秒传递一个\r\n1.  初始大小定为1M，如果上传花了10秒，那下一个区块大小变成3M\r\n1.  如果上传花了60秒，那下一个区块大小变成500KB 以此类推\r\n\r\n ## 9.碎片清理\r\n \r\n如果用户上传文件到一半终止,并且以后也不传了,后端保存的文件片段也就没有用了。\r\n\r\n我们可以在node端设置一个定时任务`setInterval`,每隔一段时间检查并清理不需要的碎片文件\r\n \r\n 可以使用 `node-schedule` 来管理定时任务,比如每天检查一次目录,如果文件是一个月前的,那就直接删除把。\r\n \r\n\r\n**垃圾碎片文件**\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e54b727d84442a3aa273105dbf95374~tplv-k3u1fbpfcp-watermark.image?)\r\n \r\n \r\n ## 后记\r\n 以上就是一个完整的比较高级的文件上传组件的全部功能,希望各位有耐心看到这里的新手小伙伴能够融会贯通。每天进步一点点。\r\n"
    },
    {
        "article_id": "7161983096256987172",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b3bddbf9dad4581830958c68ebb4ecd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "实时通信Socket.io的使用",
        "preview": "最近在工作中，遇到了一个需求，需要和后台服务实时通信，获取各种设备的实时状态、以及对设备下发指令。后端这边选择了socket.io这个库，前端这边配合也只能使用这个，它的使用方式跟websocket很",
        "author": "故友",
        "view_count": 3130,
        "collect_count": 58,
        "comment_count": 4,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/33374c2e90a437ccf12a3921138fa10a~300x300.image",
        "category": "前端",
        "content": "最近在工作中，遇到了一个需求，需要和后台服务实时通信，获取各种设备的实时状态、以及对设备下发指令。后端这边选择了socket.io这个库，前端这边配合也只能使用这个，它的使用方式跟websocket很类似，为此简单记录一下socket.io的使用，希望帮助到有需要的人。\r\n\r\n\r\n# 1、什么是socket.io\r\n\r\nSocket.IO 是一个库，可以在客户端和服务器之间实现 **低延迟**, **双向** 和 **基于事件的** 通信。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e81e5369864540f2ac6e88ce9bdd864c~tplv-k3u1fbpfcp-watermark.image?)\r\n它建立在 [WebSocket](https://fr.wikipedia.org/wiki/WebSocket) 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。\r\n\r\n# 2、socket.io的使用\r\n\r\n**1、安装引入**\r\n\r\n```\r\nnpm install socket.io-client\r\nimport { io } from \\\"socket.io-client\\\";\r\n```\r\n\r\n**2、初始化**\r\n\r\n`const socket = io(\\\"https://server-domain.com\\\");`\r\n\r\n**3、使用**\r\n\r\nsocket链接成功以后，我们继续接下来的操作，了解各个事件的使用。\r\n```\r\n    socket.on(\\\"connect\\\", () => {\r\n        //监听连接是否成功\r\n        console.log(\\\"链接成功\\\");\r\n      });\r\n      socket.on(\\\"disconnect\\\", (reason) => {\r\n        //监听连接异常中断\r\n        console.log(\\\"中断\\\", reason);\r\n      });\r\n      \r\n      socket.on(\\\"message_event\\\", (data) => {\r\n      console.log(\\\"接收到的消息\\\", data);\r\n      })\r\n      \r\n     // 此处需要注意的是on是一个监听事件，监听的message_event是和后台约定好的事件名。\r\n     \r\n     前端主动断开链接\r\n     socket.close()或者 socket.disconnect()\r\n```\r\n\r\n**4、消息的发送**\r\n\r\n```\r\n    // 发送消息\r\n    sendMessage(msgType, msgContent) {\r\n      var jsonObject = { msgType: msgType, msgContent: msgContent };\r\n      socket.emit(\\\"send_event\\\", jsonObject);\r\n    },\r\n\r\n    //前端这边通过emit发送消息，这里的send_event也是跟后端人员约定好的事件。\r\n```\r\n\r\n# 3、客户端自带事件\r\n\r\n除了上面介绍的几个主要事件外、还有一些其他事件\r\n-   connect：连接成功\r\n-   connecting：正在连接\r\n-   disconnect：断开连接\r\n-   connect_failed：连接失败\r\n-   error：错误发生，并且无法被其他事件类型所处理\r\n-   reconnect_failed：重连失败\r\n-   reconnect：成功重连\r\n-   reconnecting：正在重连\r\n\r\n# 4、版本问题\r\n\r\nsocket.io分为客户端和服务器端，在选择使用的时候，一定要注意相关版本的选择要对应，要不然就会出现各种奇怪的问题，我当时做的时候没注意这一块，就耽误了一些时间。。。\r\n\r\n**相关版本兼容性如下表所示！**\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcbed3d0f09e4a0ba97d225775e8c83a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n至此结束，如果此文对你有帮助，请留下你的点赞和评论吧~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7186478493322969143",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ffde1c9c2a462ab3516c45e0e65970~tplv-k3u1fbpfcp-watermark.image?",
        "title": "《隐私计算白皮书（2022年）》概览",
        "preview": "2022年12月28日，由中国信息通信研究院、中国通信标准化协会指导，隐私计算联盟、中国通信标准化协会大数据技术标准推进委员会联合主办的“2022可信隐私计算峰会”在京召开。",
        "author": "京东云开发者",
        "view_count": 5374,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "开发工具",
        "content": "##### 作者： 京东科技 杨博\r\n\r\n## **导读**\r\n\r\n2022年12月28日，由中国信息通信研究院、中国通信标准化协会指导，隐私计算联盟、中国通信标准化协会大数据技术标准推进委员会联合主办的“2022可信隐私计算峰会”在京召开。会上发布了由 **“隐私计算联盟成员-京东科技”** 牵头主编的行业白皮书《隐私计算白皮书（2022年）》，主要涉及隐私保护计算（简称 隐私计算，下同）概况、技术分析、应用分析、行业分析、热点问题分析以及总结展望等多个方面，全面展了现行业成就及发展新态势，旨在为产业界应用隐私计算技术提供参考指导，推动隐私计算行业健康发展，在数据要素市场建设中发挥更大的价值。\r\n\r\n## **简介**\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2d56f2009624f26a0e6045e3dd7d4e5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n随着数字经济持续高速增长，数据流通已成为数据价值化的重要途径。而在满足数据融合需求的同时，如何增强数据要素安全防护是数据流通面临的关键问题。然而 **《中华人民共和国个人信息保护法》** （以下简称“个保法”）的出台，个人隐私保护问题迎来广泛探讨。经过业界广泛探讨，普遍认为单纯使用隐私计算技术并不能免除取得授权同意义务、达到绝对的匿名化或满足目的限制要求，它并不是为了帮助履行个保法的合规义务而设计的合规工具，而是对于增强数据处理安全性具有积极意义的技术手段。隐私计算可以通过加密、分片、不传递原始数据等方式大大降低数据泄露和被滥用的风险，是平衡数据利用与安全的重要路径。近几年来，我国持续重视隐私计算技术的发展，特别是今年，国内多部门密集出台了一系列政策文件，提出支持隐私计算技术探索，促进数据要素市场流通，隐私计算产业迎来良好发展环境。2022年1月，国务院办公厅印发的 **《要素市场化配置综合改革试点总体方案》** 中提出探索“原始数据不出域、数据可用不可见”的交易范式，探索建立数据用途和用量控制制度，实现数据使用“可控可计量”，作为释放要素价值的关键环节。2022年12月中共中央国务院 **《关于构建数据基础制度更好发挥数据要素作用的意见》** （数据二十条）作为基础性制度的发布，标志着我国数据要素市场将从无序进入有序规范的正式探索。其中明确指出“…… 强化统筹授权使用和管理，**推进互联互通，打破“数据孤岛”** 。鼓励公共数据在保护个人隐私和确保公共安全的前提下，按照 **“原始数据不出域、数据可用不可见”** 的要求，以模型、核验等产品和服务等形式向社会提供，对不承载个人信息和不影响公共安全的公共数据，推动按用途加大供给使用范围。”为隐私计算技术指明了发展方向和应用市场。\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa8cfd2f82e0419dbd07b25896f61a85~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n目前，隐私计算在金融、通信、政务、互联网、医疗等行业中的应用广泛。通过调研分析，隐私计算的应用主要覆盖两类场景：第一类中，传统信息安全技术已被普遍应用，但仍存在安全风险，隐私计算的应用可以进一步提升安全性，称为**隐私计算存量优化应用场景**；第二类中，传统信息安全技术无法满足应用需求，隐私计算则提供了新的机会，拓展了数据安全流通的应用场景，称为**隐私计算增量创新应用场景**。\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c24c0d8e0024addbc3d295d59203fb4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n隐私计算存量优化应用场景，主要有三个特点：一是原始数据保护要求较为严格；二是在保护原始数据安全前提下，通过共享数据ID提高计算效率；三是数据集规模较大。相比于传统的方法，存量优化场景解决方案能够加固对隐私数据的安全保护，同时提升关键的业务指标。\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f610ce479c340d6ac5fa4a71bd34b20~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n隐私计算增量创新应用场景拓展了数据安全流通的应用场景。该类场景对原始数据的保护更为严格；在保护原始数据安全同时具有特殊的要求，如需要在保护数据ID条件下完成特定任务等。通过隐私计算技术能够满足传统数据流通技术无法支持的场景需求。两个案例表明增量创新场景能够完成特定安全要求下的数据流通任务，同时提升业务指标和计算效率。\r\n\r\n## **展望**\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b519fafe15a41a79e3825b2b5b5d158~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n隐私计算作为数据流通的重要创新前沿技术，近几年来在技术、应用和行业层面上都得到了快速发展，下一步应在性能提升、安全分级、互联互通等方面重点突破。在未来，随着隐私技术产品的技术能力和应用模式越发成熟，隐私计算将有助于构建数据流通的基础设施，在保证安全的前提下有效持续释放数据要素价值，促进数字经济高质量发展。\r\n\r\n﻿\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c3648bd76e34796ac4598d28160aaeb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n﻿﻿  \r\n\r\n\r\n京东万象+隐私计算平台致力于应用技术持续改进数据要素流通应用产品和服务的质量，坚持数据开发利用和有效保护两者并重，秉持客户利益为先的商业准则，致力于成为业界一流的数据要素流通技术服务商，提高数据要素交易效率与价值，为数据供需双方提供数据产品开发、发布和数据资产的合规化、增值化服务，为实现数据要素在数据安全和隐私保护基础上有序流通添砖加瓦。"
    },
    {
        "article_id": "7147184835377758238",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a08b4c45fc440bc8ac3999447dfa7ec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "小白也能看懂的 Nuxt.js 入坑指南",
        "preview": "Nuxt 的出现让一些曾经因繁琐的配置而放弃服务端渲染的小伙伴跃跃欲试。本专栏从 0 到 1带大家入门 Nuxt.js，作者尝试从初学者的角度来和大家同步学习。",
        "author": "CatWatermelon",
        "view_count": 4184,
        "collect_count": 53,
        "comment_count": 16,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/c4cc67b8f834d8ffbd017a458ab83298~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: scrolls-light\r\n---\r\n我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第4篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")\r\n\r\n# 关于 Nuxt.js\r\n\r\n2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 **Next.js** ，一个 React 的服务端渲染应用框架。几小时后，与 **Next.js** 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：**Nuxt.js**。\r\n\r\n# Nuxt.js 是什么？\r\n\r\n`Nuxt.js` 是一个 **基于 Vue.js** 的通用应用框架。\r\n\r\n通过对客户端/服务端基础架构的抽象组织，`Nuxt.js` 主要关注的是应用的 **UI 渲染** 。\r\n\r\nNuxt.js 预设了利用 Vue.js 开发 **服务端渲染** 的应用所需要的各种配置（在 Nuxt 之前大多 Vue 项目的 SSR 解决方案是 **vue-server-renderer** ，需要做很多工作）。\r\n\r\n作为框架，Nuxt.js 为 `客户端/服务端` 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。\r\n\r\n# 通过 SSR 应用和 SPA 应用有什么不同\r\n\r\n首先，我们来了解两个概念：客户端渲染（CSR）和服务端渲染（SSR）。\r\n\r\n## 客户端渲染 CSR\r\n\r\n![捕获.PNG](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9db0f848dc94ad6b35497a60828eb1c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从图中可以看到，用户打开一个链接时，浏览器向 **Web 服务器**（通常是 nginx）请求对应的资源，请求到之后，浏览器会去解析 HTML，下载对应的资源（CSS、JS等），对于 Vue 来说，接收到的 HTML 一般就是个 **只有根节点的容器** ，真正的内容需要解析运行 js 脚本才能渲染出来。（需要额外的向接口服务器请求数据，最终的页面才是完整的）\r\n\r\n我们可以发现，HTML 最终是在客户端进行“组装”，然后才呈现给用户的。\r\n\r\n## 服务端渲染 SSR\r\n\r\n![捕获.PNG](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22cd865d1eb34d05baa88b243fc40b46~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从图中可以看到，用户打开一个链接时，浏览器向 Nuxt 应用的服务器请求对应的资源，从浏览器的角度来看，最终响应的 HTML 文件是“完整”的。而 Nuxt 应用的服务器接手了“拼接”的过程。\r\n\r\n## SSR 的优点\r\n\r\n以上就是 CSR 和 SSR 的区别，那么我们为什么要使用 SSR 呢？\r\n\r\n我们或多或少都听过 Vue 写的 SPA 应用 SEO 不太好，为啥不好呢？实际上我们去搜索引擎搜一个问题时，搜索引擎会去“爬取”所有相关的内容，然后对内容进行排序，而爬虫爬取的是 HTML，我们之前说过，SPA 应用服务器响应的一般是只有根节点的容器，里面的内容在完成数据填充后才有，爬虫爬不到东西，自然不会优先显示你的网页，而通过 SSR 响应的 HTML 是 **完整的** ，很 **利于爬虫的采集**。\r\n\r\n除此之外，由于 SSR 请求返回的 HTML 是完整的，我们无需发起别的接口请求，因此 **首屏渲染** 会比 CSR 快上许多。\r\n\r\n## 应用\r\n\r\n那么 SSR 什么时候该用呢？\r\n\r\n首先应用如果比较注重 **流量** 的，推荐使用 SSR，比如 **博客、论坛、官网** 等，流量就是命脉。\r\n\r\n像管理后台等 B 端网站，一般是没有必要使用服务端渲染的。\r\n\r\n# 创建一个 Nuxt 应用\r\n\r\n`Nuxt.js` 的团队专门做了一个脚手架，来方便我们快速启动一个 `nuxt` 项目。由于 `Nuxt.js` 在 `node` 之上，所以我们首先要确保 `node` 环境已经安装好。\r\n\r\n安装好后，我们开始使用提供的命令来创建脚手架。\r\n\r\n首先，`win + r` 输入 `cmd` 打开终端，然后开始创建我们的 `Nuxt` 项目，相关命令如下：\r\n\r\n```js\r\nnpx create-nuxt-app <项目名>\r\n```\r\n\r\n创建项目的时候，脚手架会询问我们 `Server` 用的框架、是否使用 `lint` 以及 `css` 预处理语言等问题，我们按需选择就好了。\r\n\r\n需要注意的是，如果我们需要创建的是一个服务端渲染的应用，那么在 `Nuxt` 模式的选择中，我们应该选择  `Universal` 而不是 `SPA`。\r\n\r\n接下来我们进入到项目中。\r\n\r\n```js\r\ncd <project-name>\r\n```\r\n\r\n试试启动项目：\r\n\r\n```js\r\nnpm run dev\r\n```\r\n\r\n默认的端口是 `3000`，不出意外我们打开 `3000` 端口可以看到应用已经启动了。\r\n\r\n\r\n![捕获.PNG](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da8077fa35534ccd9b835f47881f64f4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 注意：Nuxt.js 会监听 `pages` 目录中的文件更改，因此在添加新页面时无需重新启动应用程序。\r\n\r\n至此，一个简单的 Nuxt 应用就成功启动啦。\r\n\r\n# 参考\r\n\r\n- [2022年的CSR和SSR](https://juejin.cn/post/7094664016575856648#heading-3)\r\n- [关于 Nuxt.js - NuxtJS](https://www.nuxtjs.cn/guide)\r\n"
    },
    {
        "article_id": "7186524005371740215",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9705c8dc7a469c8055052beef2d327~tplv-k3u1fbpfcp-watermark.image?",
        "title": "加速几十倍 git clone 速度的 --depth 1，它的后遗症怎么解决？",
        "preview": "我们经常会用 git clone 来下载项目，但遇到大项目的时候，clone 就很慢，比如 react： 要等很久。 当然，还有更慢的项目。 这类项目可以通过 --depth 1 来加速： 这速度快了",
        "author": "zxg_神说要有光",
        "view_count": 3666,
        "collect_count": 54,
        "comment_count": 10,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e9e751e2b32fb8afbbf559a296ccbf2~300x300.image",
        "category": "前端",
        "content": "我们经常会用 git clone 来下载项目，但遇到大项目的时候，clone 就很慢，比如 react：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb24751d69c4f3f8f80d4da75f89ccc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n要等很久。\r\n\r\n当然，还有更慢的项目。\r\n\r\n这类项目可以通过 --depth 1 来加速：\r\n\r\n```\r\ngit clone --depth 1 https://github.com/facebook/react\r\n```\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ea7a1540e24ec5964762d1ac3cc667~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这速度快了有几十倍吧！越大的项目加速效果越明显。\r\n\r\n原因就是下载的内容更少了。\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5470f3e619ef466886741c6855074efa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e664ce773d44539a510902c07831dd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n那这样代码还是全的么？\r\n\r\n当然，代码是最新的完整代码。\r\n\r\n那为啥下载的内容少了呢？少了哪一部分呢？\r\n\r\n很容易想到，就是历史 commit。\r\n\r\n这里要涉及一点 git 的实现原理了：\r\n\r\ngit 中文件是通过 object 存储不同数据的：\r\n\r\n-   blob 对象存储文件内容\r\n-   tree 对象存储文件路径\r\n-   commit 对象存储 commit 信息，关联多个 tree\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91c08ab2d0ec40b7abd654b70f53a822~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后 HEAD、branch、tag 等是指向具体 commit 的指针，可以在 .git/refs 下看到\r\n\r\n所以说，每个版本的代码都是从 commit 对象作为入口关联起来的。\r\n\r\n指定了 depth 1 的时候，就是只保留了最新的入口，历史入口就没下载了。\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be6434abc7294ed2b94ac15483484a43~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样自然快很多，代码也是完整的。\r\n\r\n但这么好的事情也是有代价的，它有一些后遗症。\r\n\r\n最容易想到的就是切不到历史 commit。\r\n\r\n正常下载的项目的 git log 是这样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21896353d42c4fcb9b28a2e94055525b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n你可以 git reset 切到任意 commit：\r\n\r\n比如：\r\n\r\n```\r\ngit reset --hard 4dda96a40\r\n```\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d39a14c4b98542ea9ae0a4dc67afc620~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但是 depth 1 下载的项目就不可以，因为本地没有这个 commit 可以切：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f46bfa9c8fe4640ae4245e601149e8b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121288da7d454312ba5cefc2543238cf~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n你再 git pull 的时候，也下载不了历史 commit 的代码：\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14696b8e5655456c9e3012b35f06e665~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n就很尴尬。\r\n\r\ngit 团队自然也想到了这点，于是提供了一个 unshallow 的选项：\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9361c1f6c91c4bbcbcd4fe9d9cd46243~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n加上 --unshallow 再 pull 的时候也会同时拉取历史 commit。（默认没开这个是为了性能）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f008fa0c0f184296be18730d346e3a54~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n你完全可以用 depth 1 下载的项目来开发，正常的 pull、push 都没问题，因为都是基于最新 commit 创建的更新的 commit。\r\n\r\n当你有一天需要历史 commit 的时候再 pull --unshallow 也不迟。\r\n\r\n这样下载项目快，后面也能恢复成完整版代码库，何乐而不为呢？\r\n\r\n但 depth 1 还有一个问题，就是切换不了其他 branch。\r\n\r\n正常项目是这样的：\r\n\r\ngit branch -r 可以查看远程分支：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92a207c4bb454262a14f4b7241a60ac4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\ngit branch -a 可以查看本地和远程的分支：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e3a276364b84646b164988b3cb09fc6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但你 depth 1 下载的项目是没有的：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5665f162b3ca4090909ada6be9665b45~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n只有一个 main。\r\n\r\n有的同学说，fetch 一下就好了呀。\r\n\r\n太天真了。\r\n\r\ngit fetch 的作用是把远程分支的新 commit 下载到本地。\r\n\r\n默认下载所有远程分支的新 commit。\r\n\r\n也可以单独指定某个分支：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17d162fc8da34dd78d711138c6382ec4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但你会发现 git fetch 了这个分支的代码，也不能看到和切换到它： \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf580ec9bbe4b4181ec379e7edd2ed0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这是因为有个 remote.origin.fetch 的配置。\r\n\r\n正常下载的项目的 fetch 配置是这样的：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b802f9b9dadc4b9da17f43fd85964829~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n把 remote 的所有分支下载到本地的所有分支。\r\n\r\n而 depth 1 下载的项目的 fetch 配置是这样的：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/406f9cc9e9e94f6c9a317d8d478106b9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nfetch 只会下载 main 分支。\r\n\r\n就算你手动 fetch 了其他分支的代码也不会处理。\r\n\r\n所以我们可以改下这个配置，我们先指定一个 0.3-stable 分支看看：\r\n\r\n```\r\ngit config remote.origin.fetch \\\"+refs/heads/0.3-stable:refs/remotes/origin/0.3-stable\\\"\r\n```\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6022ea4685ee4401b3d954e44f35d61c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看到 pull 的时候就拉取到新分支了，而且 branch -r 可以看到这个分支了。\r\n\r\n这里 pull 或者 fetch 都行。pull 就相当于 git fetch + git merge，把代码下载下来，然后 merge 到本地。fetch 是 pull 的第一步：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e4bcd8e965f42cabb4b04418ebb20d5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n接下来再改为 * 试试：\r\n\r\n```\r\ngit config remote.origin.fetch \\\"+refs/heads/*:refs/remotes/origin/*\\\"\r\n```\r\n再执行 git fetch 或者 git pull，就会拉取全部分支的 commit：\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7837d086e6514fc2b9dafc461f64cea4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这时候就可以切换到这些分支了：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/662aa6f57fc547c9ad2791dc57b3da6f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55bde8959c9b440880fbba69845e4fb4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样就解决了 --depth 1 的第二个问题。\r\n\r\n\r\n## 总结\r\n\r\n当 git clone 下载大项目的时候，加个 --depth 1 可以提速几十倍。\r\n\r\n下载下来的项目也可以正常的 pull 和 push。\r\n\r\n这是因为 git 是通过 commit、tree、blob 的对象存储的，每个 commit 是关联这些对象的入口。\r\n\r\ndepth 1 只会下载最后一个 commit 关联的 object，下载内容更少，所以速度快很多。\r\n\r\n但这种方式有两个问题：\r\n\r\n- 切换不到历史 commit\r\n- 切换不到别的分支\r\n\r\n没有历史 commit 可以通过 git pull --unshallow 解决。\r\n\r\n切不到别的分支是因为 fetch 配置导致的，配置成 +refs/heads/\\\\*:refs/remotes/origin/\\\\* 也就可以了，也就是拉取远程所有分支代码到本地。\r\n\r\n这样再 fetch 和 pull 就会拉取所有分支的新 commit，也可以正常的切分支。\r\n\r\n--depth 1 在下载大项目的时候，或者 build 时下载代码的时候，都很有意义。它提高下载速度导致的俩后遗症也都可以解决。\r\n\r\n\r\n"
    },
    {
        "article_id": "7187703065598754876",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d24ae0710a84e2294d2a4f05e208967~tplv-k3u1fbpfcp-watermark.image?",
        "title": "iOS底层二刷第一课alloc的流程分析",
        "preview": "1.准备工作 我的运行环境 macOS 13.1 M1 芯片 Xcode 14.0.1 首先准备好一份源码，链接地址：https://github.com/LGCooci/KCObjc4_debug ",
        "author": "牛牛大王奥利给",
        "view_count": 3063,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/394e6be0081de5ef291e9e2d7c66c064~300x300.image",
        "category": "iOS",
        "content": "---\r\ntheme: juejin\r\nhighlight: xcode\r\n---\r\n### 1.准备工作\r\n- 我的运行环境\r\n    - macOS 13.1\r\n    - M1 芯片\r\n    - Xcode 14.0.1\r\n- 首先准备好一份源码，链接地址：https://github.com/LGCooci/KCObjc4_debug ，我使用的是 `objc4-866.9`，初次运行报错如下：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/525e0e4d2725479f972c18e7d76e9a8c~tplv-k3u1fbpfcp-watermark.image?)\r\n`__dyld_get_dlopen_image_header ` 和`__dyld_objc_register_callbacks`报错。    \r\n**解决办法**：分别搜一下这两个方法改成如下\r\n\r\n![dyld_get_dlopen_image_header](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb8d1a172264f5ea8e51609f2096871~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![dyld_objc_register_callbacks](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ff733709644081874deffe481f0cd5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nclean一下，再运行就成功了。不过偶尔也报错，但是再clean一次就可以了。\r\n\r\n### 2.从alloc入手\r\n\r\n```\r\n LGPerson *p = [LGPerson alloc];\r\n LGPerson * p1 = [p init];\r\n LGPerson * p2 = [p init];\r\n NSLog(@\\\"对象p：%@，p的指针：%p\\\",p,&p);\r\n NSLog(@\\\"对象p1：%@，p1的指针：%p\\\",p1,&p1);\r\n NSLog(@\\\"对象p2：%@，p2的指针：%p\\\",p2,&p2);\r\n```\r\n\r\n输出：\r\n```\r\n对象p ：<LGPerson: 0x600000c0c000>，p的指针： 0x30410b230\r\n对象p1：<LGPerson: 0x600000c0c000>，p1的指针：0x30410b220\r\n对象p2：<LGPerson: 0x600000c0c000>，p2的指针：0x30410b228\r\n```\r\n**从输出来看p，p1，p2指向的是一个对象，也就是同一片内存，但是p，p1，p2本身是不同的。**\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee49dee43d534950ba15152ef55eac6a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nalloc方法开辟了一块内存空间，下面的init方法相当于又创建了几个指针来指向这块内存。但是他们具体做了什么操作，需要进一步的探究源码，一探究竟。\r\n\r\n### 3.探究源码的方式\r\n**跟着`KC`学习到了探究源码的三种方式。**\r\n\r\n- 使用`Control+Step Into`进行调试\r\n- 通过汇编查看调用流程\r\n- 通过已知符号来探索具体调用\r\n\r\n通过这三种方式都可以找到最终的`libobjc.A.dylib-objc_alloc`\r\n\r\n### 4.alloc的具体探究\r\n打开我们准备好的`objc4-866.9`，然后运行代码跟着流程和调用来看看一个alloc下面到底藏了多少方法。\r\n#### 4.1 alloc的实现方法\r\n跟着源码，点击进入到alloc的实现：\r\n```\r\n+ (id)alloc {\r\n    return _objc_rootAlloc(self);\r\n}\r\n\r\nid\r\n_objc_rootAlloc(Class cls)\r\n{\r\n    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);\r\n}\r\n```\r\n调用流程`alloc`->`_objc_rootAlloc`->`callAlloc`，而`callAlloc`的实现就相对比较复杂了。\r\n```\r\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate\r\n\r\n// shortcutting optimizations.\r\n\r\nstatic ALWAYS_INLINE id\r\n\r\ncallAlloc(Class cls, bool checkNil, bool allocWithZone=false)\r\n\r\n{\r\n\r\n    if (slowpath(checkNil && !cls)) return nil;\r\n\r\n    if (fastpath(!cls->ISA()->hasCustomAWZ())) {\r\n\r\n        return _objc_rootAllocWithZone(cls, nil);\r\n\r\n    }\r\n\r\n\r\n    // No shortcuts available.\r\n\r\n    if (allocWithZone) {\r\n\r\n        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);\r\n\r\n    }\r\n    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));\r\n}\r\n```\r\n这里出现了几个比较重要的判断和方法：\r\n\r\n1、`slowpath`和`fastpath`\r\n\r\n这是宏定义\r\n```\r\n// 表示x的值为假的可能性更大\r\n#define slowpath(x) (__builtin_expect(bool(x), 0))\r\n\r\n// 表示x的值为真的可能性更大\r\n#define fastpath(x) (__builtin_expect(bool(x), 1))\r\n```\r\n__builtin_expect是GCC提供给程序员使用，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。\r\n\r\n`if (slowpath(checkNil && !cls))`的意思就是`cls`大概率是有值的，告诉编译器编译时优化掉这个部分，也就是nil这个部分几乎不会走，那么就直接来到了判断` if (fastpath(!cls->ISA()->hasCustomAWZ()))`的部分。\r\n\r\n2、`hasCustomAWZ`\r\n\r\n它的实现如下：\r\n```\r\nbool hasCustomAWZ() const {\r\n    return !cache.getBit(FAST_CACHE_HAS_DEFAULT_AWZ);\r\n}\r\n```\r\n而`FAST_CACHE_HAS_DEFAULT_AWZ`的描述是：\r\n```\r\n// class or superclass has default alloc/allocWithZone: implementation\r\n// Note this is is stored in the metaclass.\r\n\r\n#define FAST_CACHE_HAS_DEFAULT_AWZ  (1<<14)\r\n```\r\n它是判断这个类或者它的父类有没有实现`allocWithZone`的，而方法`hasCustomAWZ`大概率全称是`hasCustomAllocWithZone`后面`AllocWithZone`缩写成了`AWZ`😂。\r\n\r\n而类本身是有懒加载的概念的，第一次给这个类发送消息之前，该类是没有加载的，所以收到alloc消息的时候，那么allocWithZone是没有默认实现的，所以`hasCustomAWZ`返回`false`，会走流程`_objc_rootAllocWithZone`\r\n\r\n第一次进到该方法：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a501dfc4e84be8beaad92928cf3808~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n而方法`_objc_rootAllocWithZone`的具体实现接着看下面。\r\n\r\n3、`_objc_rootAllocWithZone`\r\n```\r\nid\r\n_objc_rootAllocWithZone(Class cls, objc_zone_t zone __unused)\r\n{\r\n    // allocWithZone under __OBJC2__ ignores the zone parameter\r\n    return _class_createInstanceFromZone(cls, 0, nil,\r\n                                         OBJECT_CONSTRUCT_CALL_BADALLOC);\r\n}\r\n```\r\n调用了`_class_createInstanceFromZone`，这个方法就内容挺长的还挺多的，下面来着重的看一下。\r\n\r\n#### 4.2 class_createInstanceFromZone方法开辟空间\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9a4376a15044ef1b05a1a167e214ec2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- **hasCxxCtor()** 和 **hasCxxDtor()**\r\n\r\n`hasCxxCtor`和`hasCxxDtor`是用来处理C++成员变量的构造和析构。\r\n\r\n`hasCxxCtor`是判断当前class或者superclass是否有.cxx_construct的实现；\r\n\r\n`hasCxxDtor`是判断当前class或者superclass是否有.cxx_destruct的实现。\r\n\r\n```\r\n// class or superclass has .cxx_construct/.cxx_destruct implementation\r\n// FAST_CACHE_HAS_CXX_DTOR is chosen to alias with isa_t::has_cxx_dtor\r\n#define FAST_CACHE_HAS_CXX_CTOR       (1<<1)\r\n\r\nbool hasCxxCtor() {\r\n    ASSERT(isRealized());\r\n    return cache.getBit(FAST_CACHE_HAS_CXX_CTOR);\r\n}\r\n```\r\n- **instanceSize()**\r\n```\r\n//extraBytes 传进来是0\r\ninline size_t instanceSize(size_t extraBytes) const {\r\n\r\n    if(fastpath(cache.hasFastInstanceSize(extraBytes))) {\r\n        return cache.fastInstanceSize(extraBytes);\r\n    }\r\n    \r\n    size_t size = alignedInstanceSize() + extraBytes;\r\n    // CF requires all objects be at least 16 bytes.\r\n    //至少16个字节！！！！！！！！！！！！！！！！！！！！！\r\n    if(size < 16) size = 16;\r\n    return size;\r\n}\r\n\r\nuint32_t alignedInstanceSize() const {\r\n    return word_align(unalignedInstanceSize());\r\n}\r\n\r\nstatic inline uint32_t word_align(uint32_t x) {\r\n   return (x + WORD_MASK) & ~WORD_MASK;\r\n}\r\n\r\n#ifdef __LP64__\r\n#define WORD_SHIFT 3UL\r\n#define WORD_MASK 7UL\r\n#define WORD_BITS 64\r\n\r\n#else\r\n#define WORD_SHIFT 2UL\r\n#define WORD_MASK 3UL\r\n#define WORD_BITS 32\r\n#endif\r\n```\r\n在调用方法`instanceSize`传进来的参数`extraBytes`是0；\r\n`hasFastInstanceSize`在64位下才启用；\r\n\r\n`alignedInstanceSize`是对齐方式，根据代码可以看到64位下是8字节对齐，32位下是4字节对齐，计算方式是对`WORD_MASK`取反，然后进行与的操作。所以这个方法计算了需要开辟的空间大小。\r\n\r\n我们回到方法`_class_createInstanceFromZone`中，`zone`这个值传进来的是`nil`，所以下面走的方法是 **obj = (id)calloc(1, size);**\r\n而实际去开空间的操作是在`calloc`，它的具体实现在`libmalloc`中，它开辟了内存空间，并且返回了一个指向该内存地址的指针。\r\n\r\n#### 4.3 initInstanceIsa 将类和isa指针关联\r\n上面的`instanceSize`和`calloc`完成了空间的计算和开辟，接下来执行来到\r\n```\r\nif(!zone && fast) {\r\n        obj->initInstanceIsa(cls, hasCxxDtor);\r\n } else {\r\n\r\n    // Use raw pointer isa on the assumption that they might be\r\n    // doing something weird with the zone or RR.\r\n    obj->initIsa(cls);\r\n }\r\n```\r\nzone是nil，fast是是否可以创建Nonpointer的返回。会来到方法`initInstanceIsa`。\r\n```\r\ninline void\r\nobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)\r\n{\r\n    ASSERT(!cls->instancesRequireRawIsa());\r\n    ASSERT(hasCxxDtor == cls->hasCxxDtor());\r\n    initIsa(cls, true, hasCxxDtor);\r\n}\r\n```\r\n主要调用方法`initIsa`。\r\n\r\n- **initIsa**\r\n```\r\ninline void\r\n\r\nobjc_object::initIsa(Class cls, bool nonpointer, UNUSED_WITHOUT_INDEXED_ISA_AND_DTOR_BIT bool hasCxxDtor)\r\n{ \r\n    isa_t newisa(0);\r\n    // nonpointer:ture\r\n    if (!nonpointer) {\r\n        newisa.setClass(cls, this);\r\n    } else {\r\n        newisa.bits = ISA_MAGIC_VALUE;\r\n        newisa.setClass(cls, **this**);\r\n        newisa.extra_rc = 1;\r\n    }\r\n    isa() = newisa;\r\n}\r\n```\r\n从方法`initInstanceIsa`传进来的第二个参数`nonpointer`是`ture`，所以走流程 `else`。\r\n\r\n`SUPPORT_INDEXED_ISA`不同的架构下处理不同。64位下的直接走`else`的部分。走`setClass`。该方法关键代码：\r\n```\r\ninline void\r\nisa_t::setClass(Class newCls, UNUSED_WITHOUT_PTRAUTH objc_object *obj)\r\n{\r\n    shiftcls = (uintptr_t)newCls >> 3;\r\n}\r\n```\r\n该方法其实就是初始化一个`isa_t`然后绑定指向给cls。至于右移3位，因为是八字节对齐，指针后三位是无用的0，0与上任何都是0，估计是为了省内存减少消耗吧。\r\n\r\n### 5. alloc的流程图\r\n\r\n![未命名文件.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/133b10bdbb4a4a3e8b08b68f5f4b6467~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 6. init 和 new\r\n看过了上面alloc的流程，也简单看一下我们常用的init还有new。\r\n#### 6.1 init\r\n进行断点调试，我们找到方法`_objc_rootInit`\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae0a843f3c442db8b58324b12c342d1~tplv-k3u1fbpfcp-watermark.image?)\r\n它的实现：\r\n```\r\nid\r\n\r\n_objc_rootInit(id obj)\r\n{\r\n    // In practice, it will be hard to rely on this function.\r\n\r\n    // Many classes do not properly chain -init calls.\r\n    return obj;\r\n}\r\n```\r\n嗯，传进来啥，返回啥😂。\r\n\r\n#### 6.2 new\r\n同样的，new的实际实现方法是`objc_opt_new`。它的实现：\r\n```\r\nid\r\nobjc_opt_new(Class cls)\r\n{\r\n\r\n    if (fastpath(cls && !cls->ISA()->hasCustomCore())) {\r\n        return [callAlloc(cls, false/checkNil/) init];\r\n    }\r\n    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(new));\r\n}\r\n```\r\n关键代码是`[callAlloc(cls, false/checkNil/) init]`，实际上也是调用的 `[alloc init] `。\r\n\r\n### 7.总结\r\n**alloc的主要流程：**\r\n\r\n1. 类没有被加载进来时，也就是没有实现allocWithZone方法时，那么再发送一遍alloc消息，直到已经allocWithZone了，确保已经被加载进来。\r\n2. 通过instanceSize计算需要的空间。\r\n3. calloc开辟实际的空间。\r\n4. initInstanceIsa将class与isa进行关联。\r\n\r\n\r\n- init 本质返回传入的self对象\r\n- new 等价于alloc+init\r\n\r\n关于`(uintptr_t)newCls >> 3`，到底为啥还是有点模糊，只是猜测是节约内存，后面有新的发现再补充~\r\n"
    },
    {
        "article_id": "7189437538849783869",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dac130e8040d451a9a7d9a5331887679~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【综合笔试题】难度 2/5，简单且经典面试题",
        "preview": "题目描述 这是 LeetCode 上的 870. 优势洗牌 ，难度为 中等。 Tag : 「红黑树」、「哈希表」、「排序」、「双指针」、「贪心」 给定两个大小相等的数组 nums1 和 nums2，n",
        "author": "宫水三叶的刷题日记",
        "view_count": 587,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6452ebec1b08c50b94b69c91d4626bae~300x300.image",
        "category": "后端",
        "content": "## 题目描述\r\n\r\n这是 LeetCode 上的 **[870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/solution/by-ac_oier-i01s/)** ，难度为 **中等**。\r\n\r\nTag : 「红黑树」、「哈希表」、「排序」、「双指针」、「贪心」\r\n\r\n\r\n\r\n给定两个大小相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums` 的优势可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述。\r\n\r\n返回 `nums1` 的任意排列，使其相对于 `nums2` 的优势最大化。\r\n\r\n示例 1：\r\n```\r\n输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]\r\n\r\n输出：[2,11,7,15]\r\n```\r\n示例 2：\r\n```\r\n输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]\r\n\r\n输出：[24,32,8,12]\r\n```\r\n\r\n提示：\r\n* $1 <= nums1.length <= 10^5$\r\n* nums2.length = nums1.length\r\n* $0 <= nums1[i]$, $nums2[i] <= 10^9$\r\n\r\n## 数据结构\r\n\r\n显然，对于任意一个 $t = nums2[i]$ 而言，我们应当在候选集合中选择**比其大的最小数**，若不存在这样的数字，则选择候选集合中的**最小值**。\r\n\r\n同时，由于 $nums1$ 相同数会存在多个，我们还要对某个具体数字的可用次数进行记录。\r\n\r\n也就是我们总共涉及两类操作：\r\n\r\n1. 实时维护一个候选集合，该集合支持高效查询比某个数大的数值操作；\r\n2. 对候选集合中每个数值的可使用次数进行记录，当使用到了候选集合中的某个数后，要对其进行计数减一操作，若计数为 $0$，则将该数值从候选集合中移除。\r\n\r\n计数操作容易想到哈希表，而实时维护候选集合并高效查询可以使用基于红黑树的 `TreeSet` 数据结构。\r\n\r\nJava 代码：\r\n```Java\r\nclass Solution {\r\n    public int[] advantageCount(int[] nums1, int[] nums2) {\r\n        int n = nums1.length;\r\n        TreeSet<Integer> tset = new TreeSet<>();\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int x : nums1) {\r\n            map.put(x, map.getOrDefault(x, 0) + 1);\r\n            if (map.get(x) == 1) tset.add(x);\r\n        }\r\n        int[] ans = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            Integer cur = tset.ceiling(nums2[i] + 1);\r\n            if (cur == null) cur = tset.ceiling(-1);\r\n            ans[i] = cur;\r\n            map.put(cur, map.get(cur) - 1);\r\n            if (map.get(cur) == 0) tset.remove(cur);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\nPython 代码：\r\n```Python\r\nfrom sortedcontainers import SortedList\r\n\r\nclass Solution:\r\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\r\n        n = len(nums1)\r\n        cnts, tset = defaultdict(int), SortedList()\r\n        for i in range(n):\r\n            cnts[nums1[i]] += 1\r\n            if cnts[nums1[i]] == 1:\r\n                tset.add(nums1[i])\r\n        ans = [0] * n\r\n        for i in range(n):\r\n            t = nums2[i]\r\n            if (idx := tset.bisect_left(t + 1)) == len(tset):\r\n                idx = tset.bisect_left(-1)\r\n            ans[i] = tset[idx]\r\n            cnts[ans[i]] -= 1\r\n            if cnts[ans[i]] == 0:\r\n                tset.remove(ans[i])\r\n        return ans\r\n```\r\n* 时间复杂度：$O(n\\\\log{n})$\r\n* 空间复杂度：$O(n)$\r\n\r\n## 排序 + 双指针\r\n\r\n在解法一中，我们是从每个 $nums2[i]$ 出发考虑，使用哪个 $nums1[i]$ 去匹配最为合适。\r\n\r\n实际上，我们也能从 $nums1[i]$ 出发，考虑将其与哪个 $nums2[i]$ 进行匹配。\r\n\r\n为了让每个决策回合具有独立性，我们需要对两数组进行排序，同时为了在构造答案时，能够对应回 `nums2` 的原下标，排序前我们需要使用「哈希表」记录每个 $nums2[i]$ 的下标为何值。\r\n\r\n使用变量 `l1` 代表当前决策将 $nums1[l1]$ 分配到哪个 `nums2` 的位置，使用 `l2` 和 `r2` 代表当前 `nums2` 中还有 $[l2, r2]$ 位置还待填充。\r\n\r\n可以证明我们在从前往后给每个 $nums1[l1]$ 分配具体位置时，分配的位置只会在 `l2` 和 `r2` 两者之间产生。\r\n\r\nJava 代码：\r\n```Java\r\nclass Solution {\r\n    public int[] advantageCount(int[] nums1, int[] nums2) {\r\n        int n = nums1.length;\r\n        Map<Integer, List<Integer>> map = new HashMap<>();\r\n        for (int i = 0; i < n; i++) {\r\n            List<Integer> list = map.getOrDefault(nums2[i], new ArrayList<>());\r\n            list.add(i);\r\n            map.put(nums2[i], list);\r\n        }\r\n        Arrays.sort(nums1); Arrays.sort(nums2);\r\n        int[] ans = new int[n];\r\n        for (int l1 = 0, l2 = 0, r2 = n - 1; l1 < n; l1++) {\r\n            int t = nums1[l1] > nums2[l2] ? l2 : r2;\r\n            List<Integer> list = map.get(nums2[t]);\r\n            int idx = list.remove(list.size() - 1);\r\n            ans[idx] = nums1[l1];\r\n            if (t == l2) l2++;\r\n            else r2--;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\nPython 代码：\r\n```Python\r\nclass Solution:\r\n    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:\r\n        n = len(nums1)\r\n        mapping = defaultdict(list)\r\n        for i in range(n):\r\n            mapping[nums2[i]].append(i)\r\n        nums1.sort()\r\n        nums2.sort()\r\n        ans = [0] * n\r\n        l2, r2 = 0, n - 1\r\n        for l1 in range(n):\r\n            t = l2 if nums1[l1] > nums2[l2] else r2\r\n            ans[mapping[nums2[t]].pop()] = nums1[l1]\r\n            if t == l2:\r\n                l2 += 1\r\n            else:\r\n                r2 -= 1\r\n        return ans\r\n```\r\n* 时间复杂度：$O(n\\\\log{n})$\r\n* 空间复杂度：$O(n)$\r\n\r\n\r\n## 最后\r\n\r\n这是我们「刷穿 LeetCode」系列文章的第 `No.870` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先把所有不带锁的题目刷完。\r\n\r\n在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。\r\n\r\n为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode 。\r\n\r\n在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。\r\n\r\n更多更全更热门的「笔试/面试」相关资料可访问排版精美的 [合集新基地](https://www.acoier.com/archives/) 🎉🎉\r\n\r\n\r\n"
    },
    {
        "article_id": "7189551030793666616",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/164464b4491c4a9ab39d398be27e6396~tplv-k3u1fbpfcp-watermark.image?",
        "title": "深入分析 RPC 框架，从源码扒开来看「RPCX」",
        "preview": "如何理解「服务」和「服务实例」 一个 xClient对应一个「服务」，但可以持有该「服务」的多个「服务实例」。怎么理解「服务」和「服务实例」？ 上面的 UserCenter 即一个「服务」，但是为了服",
        "author": "用户1781525626194",
        "view_count": 520,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/mosaic-legacy/3795/3044413937~300x300.image",
        "category": "后端",
        "content": "<a name=\\\"Ybfsd\\\"></a>\r\n### 如何理解「服务」和「服务实例」\r\n一个 `xClient`对应一个「服务」，但可以持有该「服务」的多个「服务实例」。<br />怎么理解「服务」和「服务实例」？\r\n```go\r\ntype UserCenter struct {}\r\n\r\nfunc (u *UserCenter) SignIn() {}\r\n\r\nfunc (u *UserCenter) SignOut() {}\r\n\r\nfun Service1() {\r\n    s := server.NewServer()\r\n    s.RegisterName(\\\"UserCenter\\\", new(UserCenter), \\\"\\\")\r\n    s.Serve(\\\"tcp\\\", \\\":8080\\\")\r\n}\r\n\r\nfun Service2() {\r\n    s := server.NewServer()\r\n    s.RegisterName(\\\"UserCenter\\\", new(UserCenter), \\\"\\\")\r\n    s.Serve(\\\"tcp\\\", \\\":8081\\\")\r\n}\r\n\r\nfun Service3() {\r\n    s := server.NewServer()\r\n    s.RegisterName(\\\"UserCenter\\\", new(UserCenter), \\\"\\\")\r\n    s.Serve(\\\"tcp\\\", \\\":8082\\\")\r\n}\r\n\r\n```\r\n上面的 `UserCenter` 即一个「服务」，但是**为了服务的「高可用」，或者「负载均衡」，我们一般会给一个服务启动多个实例（或者说进程）**。<br />比如上面的代码中，我们给 `UserCenter` 服务启动了 3 个服务实例，分别是 `tcp@localhost:8081`、`tcp@localhost:8082`、`tcp@localhost:8083`。在生产环境，一般每个服务实例是部署在不同的机器上的（不管是物理机，还是虚拟机/容器），并且根据每台机器的性能配置不同的流量权重，给流量权重越高的「服务实例」分发越多的请求，可以理解为服务的**「负载均衡」**；<br />下面我制作了一个组件图，更形象的去理解服务以及服务实例。可以看到我们有 UserCenter 以及 OrderCenter 两个服务，分别对外提供“用户”以及“订单”两个领域相关的业务方法，并且都启动了 3 个服务实例。服务一般是不会给用户终端（User Agent/浏览器、App）等直接调用的，而是由业务进程去调用/聚合不同的服务提供的业务方法去对用户终端提供服务。\r\n> 写 Java 的同学可以把业务进程理解成 Controller 层，服务理解成 Service 层。\r\n\r\n「RPCX」规定，一个 xClient 结构体只对应一个服务，例如 UserCenter，业务进程只需要通过 xClient 结构体就可以对 UserCenter 服务发起远程调用，至于最终是调用哪个服务实例、失败的重试机制、网络连接的管理、数据序列化等底层细节都不需要关心，只需要实例化 xClient 结构体时指定配置即可。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7638433fdf1646c089f653fd41161d35~tplv-k3u1fbpfcp-zoom-1.image)<a name=\\\"lGNu9\\\"></a>\r\n### \r\n<a name=\\\"jD42h\\\"></a>\r\n### XClient 与 xClient\r\n<a name=\\\"nikc8\\\"></a>\r\n#### 接口 XClient\r\n下面是 XClient 的源码，可以看到它是一个 interface ，是一个服务在客户端（即该服务的调用方）的抽象。<br />PluginContainer 字面是理解是插件容器，那什么是插件，其实就是 Hook，钩子函数。Selector 就是选择器，主要负责在一次 RPC 调用中，挑选指定的服务实例。<br />下面看一下 XClient 声明的公共方法：\r\n\r\n- XClient#Go() 是一个异步方法，serviceMethod 即调用者要调用的服务的方法名，args 和 reply 大家也能猜出来，返回值 Call 结构体代表一次 RPC 调用，比较重要的是，Call 结构体中有一个 channel 成员用于获得 RPC 调用的执行结果（该 channel 也可以由 Go 方法的调用者传递），所以 XClient#Go() 方法是一个相对比较 low-level 的方法，去让调用者实现 RPC 异步调用。\r\n- XClient#Call() 类似 Go 方法，不过是阻塞调用，会等待 RPC 的调用结果返回，且有对失败做重试，而 Go() 方法没有。\r\n- XClient#Broadcast() 有点意思，即向所有服务实例发起 RPC 调用，这也应证了一个服务会有多个服务实例。\r\n```go\r\n// client/xclient.go\r\n\r\ntype XClient interface {\r\n\\tSetPlugins(plugins PluginContainer)\r\n\\tGetPlugins() PluginContainer\r\n\\tSetSelector(s Selector)\r\n\\tConfigGeoSelector(latitude, longitude float64)\r\n\\tAuth(auth string)\r\n\r\n\\tGo(ctx context.Context, serviceMethod string, args interface{}, reply interface{}, done chan *Call) (*Call, error)\r\n\\tCall(ctx context.Context, serviceMethod string, args interface{}, reply interface{}) error\r\n\\tBroadcast(ctx context.Context, serviceMethod string, args interface{}, reply interface{}) error\r\n\\tFork(ctx context.Context, serviceMethod string, args interface{}, reply interface{}) error\r\n\\tInform(ctx context.Context, serviceMethod string, args interface{}, reply interface{}) ([]Receipt, error)\r\n\\tSendRaw(ctx context.Context, r *protocol.Message) (map[string]string, []byte, error)\r\n\\tSendFile(ctx context.Context, fileName string, rateInBytesPerSecond int64, meta map[string]string) error\r\n\\tDownloadFile(ctx context.Context, requestFileName string, saveTo io.Writer, meta map[string]string) error\r\n\\tStream(ctx context.Context, meta map[string]string) (net.Conn, error)\r\n\\tClose() error\r\n}\r\n```\r\n剩下的就不多说了，就是发送文件、下载文件等方法，后面有需要的时候再来看，这里主要理清一些重要的结构体以及方法，下面看一下 XClient 接口的实现。\r\n\r\n<a name=\\\"cXZR4\\\"></a>\r\n#### 结构体 xClient\r\n结构体 xClient 是接口 XClient 的实现，下面我们把它扒开来看一下。\r\n\r\n- failMode 和 selectMode 即 RPC 调用失败时的重试机制和服务实例的挑选机制，这个看文档就好了，不作深入。\r\n- cachedClient 比较重要，可以看到它是一个 Map，这个 map 装啥呢？就是我们上面一直强调的服务实例啦！key 是服务实例注册在服务发现上的连接地址，value 可以看到是 RPCClient，也是一个 interface，代表的就是一个服务实例，本质上就是一个和该服务实例建立好了的网络连接，因为网络连接是一种比较耗时的系统资源，所有才需要 cached，以便复用！那么取名叫作 cachedClient 也很合理嘛，关于 RPCClient 的更多细节，下面会讲到。\r\n```go\r\ntype xClient struct {\r\n\\tfailMode     FailMode\r\n\\tselectMode   SelectMode\r\n\\tcachedClient map[string]RPCClient\r\n\\tbreakers     sync.Map\r\n\\tservicePath  string\r\n\\toption       Option\r\n\r\n\\tmu        sync.RWMutex\r\n\\tservers   map[string]string\r\n\\tdiscovery ServiceDiscovery\r\n\\tselector  Selector\r\n\r\n\\tslGroup singleflight.Group\r\n\r\n\\tisShutdown bool\r\n\r\n\\t// auth is a string for Authentication, for example, \\\"Bearer mF_9.B5f-4.1JqM\\\"\r\n\\tauth string\r\n\r\n\\tPlugins PluginContainer\r\n\r\n\\tch chan []*KVPair\r\n\r\n\\tserverMessageChan chan<- *protocol.Message\r\n}\r\n```\r\n\r\n<a name=\\\"Pnog1\\\"></a>\r\n#### 断路器 xClient#breakers\r\n下面重点讲一下 breaker 断路器。\r\n> 断路器对电源线路及电动机等实行保护，当它们发生严重的过载或者短路及欠压等故障时能自动切断电路。\r\n\r\n```go\r\ntype xClient struct {\r\n    // ...\r\n\\tfailMode     FailMode\r\n\\tselectMode   SelectMode\r\n\\tcachedClient map[string]RPCClient\r\n\\tbreakers     sync.Map\r\n    // ...\r\n}\r\n```\r\nbreakers ，也是个 map，和 cachedClient 一样，key 是服务实例的网络地址，但 value 是一个断路器，当 selector 挑到了某个服务实例 A，但 xClient 和 A 建立网络连接失败时，xClient 就会触发 A 的断路器的断路，若是 [FailOver](https://doc.rpcx.io/part3/failmode.html#failfast) 失败模式，xClient 就会尝试和下一个服务实例建立网络连接。还没完，等到了下一次 RPC 调用，selector 又挑到了服务实例 A，xClient 从 breakers 里拿到 A 的断路器，就可以判断 A 是否处于断路，如果是，就不会再尝试和 A 建立网络连接了，直接找下一个服务实例了！这样，是不是就避免了客户端一直向一个已经不具备功能的服务实例发送请求建立的网络报文呢？即节省了客户端一次 RPC 调用的时间，又可以让服务器专心的去处理别的还可用的服务实例的请求。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f572f9fb7694cfa84026e1aff63fc84~tplv-k3u1fbpfcp-zoom-1.image)上面，我们还提出了两个问题：\r\n\r\n- 难道一次请求建立失败，就触发断路吗？如果刚好碰到网络波动，一次稍微的网络延时，就让一个服务实例完全不可用，会不会太苛刻了呢？\r\n- 已经处于断路中的服务实例，难道只要客户端不重启，客户端就一直把这个服务实例视而不见吗？\r\n\r\n[答案显然都是否定的，细节就看 RPCX 用的断路器的具体实现啦。](https://github.com/rubyist/circuitbreaker)\r\n\r\n<a name=\\\"TcDxj\\\"></a>\r\n####  并发调用抑制 xClient#slGroup\r\n```go\r\ntype xClient struct {\r\n    // ...\r\n\\tfailMode     FailMode\r\n\\tselectMode   SelectMode\r\n\\tcachedClient map[string]RPCClient\r\n\\tslGroup singleflight.Group\r\n    // ...\r\n}\r\n```\r\n结构体 xClient 中还有一个 slGroup 成员，类型为 singleflight.Group，我把它理解为串行的通道。\r\n```go\r\npackage singleflight\r\n\r\ntype Group struct {\r\n    // ...\r\n}\\t\r\n\r\n// Do executes and returns the results of the given function, making\r\n// sure that only one execution is in-flight for a given key at a\r\n// time. If a duplicate comes in, the duplicate caller waits for the\r\n// original to complete and receives the same results.\r\n// The return value shared indicates whether v was given to multiple callers.\r\nfunc (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {}\r\n\r\n// Forget tells the singleflight to forget about a key.  Future calls\r\n// to Do for this key will call the function rather than waiting for\r\n// an earlier call to complete.\r\nfunc (g *Group) Forget(key string) {}\r\n\r\n```\r\n这个 singleflight.Group 的实现也比较简单，Group#Do() 方法即：对于相同的 key，即 1 个分组，在第一次调用 Do() 方法到调用 Forget() 前的这段时间内的 Do() 函数调用都将阻塞等待并使用第 1 个 Do() 方法的结果。概念比较简单，[源码也不复杂，感兴趣的同学可以去看下](https://pkg.go.dev/golang.org/x/sync@v0.0.0-20210220032951-036812b2e83c/singleflight)。<br />这里主要看 RPCX 是怎么使用的，聪明的小伙伴应该也应该猜到了，就是在 xClient 和服务实例建立网络连接的这一过程适和 singleflight.Group 去做并发抑制。key 就是指定的服务实例的网络地址，在不上锁的情况下，就会使用 singleflight.Group 去实现并发控制，下面是缩略过的源码。\r\n> 注意：RPCClient 是一个 interface， 是 RPCX 抽象的在客户端的服务实例，可以认为是 xClient 持有的和指定的服务实例的一个网络连接，Client 是 RPCClient 的实现，后面会讲到。\r\n\r\n```go\r\n// 不上锁的情况下去获取一个和指定的服务实例的可以用的网络连接\r\n// 解释一下：k 就是上面所说的服务实例的网络地址；servicePath 是服务的标识（比如 \\\"UserCenter\\\"），这段代码，包括里面调用到的函数，都没有使用到这个变量，可以不理会\r\nfunc (c *xClient) getCachedClientWithoutLock(k, servicePath, serviceMethod string) (RPCClient, bool, error) {\r\n    // ...\r\n    var needCallPlugin bool\r\n    // 查找是否有建立了的网络连接\r\n\\tclient = c.findCachedClient(k, servicePath, serviceMethod)\r\n\\tif client == nil || client.IsShutdown() {\r\n\\t\\tgeneratedClient, err, _ := c.slGroup.Do(k, func() (interface{}, error) {\r\n            // 如果没有，或者该网络连接已经断开，则和 k 指定的服务实例建立网络连接\r\n\\t\\t\\treturn c.generateClient(k, servicePath, serviceMethod)\r\n\\t\\t})\r\n\\t\\tc.slGroup.Forget(k)\r\n\\t\\tif err != nil {\r\n\\t\\t\\treturn nil, needCallPlugin, err\r\n\\t\\t}\r\n\\t\\tclient = generatedClient.(RPCClient)\r\n        \r\n        // 这个东西比较特殊，RPCX 是支持客户端和服务实例之间的全双工通信的，即服务实例可以主动推送消息给客户端，这里主要用户实现这个功能\r\n        client.RegisterServerMessageChan(c.serverMessageChan)\r\n        \r\n\\t\\tc.setCachedClient(client, k, servicePath, serviceMethod)\r\n\\t}\r\n\\treturn client, needCallPlugin, nil\r\n}\r\n\r\nfunc (c *xClient) generateClient(k, servicePath, serviceMethod string) (client RPCClient, err error) {\r\n\\tclient = &Client{\r\n\\t\\toption:  c.option,\r\n\\t\\tPlugins: c.Plugins,\r\n\\t}\r\n    // 这里可以看到上面说的断路器\r\n\\tvar breaker interface{}\r\n\\tif c.option.GenBreaker != nil {\r\n\\t\\tbreaker, _ = c.breakers.LoadOrStore(k, c.option.GenBreaker())\r\n\\t}\r\n\\terr = client.Connect(network, addr)\r\n    // 和 k 指定的服务实例建立网络连接失败，触发断路！\r\n\\tif err != nil {\r\n\\t\\tif breaker != nil {\r\n\\t\\t\\tbreaker.(Breaker).Fail()\r\n\\t\\t}\r\n\\t\\treturn nil, err\r\n\\t}\r\n\\treturn client, err\r\n}\r\n```\r\n这里，我们再次提出一个问题，除了建立网络连接这个场景，还有什么别的可能的场景可以用上 singleflight.Group 呢？\r\n\r\n- 读取本地文件、本地图片、本地音频等，当第一次调用的结果还没有返回时，其余的调用并不会实际去发起 read 系统调用，转而等待第一次调用的结果，虽然说读取文件这种行为，内核会有 PageCache 作缓存，并发下读取一个文件命中内核缓存的几率会非常大，但是内核态和用户态之间的内存拷贝是少不了的。[关于 Linux 内核的 IO 操作，感兴趣的朋友可以来这里](https://strikefreedom.top/linux-io-and-zero-copy)。\r\n- 进阶点，读取存储在 OSS 的文件。\r\n\r\n相同点在于：\r\n\r\n- 这会是一个耗时的操作，而且不是 CPU 耗时，反而 CPU 此时可能会是闲置的，线程是会被挂起的，比如 CPU 和外部设备的 IO 行为。\r\n- 短时间内，多次的调用，执行结果是相差不大的。\r\n\r\n<a name=\\\"adJ0W\\\"></a>\r\n#### 揭秘 xClient 的实例化过程\r\n`xClient` 的实例化过程还是比较简单的，只从「服务发现器」初始化了一下「服务实例」的连接地址，**没有马上和至少一个「服务实例」建立起来网络连接**，只有在 RPC 调用时，发现没有和「服务实例」的可用连接，才进行建立。那么，这样的「懒加载」策略，是否会导致当流量打到一个刚上线的应用时，大量的请求因为 RPC 调用而阻塞在和「服务实例」建立网络连接的过程？那线程池是否会有同样的问题呢？区别于 RPC 调用，线程池一般是用来进行任务的异步处理的，对于线程的创建过程所产生的时间消耗可以认为是不敏感的。\r\n```go\r\n// client/xclient.go\r\n\r\nfunc NewXClient(servicePath string, failMode FailMode, selectMode SelectMode, discovery ServiceDiscovery, option Option) XClient {\r\n    client := &xClient{\r\n        failMode:     failMode,\r\n        selectMode:   selectMode,\r\n        discovery:    discovery,\r\n        // 服务的名称，比如之前说的 “UserCenter” 服务。\r\n        servicePath:  servicePath,\r\n        // 缓存着的「服务实例」，即已经建立好了的网络连接\r\n        cachedClient: make(map[string]RPCClient),\r\n        option:       option,\r\n    }\r\n    \r\n    // 从「服务发现器」获取「服务实例」的连接地址，及其元数据（一个 url query 格式的字符串）。\r\n    pairs := discovery.GetServices()\r\n    sort.Slice(pairs, func(i, j int) bool {\r\n        return strings.Compare(pairs[i].Key, pairs[j].Key) <= 0\r\n    })\r\n    servers := make(map[string]string, len(pairs))\r\n    for _, p := range pairs {\r\n        servers[p.Key] = p.Value\r\n    }\r\n    \r\n    // 过滤出来和当前 xClient 的同一个「分组」的「服务实例」\r\n    filterByStateAndGroup(client.option.Group, servers)\r\n    \r\n    // 初始化一下「服务实例」的连接地址\r\n    client.servers = servers\r\n    \r\n    // 根据选项初始化指定的「服务实例选择器」\r\n    if selectMode != Closest && selectMode != SelectByUser {\r\n        client.selector = newSelector(selectMode, servers)\r\n    }\r\n    \r\n    client.Plugins = &pluginContainer{}\r\n    \r\n    // 1. 如果是「zookeeper」、「etcd」等可实时监测「服务实例」上线/下线的「服务发现器」，\r\n    //    则开启注册一个 channel，该 channel 的元素类型是一个承载着「服务实例」连接地址及其元数据的数组。\r\n    //    所以每次都是全量更新最新的「服务实例」的。\r\n    // \r\n    // 2. 如果是 「peer2peer2」、「MultipleServers」，WatchService() 返回 nil。\r\n    ch := client.discovery.WatchService()\r\n    if ch != nil {\r\n        client.ch = ch\r\n        go client.watch(ch)\r\n    }\r\n    \r\n    return client\r\n}\r\n\r\nfunc (c *xClient) watch(ch chan []*KVPair) {\r\n\\tfor pairs := range ch {\r\n\\t\\tservers := make(map[string]string, len(pairs))\r\n\\t\\tfor _, p := range pairs {\r\n\\t\\t\\tservers[p.Key] = p.Value\r\n\\t\\t}\r\n\\t\\tfilterByStateAndGroup(c.option.Group, servers)\r\n\\t\\tc.servers = servers\r\n\\t\\tif c.selector != nil {\r\n\\t\\t\\tc.selector.UpdateServer(servers)\r\n\\t\\t}\r\n\\t}\r\n}\r\n```\r\n<a name=\\\"ZzzXY\\\"></a>\r\n#### \r\n<a name=\\\"aRVoG\\\"></a>\r\n#### 总结\r\n至此，xClient 这一重要的结构体基本上我们已经解读完毕了，下面从中得出的一些重点：\r\n\r\n- 网络连接复用，xClient 结构体内部缓存着已经建立好了的和「服务实例」网络连接。\r\n- 断路器，当某一个「服务实例」异常时，会触发客户端到该「服务实例」这条通路的断路，企图前往该「服务实例」的请求会快速失败，但是会有一定的补偿策略（比如周期性测试通路）。\r\n- 并发调用抑制，一段时间内，一批次的对同一个「服务实例」的连接建立申请，该批次的所有申请会阻塞等待该批次中第 1 个调用的结果。\r\n- 全双工通信，RPCX 是支持客户端监听服务实例主动推送到客户端的消息的。\r\n\r\n以及上面我们提出的问题：\r\n\r\n- [断路器的断路触发策略以及断路后的补偿策略](#Pnog1)。\r\n- [并发调用抑制 singleflight.Group 的除 RPC 外的使用场景](#TcDxj)。\r\n\r\n<a name=\\\"wZxLx\\\"></a>\r\n### RPCClient 与 Client\r\n上面我们接触完了 xClient，知道了 xClient 代表一个「服务」，接下来，我们来看一下 RPCClient 与 Client 所代表的「服务实例」。<br />和 XClient 与 xClient 相类似，RPCClient 是一个 interface，是「服务实例」在客户端/调用方的抽象，Client 是结构体，是 RPCClient 的具体实现。\r\n<a name=\\\"r4ihE\\\"></a>\r\n#### 接口 RPCClient\r\nConnect() 和 Close() 毫无疑问是作为网络连接建立和关闭的两个方法，network 是网络协议，如 tcp、quic 甚至是 http（当然几乎不会有用 http 作为 RPC 网络协议的时候）。GetConn() 也是一个相对比较 low-level 的方法，直接让我们拿到底层的网络连接，这里可以看到 RPCX 是使用 Golang 的 net 标准包来做底层的网络连接的。\r\n> 这样，下一步我们可以通过去看 Golang 的 net 标准包的源码来看 RPCX 在底层网络 IO 这块有没有改进空间了。比如 net 包底层是否是 reactor 模型呢？\r\n\r\n[ Go() 和 Call() 两个方法，和 XClient interface 是一样的，不多赘述了](#nikc8)，SendRaw() 也是一个 low-level 的方法，protocol.Message 结构体类似 HTTP 报文，是 RPCX 自己的应用层报文协议，具体看[这里](https://doc.rpcx.io/part5/protocol.html)。\r\n```go\r\n// client/client.go\r\n\r\ntype RPCClient interface {\r\n    Connect(network, address string) error\r\n    Close() error\r\n\\tRemoteAddr() string\r\n    GetConn() net.Conn\r\n    \r\n\\tGo(ctx context.Context, servicePath, serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call\r\n\\tCall(ctx context.Context, servicePath, serviceMethod string, args interface{}, reply interface{}) error\r\n\\tSendRaw(ctx context.Context, r *protocol.Message) (map[string]string, []byte, error)\r\n\r\n\r\n\\tRegisterServerMessageChan(ch chan<- *protocol.Message)\r\n\\tUnregisterServerMessageChan()\r\n\r\n\\tIsClosing() bool\r\n\\tIsShutdown() bool\r\n\r\n}\r\n```\r\n\r\n<a name=\\\"eC6Ia\\\"></a>\r\n#### 结构体 Client\r\n下面来看下 RPCClient 的具体实现。`r *bufio.Reader`用于从 `Conn net.Conn`网络连接中读取「服务实例」发送过来的数据，可以理解为底层网络连接的包装类。<br />重点讲 `seq uint64` 和 `pending map[uint64]*Call`，`seq`是一个单调递增的计数值 counter，该 `Client` 结构体所代表的「服务实例」每进行一次 RPC 调用前，会进行`seq++` 作为此次 RPC 调用的唯一标识 `MessageID`。`pending map[uint64]*Call` 中存储着正在等待执行结果的 RPC 请求，key 毫无疑问就是刚才的 `MessageID`，value 是一个 `Call` 结构体（RPCX 抽象的客户端发出的一次 RPC 请求）。此时，`MessageID` 和 `pending`这两个结构体成员就构成了客户端和该服务实例的所有 RPC 调用的上下文了，`MessageID` 会随着一次 RPC 请求发送给服务实例，服务实例处理完这次 RPC 请求后会把 `MessageID` 和执行结果一起返回给客户端，客户端通过这个 `MessageID` 就可以从 `pending` 中找到对应的 `Call`结构体，就可以通过 `Call`结构体中的 `Done chan *Call` 唤醒发起这一次 RPC 请求的协程/线程了。更多的细节在后面揭秘一次 RPC 调用的章节中会讲到。\r\n```go\r\n// client/client.go\r\n\r\ntype Client struct {\r\n\\toption Option\r\n\r\n\\tConn net.Conn\r\n\\tr    *bufio.Reader\r\n\\t// w    *bufio.Writer\r\n\r\n\\tmutex        sync.Mutex // protects following\r\n\\tseq          uint64\r\n\\tpending      map[uint64]*Call\r\n\\tclosing      bool // user has called Close\r\n\\tshutdown     bool // server has told us to stop\r\n\\tpluginClosed bool // the plugin has been called\r\n\r\n\\tPlugins PluginContainer\r\n\r\n\\tServerMessageChan chan<- *protocol.Message\r\n}\r\n\r\n// Call represents an active RPC.\r\ntype Call struct {\r\n\\tServicePath   string            // The name of the service and method to call.\r\n\\tServiceMethod string            // The name of the service and method to call.\r\n\\tMetadata      map[string]string // metadata\r\n\\tResMetadata   map[string]string\r\n\\tArgs          interface{} // The argument to the function (*struct).\r\n\\tReply         interface{} // The reply from the function (*struct).\r\n\\tError         error       // After completion, the error status.\r\n\\tDone          chan *Call  // Strobes when call is complete.\r\n\\tRaw           bool        // raw message or not\r\n}\r\n```\r\n<a name=\\\"kVPlL\\\"></a>\r\n#### \r\n<a name=\\\"FwHWY\\\"></a>\r\n#### 与「服务实例」建立连接\r\n结构体 `Client` 是「服务实例」在客户端的实体，本质是持有一条和「服务实例」建立的网络连接，[接着上一次继续讲到的内容](#TcDxj)，我们通过看源码来了解 RPCX 的客户端是如何与「服务实例」建立连接的。\r\n```go\r\n// client/connection.go\r\n\r\ntype ConnFactoryFn func(c *Client, network, address string) (net.Conn, error)\r\n\r\nvar ConnFactories = map[string]ConnFactoryFn{\r\n\\t\\\"http\\\": newDirectHTTPConn,\r\n\\t\\\"kcp\\\":  newDirectKCPConn,\r\n\\t\\\"quic\\\": newDirectQuicConn,\r\n\\t\\\"unix\\\": newDirectConn,\r\n\\t\\\"memu\\\": newMemuConn,\r\n}\r\n\r\n// Connect connects the server via specified network.\r\nfunc (client *Client) Connect(network, address string) error {\r\n\\tvar conn net.Conn\r\n\\tvar err error\r\n\r\n\\tswitch network {\r\n\\tcase \\\"http\\\":\r\n\\t\\tconn, err = newDirectHTTPConn(client, network, address)\r\n\\tcase \\\"ws\\\", \\\"wss\\\":\r\n\\t\\tconn, err = newDirectWSConn(client, network, address)\r\n\\tdefault:\r\n\\t\\tfn := ConnFactories[network]\r\n\\t\\tif fn != nil {\r\n\\t\\t\\tconn, err = fn(client, network, address)\r\n\\t\\t} else {\r\n\\t\\t\\tconn, err = newDirectConn(client, network, address)\r\n\\t\\t}\r\n\\t}\r\n\r\n\\tif err == nil && conn != nil {\r\n\\t\\tif tc, ok := conn.(*net.TCPConn); ok && client.option.TCPKeepAlivePeriod > 0 {\r\n\\t\\t\\t_ = tc.SetKeepAlive(true)\r\n\\t\\t\\t_ = tc.SetKeepAlivePeriod(client.option.TCPKeepAlivePeriod)\r\n\\t\\t}\r\n\r\n\\t\\tif client.option.IdleTimeout != 0 {\r\n\\t\\t\\t_ = conn.SetDeadline(time.Now().Add(client.option.IdleTimeout))\r\n\\t\\t}\r\n\r\n\\t\\tif client.Plugins != nil {\r\n\\t\\t\\tconn, err = client.Plugins.DoConnCreated(conn)\r\n\\t\\t\\tif err != nil {\r\n\\t\\t\\t\\treturn err\r\n\\t\\t\\t}\r\n\\t\\t}\r\n\r\n\\t\\tclient.Conn = conn\r\n\\t\\tclient.r = bufio.NewReaderSize(conn, ReaderBuffsize)\r\n\\t\\t// c.w = bufio.NewWriterSize(conn, WriterBuffsize)\r\n\r\n\\t\\t// start reading and writing since connected\r\n\\t\\tgo client.input()\r\n\r\n\\t\\tif client.option.Heartbeat && client.option.HeartbeatInterval > 0 {\r\n\\t\\t\\tgo client.heartbeat()\r\n\\t\\t}\r\n\r\n\\t}\r\n\r\n\\tif err != nil && client.Plugins != nil {\r\n\\t\\tclient.Plugins.DoConnCreateFailed(network, address)\r\n\\t}\r\n\r\n\\treturn err\r\n}\r\n```\r\n首先就是根据不同网络协议通过不同的方式创建网络连接，可以看到 RPCX 支持很多网络协议，甚至支持 http 协议。\r\n> 当然了，几乎不会有人想使用 http 协议来作为 RPC 的网络通讯协议，对于 RPC 这个场景来说，HTTP 的请求头、响应头太冗余了，一来增加网络传输的时间，二来增加 CPU 序列化、反序列化的时间。\r\n\r\n尽管网络协议可以千变万化，但是网络 IO 是不变的，本质都是把用户态的一段内存空间的数据写入到内核态中对应的 socket 的发送缓冲区（发送数据）或者把该 socket 的接收缓存区的一段数据写入到用户态的一段内存空间中（接收数据），这部分内容 Golang 的 net 标准包的 Conn 包装类帮我们实现了，所以对于不同的网络协议，最后 PRCX 还是持有的 net.Conn 这个结构体。<br />建立完连接后，如果我们有指定 `keep-alive` 时长，就是设置 `keep-alive`了，`keep-alive` 机制其实也就是通信的双方的内核约定好这个 socket 什么时候到期，到期了就四次挥手说拜拜，没到期之前双方的 socket 一直都有效。\r\n> `keep-alive` 机制对于 RPC 场景来说毫无疑问是必要的。三次握手建立连接和四次挥手断开连接一共 7 次的网络 IO 了，省下这 7 次的网络 IO 可以多进行至少 3 次的 RPC 调用，也就有至少 3 倍的性能差距。\r\n\r\n`net.Dialer`是 Golang 封装的用于与指定的网络地址创建连接的结构体，取名“拨号”，很形象。这里的注释告诉我们，在建立网络连接的时候，默认的 `keep-alive` 时长是 15 秒。\r\n```go\r\npackage net\r\n\r\ntype Dialer struct {\r\n        \r\n    // ...\r\n\r\n\\t// KeepAlive specifies the interval between keep-alive\r\n\\t// probes for an active network connection.\r\n\\t// If zero, keep-alive probes are sent with a default value\r\n\\t// (currently 15 seconds), if supported by the protocol and operating\r\n\\t// system. Network protocols or operating systems that do\r\n\\t// not support keep-alives ignore this field.\r\n\\t// If negative, keep-alive probes are disabled.\r\n\\tKeepAlive time.Duration\r\n    \r\n    // ...\r\n}\r\n```\r\n整完 `keep-alive` 后，还要再整一个 `IdleTimeout` 时长，即最大空闲时长的意思。\r\n```go\r\n// ...\r\nif client.option.IdleTimeout != 0 {\r\n    _ = conn.SetDeadline(time.Now().Add(client.option.IdleTimeout))\r\n}\r\n// ...\r\n```\r\n可以看到，RPCX 是直接使用 Golang 标准包的 `net.Conn#SetDeadline` 方法来完成空闲连接的回收的，从下面的注释可以看到，对一个已经过了 `deadline` 时间（后面统称：“过期”）的连接进行的 IO 操作会直接返回 `ErrDeadlineExceeded` 异常，正在被内核挂起着的线程也会直接返回 ``ErrDeadlineExceeded` 异常。\r\n```go\r\ntype Conn struct {\\t\r\n    // A deadline is an absolute time after which I/O operations\r\n\\t// fail instead of blocking. The deadline applies to all future\r\n\\t// and pending I/O, not just the immediately following call to\r\n\\t// Read or Write. After a deadline has been exceeded, the\r\n\\t// connection can be refreshed by setting a deadline in the future.\r\n\\t//\r\n\\t// If the deadline is exceeded a call to Read or Write or to other\r\n\\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\r\n\\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\r\n\\t// The error's Timeout method will return true, but note that there\r\n\\t// are other possible errors for which the Timeout method will\r\n\\t// return true even if the deadline has not been exceeded.\r\n\\t//\r\n\\t// An idle timeout can be implemented by repeatedly extending\r\n\\t// the deadline after successful Read or Write calls.\r\n\\t//\r\n\\t// A zero value for t means I/O operations will not time out.\r\n\\tSetDeadline(t time.Time) error\r\n}\r\n```\r\n我看了 RPCX 的源码，发现 RPCX 并不会对 `ErrDeadlineExceeded` 这个异常做特殊的处理，而且它也不保证你不会拿到一条已经过期的连接进行 RPC 调用。这会出现什么情况：\r\n\r\n- 写失败：向「服务实例」发送 RPC 请求报文的时候，因为底下的 `net.Conn` 连接已经过期，导致写失败。\r\n- 读失败：后面会讲到，`Client` 结构体在和「服务实例」建立完连接后，会启动一个协程「**阻塞轮询」**来自「服务实例」的报文，若此时这条连接过期了，内核会直接给这个「轮询读协程」返回 ``ErrDeadlineExceeded`` 异常，RPCX 也没有对这个异常作特殊处理，而是直接调用 `Client#Close` 方法关闭 `Client` 结构体，此时 `pending` 着的 RPC 请求全部返回 `ErrShutdown` 异常，而不管「服务实例」那边是不是已经处理完这些  RPC 请求了。就会出现一个请求，服务端那边是处理成功的，而客户端这边以为是失败，若服务端没有做幂等处理，那就麻烦了。\r\n> 具体可以看 `Client#input` 方法，就是上面说的「轮询读协程」，后面也会马上讲到这个方法。\r\n\r\n\r\n<a name=\\\"ogJ8X\\\"></a>\r\n#### RPCX 是如何拆包的\r\n// todo\r\n\r\n<a name=\\\"knwn7\\\"></a>\r\n#### 揭秘一次 RPC 调用\r\n// todo\r\n\r\n<a name=\\\"x91Z2\\\"></a>\r\n### RPCX 的 client 端类图\r\n下面是我刚开始看 RPCX 的 client 客户端的源码时，梳理出来的比较完整的类图，可能会有少许小瑕疵，但是大体上是正确的，相信对大家理解 RPCX 的客户端的设计会有作用。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4f7dc406b246b9941f0eda34ea8894~tplv-k3u1fbpfcp-zoom-1.image)"
    },
    {
        "article_id": "7179809074551193659",
        "snapshot": "",
        "title": "「2022」寒冬下我的面试知识点复盘【CSS】篇",
        "preview": "笔者今年2022寒冬下成功跳槽了阿里，这篇文章就是将自己面试的一些准备、知识总结分享出来~如果这篇文章对你有用，请一键三连（点赞+评论+收藏）",
        "author": "菜猫子neko",
        "view_count": 1085,
        "collect_count": 28,
        "comment_count": 2,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/15b3e24044672969f37ba2845608897e~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: devui-blue\r\n---\r\n\r\n## 前言\r\n\r\n笔者今年`2022寒冬`下成功跳槽了`阿里`，这篇文章就是将自己`面试`的一些`准备`、`知识总结`分享出来~\r\n\r\n> 如果这篇文章对你有用，`请一键三连（点赞评论+收藏）`让更多的同学看到\r\n\r\n> 如果需要`转载`，请评论区`留言`，未经允许请不要私自`转载`；\r\n\r\n## 防杠声明\r\n\r\n这篇文章不是纯堆砌`面试题`，而是以`知识总结`为主，`主观观点和主观总结居多`，`里面总结的知识点在我这次的面试中也不全都有用到`~如果有写错的地方欢迎评论区提出，如果只是要`杠`那请右上角`X`掉慢走；\r\n\r\n## 传送门\r\n\r\n> 这个专栏预计要做以下这些内容，可以根据自己的需要跳转查看\r\n\r\n**面经**：[「2022面经」：2年前端拿下字节阿里offer总结](https://juejin.cn/post/7173865309185671181)\r\n\r\n**专栏**：[2022寒冬下我的面试知识点复盘：](https://juejin.cn/column/7166442462200725540)\r\n\r\n[「2022」寒冬下我的面试知识点复盘【浏览器原理】篇](https://juejin.cn/post/7168637354536599559)\r\n\r\n[「2022」寒冬下我的面试知识点复盘【计算机网络】篇](https://juejin.cn/post/7166870049066582053)\r\n\r\n「2022」寒冬下我的面试知识点复盘【JS】篇`（加紧编写中）`\r\n\r\n[「2022」寒冬下我的面试知识点复盘【CSS】篇](https://juejin.cn/post/7179809074551193659/)\r\n\r\n[「2022」寒冬下我的面试知识点复盘【Vue3、Vue2、Vite】篇](https://juejin.cn/post/7166446028266733581)\r\n\r\n「2022」寒冬下我的面试知识点复盘【工程化】篇`（加紧编写中）`\r\n\r\n「2022」寒冬下我的面试知识点复盘【Nodejs】篇`（加紧编写中）`\r\n\r\n「2022」寒冬下我的面试知识点复盘【TypeScript】篇`（加紧编写中）`\r\n\r\n## 本文标题思维导图\r\n\r\n制作ing\r\n\r\n## CSS 篇\r\n\r\n#### 1.盒模型\r\n\r\n\r\n##### 概念\r\n\r\n> 盒子模型的组成为：`content（元素内容）` + `padding（内边距）` + `border（边框）` + `margin（外边距）`\r\n\r\n`CSS`的`盒模型`有两种：`标准盒子模型`和`IE盒子模型`\r\n\r\n\r\n- 标准盒子模型：盒子实际总宽高=内容的宽高width\\\\height（content）+ border + padding + margin\r\n- IE盒子模型：盒子实际总宽高=内容的宽高width\\\\height（content+border+padding）+ margin\r\n\r\n\r\n##### 如何设置盒模型\r\n\r\n- 可以通过设置`box-sizing`的值来改变盒模型；\r\n    - `box-sizeing: content-box`为`标准盒子模型`；也是`默认值`；\r\n    - `box-sizeing: border-box`为`IEh盒子模型`；\r\n\r\n`box-sizing`的应用场景在于是否想让子元素因为`padding`和`border`溢出\r\n\r\n\r\n##### 盒模型 margin 负值问题\r\n\r\n\r\n-   `margin-top` 元素自身会向上移动，同时会影响下方的元素会向上移动；\r\n-   `margin-botom` 元素自身不会位移，但是会减少自身供`css`读取的高度，从而影响下方的元素会向上移动。\r\n-   `margin-left` 元素自身会向左移动，同时会影响其它元素；\r\n-   `margin-right` 元素自身不会位移，但是会减少自身供`css`读取的宽度，从而影响右侧的元素会向左移动；\r\n\r\n#### 2.BFC & 块级格式化上下文\r\n\r\n\r\n##### 概念\r\n\r\n**块级格式化上下文**，是一个独立的渲染区域，让处于 `BFC` 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\r\n\r\n\r\n##### 触发条件\r\n\r\n-   `position: absolute`/`fixed`：绝对定位\r\n-   `display: inline-block` / `table` / `flex`\r\n-   `float` 设置除`none`以外的值；（只要设置了浮动，当前元素就创建了`BFC`）\r\n-   `ovevflow !== visible` (可为：`hidden`、`auto`、`scroll`)\r\n\r\n##### 规则\r\n\r\n-   属于同一个 `BFC` 的相邻 `Box` 垂直排列\r\n-   属于同一个 `BFC` 的相邻 `Box` 的 `margin` 会发生`外边距重叠`\r\n-   `BFC` 在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。\r\n-   `BFC` 的区域不会与 `float` 的元素区域重叠\r\n-   计算 `BFC` 的高度时，浮动子元素也参与计算\r\n\r\n\r\n##### 特性和应用\r\n\r\n-   阻止`margin`重叠：**同一个 BFC 下外边距（margin）会发生折叠**\r\n-   清除浮动 ：**清除内部浮动(清除浮动的原理是两个**`div`**都位于同一个** `BFC` **区域之中)**\r\n-   自适应两栏布局：左`float`+右`BFC`，是利用了`BFC` 的区域不会与 `float` 的元素区域重叠的机制\r\n\r\n\r\n\r\n\r\n\r\n##### 外边距重叠\r\n\r\n\r\n-   在`CSS`当中，上下相邻的两个盒子的外边距可以结合成一个单独的外边距。\r\n    -   注意：只有在文档流中的`垂直外边距`才会合并\r\n\r\n**外边距重叠结果遵循下列计算规则**：\r\n\r\n-   两个相邻的外边距`都是正数`时，折叠结果是它们两者之间较大的值。\r\n-   两个相邻的外边距`都是负数`时，折叠结果是两者绝对值的较大值。\r\n-   两个外边距`一正一负`时，折叠结果是两者的相加的和。\r\n\r\n\r\n\r\n\r\n#### 3.Z-index（层叠上下文）\r\n\r\n\r\n##### 触发条件\r\n\r\n- `根层叠上下文(html)`：本身就有层叠上下文\r\n- `position非static`\r\n- `css3`新属性\r\n  - `flex`\r\n  - `transform`\r\n  - `opacity`\r\n  - `filter`\r\n  - `will-change`\r\n  - `webkit-overflow-scrolling`\r\n\r\n\r\n##### 层叠等级：层叠上下文在z轴上的排序\r\n\r\n\r\n- 在同一层叠上下文中，层叠等级才有意义\r\n- `z-index`的优先级最高\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd5f7551bd74690a70f9fe7576596f4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n##### z-index:auto 和 z-index:0 层叠关系\r\n\r\n设置为`auto`和`0`后，后出现的覆盖前面的；\r\n\r\n\r\n\r\n\r\n\r\n#### 4.浮动\r\n\r\n\r\n##### 浮动会造成什么\r\n\r\n- 父元素高度塌陷\r\n- 与浮动元素同级的非浮动元素会填补原有位置\r\n\r\n##### 如何清除浮动的影响\r\n\r\n- 给父元素设置高度 `height`\r\n- 在浮动元素后面添加` clear:both`的空 `div` 或者`br`标签\r\n- 给父元素添加 `overflow:hidden` 或者 `auto` 样式\r\n- 使用`:after`在父元素末尾加一个点，并添加 `clear: both` 属性；\r\n\r\n##### 设置元素浮动后 display 值是多少\r\n\r\n自动变成`display:block`;\r\n\r\n\r\n#### 5.各种居中\r\n\r\n\r\n##### 水平居中方案\r\n\r\n-   行内元素，给其父元素设置`text-align:center`\r\n-   定宽块级元素，该元素设置`margin:0 auto`\r\n-   定宽块级元素，还可以用`绝对定位`设置和`left:50%`;加`margin-left:-1/2`宽度；\r\n-   不定宽块级元素，设置父元素为`flex`布局，子元素设置`margin:0 auto`即可\r\n-   不定宽块级元素，设置父元素为`flex`布局，且设置`justify-content: center`;\r\n-   不定宽块级元素，设置父元素为`position: relative`;子元素`position: absulote;left: 50%;transform: translateX(-50%);`\r\n\r\n\r\n##### 垂直居中方案\r\n\r\n-   若元素是单行文本, 则可设置`line-height`等于`父元素高度`\r\n-   定高块级元素，该元素设置`margin:auto 0`\r\n-   定高块级元素，可以用`绝对定位`+`top:50%`;+`margin-top`\r\n-   不定高块级元素，设置`父元素`为`flex`布局，`子元素`设置`margin: auto 0`即可\r\n-   不定高块级元素，设置`父元素`为`flex`布局，且设置`align-items: center;`\r\n-   不定高会级元素，可以用`绝对定位`和`transform`\r\n-   不定高块级元素，设置`父元素`为`table`布局，子元素`display: table-cell;vertical-align:middle;`\r\n\r\n##### 水平垂直居中方案\r\n\r\n- 子元素为块级元素，父元素`flex`布局，子元素设置`margin:auto`;\r\n- 子元素未知，父元素`flex`布局，设置`justify-content: center;align-items: center`;\r\n- 子元素用绝对定位，设置上下左右为`0`，`margin:auto`;父元素`position: relative`;\r\n- 子元素已知宽高，绝对定位 `left: 50%;top: 50%;`  再 `margin` 自己的负一半；或者 `transform: translate(-50%,-50%)`;\r\n\r\n#### 6.各种布局方案\r\n\r\n##### 两栏布局\r\n\r\n-   左`float`+ 右`margin`（左设置`固定宽度+向左浮动`，右边设置`margin-left`为左边的固定宽度；）\r\n-   左`fixed`+右`margin`\r\n-   双`float`+ 右`calc`\r\n-   双`inline-block`+右`calc`\r\n-   左`float`+右`BFC`，是利用了`BFC` 的区域不会与 `float` 的元素区域重叠的机制\r\n-   `最简单常用`：使用`flex`布局（`左定宽，右flex1`）\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2973a291ce314f1cbd4791408e8c60bc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n##### 三栏布局\r\n\r\n\r\n- 左右`float`+中`margin`：左右栏定宽并设置浮动，中间一栏设置左右两个方向的`margin`值且不设置宽度；（`中间一栏必须放在最后`）\r\n- 左右`绝对定位`+中`margin`：左右两栏设置绝对定位放左右，中间设置两个方面的`margin`值；\r\n- `圣杯布局`：父元素设置左右`padding`，子元素三栏都通过`float`浮动，通过负值`margin`进行调整\r\n- `双飞翼布局`：对圣杯布局的改进，取消了相对定位（`不了解的话文章有很多`）\r\n- 最简单的`flex`布局，左右设置`flex: 0 1 200px`;中间设置`flex:1;`父元素`flex`。\r\n\r\n\r\n#### 7.Flex\r\n\r\n##### flexbox（弹性盒布局模型）\r\n\r\n-   通常被称为`flexbox`，`flex`是`弹性布局`，是`CSS3`的一种布局方式，给子元素提供了空间分布和对齐能力。它由（`Flex Container`容器/`Flex item`项目成员）构成。\r\n-   `flex`布局的元素称为`Flex Container`容器，它的所有子元素都是`Flex item`项目成员；\r\n-   容器有两个轴线排列，水平轴和垂直轴，默认为水平轴排列；\r\n\r\n该布局模型的目的是提供一种更加高效的方式来对容器中的项目成员进行`布局`、`对齐`和`分配空间`。通常可用于`水平垂直居中`，`两栏`、`三栏布局`等的场景里\r\n\r\n##### 容器的 flex 属性\r\n\r\n-   `flex-direction`属性：有 `row | row-reverse | column | column-reverse` 等取值，决定主轴的方向（即项目成员的排列方向）。\r\n    -   `row`（默认值）：主轴为水平方向，起点在左端。\r\n    -   `row-reverse`：主轴为水平方向，起点在右端。\r\n    -   `column`：主轴为垂直方向，起点在上沿。\r\n    -   `column-reverse`：主轴为垂直方向，起点在下沿。\r\n-   `flex-wrap`属性：有 `nowrap | wrap | wrap-reverse` 等取值如果一条轴线排不下，如何换行。\r\n    -   `nowrap`（默认）：不换行。\r\n    -   `wrap`：换行，第一行在上方。\r\n    -   `wrap-reverse`：换行，第一行在下方。\r\n-   `flex-flow`属性：是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\r\n-   `justify-content`属性：定义了项目在主轴上的对齐方式（水平方向）。\r\n-   `align-items`属性：定义项目在交叉轴上的对齐方式（垂直方向）。\r\n-   `align-content`属性：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\r\n\r\n##### 项目成员的 flex-grow、flex-shrink、flex-basis 属性作用\r\n\r\n-   `flex-grow`：项目的放大比例，默认为`0`，即如果存在剩余空间，也`不放大`。\r\n    -   如果所有项目的`flex-grow`属性相等（`或都为1`），将等分剩余空间，如果有一个为`2`，那么它占据的剩余空间将比其他项目`多`；\r\n-   `flex-shrink`：项目的缩小比例，默认为`1`，即如果空间不足，该项目将缩小\r\n-   `flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（`main size`）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，也就是项目的本来大小。\r\n-   `flex`属性是`flex-grow`,`flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。该属性有两个`快捷值`：`auto (1 1 auto)` 和 `none (0 0 auto)`。\r\n\r\n\r\n如果设置 `flex:1`，就等于 `flex: 1 1 0`;设置 `flex:0`；就等于 `flex: 0 0 0`;\r\n\r\n##### 子元素均设置 flex 1 宽度是否一样\r\n\r\n- `Flex 1` 相当于 `flex: 1 1 0`；项目占的主轴空间为`0`，所以平分；\r\n- **但是**：如果子元素有`padding`属性的话，元素占的地方会被增加；\r\n- 如果子元素有`margin`属性的话，元素的宽度不变，但是`content`内容的宽度变小；\r\n\r\n##### **使用时应该注意些什么？**\r\n\r\n\r\n-   在父级元素设置为`flex`布局后，子元素的`float`、`clear`、`vertical-align`属性都将失效，所以在使用`flex`布局时，不应该先设置完子元素布局后再使用。\r\n\r\n#### 8.伪类和伪元素\r\n\r\n> `css`引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分\r\n\r\n##### 伪类\r\n\r\n> `伪类`存在的意义是为了通过选择器找到那些不存在`DOM`树中的信息以及不能被常规`CSS`选择器获取到的信息\r\n\r\n##### 伪元素\r\n\r\n> 伪元素用于创建一些不在文档树中的元素，并为其添加样式。\r\n> \r\n> 比如说，我们可以通过`:before`来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。\r\n> \r\n> 常见的伪元素有：`::before`，`::after`，`::first-line`，`::first-letter`，`::selection`、`::placeholder`等\r\n\r\n##### 区别\r\n\r\n> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素，`伪元素是::双冒号`\r\n\r\n##### CSS3新增伪类\r\n\r\n-   `p:first-of-type` 选择属于其父元素的首个元素\r\n-   `p:last-of-type` 选择属于其父元素的最后元素\r\n-   `:enabled :disabled` 表单控件的禁用状态。\r\n-   `:checked` 单选框或复选框被选中。\r\n\r\n\r\n#### 9.position定位\r\n\r\n-   `absolute`：生成`绝对定位`的元素，相对于 `static` 定位以外的第一个父元素进行定位\r\n-   `fixed`：生成`固定定位`的元素，相对于`浏览器窗口`进行定位\r\n-   `relative`：生成`相对定位`的元素，相对于其`正常位置`进行定位\r\n-   `static` 默认值。没有定位，元素出现在正常的文档流中\r\n-   `inherit` 规定从父元素继承 `position` 属性的值\r\n-   `sticky` 粘性定位，适用于浏览器滚动到一定高度时，让一部分内容固定；\r\n\r\n##### position: fixed什么时候会失效？\r\n\r\n-   若是设置了`position: fixed`属性的元素，它的上级元素设置了`transform`任意属性则会导致固定定位属性失效。\r\n-   注意，这个特性表现，目前只在`Chrome`浏览器/`FireFox`浏览器下有。\r\n\r\n\r\n#### 10.display属性\r\n\r\n##### display属性的几个取值\r\n\r\n-   `block` 转换成块状元素。\r\n-   `inline` 转换成行内元素。\r\n-   `none` 设置元素不可见，从文档流中移除。\r\n-   `inline-block` 元素像行内元素一样显示，但元素的内容像块类型元素一样显示。\r\n-   `list-item` 像块类型元素一样显示，并添加样式列表标记。\r\n-   `table` 作为块级表格来显示\r\n-   `inherit` 表示从父元素继承 `display` 属性的值\r\n\r\n##### display:inline-block 为什么会显示间隙\r\n\r\n因为原来`HTML`代码中的`回车换行等`被转成一个空白符，在`字体不为0`的情况下，空白符占据一定宽度，所以`inline-block`的元素之间就出现了空隙\r\n\r\n##### 如何消除 display:inline-block 的间隙\r\n\r\n-   移除空格\r\n-   使用`margin`负值\r\n-   使用`font-size:0`\r\n-   `letter-spacing`\r\n-   `word-spacing`\r\n\r\n#### 11.CSS选择器权重 & 优先级\r\n\r\n##### 优先级权重\r\n\r\n**选择器**  | **优先级权重** |\r\n| -------  | --------- |\r\n| id选择器   | 100       |\r\n| 类选择器      | 10        |\r\n| 属性选择器   | 10        |\r\n| 伪类选择器   | 10        |\r\n| 标签选择器        | 1         |\r\n| 伪元素选择器      | 1         |\r\n| 相邻兄弟选择器     | 0         |\r\n| 子选择器        | 0         |\r\n| 后代选择器        | 0         |\r\n| 通配符选择器      | 0         |\r\n\r\n\r\n##### 注意点\r\n\r\n1.  `!important`声明的样式优先级最高，如果冲突再进行计算。\r\n1.  如果优先级相同，则选择最后出现的样式。（`后出现的覆盖之前的`）\r\n1.  继承得到的样式的优先级最低。\r\n2.  不同来源下：`内联样式` > `内部样式` > `外部样式` > `浏览器用户自定义样式` > `浏览器默认样式`。\r\n\r\n\r\n#### 12.隐藏元素的方法\r\n\r\n##### CSS属性来隐藏元素的方法\r\n\r\n-   `visibility: hidden`： 这个属性只是简单的隐藏某个元素，元素继续占用空间，`不可交互`\r\n-   `display: none`： 元素会变得不可见，元素从文档流中消失，不再占用文档的空间，`不可交互`\r\n-   `opacity: 0`：本质上是将元素的透明度设置为`0`，就看起来隐藏了，但是依然占据空间且`可以交互`\r\n-   `position: absolute`： 设置一个很大的 `left负值`定位，使元素定位在可见区域之外\r\n-   `transform: scale(0)`： 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留，但`不可交互`；\r\n-   `height: 0`： 将元素高度设为 `0`\r\n\r\n##### opacity: 0、visibility: hidden、display: none 优劣和适用场景。\r\n\r\n-   **从结构上看**：\r\n    -   `display:none` 不显示对应的元素，在文档布局中不再分配空间（回流+重绘） ，内容不可见，不可点击\r\n    -   `visibility: hidden` 隐藏对应元素，在文档布局中仍保留原来的空间（重绘），内容不可见，不可点击\r\n    -   `opacity: 0` 隐藏对应元素，在文档布局中仍保留原来的空间（重绘），内容不可见，可以点击\r\n-   **从继承上看**：\r\n    -   `display: none` 和 `opacity: 0` 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。\r\n    -   `visibility: hidden` 是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible` 可以让子孙节点显式。\r\n\r\n\r\n##### rgba() 和 opacity 的透明效果比较\r\n\r\n-   `rgba()`和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度，\r\n-   而`rgba()`只作用于元素的颜色或其背景色。（设置`rgba`透明的元素的子元素不会继承透明效果！）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 13.动画 & 过渡效果\r\n\r\n\r\n##### animation\r\n\r\n-   `css3`的`animation`是css3新增的动画属性，这个`css3`动画的每一帧是通过`@keyframes`来声明的，`keyframes`声明了动画的名称，通过`from`、`to`或者是百分比来定义\r\n\r\n##### transform\r\n\r\n-   `transform`主要用于给元素做变换,主要由以下几种变换,`rotate`(旋转),`scale`(缩放),`skew`(扭曲),`translate`(移动)和`matrix`(矩阵变换).\r\n-   `transform`本身是没有过渡效果的,它只是对元素做`大小`、`旋转`、`倾斜`等各种变换,通过和`transition`或者`animation`相结合,可以让这一变换过程具有动画的效果\r\n\r\n**transition 和 animation 以及 transform 的区别**\r\n\r\n-   `transform` 本身没有动画效果，它实现动画需要依赖其余两者\r\n-   `Animation`和`transition`大部分属性是相同的，他们都是随时间改变元素的属性值\r\n-   `transition` 设置的是 `css` 属性变化时的过渡动画，而 `animation` 动画会自动执行； `transition` 定义的动画触发一次执行一次，想再次执行就需要再次触发；`animation` 可以执行指定次数或者无数次；\r\n-   ` transition`定义的动画只有两个状态,开始态和结束态,`animation`可以定义多个动画中间态,且可以控制多个复杂动画的有序执行.\r\n\r\n##### 如何优化动画性能\r\n\r\n-   尽量减少`js`动画，如需要，使用对性能友好的 `requestAnimationFrame`\r\n-   开启硬件加速\r\n-   使用 `css3` 的 `transform` 代替`left`、`top`减少使用引起页面重排的属性：（该CSS属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改CSS 可视格式模型的坐标空间来实现的。）\r\n-   `requestAnimationFrame()` 方法，会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成\r\n-   `requestIdleCallback()` 方法，它指定只有当一帧的末尾有空闲时间，才会执行回调函数。\r\n\r\n##### **手写动画的最小时间间隔是多久**\r\n\r\n多数显示器默认频率是`60Hz`，即`1秒刷新60次`，所以理论上最小间隔为`1/60＊1000ms ＝ 16.7ms`。\r\n\r\n##### transform 的 rotate translateX 先后顺序有何不同？\r\n\r\n如果先旋转再平移的话，会按照旋转后的坐标系进行平移。哪个在前就先执行。\r\n\r\n\r\n#### 14.link和@import\r\n\r\n\r\n-   `link`可以放在`html`任意位置，`@import`一定要写在除`@charset`外的其他任何 `CSS` 规则之前，并且`@import`之后的分号必须书写不可省略；（不符合就不会生效且不报错）\r\n-   `link`的内容会被并行加载，`html`内的`@import`也会被并行加载，但是`link`内的`import`需要等到页面加载完后才会加载（可能会导致页面跳一下`FOUC`）\r\n-   `@import`需要 `IE5` 以上才能使用，`link`作为`html`标签没有兼容问题；\r\n-   `link`可以使用 `js` 动态插入，`@import`也可以通过`js`插入，但是比较麻烦；需要新建一个`style`标签，在`style`标签里面再注入`import`指令再`插入`到页面上；\r\n-   导入方式并不会影响`样式权重规则`\r\n-   都会阻塞`页面渲染`，同样支持媒体查询；\r\n\r\n\r\n#### 15.像素单位\r\n\r\n##### px、em、rem、vw、vh\r\n\r\n-   `px`：绝对单位，页面按精确像素展示。\r\n-   `em`：相对单位，`基准点为父节点字体的大小`，如果自身定义了`font-size`按自身来计算（浏览器默认字体是`16px`），整个页面内`1em`不是一个固定的值。\r\n-   `rem`：`以根元素的字体大小为基准`。例如`html`的`font-size: 16px`，则子级`1rem = 16px`。\r\n-   `vw`和`vh`：都是针对当前浏览器窗口大小而言，`1vw` 就等于可视窗口宽度的百分之一，`1vh` 就等于可视窗口高度的百分之一。\r\n\r\n##### 移动端开发为什么需要二倍图\r\n\r\n因为逻辑像素（CSS）和 物理像素不相等，苹果有的是320物理像素，有的是640物理像素\r\n\r\n\r\n\r\n#### 16.杂问题\r\n\r\n\r\n##### 绘制三角形\r\n\r\n```css\r\nwidth: 0;\r\nheight: 0;\r\nborder: 50px solid transparent;\r\nborder-bottom-color: blue;\r\n```\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83d259f6ca894251aec8e4ec22a0c8a0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n##### 绘制扇形\r\n\r\n\r\n```css\r\nborder: 50px solid transparent;\r\nwidth: 0;\r\nheigt: 0;\r\nborder-radius: 50px;\r\nborder-top-color: blue;\r\n```\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5be38bac250477ca300154f45d1e3d4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n##### 如何实现小于12px的字体效果\r\n\r\n我们用`css`设置字体大小为`12px`及以下时，显示都是一样大小，都是默认`12px`。\r\n\r\n> `transform:scale()`这个属性只可以缩放可以定义宽高的元素\r\n> \r\n> 而行内元素是没有宽高的，所以对于行内元素设置小于`12px`，我们可以加上一个`display:inline-block`;\r\n\r\n```\r\ntransform: scale(0.7);\r\n```\r\n\r\n\r\n##### 元素竖向的百分比设定是相对于容器的高度吗\r\n\r\n- 当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的\r\n- 但是，对于一些表示竖向距离的属性，例如 `padding-top` , `padding-bottom` , `margin-top` , `margin-bottom` 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。\r\n\r\n\r\n##### 文本超出显示省略号\r\n\r\n```\r\noverflow: hidden;\r\ntext-overflow: ellipsis;\r\nwhite-space: nowrap;\r\n```\r\n\r\n##### line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）\r\n\r\n-   `带单位`：`px` 是固定值，而 `em` 会参考父元素 `font-size` 值计算自身的行高\r\n-   `纯数字`：会把比例传递给后代。例如，父级行高为 `1.5`，子元素字体为 `18px`，则子元素行高为 `1.5 * 18 = 27px`\r\n-   `百分比`：将计算后的值传递给后代\r\n\r\n##### CSS 中的`background-image` 属性可以和 `background-color` 属性一起生效么？\r\n\r\n目前来看可以生效，且`background-image`在`background-color`上。\r\n\r\n\r\n##### ackground-size: cover和contain 区别\r\n\r\n-   `cover`：缩放背景图片以完全`覆盖`背景区，可能背景图片部分看不见。\r\n-   `contain`：缩放背景图片以完全`装入`背景区，可能背景区部分空白。\r\n"
    },
    {
        "article_id": "7126100960593575949",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b71db5b68d49419a686d926e58df70~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端工作一年半，离职了！！！",
        "preview": "哈喽~，大伙儿好久不见。今天爬上来唠唠，是因为最近向公司主动提出离职了，这几天刚办理完。这是小鹿的第一份工作，算是正式画上了一个句号，我觉得有很多经历需要在这里记录分享一下。 从 2020 年 8 月",
        "author": "程序员小鹿",
        "view_count": 83467,
        "collect_count": 113,
        "comment_count": 190,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/71175455eb2ef6f4f67065569e6304dc~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: juejin\r\n---\r\n> 前段时间写的一篇文章，一直没有更新，最近工作节奏慢下来了，就爬上来更新一波。\r\n\r\n哈喽~，大伙儿好久不见。今天爬上来唠唠，是因为最近向公司主动提出离职了，这几天刚办理完。这是小鹿的第一份工作，算是正式画上了一个句号，我觉得有很多经历需要在这里记录分享一下。\r\n\r\n从 2020 年 8 月 4 日入职老东家起，到 2022 年 4 月15 日正式离职，已经有一年半左右的时间了。在这短短的一年半时间里发生了很多的事情，业务的改变，人员的变动，自我的成长，也经历了一个创业公司从初期到中期的发展。\r\n\r\n在这里想总结一下，这过去的一年半时间里，能够影响到我以及改变到我的东西。那就按照时间线来吧~\r\n\r\n## 1、初入职场\r\n\r\n从学校到职场，我的第一个想法就是能够尽快让自己成长起来，无论是技术能力、思考能力、沟通能力以及其他能力等等，这将影响到我以后的路好不好走。所以在疫情之下，就很幸运的入职了老东家。\r\n\r\n\r\n初入职场避免不了经常犯错误，把 git 分支玩坏，代码提交不规范，逻辑思路混乱这是常常犯的低级错误。\r\n\r\n\r\n正是由于 leader 和前辈给了很多包容和让我试错的机会，也在短时间之内逐渐成长了起来，慢慢的适应了当下的环境，逐步对自己有了更高的要求。\r\n\r\n\r\n其实这段时间是自我成长最快的一段时期。\r\n\r\n## 2、出差\r\n\r\n待了半年左右，老东家正好有一个出差的项目要去面对面和客户负责，当时内部也是比较缺人，所以主动申请了。\r\n\r\n\r\n其实我心里也没底能不能把这次任务做好，只是觉得机会是很难得，所以就争取了下来。\r\n\r\n\r\n在出差的这三个多月里，对公司的产品有了更进一步的了解，也对这个金融行业有了更深的认识，当然个人的沟通协调能力也得到了大幅度的提升，也逐渐总结出了自己处理事情的方式和方法，这让我在接下来的发展中能够更加顺利。\r\n\r\n\r\n在提高能力和学到知识的同时，老东家也给了我许多的激励和奖励。也许就在这一刻，我感受到自己的巨大成长，逐渐能够担任技术之外的一些责任。\r\n\r\n## 3、迷茫\r\n\r\n成长的同时伴随着迷茫的产生，我在哪？我是谁？我要干什么？\r\n\r\n有一段时间，我突然陷入了一个低谷期，不知道下面的路如何走，这也是我最焦虑的一段时间。\r\n\r\n\r\n站在现在的角度去看当初，其实这个低谷期就是从一个山峰到另一个山峰中间的山谷。引用温伯格大牛在《如何成为技术领导者》书中提到的提高能力的两种模式，一种叫做渐进模式，另一种叫做跃迁模式，而上述所提到的就是跃迁模式结构。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a671de53e4a499499e9b87536aee891~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n就是每当你进行新的挑战时，一开始能力水平是低于之前上一个挑战能力水平的，但是当你逐渐的去训练自己，慢慢的把能力提升上来之后，就会超过于上一次挑战获得的能力水平。\r\n\r\n\r\n突破迷茫的关键点在于如何寻找更大挑战的事情。\r\n\r\n\r\n## 4、裁员\r\n\r\n到了 21 年年底，公司迎来了第一次大规模裁员。如果你问我当时慌不慌，说实话，已经做好被裁的准备，因为应对黑天鹅最好的办法就是提高自己反脆弱的能力。（给大伙儿推荐《反脆弱》这本经典书籍）\r\n\r\n\r\n当然，像裁员这波操作其实很多人可以提前做出决策，这就要分析创业公司整个发展过程以及遇到的实质性障碍是什么，大约会发展到什么阶段会出现裁员（疫情虽然有影响，但是关键并不是外界环境所致），这个有机会会单独写一篇跟大伙儿唠唠~\r\n\r\n\r\n这次裁员，走了一些之前一起合作的同事，公司业务和结构也发生了很大的改变，这一次的变动让我更加明白自己想要什么，想要往哪个方向发展和提高。\r\n\r\n\r\n## 5、离职\r\n\r\n\r\n4 月初，我正式提出离职。也许这个想法在我心内争斗了许久，最后还是决定了。离职的原因很简单，自我优化。\r\n\r\n\r\n\r\n其实一开始入职的时候就想过，当我不能够为公司提供更多的价值以及自己能力在当下环境不能够得到提升，就要考虑换个环境了，越早跳出舒适圈，对自己来说是有利的。\r\n\r\n\r\n还有一个比较重要的原因就是做的事情要有长期的价值。这不得不让我想起一个比较有思考性的问题。\r\n\r\n\r\n在这里想问一下大伙儿，在这个互联网时代，我们所拿到的薪资水平真的和自己的能力所匹配么？你怎么判定自己所产生的的价值是多少？\r\n\r\n\r\n\r\n当然，当我们面对“价值”两个字时，不同的角度会有不同的认定，比如站在公司角度，可能会受到利益的驱动，从而会否定你产生的价值。如果站在客户角度，增加了他的办公效率，可能会认可你所产生的价值。\r\n\r\n\r\n你到底产生多少有用的价值，其实这一点很值得我们每个人去思考。后续在写面试系列的文章中会重点说一下“工作价值”在面试过程中体现出来的作用。\r\n\r\n\r\n## 小结\r\n\r\n过去的已经过去吧，未来还有很长一段路要走。坚持自己学技术的初衷，希望能够为社会发展带来一点点的作用。在工作的同时不断寻求属于自己的出路，争取有一天能够摆脱打工人的角色。\r\n\r\n加油:)\r\n\r\n"
    },
    {
        "article_id": "7153661619787005989",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6041c6fc3e474414b3dc04f84647f504~tplv-k3u1fbpfcp-watermark.image?",
        "title": "🤔为什么需要前端工程师？",
        "preview": "互联网行业都将会处于一个价值回归的状态。每个在互联网行业中的职业，都比以往更加需要知道 **职业和个人的核心竞争力** - 企业为什么需要前端工程师？ - 当前国内环境下，前端工程师的核心竞争力是什",
        "author": "YeeWang",
        "view_count": 12242,
        "collect_count": 82,
        "comment_count": 46,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/0a1ab6b583553b06200d521b15a14438~300x300.image",
        "category": "前端",
        "content": "之前我在[《如何看待技术匠心》](https://yeee.wang/posts/3469.html) 的文章中提到，今后的一段时间中，互联网行业都将会处于一个价值回归的状态。每个在互联网行业中的职业，都比以往更加需要知道 **职业和个人的核心竞争力**。\r\n\r\n- 企业为什么需要前端工程师？\r\n- 当前国内环境下，前端工程师的核心竞争力是什么？\r\n- 如何创造更多前端岗位？\r\n\r\n这几个问题我思考了很久，其背后所代表的目的是一样的。前端开发者，如何能够在这个洪流涌动的时代中更有竞争力。\r\n\r\n**当然，本文所提到的观点不一定正确，纯粹个人见解。**\r\n\r\n\r\n### 从何而来？\r\n\r\n搞清楚这个问题之前，不如来看看早些时候，这个职业是从何而来？\r\n\r\n其实早些年是没有前端工程师这个职业的，和这个职业最相关的应该是网页设计师，大家大多叫做 “切图仔”。主要工作就是把设计稿的图片转换成 html，将图片变成网页；过程就好像是拿美工刀把图片一片片切割下来，再拼成 html 的网站，所以俗称 “切图”。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3774c5463f41e89ee3fca205bf2905~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n大家都知道一个完整的网页主要是由3个部分：html, css, js \r\n\r\n那时网页设计师最常用的工具其实是设计软件：Adobe Dreamweaver、Microsoft FrontPage，所见即所得的GUI操作方式来设计网页的布局、样式、内容，这些主要是 html  和 css 部分。\r\n\r\n这是那个时候，网页设计师被雇佣所要处理的工作，也是网页设计师的价值体现。\r\n\r\n其实在这段时间内，从图片转换到 html 的工作还是处于一个边界模糊的状态，有的公司会划分这部分内容给设计师，因为他们可以随时调整；有的公司会划分这部分内容给 Web工程师（PHP、ASP工程师），因为他们转换的产物会更加精准。\r\n\r\n后来，随着浏览器技术的不断变革、多端设备的普及、网络条件的提升，这给Web这一终端提供了巨大的提升空间，同样也带来了更高的专业要求。\r\n\r\n一个有经验的Web开发者 和 一个刚入门的Web开发者，所做出来的产品逐渐表现出了巨大的体验差异。\r\n\r\n互联网企业们才逐渐关注到 Web 除了传递信息以外，还有兼容性、SEO、网站性能、动画效果、响应式等方面的价值。\r\n\r\n于是**部分公司**专门设立了 “前端工程师” 这一岗位，专门来解决网页开发、动效制作、性能调优、兼容性等诸多事务。\r\n\r\n但这一时期，可以感觉到前端的必要性依旧不是很高，对于部分对 Web端要求不是很高，或者拥有资深网页开发经验的后端工程师们（PHP、ASP工程师），大多百度查一查，多花点时间也一样能搞个七七八八。\r\n\r\n再后来，\r\nNode.js 出现了；\r\nWebpack 出现了；\r\n五花八门的DSL (.vue,.tsx,.scss,.less,.ts)出现了；\r\n各种跨端技术出现了；\r\n\r\n头部前端开发者们：哇，这MVVM；哇，这模块化；哇，这自动化；哇，这热更新；这要是做一套组件库，能省多少事啊！\r\n\r\n生产力前端开发者们：这有个新组件库！哇，看着好炫酷；哇，好现代的交互；怎么用？恩？什么是 React？ 什么是 Vue ？\r\n\r\n技术管理者们：哇，这东西，这么炫的吗。这要是盘下来，咱们的项目维护成本不是一下子就下来了么，交付的产品不是一下子就专业了么。（下次跟老板汇报又有吹的了）\r\n\r\n企业管理者们：咱们的愿景是，国内一流的XXX。“可是你们的产品看着好LOW，某某“小而美”的产品就很现代。” CTO：你去研究一下他们的技术方案。\r\n\r\n小公司：老板，咱们追吧？现在投资人看到的产品都老酷炫了，咱们这个根本入不了眼，包装还是要包装一下的。\r\n\r\nWeb开发者（PHP、ASP工程师）：蓦然回首，啥！这都是啥！老板，这活干不了。找个专业点的人进来吧。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96355c5c22a443068f003910e9e7b67d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n于是就有了： \r\n>岗位要求：  \r\n>1. 本科或以上学历，计算机或相关专业；  \r\n>2. 至少X年以上web前端开发经验；  \r\n>3. 精通react框架、HTML5、CSS3、Javascript、等Web前端开发技术。 \r\n>4. 熟悉前端常用的构建工具（如：webpack ），熟悉使用 Git 工具；\r\n\r\n### 职业本质\r\n\r\n>幻觉主宰着大家放大一些关注点，视而不见一些本来该是问题的问题。\r\n\r\n在过去的5-10年里，整个互联网行业都涌入了大量的从业者。各个互联网巨头以垄断式的方式抢夺人才，许多应届生莫名其妙的就倒挂了一些老员工。问为什么？没有为什么，其他公司就开了这个薪资。\r\n\r\n或许在过去的很长一段时间内，涌入这个行业的从业者们可能都没有想过，或者也是没有功夫去想。这个职业，在解决公司什么环节的问题，在解决社会哪部分的问题。\r\n\r\n在这个增速放缓，价值回归的时期里，或许大家可以静心思考下上述问题，本文抛砖引玉，欢迎更多有见地的开发者们评论回复。\r\n\r\n首先我的观点是：**前端工程师是一个翻译性质的结构洞岗位（各领域连接节点）**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caa6f3f1cfbf45f9addc03cf86303adf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n从前端职业的发展历程我们可以了解到，前端从一开始就在做把不同领域的事情整理、转换、展示的事情。\r\n\r\n从某种意义上讲，前端工程师更像是一个 **翻译师**，将人类所能理解的内容，利用编程语言翻译给各个终端（APP、浏览器、小程序），再把这些信息序列化后存储、发布到服务器，通过网络传递给任何需要这部分信息的终端中重新展示，然后被另外一群人理解。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45228175b60c4b0b812d13dada0eadd0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果纯粹从信息传递的角度来看，人类的目前所有用于传递信息的方式都是低效的。\r\n\r\n语言、文字、图片、表情，创造这些工具的目的都是为了让人们在沟通时，能够理解相互之间所要表达的内容、感受、情绪。所以，如果未来脑机接口真正普及，世界或许会消失很多东西，语言、文字、画面、前端或许都没有意义，因为信息传达不再需要翻译。\r\n\r\n但目前来说，人们需要信息传递，互联网是当下最高效的传递方式，信息通过互联网传递需要终端显示，终端显示需要信息转换，信息转换需要前端工程师，所以企业、社会需要前端工程师（或者任何能完成这项工作的职业）。\r\n\r\n所以我认为，衡量前端的标准，就是衡量翻译的标准：\r\n\r\n- **翻译的快不快（效率）**\r\n- **翻译的准不准（转化率）**\r\n- **翻译的符不符合语境（调性）**\r\n\r\n当下，许多前端工程师会把自己的定位理解成 “程序员” 的一个分支，认为自己的工作就是个写代码的，和后端相比只是写的语言不同。\r\n\r\n所以除了代码以外的事情一律不管，什么界面好不好看、什么文字是不是符合语境、什么交互是不是合理，那些应该是产品和设计考虑的事情，我只需要把设计稿变成网页，把接口调通就可以。许多中层管理者也会把前端和那些服务端开发者们拉在一起横向比较，所衡量的指标也是：业务表现、稳定性、点击率 等等，这些有没有都无关痛痒的指标。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491cbbe18a4b4fdbaaa31f088231600d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这些现象之所以会在近几年表现的如此明显，是因为这个行业涌入了许多迷茫从业者，许多认为这是一条赚钱的好路子的从业者。\r\n\r\n在培养了4、5年算法、数学，刷LeeCode后进入社会的科班生，他们主导这个职业的漏斗，当然是程序员那套路子，面试题逐渐变成了算法、协议、隐秘的框架特性这些八股文🤒。现在我几乎很少看到有企业会出 html/css 的题目，但前端的职业定位并不是一个单纯的程序员，如果单从程序员的竞争力来看，前端是不可能超过一个后端开发者的，这也不是企业雇佣前端的核心价值。\r\n\r\n前端这项职业，既然是站在结构洞上，**最大的竞争力就应该是充分发挥结构洞所代表的特性和价值**，充分融合、连接各种领域的优点，然后转换体现在产品上面。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d66ad8cd6114f8db1f03ba00f5e0801~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这对前端的要求就不仅是在编码层面的能力了，一个符合互联网综合性要求的前端岗位应该拥有以下几方面能力：\r\n\r\n- **有审美**，了解用户体验法则，懂得现代Design System (!important)\r\n- 了解当代主流设备的 **Web应用差异及渲染方案**，能够 **实现各端界面开发**\r\n- 了解 **网络协议**，浏览器特性等终端传输转换原理\r\n- 了解 **现代前端工程化工具**，帮助企业能够更规范、更稳定、更高效的产出\r\n- 了解互联网 **主流产品运行规则**，这里包含SEO、语义化、META等\r\n- 了解当代 **后端应用部署方案** 和 **攻防手段**，包含CDN、Docker、SSR 等等等等\r\n- **会做人，会换位思考，有责任心**，能够照顾市场、企业、项目质量等各方利益\r\n- **会表达**，能够简短、清晰、完整的表达内容，毕竟招你就是来做表达的\r\n\r\n很多读者看到这不仅拍桌子了。好家伙，公司所有活你一个人干了得了，CEO你来当！这哪是前端啊！\r\n\r\n但回顾下整个前端的发展史，这是一个发展了才没几年的职业。在当下，这一个职业做的事情本来就不是什么需要多么资深研究才能做到的事情，**这是一个需要广度、需要审美、需要持续的热情、需要应对变化、需要对着丑陋拍桌子说不的职业。** 一个企业或许需要创造框架的技术性人才，但不是每个团队都需要。\r\n\r\n前端这些年之所以发展的这么火热，正是因为站在 **互联网热潮** 的 **结构洞** 上。许多已经发展到近乎死水的技术领域，因为有前端的跨界融合发生了改变，前端工程师们既可以写界面、又可以写脚本、还可以写接口、老板夸两句还能造个APP出来 😂。这对于老板来说简直是冬日里的小棉袄，互联网界的瑞士军刀啊！\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec046386a7b043599cd9f503705a1d55~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这是前端近年火热的关键，因为前端在结构洞上，他们可以了解各个领域的事情，他们懂审美懂设计，他们可以高效的摆平许多事情。\r\n\r\n反过来站在企业的角度上看，需要招一个前端团队，来解决的 **最基本诉求是界面开发，能够将公司运转的逻辑、数据、情绪表达出来。**\r\n\r\n如果发现招来的前端，界面做的奇丑无比；从他身上找不到一点时尚、朝气；面对各端设备只会说 \\\"这个做不到\\\"；这样的前端对于企业来说，或许真的没有太大的必要，这种程度的网页开发，或许找一个后端🤓 逼他一把 把他变成全栈，应该也可以 Cover 了💅\r\n\r\n### 做点改变？\r\n\r\n如果你不认同上述观点也是正常，毕竟我的资历尚浅，算是阶段性总结，抛砖引玉，可以在评论区留下你的见解，尊重深度思考。\r\n\r\n如果你也认同上述观点，觉得上述思考对你有帮助，或许我们需要总结一些告诫出来。\r\n\r\n--- \r\n\r\n如果你是初期前端开发者，我建议你慎重的思考一个问题，进入这个行业是不是你心之所向？你是否能在接下来很长一段时间内保持学习的热情？\r\n\r\n如果不是我建议你慎重考虑进入这个行业，这个行业已经不是那么容易捞钱了，并且在接下来一段时间内会变的更难，如果你没有足够的热情，或许真的会搭一个黄金年华进去，等到30好几再寻求出路。\r\n\r\n--- \r\n\r\n如果你是中、高级前端开发者，我建议你能够在繁忙的工作中，抽出时间多做总结和思考。\r\n\r\n不光关于技术，而是像这样的职业思考、行业思考、人生思考，想想清楚自己的核心竞争力和职业规划，尝试写下来。\r\n\r\n你必须要想想接下来一段时间里，或许不再是顺风顺水，如果有一天自己没了工作，还能用什么换得酬劳？\r\n\r\n如果有，就有意识的培养那项技能，让它默默生长；如果没有，抓紧时间寻找到它。\r\n\r\n因为那些东西才是你光环褪下的核心价值。\r\n\r\n--- \r\n\r\n如果你是技术管理者，想清楚团队在公司大图的位置，企业希望这支团队处理哪些工作，再决定团队的发力方向。\r\n\r\n**团队的价值及影响力，需要整个团队抱元守一的长期打磨，不是一两个 几个月就能做完的明星项目。** \r\n\r\n团队多招几个人，今年多晋升几个能如何，失去团队的核心竞争力一样会被干掉。圈地圈资源，圈的越多砍的越多。\r\n\r\n**技术团队需要体现出职业的专业度，团队的特殊性和积极的参与度**。一如既往的高品质、高效率、高凝聚就是团队的护城河，长期打磨的产品才是闪闪发光的团队名片。\r\n\r\n企业之所以一年比一年更苛刻的跟技术要业务数据，就是觉得 年年汇报375，产品反馈不相符，季季喊着缺人手，内耗比武心伤透。\r\n\r\n价值回归的时代，企业会逐步着手识别那些白兔团队。\r\n\r\n放下争名逐利，着手做点正确的事。\r\n\r\n--- \r\n\r\n如果你是企业经营者，建议你重新想想需要什么样的技术团队，给管理者明确的价值导向是非常重要的环节，开发者之间分工不同，定位不同，导向不同。\r\n\r\n作为企业都会有成熟的管理工具和衡量标准，但成熟的管理工具就有成熟的应对策略，清晰识别那些企业所真正需要的东西对于企业的长期发展来说是非常有必要的。\r\n\r\n如果你真的认为开发者可以像销售、运营团队使用业务数据指标来衡量，那开发者们就会变得像销售、运营团队那样，整天盯着数据，满口的业务指标，听上去好像是上下齐心的客户第一。\r\n\r\n但又想想，当初高薪招他们来是干什么的呢？🤔\r\n"
    },
    {
        "article_id": "7162105483338678280",
        "snapshot": "",
        "title": "NB的Github项目，看到最后一个我惊呆了！",
        "preview": "最近看到不少好玩的、实用的 Github 项目，就来给大家推荐一把。 中国制霸生成器 最近在朋友圈非常火的一个小网站，可以在线标记 居住、短居、游玩、出差、路过 标记后可生成图片进行社区分享，标记过的",
        "author": "艾小仙",
        "view_count": 24788,
        "collect_count": 354,
        "comment_count": 27,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/040d0508cdb175b7ed7ed39350583613~300x300.image",
        "category": "后端",
        "content": "最近看到不少好玩的、实用的 Github 项目，就来给大家推荐一把。\r\n\r\n# 中国制霸生成器\r\n\r\n最近在朋友圈非常火的一个小网站，可以在线标记 居住、短居、游玩、出差、路过 标记后可生成图片进行社区分享，标记过的信息会记录到本地存储。\r\n\r\n简化地图在保留了地缘相接特征的基础上把省级行政区域尽可能简化成了方框，一目了然，或许这也是他能火的原因之一了。\r\n\r\n地址：<https://github.com/itorr/china-ex>\r\n\r\nStar：1.1K\r\n\r\n还有一个全球版的，就不发了，在这个项目里能找得到。\r\n\r\n![中国制霸生成器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee22b7afa6241c6923fd29f789b121b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# Monocraft\r\n\r\n这是一个特殊的字体，像素风游戏我玩过，我不信有谁真的用这个字体去写代码，简直眼睛都要瞎了，它模拟的是我的世界游戏里面的字体。\r\n\r\n地址：<https://github.com/IdreesInc/Monocraft>\r\n\r\nStar：5.1K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74545c92c4494309bc170d0fb8d7d922~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# youtube-dl\r\n\r\nyoutube-dl是一个命令行工具， 可以让你从 youtube 或者国内一些其他的视频网站上下载视频，并且跨平台，Windows、Mac、Linux都支持。\r\n\r\n我试了下，B站的视频是可以支持，抖音无法下载。\r\n\r\n地址：<https://github.com/ytdl-org/youtube-dl>\r\n\r\nStar：114K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/275c6787a28b4c2481e5790213230199~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 90年代鼠标特效\r\n\r\n这个项目帮你找回童年网吧上网的感觉，支持我们那个年代一些花里胡哨的鼠标特效，比如🌈鼠标、emoj表情、鼠标影子、雪花效果，有一种回到QQ空间的感觉？\r\n\r\n地址：<https://github.com/tholman/cursor-effects>\r\n\r\nStar：2.3K\r\n\r\n![彩虹](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812ee4a8163643c7ba44bc72772a5801~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![影子](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b82296c19ad545139e4d4a33b58da206~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![雪花](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993789ebdebd4d7ab865c79ad1018acd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 有钱人模拟器\r\n\r\n一个React前端实现的简单网页，作者真的是有够无聊的，看着我的余额差点搞的我就辞职了。\r\n\r\n地址：<https://github.com/liust97/rich-simulator>\r\n\r\nStar：55（哈哈）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8936606f97624095807c029571808bcc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n作者这个网站还做了其他看起来挺无聊的东西，但是我觉得还不错。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fdc19fd07654f659f4d42d2ee5322d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 区块链视频网站\r\n\r\n这个不是一个开源项目，据说是一个基于区块链的视频网站，上去看了一下发现没有什么流量，最受欢迎的排序第一个你细品。\r\n\r\n地址：<https://odysee.com/>\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee871a7c53304df09234ddd3dc10e0ff~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# Bashly\r\n\r\nBashly 是一个 Ruby 编写的 Bash 脚本框架和生成器，通过简单的 YAML 配置我们就可以快速开发功能丰富的命令行工具。\r\n\r\n使用起来我试了下确实非常方便，提供一个简单的 YAML 文件，文件中提供我们的命令、子命令、参数等信息，然后执行`bashly generate`就可以生成脚本了。\r\n\r\n```\r\n name: download\r\n help: Sample minimal application without commands\r\n version: 0.1.0\r\n ​\r\n args:\r\n - name: source\r\n   required: true\r\n   help: URL to download from\r\n - name: target\r\n   help: \\\"Target filename (default: same as source)\\\"\r\n ​\r\n flags:\r\n - long: --force\r\n   short: -f\r\n   help: Overwrite existing files\r\n ​\r\n examples:\r\n - download example.com\r\n - download example.com ./output -f\r\n```\r\n\r\n地址：<https://github.com/DannyBen/bashly>\r\n\r\nStar：1.3K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8fe26d5f6234f7bac40857439d381d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# nginx-config\r\n\r\nNginx 是我们程序员绕不开的一个堪，对于不太熟悉的程序员来说，每次配置一次 nginx 都要去搜索一次配置，是不是你？\r\n\r\n这个开源项目给我们提供了一个可视化配置 Nginx 的方式，简直就是相见恨晚。\r\n\r\n整个配置方式包含3个部分，预设、网站配置、全局配置。\r\n\r\n预设针对网站类型，比如前端、PHP、单页面应用等。\r\n\r\n网站配置包含域名、HTTPS、PHP、路由、反向代理、日志等。\r\n\r\n全局配置包含HTTPS、安全、Python、反向代理、性能等。\r\n\r\n地址：<https://github.com/digitalocean/nginxconfig.io>\r\n\r\nStar：23.1K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35490e2628449c19c3ce1667350d1e9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 开源API管理工具\r\n\r\n这是一个开关的API管理工具，界面风格看着比较像换了颜色的Postman，能自定义主题，设置颜色、字体之类的，请求方式能支持Rest Api、GraphQL、WebSocket等等。\r\n\r\n地址：<https://github.com/hoppscotch/hoppscotch>\r\n\r\nDemo：<https://hoppscotch.io/>\r\n\r\nStar：48K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/369b71a7f12b4c0390b7a1f3fd7cb1a7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 自动化万能通用接口\r\n\r\n腾讯开源作品：APIJSON，一种专为 API 而生的 JSON 网络传输协议 以及 基于这套协议实现的 ORM 库。\r\n\r\n#### 对于后端\r\n\r\n-   提供万能通用接口，大部分 HTTP API 不用再写\r\n-   零代码增删改查、各种跨库连表、JOIN 嵌套子查询等\r\n-   自动生成文档，不用再编写和维护，且自动静态检查\r\n-   自动校验权限、自动管理版本、自动防 SQL 注入\r\n-   开放 HTTP API 无需划分版本，始终保持兼容\r\n\r\n#### 对于前端\r\n\r\n-   不用再向后端催接口、求文档\r\n-   数据和结构完全定制，要啥有啥\r\n-   看请求知结果，所求即所得\r\n-   可一次获取任何数据、任何结构\r\n-   能去除多余数据，节省流量提高速度\r\n\r\n地址：<https://github.com/Tencent/APIJSON>\r\n\r\nStar：13.9K\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85547754108a42f18d4fde223002a125~tplv-k3u1fbpfcp-zoom-1.image)"
    },
    {
        "article_id": "7166186331196882974",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a335c318f80e416089b139f598b7bf45~tplv-k3u1fbpfcp-watermark.image?",
        "title": "注释写的好✍️，文档不潦草👍！",
        "preview": "写「注释」的好处众所周知，但有时在实现一些「公共代码」后，还要编写「文档」，其中「注释」和「文档」的内容是大致相同的......",
        "author": "JustCarryOn",
        "view_count": 6539,
        "collect_count": 83,
        "comment_count": 9,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/6af99eb6fcbe90bcf09106d8e4b08879~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: scrolls-light\r\n---\r\n> 大家好，long time no see！这次聊一聊「注释」。写「注释」的好处众所周知，但有时在实现一些「公共代码」后，需要编写「文档」，其中「注释」和「文档」的内容是大致相同的，比如`param`和`returns`等(相信有不少同学试过把「注释」copy到「文档」中吧🌝)。So，有没有一种可能，直接把「注释」直接转化为「文档」呢？\r\n\r\n# 背景\r\n\r\n👨‍💼：一会抽空优化下**JsBridge**，写好注释！写好文档！\r\n\r\n> JsBridge：用于「Hybrid」开发模式下，「Native 原生」和「Web H5」之间通信。\r\n\r\n🧑‍💻：**JsBridge**里面几十个方法，写完注释还要写文档，得花不少时间。\r\n\r\n👨‍💼：你傻啊，不会用[TypeDoc](https://typedoc.org/guides/installation/)吗？\r\n\r\n🧑‍💻：就是那个根据「代码」直接生成「文档」的工具吗？我这就去试试！\r\n\r\n# TypeDoc\r\n\r\n**TypeScript**的「文档生成器」，通过读取**TypeScript源文件**，解析其中包含的注释，并为代码生成包含文档的「静态站点」。\r\n\r\n## 安装\r\n\r\n```\r\n$ npm install typedoc --save-dev\r\n```\r\n\r\n> 安装时，要注意对应项目的**typescript版本**。\r\n\r\nTypeDoc Version | TypeScript Version(s) |\r\n| --------------- | --------------------- |\r\n| 0.23            | 4.6 through 4.8       |\r\n| 0.22            | 4.0 through 4.7       |\r\n| 0.21            | 4.0 through 4.4       |\r\n| 0.20            | 3.9 through 4.2       |\r\n| 0.19            | 3.9 through 4.0\r\n\r\n## 使用方式\r\n\r\n**TypeDoc**提供两种了运行方式：\r\n- **Cli**\r\n- **Node Module**\r\n\r\n\r\n### Cli\r\n\r\n使用「命令行」运行时，有三种配置方式：\r\n\r\n1. 把所有参数添加在「命令」中：\r\n\r\n```\r\n$ typedoc --out docs src/index.ts\r\n```\r\n\r\n2. 使用**typedoc.json**（推荐）：\r\n\r\n在项目的「根路径」下创建**typedoc.json**。\r\n\r\n> ./typedoc.json\r\n```\r\n{\r\n    \\\"entryPoints\\\": [\\\"src/index.ts\\\"],\r\n    \\\"out\\\": \\\"docs\\\"\r\n}\r\n```\r\n\r\n3. 在**tsconfig.json**中配置:\r\n\r\n在**tsconfig.json**中的`typedocOptions`字段定义参数。\r\n\r\n```\r\n{\r\n    // ...\r\n    \\\"typedocOptions\\\": {\r\n        \\\"entryPoints\\\": [\\\"src/index.ts\\\"],\r\n        \\\"out\\\": \\\"docs\\\"\r\n    }\r\n}\r\n```\r\n\r\n### Node Module\r\n\r\n如果想要「动态配置」或者不使用**Cli**来运行**typedoc**，可以`require(\\\"typedoc\\\")`进行文档构建。\r\n\r\n```\r\nconst TypeDoc = require(\\\"typedoc\\\")\r\n\r\n// 初始化\r\nconst app = new TypeDoc.Application()\r\n// 读取 tsconfig.json\r\napp.options.addReader(new TypeDoc.TSConfigReader())\r\n// or 读取 typedoc.json\r\napp.options.addReader(new TypeDoc.TypeDocReader())\r\n// or 直接配置\r\napp.bootstrap({\r\n   entryPoints: [\\\"src/index.ts\\\"],\r\n});\r\n\r\nconst project = app.convert()\r\nif (project) {\r\n  const outputDir = \\\"docs\\\"\r\n  // 生成文档\r\n  await app.generateDocs(project, outputDir)\r\n  // 生成json\r\n  await app.generateJson(project, outputDir + \\\"/documentation.json\\\")\r\n}\r\n```\r\n\r\n具体的参数配置，👉 [传送门](https://typedoc.org/guides/options/)\r\n\r\n## 插件\r\n\r\n> 使用`plugin`字段扩展**TypeDoc**的能力。\r\n\r\n```\r\n{\r\n  // ...\r\n  plugin: ['typedoc-plugin-markdown'],\r\n}\r\n```\r\n\r\n默认情况下，**TypeDoc**只生成**html**的静态站点文档，如需**Markdown**格式，可添加**typedoc-plugin-markdown**，生成对应的**Markdown**文档。\r\n\r\n更多的官方插件，👉 [传送门](https://typedoc.org/guides/plugins/)\r\n\r\n> Tips: 在**npm**的[typedoc-plugin](https://www.npmjs.com/search?q=typedoc-plugin)关键字下可以找到更多插件。\r\n\r\n## 主题\r\n\r\n> 使用`theme`字段配置生成文档的主题。\r\n\r\n```\r\n{\r\n  // ...\r\n  \\\"plugin\\\": [\\\"typedoc-theme-hierarchy\\\"],\r\n  \\\"theme\\\": \\\"hierarchy\\\",\r\n}\r\n```\r\n\r\n使用主题时，要先添加进`plugin`中，再添加到`theme`中。\r\n\r\n更多主题，👉 [传送门](https://typedoc.org/guides/themes/)\r\n\r\n> Tips: 在**npm**的[typedoc-theme](https://www.npmjs.com/search?q=typedoc-theme)关键字下可以找到更多主题。\r\n\r\n# TSDoc\r\n\r\n**TypeDoc**不是万能的，“龙飞凤舞”的「注释」生成不了「文档」，或者生成后的「文档」阅读性很差。\r\n\r\n因此，这就要求我们✍️「注释」时要符合“规范”！\r\n\r\n没错，用别人的工具，就要遵守别人的规则，这个“规范”就是**TSDoc**。\r\n\r\n> **TSDoc**是标准化**TypeScript**代码中使用的文档注释，这样不同的工具就可以提取内容，而不会被彼此的标记混淆。\r\n\r\n通俗来说，**TSDoc**就是「微软」的一套「注释规范」，主要用于统一某些工具（除了**TypeDoc**外还有[**DocFX**](https://dotnet.github.io/docfx/)、[**API Extractor**](https://api-extractor.com/)等）对「注释」的识别，避免每个工具都搞一套自己的注释规范。\r\n\r\n## Tags（重点）\r\n\r\n> 正确使用**Tags**是写好注释的基础。\r\n\r\n标签名以 @ 开头，后面跟着使用「驼峰大小写的ASCII字母」。\r\n\r\n### kind\r\n\r\n**Tags**根据「类型」来区分，分三种：\r\n\r\n- **Block tags**\r\n- **Modifier tags**\r\n- **Inline tags**\r\n\r\n#### Block tags\r\n\r\n「块级」标签：\r\n\r\n1. 该**tags**作为一行中「第一个」出现的元素；\r\n2. 一行中仅允许该**tags**存在(很多**Block tag**都没遵守该约定)；\r\n3. 直至遇到下个**Block tags**前，都是该**tags**的内容；\r\n4. 第一个**Block tags**前面的内容为“摘要”；\r\n\r\n#### Modifier tags\r\n\r\n「修饰」标签：\r\n\r\n1. 内容为空的**Block tags**；\r\n2. 出现在注释底部；\r\n\r\n#### Inline tags\r\n\r\n「行内」标签：\r\n\r\n1. 与**Markdown**表达式一起作为内容元素出现；\r\n2. 被 **{ }** 字符包围；\r\n\r\n### Standardization\r\n\r\n**Tags**根据「兼容性」来区分，分三组：\r\n\r\n- **Core**\r\n- **Extended**\r\n- **Discretionary**\r\n\r\n#### Core\r\n\r\n每个「文档工具」都支持。\r\n\r\n#### Extended\r\n\r\n「文档工具」可能支持，也可能不支持，需要查阅该工具的文档。\r\n\r\n#### Discretionary\r\n\r\n针对某个/些「文档工具」而自身定制的**tags**。\r\n\r\n### 常用的Tags\r\n\r\n#### @alpha\r\n\r\n表示该**Api**的发布阶段为**alpha**。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Discretionary  | Modifier |\r\n\r\n```\r\nexport class Book {\r\n  /**\r\n   * The title of the book.\r\n   * @alpha\r\n   */\r\n  public get title(): string;\r\n};\r\n```\r\n\r\n#### @beta @experimental\r\n\r\n> beta与experimental同义\r\n\r\n表示该**Api**的发布阶段为**beta/experimental**。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Discretionary  | Modifier |\r\n\r\n```\r\nexport class Book {\r\n  /**\r\n   * The title of the book.\r\n   * @beta\r\n   */\r\n  public get title(): string;\r\n};\r\n```\r\n\r\n#### @internal\r\n\r\n表示该**Api**不计划供第三方使用。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Discretionary  | Modifier |\r\n\r\n```\r\nexport class Book {\r\n  /**\r\n   * The title of the book.\r\n   * @internal\r\n   */\r\n  public get _title(): string;\r\n};\r\n```\r\n\r\n#### @public\r\n\r\n表示该**Api**的发布阶段为**public**，代表已正式发布且稳定的（可省略）。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Discretionary  | Modifier |\r\n\r\n```\r\nexport class Book {\r\n  public get title(): string;\r\n};\r\n```\r\n\r\n#### @decorator\r\n\r\n由于**TypeScript**编译器并不能识别`.d.ts`中的「装饰器」，所以使用该**tag**在文档注释中引用**decorator**表达式。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Block |\r\n\r\n```\r\nclass Book {\r\n  /**\r\n   * The title of the book.\r\n   * @decorator `@jsonSerialized`\r\n   * @decorator `@jsonFormat(JsonFormats.Url)`\r\n   */\r\n  @jsonSerialized\r\n  @jsonFormat(JsonFormats.Url)\r\n  public website: string;\r\n}\r\n```\r\n\r\n#### @deprecated\r\n\r\n表示该**Api**不再被支持，未来可能会被删除，其后面是替代方案。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Block |\r\n\r\n```\r\n/**\r\n * The base class for controls that can be rendered.\r\n *\r\n * @deprecated Use the new {@link Control} base class instead.\r\n */\r\nexport class VisualControl {\r\n  . . .\r\n}\r\n```\r\n\r\n#### @defaultValue\r\n\r\n如果未显式分配值，则用于记录字段或属性的默认值。\r\n\r\n> ⚠️：该标记只能用于作为类或接口成员的字段或属性。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Block |\r\n\r\n```\r\nenum WarningStyle {\r\n  DialogBox,\r\n  StatusMessage,\r\n  LogOnly\r\n}\r\n\r\ninterface IWarningOptions {\r\n  /**\r\n   * Determines how the warning will be displayed.\r\n   *\r\n   * @defaultValue `WarningStyle.DialogBox`\r\n   */\r\n  warningStyle: WarningStyle;\r\n}\r\n```\r\n\r\n#### @eventProperty\r\n\r\n应用于「类」或者「接口属性」时，表示其返回的「事件处理程序」可以附加到事件对象上（通常具备`addHandler()`和`removeHandler()`）。\r\n\r\n> ⚠️：「文档工具」会把该类/属性归纳到「事件」内。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Modifier |\r\n\r\n```\r\nclass MyClass {\r\n  /**\r\n    * This event is fired whenever the application navigates to a new page.\r\n    * @eventProperty\r\n    */\r\n  public readonly navigatedEvent: FrameworkEvent<NavigatedEventArgs>;\r\n}\r\n```\r\n\r\n#### @example\r\n\r\n演示如何使用该**Api**，可能包含一个代码示例。\r\n\r\n> 与该**tag**出现在同一行上的后续文本为示例的标题。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Block |\r\n\r\n````\r\n/**\r\n * Adds two numbers together.\r\n * @example\r\n * Here's a simple example:\r\n * ```\r\n * // Prints \\\"2\\\":\r\n * console.log(add(1,1));\r\n * ```\r\n */\r\nexport function add(x: number, y: number): number {\r\n}\r\n````\r\n\r\n#### @inheritDoc\r\n\r\n用于复制另一个**Api**的**tag**，甚至可以从一个不相关的**package**中进行复制。\r\n\r\n> ⚠️：并不是所有的**tags**都能被复制，只有**remarks**、**params**、**typeParam**、**returns**能被复制。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Inline |\r\n\r\n```\r\nimport { Serializer } from 'example-library';\r\n\r\nexport interface IWidget {\r\n  /**\r\n   * Draws the widget on the display surface.\r\n   * @param x - the X position of the widget\r\n   * @param y - the Y position of the widget\r\n   */\r\n  public draw(x: number, y: number): void;\r\n}\r\n\r\nexport class Button implements IWidget {\r\n  /** {@inheritDoc IWidget.draw} */\r\n  public draw(x: number, y: number): void {\r\n    . . .\r\n  }\r\n\r\n  /**\r\n   * {@inheritDoc example-library#Serializer.writeFile}\r\n   */\r\n  public save(): void {\r\n    . . .\r\n  }\r\n}\r\n```\r\n\r\n#### @label\r\n\r\n表示一个声明，可在**TSDoc**中使用「选择器」引用它。\r\n\r\n> ⚠️：该**tag**还没有最终确定。👉 GitHub [issue #9](https://github.com/microsoft/tsdoc/issues/9)\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Inline |\r\n\r\n```\r\nexport interface Interface {\r\n  /**\r\n   * Shortest name:  {@link InterfaceL1.(:STRING_INDEXER)}\r\n   * Full name:      {@link (InterfaceL1:interface).(:STRING_INDEXER)}\r\n   *\r\n   * {@label STRING_INDEXER}\r\n   */\r\n  [key: string]: number;\r\n\r\n  /**\r\n   * Shortest name:  {@link InterfaceL1.(:CONSTRUCTOR)}\r\n   * Full name:      {@link (InterfaceL1:interface).(:CONSTRUCTOR)}\r\n   *\r\n   * {@label CONSTRUCTOR}\r\n   */\r\n  new (hour: number, minute: number);\r\n}\r\n```\r\n\r\n#### @link\r\n\r\n表示用于创建到文档系统中其他页面或一般的**url**超链接。\r\n\r\n> ⚠️：该**tag**还没有最终确定。👉 GitHub [issue #9](https://github.com/microsoft/tsdoc/issues/9)\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Inline |\r\n\r\n```\r\n/**\r\n * Links can point to a URL: {@link https://github.com/microsoft/tsdoc}\r\n */\r\n```\r\n\r\n#### @override @sealed @virtual\r\n\r\n- **@override**: 表示此定义覆盖父类的定义；\r\n- **@sealed**: 表示该定义不能被继承，且不得被重写；\r\n- **@virtual**：表示该定义能被继承，能被重写；\r\n\r\n> ⚠️：「文档工具」强制要求**virtual**、**override**或**sealed**同时使用。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Modifier |\r\n\r\n```\r\nclass Base {\r\n  /** @virtual */\r\n  public render(): void {\r\n  }\r\n\r\n  /** @sealed */\r\n  public initialize(): void {\r\n  }\r\n}\r\n\r\nclass Child extends Base {\r\n  /** @override */\r\n  public render(): void;\r\n}\r\n```\r\n\r\n#### @packageDocumentation\r\n\r\n表示描述整个**package**的文档注释。\r\n\r\n> ⚠️：注释在`.d.ts`文件中，且不得用于描述单项**Api**。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Modifier |\r\n\r\n```\r\n// Copyright (c) Example Company. All rights reserved. Licensed under the MIT license.\r\n\r\n/**\r\n * A library for building widgets.\r\n *\r\n * @remarks\r\n * The `widget-lib` defines the {@link IWidget} interface and {@link Widget} class,\r\n * which are used to build widgets.\r\n *\r\n * @packageDocumentation\r\n */\r\n\r\n/**\r\n * Interface implemented by all widgets.\r\n * @public\r\n */\r\nexport interface IWidget {\r\n  /**\r\n   * Draws the widget on the screen.\r\n   */\r\n  render(): void;\r\n}\r\n```\r\n\r\n#### @param\r\n\r\n用于记录函数参数，后面是一个参数名，后面是一个连字符，最后是一个描述。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Block |\r\n\r\n```\r\n/**\r\n * @param x - The first input number\r\n * @param y - The second input number\r\n */\r\nfunction getAverage(x: number, y: number): number {\r\n  return (x + y) / 2.0;\r\n}\r\n```\r\n\r\n#### @returns\r\n\r\n用于记录函数的返回值。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Block |\r\n\r\n```\r\n/**\r\n * @returns The arithmetic mean of `x` and `y`\r\n */\r\nfunction getAverage(x: number, y: number): number {\r\n  return (x + y) / 2.0;\r\n}\r\n```\r\n\r\n#### @remarks @privateRemarks\r\n\r\n- **@remarks**：表示一个简短的**公开**的“摘要”；\r\n- **@privateRemarks**：表示一个简短的**非公开**的“摘要”；\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Block |\r\n\r\n```\r\n/**\r\n * @remarks\r\n *\r\n * The main documentation for an API item is separated into a preview\r\n * \\\"summary\\\" section optionally followed by an `@remarks` block containing\r\n * additional details.\r\n *\r\n * @privateRemarks\r\n *\r\n * The `@privateRemarks` tag starts a block of additional commentary that is not meant\r\n * for an external audience.  A documentation tool must omit this content from an\r\n * API reference web site.  It should also be omitted when generating a normalized\r\n * *.d.ts file.\r\n */\r\n```\r\n\r\n#### @readonly\r\n\r\n表示「只读」属性。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Modifier |\r\n\r\n```\r\nexport class Book {\r\n  /**\r\n   * Technically property has a setter, but for documentation purposes it should\r\n   * be presented as readonly.\r\n   * @readonly\r\n   */\r\n  public get title(): string {\r\n    return this._title;\r\n  }\r\n\r\n  public set title(value: string) {\r\n    throw new Error('This property is read-only!');\r\n  }\r\n}\r\n```\r\n\r\n#### @see\r\n\r\n表示与当前**Api**相关的其他资源的引用列表。\r\n\r\n> ⚠️：**JSDoc**在**see**之后立即生成超链接文本。但**TSDoc**需要显式的**link**来生成超链接。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Block |\r\n\r\n```\r\n/**\r\n * Parses a string containing a Uniform Resource Locator (URL).\r\n * @see {@link ParsedUrl} for the returned data structure\r\n * @see {@link https://tools.ietf.org/html/rfc1738|RFC 1738}\r\n * for syntax\r\n * @see your developer SDK for code samples\r\n * @param url - the string to be parsed\r\n * @returns the parsed result\r\n */\r\nfunction parseURL(url: string): ParsedUrl;\r\n```\r\n\r\n#### @throws\r\n\r\n表示可能由「函数」或「属性」引发的异常类型。\r\n\r\n> ⚠️：每种异常类型都应该单独使用一个**throw**进行描述。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Extended  | Block |\r\n\r\n```\r\n/**\r\n * Retrieves metadata about a book from the catalog.\r\n *\r\n * @param isbnCode - the ISBN number for the book\r\n * @returns the retrieved book object\r\n *\r\n * @throws {@link IsbnSyntaxError}\r\n * This exception is thrown if the input is not a valid ISBN number.\r\n *\r\n * @throws {@link book-lib#BookNotFoundError}\r\n * Thrown if the ISBN number is valid, but no such book exists in the catalog.\r\n *\r\n * @public\r\n */\r\nfunction fetchBookByIsbn(isbnCode: string): Book;\r\n```\r\n\r\n#### @typeParam\r\n\r\n用于记录通用参数，后面是一个参数名，后面是一个连字符，最后是一个描述。\r\n\r\n| Standardization  | kind |\r\n| ----------------- | ------------- | \r\n| Core  | Block |\r\n\r\n```\r\n/**\r\n * Alias for array\r\n *\r\n * @typeParam T - Type of objects the list contains\r\n */\r\ntype List<T> = Array<T>;\r\n\r\n/**\r\n * Wrapper for an HTTP Response\r\n * @typeParam B - Response body\r\n * @param <H> - Headers\r\n */\r\ninterface HttpResponse<B, H> {\r\n    body: B;\r\n    headers: H;\r\n    statusCode: number;\r\n}\r\n```\r\n\r\n# 最后\r\n\r\n👨‍💼：不错不错，文档写的很好！顺便把以前的文档都重写一遍吧！\r\n\r\n🧑‍💻：卒。\r\n\r\n参考文章：\r\n- [TSDoc](https://tsdoc.org/pages/tags/alpha/)\r\n- [TypeDoc](https://typedoc.org/guides/overview/)\r\n\r\n祝大家生活愉快，工作顺利！\r\n\r\n「 ---------- The end ---------- 」"
    },
    {
        "article_id": "7153536318859903012",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aeda56aabd74fd0af42c1937fbd617f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "提升代码可读性，减少if-else的几个小技巧",
        "preview": "“我正在参加「掘金·启航计划」” 前言💁‍♂️ 相信大家或多或少都接触过拥有庞大 if else 的项目代码吧，多重嵌套的 if else 在维护的时候真的让人很恼火😡，有时候一个 bug 排查下来，",
        "author": "树深遇鹿",
        "view_count": 16510,
        "collect_count": 320,
        "comment_count": 70,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/720d9bd3481d14e40d5b13b10d7fd5c4~300x300.image",
        "category": "前端",
        "content": "“我正在参加「掘金·启航计划」”\r\n\r\n## 前言💁‍♂️\r\n\r\n相信大家或多或少都接触过拥有庞大 `if else` 的项目代码吧，多重嵌套的 `if else` 在维护的时候真的让人很恼火😡，有时候一个 bug 排查下来，严重感觉身体被掏空😿。\r\n\r\n本文并未有消灭或歧视 `if else`的意思，`if else` 的好用都知道，这里只是在某些特定场景为大家额外提供一种思路，增加我们代码的可读性🐳。\r\n\r\n## 短路运算💻\r\n\r\nJavascript 的逻辑或 `||` 的短路运算有时候可以用来代替一些比较简单的 `if else`\r\n-  逻辑或 `||` 的短路运算：若左边能转成true，返回左边式子的值，反之返回右边式子的值。\r\n\r\n下面用一个简单的案例来表述\r\n\r\n```js\r\nlet c\r\nif(a){\r\n    c = a\r\n} else {\r\n    c = b\r\n}\r\n```\r\n\r\n大家看着上面的代码会难受嘛（本人有一丢丢的强迫症🤦），明明就是一个很简单的判断却需要写好几行代码才能实现。这个时候我们就可以用短路运算去简化我们的代码啦🙂。\r\n\r\n```js\r\nlet c = a || b\r\n```\r\n\r\n这样看起来是不是就简洁了很多😕。\r\n\r\n## 三元运算符🎶\r\n\r\n三元运算符我觉得大家应该都很熟悉吧，很多时候简单的一些判断我们都可以使用三元运算符去替代 `if else`，这里只推荐 **一层** 三元运算符，因为多层嵌套的三元运算符也不具备良好的可读性🥹。\r\n\r\n例子：条件为 true 时返回1，反之返回0：\r\n\r\n```js\r\nconst fn = (nBoolean) {\r\n    if (nBoolean) {\r\n        return 1\r\n    } else {\r\n        return 0\r\n    }\r\n    \r\n}\r\n\r\n// 使用三元运算符\r\nconst fn = (nBoolean) {\r\n    return nBoolean ? 1 : 0\r\n}\r\n```\r\n\r\n三元运算符使用的地方也比较多，比如：条件赋值，递归...\r\n\r\n```js\r\n// num值在nBoolean为true时为10，否则为5\r\nlet num = nBoolean ? 10 : 5\r\n\r\n// 求0-n之间的整数的和\r\nlet sum = 0;\r\nfunction add(n){\r\n    sum += n\r\n    return n >= 2 ? add(n - 1) : result;\r\n};\r\nlet num = add(10);//55\r\n```\r\n\r\n## switch case🖥️\r\n\r\n上述的两种方式：短路运算跟三元运算虽然很好用，代码也很简洁，不过都只能用于简单的判断，遇到多重条件判断就不能使用了😭。\r\n\r\n对于 `switch case`，虽然它的可读性确实比 `else if` 更高，但是我想大家应该都觉得它写起来比较麻烦吧😣（反正我觉得很麻烦😺）。\r\n\r\n例：有A、B、C、D四种种类型，在A、B的时候输出1，C输出2、D输出3，默认输出0。\r\n\r\n```js\r\nlet type = 'A'\r\n\r\n//if else if\r\nif (type === 'A' || type === 'B') {\r\n    console.log(1);\r\n} else if (type === 'C') {\r\n    console.log(2);\r\n} else if(type === 'D') {\r\n    console.log(3);\r\n} else {\r\n    console.log(0)\r\n}\r\n\r\n//switch case\r\nswitch (type) {\r\n    case 'A':\r\n    case 'B':\r\n        console.log(1)\r\n        break\r\n    case 'C':\r\n        console.log(2)\r\n        break\r\n    case 'D':\r\n        console.log(3);\r\n        break;\r\n    default:\r\n        console.log(0)\r\n}\r\n```\r\n\r\n## 对象配置/策略模式📑\r\n\r\n对象配置看起来跟 `策略模式` 差不多，都是根据不同得参数使用不同得数据/算法/函数。😺\r\n\r\n策略模式就是将一系列算法封装起来，并使它们相互之间可以替换。被封装起来的算法具有独立性，外部不可改变其特性。\r\n\r\n接下来我们用对象配置的方法实现一下上述的例子\r\n\r\n```js\r\nlet type = 'A'\r\n\r\nlet tactics = {\r\n    'A': 1,\r\n    'B': 1,\r\n    'C': 2,\r\n    'D': 3,\r\n    default: 0\r\n}\r\nconsole.log(tactics[type]) // 1\r\n```\r\n\r\n接下来用几个例子让大家更加熟悉一点。\r\n\r\n### 案例1 商场促销价🙋\r\n\r\n根据不同的用户使用不同的折扣，如：普通用户不打折，普通会员用户9折，年费会员8.5折，超级会员8折。\r\n\r\n使用`if else`实现😢\r\n```js\r\n// 获取折扣 --- 使用if else\r\nconst getDiscount = (userKey) => {\r\n    if (userKey === '普通会员') {\r\n        return 0.9\r\n    } else if (userKey === '年费会员') {\r\n        return 0.85\r\n    } else if (userKey === '超级会员') {\r\n        return 0.8\r\n    } else {\r\n        return 1\r\n    }\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n\r\n```\r\n\r\n使用对象配置/策略模式实现🙂\r\n```js\r\n// 获取折扣 -- 使用对象配置/策略模式\r\nconst getDiscount = (userKey) => {\r\n    // 我们可以根据用户类型来生成我们的折扣对象\r\n    let discounts = {\r\n        '普通会员': 0.9,\r\n        '年费会员': 0.85,\r\n        '超级会员': 0.8,\r\n        'default': 1\r\n    }\r\n    return discounts[userKey] || discounts['default']\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n```\r\n\r\n从上面的案列中可以明显看得出来，使用对象配置比使用if else可读性更高，后续如果需要添加用户折扣也只需要修改折扣对象就行👍。\r\n\r\n\r\n对象配置不一定非要使用对象去管理我们键值对，还可以使用 `Map`去管理🦋，如：\r\n```js\r\n// 获取折扣 -- 使用对象配置/策略模式\r\nconst getDiscount = (userKey) => {\r\n    // 我们可以根据用户类型来生成我们的折扣对象\r\n    let discounts = new Map([\r\n        ['普通会员', 0.9],\r\n        ['年费会员', 0.85],\r\n        ['超级会员', 0.8],\r\n        ['default', 1]\r\n    ])\r\n    return discounts.get(userKey) || discounts.get('default')\r\n}\r\nconsole.log(getDiscount('普通会员')) // 0.9\r\n```\r\n\r\n### 案例2 年终奖🏆\r\n\r\n公司的年终奖根据员工的工资基数和绩效等级来发放的。例如，绩效为A的人年终奖有4倍工资，绩效为B的有3倍，绩效为C的只有2倍。\r\n\r\n假如财务部要求我们提供一段代码来实现这个核算逻辑，我们要怎么实现呢？\r\n\r\n这不是很简单嘛，一个函数就搞定了。\r\n\r\n```js\r\nconst calculateBonus = (performanceLevel, salary) => { \r\n    if (performanceLevel === 'A'){\r\n        return salary * 4\r\n    }\r\n    if (performanceLevel === 'B'){\r\n        return salary * 3\r\n    }\r\n    if (performanceLevel === 'C'){\r\n        return salary * 2\r\n    }\r\n}\r\ncalculateBonus( 'B', 20000 ) // 输出：60000\r\n```\r\n\r\n可以发现，这段代码十分简单，但是 `calculateBonus`函数比较庞大，所有的逻辑分支都包含在`if else`语句中，如果增加了一种新的绩效等级D，或者把A等级的倍数改成5，那我们必须阅读所有代码才能去做修改🙇‍♂️。\r\n\r\n所以我们可以用对象配置/策略模式去简化这个函数😺\r\n\r\n```js\r\nlet strategies = new Map([\r\n    ['A', 4],\r\n    ['B', 3],\r\n    ['C', 2]\r\n])\r\nconst calculateBonus = (performanceLevel, salary) => { \r\n    return strategies.get(performanceLevel) * salary\r\n}\r\ncalculateBonus( 'B', 20000 ) // 输出：60000\r\n```\r\n\r\n至此，这个需求做完了，然后产品经理说要加上一个部门区分，假设公司有两个部门D和F，D部门的业绩较好，所以年终奖翻1.2倍😄，F部门的业绩较差，年终奖打9折😭。\r\n\r\n改造以上代码，把状态值拼接，然后存入Map中\r\n\r\n```js\r\n// 以绩效_部门的方式拼接键值存入\r\nlet strategies = new Map([\r\n    ['A_D', 4 * 1.2],\r\n    ['B_D', 3 * 1.2],\r\n    ['C_D', 2 * 1.2],\r\n    ['A_F', 4 * 0.9],\r\n    ['B_F', 3 * 0.9],\r\n    ['C_F', 2 * 0.9]\r\n])\r\nconst calculateBonus = (performanceLevel, salary, department) => { \r\n    return strategies.get(`${performanceLevel}_${department}`) * salary\r\n}\r\ncalculateBonus( 'B', 20000, 'D' ) // 输出：72000\r\n```\r\n## 结尾🔚\r\n\r\n本文主要是向大家传递一种思想，我们有很多的方法去优化我们的代码，提高我们代码的可读性。\r\n\r\n对`if else`并没有歧视的意思，只是希望在大家以后的代码中不仅仅只有`if else`😨。\r\n\r\n\r\n> 博客主要记录一些学习的文章，如有不足，望大家指出，谢谢。"
    },
    {
        "article_id": "7179790901651177529",
        "snapshot": "",
        "title": "2022年终总结——从逆向转向Web开发",
        "preview": "今年主要总结我为何从逆向转向 Web 开发，并明确我未来所要走的方向，也是本文的主题。 希望我的一些经历对你有所帮助，尤其是对于一些不知如何抉择的伙伴。",
        "author": "愧怍",
        "view_count": 1822,
        "collect_count": 3,
        "comment_count": 3,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/7c128d02d5e840deaca25f5c494bb2ef~300x300.image",
        "category": "代码人生",
        "content": "---\r\ntheme: smartblue\r\n---\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n## 前言\r\n\r\n距离上一篇博文有一个月之久了，距离上次编写代码也有一周之久了，由于疫情的全面放开，加上福建省教育厅通知的提前返乡，反而让我感到有些不适。往常这个时间点我忙于期末考试，会把代码的事情放一边，等到彻底放假后，开始闭关潜心学习。然而剩余的半个月变成了线上形式，课还是要上，考试还是要考，虽说身在家乡，但心不在焉的 😂。\r\n\r\n12 月已过半，也是时候该写年终总结了。迄今为止，我已学习了 3 年半的编程。（还好不是两年半），当下的技术不再是当初只会易语言的小伙了。只是当下已没有当初如此强烈的热情与精力了，我称之为老了。\r\n\r\n现在回头回顾学习编程时间，用一个成语对自己做个评价——**差强人意**。在这些时间段，我其实荒废过一段时间，厌倦过，贪玩过，荒废过，从我的 [Github 热力图](https://github.com/kuizuo'Github热力图') 中其实就能看得出来。就导致欠下技术的，都需要后续花时间去弥补。\r\n\r\n要让自己保持每天都处于学习状态真的太难了 😩，生活总有源源不断的琐事打扰着你。在忙碌的时候总是感觉时间不够用，哪怕有时一天花费了数十个小时，也总感觉做的事情太少了；哪怕每天计划都规划得好好的，但总是有一半还未完成。生活中大量的碎片化时间，而编程学习最不需要的就是这些碎片化时间。\r\n\r\n回顾整个编程生涯有太多可感慨的，整个旅途几乎是一个人走完的，期间遇到的坎坷就只得依靠搜索引擎来解决，搜索引擎是我再生父母都不为过。没有人给我指引明确的道路，只依靠心中对技术的憧憬不断前行。走过低谷，登过山峰，而如今站稳身子就足矣。\r\n\r\n感叹的话语也就是说到这。今年主要总结我为何从逆向转 Web 开发，并明确我未来所要走的方向，也是本文的主题。**仅作为个人感悟，不作为建议参考。**\r\n\r\n## 为什么是 Web 开发？而不是逆向\r\n\r\n今年大部分的开发时间都花在 Web 开发上，在此期间也接触到许多技术，并通过博客笔记的方式记录下来。\r\n\r\n我很庆幸我的 Web 开发从一个 Beginner 到 Intermediate，现在回忆整个学习路程，一路学得都很野很随意，从未系统学习过，总是学到一半，就自认为已经掌握了，便开始进行实战项目，可以说很多知识都是在实战探索中了解的。\r\n\r\n虽然很多人都直称我为大佬，但我离 Advanced 还有一大段的路途要走，而这段路途是无比的艰难与漫长。不过好在路不歪，只要肯走终会到达终点 👨‍🦲。\r\n\r\n而带我入门的逆向技术，在今年没有丝毫的长进，说得过分点，就是弃坑了。也正如标题所说，至于缘由，细看下文。\r\n\r\n### 逆向\r\n\r\n熟悉我的人应该知道我之前是做爬虫与逆向分析，但是为何今年的技术栈彻底转型到 Web 开发上。\r\n\r\n我常常和别人说起我的技术栈转型（从逆向转到开发），不过比较多的都会比较好奇我为什么不继续深造下去。\r\n\r\n在此我也回顾了我**从逆向转变到 Web 开发**的过程，顺带也回答这个问题。不过在这里先说说我个人对逆向的看法：\r\n\r\n#### 逆向需要的技术知识面比较广。\r\n\r\n就我接触逆向的过程来说，接触了易语言，JavaScript，Python，Java，Php 等等编程语言。\r\n\r\n使用过了一堆的逆向工具，如 Frida、IDA、JEB、jadx 等等（我目前能想到比较有名的）。此外还有一堆知识，包括但不限于以下技术：自动化脚本、TCP/HTTP 协议、抓包、爬虫、加密学、图像识别（验证码、滑块位置）、汇编、反编译、AST 反混淆。\r\n\r\n**要我说我在逆向中学到的不是如何使用这些工具或掌握某个技能，而是锻炼出一定的阅读与分析代码能力。**工具与技能总是瞬息万变，但阅读与分析代码能力却是实实在在，一成不变的，也是逆向中最值得学习的。\r\n\r\n有接触过 [CTF](https://baike.baidu.com/item/ctf/9548546) 想必再熟悉不过逆向工程的技术面广了。\r\n\r\n#### 越来越多的网站或应用程序不断加强安全防护，未来只会越来越难逆向。\r\n\r\n逆向分析，说白话就是去看别人的代码，进行一些修改手段，达到自己想要的目的。比如修改某个软件的标题或作者信息、将别人的代码“偷”过来用、爬取某些网站或软件的数据。\r\n\r\n但是随着现在越来越多潜在的安全问题，很多框架底层，服务厂商，都会对一些可能有安全问题的代码进行警告或者底层处理。比如使用 ORM 框架能够有效防止 SQL 注入，前端框架中涉及 XSS 攻击也会有相应的错误提示与处理，再如浏览器跨域以及跨站点 cookie 不共享，都是为了用户的安全而去考虑的。这样的例子有太多了。\r\n\r\n简单说说安卓逆向的过程：拿到一个 Apk，发现有加壳（给代码加固让逆向者不易于看到源代码），这时候就需要通过脱壳才能查看到源代码；此时就算脱完了壳，接下来可能将面对经过混淆过的代码，这份代码难以用人眼去阅读，不调试运行，单靠静态分析很难分析出东西，这时候可能就要借助 AST 对代码进行还原；还原完了配合动静分析将代码给扣出来，而在分析的时候可能又有各种检测，比如抓包，反调试以阻碍逆向进度；最后就算逆向工作都做完了，代码也扣下来了，还要尝试运行扣完的代码，这时候极大可能还不一定能运行，然后又要回头看看到底那一步做错了。\r\n\r\n可以说逆向的工作就是不断地调试，不断分析，最终拿到想要的结果。整个过程可以说非常耗时且折磨人，心智如果不够强大，真的容易劝退（我当下耐心也早不如当初了）。但是得到最终的目的，将非常爽，成就感爆棚，相当于一个解了几小时的题，最终被攻克的感觉。\r\n\r\n前阵子在逆向圈中，看到过一张图，大致也把我的逆向学习流程也表达了出来，最终我的逆向学习也确实止步在 Flutter 上。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/214ba360113d4cfc9f293dc547904f0d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上面所说到的逆向技术中，例如加壳，代码混淆，反调试，风控等等，都是阻碍逆向手段。同样对于爬虫而已，通常会采取反爬措施，包括但不限于封 IP、封账号、JS 参数加密、代码混淆、浏览器指纹、TLS 指纹、验证等。而且防护手段可以说是越来越多，逆向的难度也就越来越大。并且在服务开发那边只需要修改一点东西，逆向可能就需要从头再来一遍。\r\n\r\n**未来逆向的难度只增不减，但薪资可不一定保证这趋势。**\r\n\r\n#### 风险\r\n\r\n从上面也不难看出逆向常常与安全挂钩，如果一个网站或软件不是那么好被逆向，那么间接说明安全性是比较高的。可一旦涉及到安全，同时又是互联网，就免不了网络安全与法律相关的风险。\r\n\r\n在大多数逆向的对象（网站，软件）中，多数都是他人的劳动产物，当你未经他人允许的情况下，去爬取他人的数据，或是修改一些版权信息再次发布出来，就属于非法行为。本质和未经他人允许，偷人家的东西性质是一个样的。并且在有防护措施的情况下，绕过网站防护措施获取数据属于违背权利人意愿读取、收集数据，将有较大可能被认定为对计算机信息系统的 “侵入”。\r\n\r\n要知道在逆向的行业中，有很多都是擦边灰产，至少我所在的逆向圈是这样的，抱着【仅供学习为参考，请勿用于非法用途】的想法做逆向工程。路子极易走歪，很少能够正常去走安全岗位的。相信你应该能看到许多类似的案件，如【某某程序员因非法侵入 xx 网站，获刑 x 年】。这不是危言耸听，目前国家对网络安全以及非法数据获取的打击力度，也将决定了这些案件将会越来越多，爬虫逆向也将会越来越邢。\r\n\r\n### 自身因素\r\n\r\n简单介绍完我认为爬虫和逆向的看法后，再来说说自身因素。\r\n\r\n#### 更想写代码，而不是看代码\r\n\r\n我是很享受写代码的过程，一份高质量的代码会让人赏心悦目。我为此特意学习下设计模式、重构技巧以及 TDD 测试。这些在逆向中基本难以涉及，但是这些对开发的体验和代码的健壮性都是非常重要的，也是让我个人觉得技术有所提升的技能点。\r\n\r\n在逆向分析中，大部分时间都不是在写代码而是在看（分析）代码，而反编译出来的代码，很有可能是带有混淆过的代码，而你想要分析这一块代码的作用，只能去一步步调试，将代码啃下来，从而推断运行时某变量的值，或是某个函数的作用。\r\n\r\n虽然说开发岗位中，有很多情况下也是在看代码的日子中度过的，但相比反编译阅读代码而言，至少不至于那么晦涩难懂。\r\n\r\n#### 更想碰新技术，而不是旧技术\r\n\r\n其次，在逆向分析中，遇到的网站或软件所用的技术一般都是较为稳定成熟的技术，而这些技术往往不是很新，因此需要去了解很多旧的技术，但这些旧技术仅仅只对逆向分析有用，甚至过段时间很有可能就会遗忘。并且要了解的旧技术还不少，学得将会特别杂。\r\n\r\n而我又是一个喜新厌旧的人，对任何新鲜事物都抱有好奇尝试的态度。我终将认为旧的技术被淘汰是迟早的问题，新技术的出现肯定不是无缘无故的出现，必然是为了解决某些问题而诞生的，如性能，开发体验，安全等等。\r\n\r\n这里有篇我对新技术的看法，推荐阅读一番。[深谈个人对新技术的看法 - 愧怍的小站](https://kuizuo.cn/talk-new-technologies-opinion)\r\n\r\n#### 更想开源，而不是闭源\r\n\r\n在逆向开发，不，是在灰产开发中，有很多代码是别指望开源出来的，这背后会涉及到商业利益或是版权等问题。一旦代码放出来，将意味着你的代码将有很大的可能被别人利用做坏事，最终甚至祸及到自己。所以大多数情况下，你多半只能将自己的应用发布出去，而不是将源码开源，通常也就带有商业化的性质。\r\n\r\n我想任何开发者肯定是希望自己的代码走的更远，走的正规，而不是被拿来做违背自身意愿的事情。\r\n\r\n开源不仅能为自己提升一些技术知名度，展现自身技术的一面，同时代码被他人使用与认可，这番成就感就足够继续坚持开源下去。因为我有很多技术都是通过开源项目中学到的，所以我能感受到开源带来的魅力，也是对于前人的崇拜，想走开源的原因。\r\n\r\n**因为淋过雨，所以很想为别人撑把伞**\r\n\r\n### 小结\r\n\r\n其实在今年出头我还特意复习了一波安卓逆向，为了更深入了解了更底层的知识与工具（当然现在忘得也差不多了），因一些特殊原因我的电子设备不在了，别问，问就是坏了到现在还没修好。就导致我的编程语言环境，逆向工具，虚拟机配置，代码等数据直接灰飞烟灭，也让我停滞了 1 个月的学习。\r\n\r\n我想这才是我从逆向转 Web 开发的最重要的理由了。\r\n\r\n逆向的学习对我开发有很大的帮助。例如开发中的安全问题，我在开发中都会时刻考虑去考虑该问题。如加壳、SQL 注入、代码混淆、接口限流、接口幂等性（Fiddle R 包）等等安全性问题。\r\n\r\n我庆幸我学过逆向，让我学到很多在开发中比较难学到的技能，如调试，阅读源码，而这些也是绝大多数 Web 开发者都欠缺的能力。\r\n\r\n逆向应该就暂以告终，未来会有很长的一段时间，甚至以后不再接触深入专研逆向。\r\n\r\n每当回想，【当时那么难的加密算法都能搞得定，开发一个功能还能有多难】，保持着这种心态，也让我保持着开发。\r\n\r\n也是逆向激起我对编程的兴趣，可以说没有接触逆向开发，我也不太可能会接触到 Web 开发。\r\n\r\n## 但 Web 开发就一定好吗？\r\n\r\n上面对逆向的看法仅个人分析而言，但是 Web 开发就一定好吗？我不敢下绝对的肯定，不同人不一定适合相同的技术，**但是我特别看好 Web 技术（尤其是 JavaScript，偏前端向）**，以下是我看好的点。\r\n\r\n### 应用性广\r\n\r\n目前仍有很多人还停留在 JavaScript 只能编写前端页面的水平，自从 Node.js 问世，目前绝大多数的应用都可以使用 JavaScript 进行编写。\r\n\r\n换句话说，只要你会 JavaScript 就可以编写很多应用了。有个在国外经常被应用的一条和 JavaScript 有关系的著名定律：\r\n\r\n**Atwood 定律：任何可以用 JavaScript 编写的应用程序，最终都会用 JavaScript 编写**\r\n\r\nWeb 前端开发不用多说，目前还得用 JavaScript 来编写。而后端开发通过 Node.js 也有一己之力。近几年特别流行跨平台开发，也就是一份代码，多端运行。\r\n\r\n使用 React Native 或是 Uniapp 这样的前端应用框架，顺带去了解一下相应平台的 API，就能够编写出安卓或 IOS 应用，做过小程序开发肯定知道小程序的技术栈就使用到前端开发的技术栈，如果你会前端开发，就能很轻松的上手小程序开发了。\r\n\r\n并且越来越多的软件都是网页版优先，然后再通过 Electron 这样的跨平台解决方案，实现不同平台间的程序。诸如 Vscode，Typeorm 等等便是其中的佼佼者。\r\n\r\n不过本质上都是在不同应用的平台上套浏览器的壳，然后接入一些该平台的接口，因此普遍应用的体积与内存都相对比较大，与原生相比自然是略逊与原生，不过这点性能上的差异在如今硬件升级如此普遍的物质生活也显得微不足道了。\r\n\r\n但借助浏览器自带的跨平台性，你所编写的应用能够非常轻松的让他人访问，只需要用户有个浏览器，并且通过上述跨平台的解决方案，也能够有效的将你的 web 应用转成其他平台的应用，而不是在耗费时间与精力去编写另一套代码。\r\n\r\n在一些技术文档上，会有 API/SDK 的支持，而绝大多数都支持使用 JavaScript/Node.js，也许该功能本身并不是使用 JavaScript 来编写的，但完全可以通过 JavaScript 来轻松调用该功能。并且如今 JavaScript 生态如此庞大，你不必担心库/包的问题，npm 作为世界上最大的开放源代码的生态系统（包管理器），在这里你几乎找得到你所想要的库/包。\r\n\r\n此外有越来越多的第三方服务平台（通常称 Fass，函数即服务），专门提供数据接口与用户鉴权，如 firebase/supabase 或是国产的云开发产品（如小程序）。前端程序员只需要专注与业务代码，借助第三方开发平台，就能够编写一个高可用的应用。反而也映衬了，Web 开发好像可以没有后端，但必须要有前端的观念。\r\n\r\n### 工作量将越来越多\r\n\r\n这句话的意思可能有点加班那味道，但我所要表明的是可以做的事情多了，意味着你的工作量增加了，同时你的编码价值也就提升了，不过实际价值（工资）的话不一定提升，因为这主要看老板和地区。\r\n\r\n怎么理解呢，我举几个例子。\r\n\r\n现在大部分的 web 应用都采用前后端分离的形式，但在曾经则是由后端通过模板语言渲染成 HTML 直接返回，通过前后端分离的形式，前端只需要专注页面交互的编写，而后端只需要保证接口可靠性。并且前后端分离也有一个特别显著的特点，能非常有效的节省服务器的资源，原本服务器的渲染动作迁移至客户端来做。也许有人会说，那这样 SEO 优化该怎么办，这不就有了 Next.js、Nuxt.js 这样的 SSR（服务端渲染） 框架，而这些工作，也是前端要做的。\r\n\r\n并且越到后面你越能感觉到客户端（前端）远比服务端（后端）做的东西来的多，比如开发阶段的数据 Mock，前端国际化，设计原型等等。之所以会有这种感觉，也许是因为我的大部分开发都是前端，这里你也可以回想当下的工作量与往年相比是多了还是不变。\r\n\r\n### 技术更新快\r\n\r\n前端真的是每隔一段时间，必定会出一些新的技术，也不由让不少前端学习者感叹真的学不动。但伴随着新的技术出现，必然会有新的岗位与机会，这也是我看好前端的一个点。\r\n\r\n**不过这种机会在国内不太多见，反而在国外特别普遍。** 多的不说，自行体会。\r\n\r\n忘记从哪看到的一句话：“前端工程师的一大焦虑：永远能（且必须要）看到大量前沿的技术，但自己手上的活儿跟不上，导致眼高手低。”\r\n\r\n不只是前端，做技术这行的，必须要跟着技术发展的角度，并且要时刻关注最新，主流的技术。\r\n\r\n---\r\n\r\n有关 Web 开发的一些想法与感悟就写到这，其实还有蛮多可写的，比如选择 Vue 与 React？为什么是 JavaScript？有太多自我审问的话题了，不过由于当下时间相对紧迫，有机会的话再续写吧。\r\n\r\n综上，也就是我看好 Web 技术的几个点，也回答了我未来的方向。希望这些能够帮助一些不知抉择方向的伙伴。\r\n\r\n## 在实践中学习\r\n\r\n回顾整个技术栈，基本都是在项目实践中不断学习。也许是因为逆向的缘故，因为逆向基本上都是靠实战出来的，导致我的学习路线也趋于实践。\r\n\r\n不过在我看来，写项目是最直接能体现出所想学的技术。我在学习一门新技术时，我通常会用项目或者博文的形式来总结我的学习过程。我也乐意花时间在这上面，并将其分享出来。当有其他人也在学习这门技术时，看到该项目或博文，我就认为非常有意义。\r\n\r\n**我在学任何一门技术，会使用该技术写点东西；换言之是为了写点东西，而去学点不一样技术。**\r\n\r\n## 技术心态的变化\r\n\r\n如今来看，确实没那么想写代码，尤其是那种工作量大，重复性强的代码，而编写这些代码，其实与搬砖无任何区别，本质也是重复性与劳动性的任务。\r\n\r\n曾经可能是因为接触得比较少，对于很多软件背后的原理及实现一概不知，所以看到啥就都想写写看，最终很多项目都成为半成品。\r\n\r\n而随着越深入的学习，反而自己所想实现的东西，前人都已经帮我们实现好了。完全可以借用前人的代码，在此基础上学习与使用，而不必从头再来，耗费很多不必要的时间。\r\n\r\n到最后为了实现一开始所想实现的东西，不用再费尽心思，去开源社区搜寻一番，总能找到与自己所要实现的类似的产品，此时只需要会看，会改，总能达到自己最终要实现的东西，有时候自己也称为了别人口中的 CV 工程师。\r\n\r\n也正因如此，写代码的欲望就不再那么强烈。很多自认为无意义的代码或者是以后都不一定用得上的代码就少写了许多。于是乎缺少了很多自我思考与专研的时间，虽说也确实节省了很多不必要的时间，加快最终功能的实现，但这就是自己想要的编程生活吗？或者说这就是绝大多数人的编程生活。\r\n\r\n## 结语\r\n\r\n今年的年终就告一段落，与之前的年终总结相比，篇幅缩减了许多，主要感觉之前写的挺多流水账的，废话挺多的。也有一点是因为时间相对紧迫，其实 12 月我还没放假，都处于线上上课，线上考试的状态，而线上考试的方式我就不得吐槽了，提前打印给定的答题纸，题目以电脑的方式展示，最终将答案手写到答题纸上并通过手机扫描（扫描全能王）成 PDF 的格式提交，当然摄像头必然也是有的。总之麻烦事还是有的，还没到彻底闲下来闭关学习的时候。\r\n\r\n按往常可能还有明年的规划，但我现在认为很多时候都难以依照自身意愿做事，而规划正好自己所设想美好的计划，很容易事与愿违。因为回顾过往的规划，有太多美好的计划，但在实际分析下也将变得不堪一击。不止项目需要可行性分析，人生计划同样需要，一些天马行空幻想，其实就不再有意义去记录了。\r\n\r\n**坚持做自己想做的事情，而不是逼自己做不愿做的事情**。这是我编程学习中座右铭，也是给予他人编程学习的建议。\r\n\r\n> 发布在掘金上的文章精简了一些内容，完整原文地址: [2022年终总结——逆向转Web开发 - 愧怍的小站](https://kuizuo.cn/2022-year-end-summary) "
    },
    {
        "article_id": "7152369961120301069",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4f6c46101ba4290a8fa78825e1d1b35~tplv-k3u1fbpfcp-watermark.image?",
        "title": "这些不知道，别说你熟悉 Spring",
        "preview": "我正在参加「掘金·启航计划」 大家好，这篇文章跟大家来聊下 Spring 中提供的常用扩展点。重点介绍下 Spring 基于这些扩展点怎么跟配置中心（Apollo、Nacos、Zookeeper、Co",
        "author": "CodeFox",
        "view_count": 26642,
        "collect_count": 461,
        "comment_count": 34,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/6d69c1af2c0452c01f0f394c5c08404f~300x300.image",
        "category": "后端",
        "content": "我正在参加「掘金·启航计划」\r\n\r\n大家好，这篇文章跟大家来聊下 Spring 中提供的常用扩展点、Spring SPI 机制、以及 SpringBoot 自动装配原理，重点介绍下 Spring 基于这些扩展点怎么跟配置中心（Apollo、Nacos、Zookeeper、Consul）等做集成。\r\n\r\n## 写在前面\r\n\r\n我们大多数 Java 程序员的日常工作基本都是在做业务开发，俗称 crudboy。\r\n\r\n作为 crudboy 的你有没有这些烦恼呢？\r\n\r\n1. 随着业务的迭代，新功能的加入，代码变得越来越臃肿，可维护性越来越低，慢慢变成了屎山\r\n\r\n2. 遇到一些框架层的问题不知道怎么解决\r\n\r\n3. 面试被问到使用的框架、中间件原理、源码层东西，不知道怎么回答\r\n\r\n4. 写了 5 年代码了，感觉自己的技术没有理想的长进\r\n\r\n如果你有上述这些烦恼，我想看优秀框架的源码会是一个很好的提升方式。通过看源码，我们能学到业界大佬们优秀的设计理念、编码风格、设计模式的使用、高效数据结构算法的使用、魔鬼细节的巧妙应用等等。这些东西都是助力我们成为一个优秀工程师不可或缺的。\r\n\r\n如果你打算要看源码了，优先推荐 Spring、Netty、Mybatis、JUC 包。\r\n\r\n## Spring 扩展\r\n\r\n我们知道 Spring 提供了很多的扩展点，第三方框架整合 Spring 其实大多也都是基于这些扩展点来做的。所以熟练的掌握 Spring 扩展能让我们在阅读源码的时候能快速的找到入口，然后断点调试，一步步深入框架内核。\r\n\r\n这些扩展包括但不限于以下接口：\r\n\r\nBeanFactoryPostProcessor：在 Bean 实例化之前对 BeanDefinition 进行修改\r\n\r\nBeanPostProcessor：在 Bean 初始化前后对 Bean 进行一些修改包装增强，比如返回代理对象\r\n\r\nAware：一个标记接口，实现该接口及子接口的类会收到 Spring 的通知回调，赋予某种 Spring 框架的能力，比如 ApplicationContextAware、EnvironmentAware 等\r\n\r\nApplicationContextInitializer：在上下文准备阶段，容器刷新之前做一些初始化工作，比如我们常用的配置中心 client 基本都是继承该初始化器，在容器刷新前将配置从远程拉到本地，然后封装成 PropertySource 放到 Environment 中供使用\r\n\r\nApplicationListener：Spring 事件机制，监听特定的应用事件（ApplicationEvent），观察者模式的一种实现\r\n\r\nFactoryBean：用来自定义 Bean 的创建逻辑（Mybatis、Feign 等等）\r\n\r\nImportBeanDefinitionRegistrar：定义@EnableXXX 注解，在注解上 Import 了一个 ImportBeanDefinitionRegistrar，实现注册 BeanDefinition 到容器中\r\n\r\nInitializingBean：在 Bean 初始化时会调用执行一些初始化逻辑\r\n\r\nApplicationRunner/CommandLineRunner：容器启动后回调，执行一些初始化工作\r\n\r\n上述列出了几个比较常用的接口，但是 Spring 扩展远不于此，还有很多扩展接口大家可以自己去了解。\r\n\r\n## Spring SPI 机制\r\n\r\n在讲接下来内容之前，我们先说下 Spring 中的 SPI 机制。Spring 中的 SPI 主要是利用 META-INF/spring.factories 文件来实现的，文件内容由多个 k = list(v) 的格式组成，比如：\r\n\r\n```yml\r\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\\\r\n  com.dtp.starter.adapter.dubbo.autoconfigure.ApacheDubboTpAutoConfiguration,\\\\\r\n  com.dtp.starter.adapter.dubbo.autoconfigure.AlibabaDubboTpAutoConfiguration\r\n\r\norg.springframework.boot.env.EnvironmentPostProcessor=\\\\\r\n  com.dtp.starter.zookeeper.autoconfigure.ZkConfigEnvironmentProcessor\r\n```\r\n\r\n这些 spring.factories 文件可能是位于多个 jar 包中，Spring 容器启动时会通过 ClassLoader.getResources() 获取这些 spring.factories 文件的全路径。然后遍历路径以字节流的形式读取所有的 k = list(v) 封装到到一个 Map 中，key 为接口全限定类名，value 为所有实现类的全限定类名列表。\r\n\r\n上述说的这些加载操作都封装在 SpringFactoriesLoader 类里。该类很简单，提供三个加载方法、一个实例化方法，还有一个 cache 属性，首次加载到的数据会保存在 cache 里，供后续使用。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1c7105e7244e5e9d7646b72de14361~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## SpringBoot 核心要点\r\n\r\n上面讲的 SPI 其实就是我们 SpringBoot 自动装配的核心。\r\n\r\n**何为自动装配？**\r\n\r\n自动装配对应的就是手动装配，在没 SpringBoot 之前，我们使用 Spring 就是用的手动装配模式。在使用某项第三方功能时，我们需要引入该功能依赖的所有包，并测试保证这些引入包版本兼容。然后在 XML 文件里进行大量标签配置，非常繁琐。后来 Spring4 里引入了 JavaConfig 功能，利用 @Configuration + @Bean 来代替 XML 配置，虽然对开发来说是友好了许多，但是这些模板式配置代码还是很繁琐，会浪费大量时间做配置。Java 重可能也就是这个时候给人留的一种印象。\r\n\r\n在该背景下出现了 SpringBoot，SpringBoot 可以说是稳住了 Java 的地位。SpringBoot 提供了自动装配功能，自动装配简单来说就是将某种功能（如 web 相关、redis 相关、logging 相关等）打包在一起，统一管理依赖包版本，并且约定好相关功能 Bean 的装配规则，使用者只需引入一个依赖，通过少量注解或简单配置就可以使用第三方组件提供的功能了。\r\n\r\n在 SpringBoot 中这类功能组件有一个好听的名字叫做 starter。比如 spring-boot-starter-web、spring-boot-starter-data-redis、spring-boot-starter-logging 等。starter 里会通过 @Configuration + @Bean + @ConditionalOnXXX 等注解定义要注入 Spring 中的 Bean，然后在 spring.factories 文件中配置为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 的实现，就可以完成自动装配了。\r\n\r\n**具体装配流程怎么样的呢？**\r\n\r\n其实也很简单，基本都是 Spring 中的知识，没啥新颖的。主要依托于@EnableAutoConfiguration 注解，该注解上会 Import 一个 AutoConfigurationImportSelector，看下继承关系，该类继承于 DeferredImportSelector。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1287db468ce747c9870993cb96784699~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n主要方法为 getAutoConfigurationEntry()\r\n\r\n```java\r\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\r\n      // 1\r\n      if (!isEnabled(annotationMetadata)) {\r\n        return EMPTY_ENTRY;\r\n      }\r\n      AnnotationAttributes attributes = getAttributes(annotationMetadata);\r\n      // 2\r\n      List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\r\n      configurations = removeDuplicates(configurations);\r\n      // 3\r\n      Set<String> exclusions = getExclusions(annotationMetadata, attributes);\r\n      checkExcludedClasses(configurations, exclusions);\r\n      configurations.removeAll(exclusions);\r\n      // 4\r\n      configurations = getConfigurationClassFilter().filter(configurations);\r\n      fireAutoConfigurationImportEvents(configurations, exclusions);\r\n      return new AutoConfigurationEntry(configurations, exclusions);\r\n}\r\n```\r\n\r\n**方法解读**\r\n\r\n1. 通过 spring.boot.enableautoconfiguration 配置项判断是否启用自动装配，默认为 true\r\n\r\n2. 使用上述说的 SpringFactoriesLoader.loadFactoryNames() 加载所有 org.springframework.boot.autoconfigure.EnableAutoConfiguration 的实现类的全限定类名，借助 HashSet 进行去重\r\n\r\n3. 获取 @EnableAutoConfiguration 注解上配置的要 exclude 的类，然后排除这些特定类\r\n\r\n4. 通过 @ConditionalOnXXX 进行过滤，满足条件的类才会留下，封装到 AutoConfigurationEntry 里返回\r\n\r\n**那 getAutoConfigurationEntry() 方法在哪儿调用呢？**\r\n\r\n```java\r\npublic void refresh() throws BeansException, IllegalStateException {\r\n    // Allows post-processing of the bean factory in context subclasses.\r\n    postProcessBeanFactory(beanFactory);\r\n\r\n    StartupStep beanPostProcess = this.applicationStartup.start(\\\"spring.context.beans.post-process\\\");\r\n    // Invoke factory processors registered as beans in the context.\r\n    invokeBeanFactoryPostProcessors(beanFactory);\r\n\r\n    // Register bean processors that intercept bean creation.\r\n    registerBeanPostProcessors(beanFactory);\r\n    beanPostProcess.end();\r\n\r\n    // Initialize message source for this context.\r\n    initMessageSource();\r\n\r\n    // Initialize event multicaster for this context.\r\n    initApplicationEventMulticaster();\r\n\r\n    // Initialize other special beans in specific context subclasses.\r\n    onRefresh();\r\n\r\n    // Check for listener beans and register them.\r\n    registerListeners();\r\n\r\n    // Instantiate all remaining (non-lazy-init) singletons.\r\n    finishBeanFactoryInitialization(beanFactory);\r\n\r\n    // Last step: publish corresponding event.\r\n    finishRefresh();\r\n}\r\n```\r\n\r\n以上是 Spring 容器刷新时的几个关键步骤，在步骤二 invokeBeanFactoryPostProcessors() 中会调用所有已经注册的 BeanFactoryPostProcessor 进行处理。此处调用也是有顺序的，优先会调用所有 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry()，BeanDefinitionRegistryPostProcessor 是一个特殊的 BeanFactoryPostProcessor，然后再调用所有 BeanFactoryPostProcessor#postProcessBeanFactory()。\r\n\r\nConfigurationClassPostProcessor 是 BeanDefinitionRegistryPostProcessor 的一个实现类，该类主要用来处理 @Configuration 注解标注的类。我们用 @Configuration 标注的类会被 ConfigurationClassParser 解析包装成 ConfigurationClass 对象，然后再调用 ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass() 进行 BeanDefination 的注册。\r\n\r\n其中 ConfigurationClassParser 解析时会递归处理源配置类上的注解（@PropertySource、@ComponentScan、@Import、@ImportResource）、 @Bean 标注的方法、接口上的 default 方法，进行 ConfigurationClass 类的补全填充，同时如果该配置类有父类，同样会递归进行处理。具体代码请看 ConfigurationClassParser#doProcessConfigurationClass() 方法\r\n\r\n```java\r\nprotected final SourceClass doProcessConfigurationClass(\r\n\\t\\t\\tConfigurationClass configClass, SourceClass sourceClass, Predicate<String> filter)\r\n\\t\\t\\tthrows IOException {\r\n      \r\n    // Process any @PropertySource annotations\r\n\r\n    // Process any @ComponentScan annotations\r\n\r\n    // Process any @Import annotations\r\n    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);\r\n\r\n    // Process any @ImportResource annotations\r\n\r\n    // Process individual @Bean methods\r\n    Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\r\n    for (MethodMetadata methodMetadata : beanMethods) {\r\n             configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\r\n    }\r\n\r\n    // Process default methods on interfaces\r\n    processInterfaces(configClass, sourceClass);\r\n\r\n    // Process superclass, if any\r\n    if (sourceClass.getMetadata().hasSuperClass()) {\r\n             String superclass = sourceClass.getMetadata().getSuperClassName();\r\n             if (superclass != null && !superclass.startsWith(\\\"java\\\") &&\r\n                            !this.knownSuperclasses.containsKey(superclass)) {\r\n                      this.knownSuperclasses.put(superclass, configClass);\r\n                    // Superclass found, return its annotation metadata and recurse\r\n                      return sourceClass.getSuperClass();\r\n            }\r\n    }\r\n\r\n    // No superclass -> processing is complete\r\n    return null;\r\n}\r\n```\r\n\r\n1）parser.parse(candidates) 解析得到完整的 ConfigurationClass 对象，主要填充下图框中的四部分。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea0effea33f469e962bf2430a089d66~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27eb915f17ee46a192cfd7b795a61738~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n2）this.reader.loadBeanDefinitions(configClasses) 根据框中的四部分进行 BeanDefination 的注册。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7df14f11ed4645e7a31ca95f4f6edd17~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在上述 processImports() 过程中会将 DeferredImportSelector 的实现类放在 deferredImportSelectorHandler 中以便延迟到所有的解析工作完成后进行处理。deferredImportSelectorHandler 中就存放了 AutoConfigurationImportSelector 类的实例。process() 方法里经过几步走会调用到 AutoConfigurationImportSelector#getAutoConfigurationEntry() 方法上获取到自动装配需要的类，然后进行与上述同样的 ConfigurationClass 解析封装工作。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761cb5df05f8407cb45af734a374a133~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a1e5427262d41b6a35cc08d17064da6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n代码层次太深，调用太复杂，建议自己断点调试源码跟一遍印象会更深刻。\r\n\r\n## ApplicationContextInitializer 调用时机\r\n\r\n我们就以 SpringBoot 项目为例来看，在 SpringApplication 的构造函数中会进行 ApplicationContextInitializer 的初始化。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a0631cbf5094b29851fa58102894e8f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上图中的 getSpringFactoriesInstances 方法内部其实就是调用 SpringFactoriesLoader.loadFactoryNames 获取所有 ApplicationContextInitializer 接口的实现类，然后反射创建对象，并对这些对象进行排序（实现了 Ordered 接口或者加了 @Order 注解）。\r\n\r\n```java\r\n private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {\r\n      ClassLoader classLoader = getClassLoader();\r\n      // Use names and ensure unique to protect against duplicates\r\n      Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\r\n      List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\r\n      AnnotationAwareOrderComparator.sort(instances);\r\n      return instances;\r\n}\r\n```\r\n\r\n至此，项目中所有 ApplicationContextInitializer 的实现已经加载并且创建好了。在 prepareContext 阶段会进行所有已注册的 ApplicationContextInitializer#initialize() 方法的调用。在此之前prepareEnvironment 阶段已经准备好了环境信息，此处接入配置中心就可以拉到远程配置信息然后填充到 Spring 环境中供应用使用。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ead2639909e4295a2fae2471526bc0c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## SpringBoot 集成 Apollo\r\n\r\nApolloApplicationContextInitializer 实现 ApplicationContextInitializer 接口，并且在 spring.factories 文件中配置如下\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a70c0759a19481e8a6845810a710e6c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n```yaml\r\norg.springframework.context.ApplicationContextInitializer=\\\\\r\ncom.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer\r\n```\r\n\r\ninitialize() 方法中会根据 apollo.bootstrap.namespaces 配置的 namespaces 进行配置的拉去，拉去到的配置会封装成 ConfigPropertySource 添加到 Spring 环境 ConfigurableEnvironment 中。具体的拉去流程就不展开讲了，感兴趣的可以自己去阅读源码了解。\r\n\r\n## SpringCloud 集成 Nacos、Zk、Consul\r\n\r\n在 SpringCloud 场景下，SpringCloud 规范中提供了 PropertySourceBootstrapConfiguration 继承 ApplicationContextInitializer，另外还提供了个 PropertySourceLocator，二者配合完成配置中心的接入。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4869f65cc649452aae18f8b2d2e26bb3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\ninitialize 方法根据注入的 PropertySourceLocator 进行配置的定位获取，获取到的配置封装成 PropertySource 对象，然后添加到 Spring 环境 Environment 中。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591143a719dc48b99afad80e9c848b83~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nNacos、Zookeeper、Consul 都有提供相应 PropertySourceLocator 的实现\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60ebf14b2374454995aaa17fb2fe210c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们来分析下 Nacos 提供的 NacosPropertySourceLocator，locate 方法只提取了主要流程代码，可以看到 Nacos 启动会加载以下三种配置文件，也就是我们在 bootstrap.yml 文件里配置的扩展配置 extension-configs、共享配置 shared-configs 以及应用自己的配置，加载到配置文件后会封装成 NacosPropertySource 放到 Spring 的 Environment 中。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388b55236f9c4d28bc5223f5d4cd87fd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n```java\r\npublic PropertySource<?> locate(Environment env) {\r\n     loadSharedConfiguration(composite);\r\n     loadExtConfiguration(composite);\r\n     loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env);\r\n     return composite;\r\n}\r\n```\r\n\r\nloadApplicationConfiguration 加载应用配置时，同时会加载以下三种配置，分别是 \r\n\r\n> 1. 不带扩展名后缀，application\r\n>\r\n> 2. 带扩展名后缀，application.yml\r\n>\r\n> 3. 带环境，带扩展名后缀，application-prod.yml\r\n\r\n**并且从上到下，优先级依次增高**\r\n\r\n```java\r\nprivate void loadApplicationConfiguration(\r\n\\t\\t\\tCompositePropertySource compositePropertySource, String dataIdPrefix,\r\n\\t\\t\\tNacosConfigProperties properties, Environment environment) {\r\n    String fileExtension = properties.getFileExtension();\r\n    String nacosGroup = properties.getGroup();\r\n    // load directly once by default\r\n    loadNacosDataIfPresent(compositePropertySource, dataIdPrefix, nacosGroup,\r\n                    fileExtension, true);\r\n    // load with suffix, which have a higher priority than the default\r\n    loadNacosDataIfPresent(compositePropertySource,\r\n                    dataIdPrefix + DOT + fileExtension, nacosGroup, fileExtension, true);\r\n    // Loaded with profile, which have a higher priority than the suffix\r\n    for (String profile : environment.getActiveProfiles()) {\r\n            String dataId = dataIdPrefix + SEP1 + profile + DOT + fileExtension;\r\n            loadNacosDataIfPresent(compositePropertySource, dataId, nacosGroup,\r\n                            fileExtension, true);\r\n    }\r\n}\r\n```\r\n\r\n加载过程中，通过 namespace, dataId, group 唯一定位一个配置文件\r\n\r\n> 1. 首先获取本地缓存的配置，如果有直接返回\r\n>\r\n> 2. 如果步骤1从本地没找到相应配置文件，开始从远处拉去，Nacos 2.0 以上版本使用 Grpc 协议进行远程通信，1.0 及以下使用 Http 协议进行远程通信\r\n>\r\n> 3. 对拉去到的字符串进行解析，封装成 NacosPropertySource 返回\r\n\r\n具体细节就不展开讲了，可以自己看源码了解\r\n\r\nZookeeper、Consul 的接入也是非常简单，可以自己分析一遍。如果我们有自研的配置中心，需要在 SpringCloud 环境下使用，可以根据 SpringCloud 提供的这些扩展参考以上几种实现快速的写个 starter 进行接入。\r\n\r\n## 总结\r\n\r\n本篇文章主要讲了下 Spring SPI 机制、SpringBoot 自动装配原理，以及扩展点 ApplicationContextInitializer 在集成配置中心时的应用。篇幅有限，一些具体代码细节就没展开讲了，以后会出些文章针对某一个点进行详细讲解。\r\n\r\n## 个人开源项目\r\n\r\nDynamicTp 是一个基于配置中心实现的轻量级动态线程池管理工具，主要功能可以总结为动态调参、通知报警、运行监控、三方包线程池管理等几大类。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e30940d9e50f4939b013f16b456a7c44~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n目前累计 2k star，代码优雅，使用了大量设计模式，如果你觉得看这些大型框架源码费劲，那么可以尝试从 DynamicTp 源码入手，欢迎大家了解试用\r\n\r\n**官网**：[https://dynamictp.cn](https://dynamictp.cn \\\"https://dynamictp.cn\\\")\r\n\r\n**gitee地址**：[https://gitee.com/dromara/dynamic-tp](https://gitee.com/dromara/dynamic-tp \\\"https://gitee.com/dromara/dynamic-tp\\\")\r\n\r\n**github地址**：[https://github.com/dromara/dynamic-tp](https://github.com/dromara/dynamic-tp \\\"https://github.com/dromara/dynamic-tp\\\")"
    },
    {
        "article_id": "7175905067843715127",
        "snapshot": "",
        "title": "JS数据类型判断的九种方式",
        "preview": "JS 的数据类型检测是一道经典的八股文面试题。相信大家都能条件反射的回答出 4 种方法：typeof、constructor、instanceof 和 Object.prototype.toStrin",
        "author": "昆吾kw",
        "view_count": 1852,
        "collect_count": 30,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/3745b7eb198f2357155cd88eb7930f35~300x300.image",
        "category": "前端",
        "content": "JS 的数据类型检测是一道经典的八股文面试题。相信大家都能条件反射的回答出 4 种方法：typeof、constructor、instanceof 和 Object.prototype.toString，并且对它们各自的优缺点也是张口就来。\r\n\r\n本文对这些方法做了简单归纳，同时又补充了其他 5 种和数据类型检测有关的方法，供诸君食用。\r\n\r\n## typeof：检测基础数据类型和函数很好用\r\n\r\ntypeof 应该是我学习到的第一个 JS 的方法，也是使用频率最高的一个用来检测数据类型的方法。\r\n\r\n它能准确判断出的数据类型有：Number，String，Boolean，Undefined，Symbol，BigInt，Function。\r\n\r\n它的缺点就是不能准确判断 null 的类型，而是返回 “object”。对于数组，日期，普通对象等数据，统一返回 “object”。\r\n\r\n所以在判断基本数据类型（除了 null）和函数类型时，都会使用它。\r\n\r\n## constructor：返回实例对象的构造函数\r\n\r\n学习 JS 到面向对象的阶段时，会学到 JS 的原型链和原型对象，会学到通过 new 一个构造函数，来创建实例对象。\r\n\r\n构造函数的原型对象上会有一个 constructor 属性，指向了构造函数自身，所以实例对象通过原型链访问 constructor 属性，就能找到自己的构造函数，也就是自己的类型了。\r\n\r\n它的本意是用来标识自己的构造函数，却临时拉来当壮丁，用来判断数据类型，当然也存在一定的风险：\r\n\r\n-   null，undefined 没有构造函数，自然也就访问不到该属性，因此不能使用此属性来判断\r\n-   constructor 可以被改写，所以不一定准确\r\n\r\n来看几个例子：\r\n\r\n```\r\nconsole.log((1).constructor === Number) // true\r\n​\r\nconsole.log([1, 2, 3].constructor === Array) // true\r\n​\r\nconsole.log(undefined.constructor === Array) // 报错\r\n```\r\n\r\n在平时写代码时，基本上不会用它来做数据类型的检测。\r\n\r\n## instanceof：沿着原型链去找\r\n\r\n它和 constructor 一样，也是临时拉来当壮丁。它的作用是检测实例对象是不是属于某个构造函数，可以用来做数据类型的检测。\r\n\r\n术业有专攻，所以它也有缺点：\r\n\r\n-   不能检测基本数据类型\r\n\r\n<!---->\r\n\r\n-   原型链可能被修改，导致检测结果不准确\r\n-   只要能在原型链上找到构造函数，就返回 true，所以类型可能不准确\r\n\r\n来看几个例子：\r\n\r\n```\r\nconsole.log(1 instanceof Number) // false\r\n​\r\nconsole.log([] instanceof Array) // true\r\n​\r\nconsole.log([] instanceof Object) // true\r\n```\r\n\r\n实际中 instanceof 也很少用。\r\n\r\n## Object.prototype.toString：是个大拿\r\n\r\n看名字它是用来将一个值转为字符串的，但其实并不是，它是一个专门检测数据类型的方法。\r\n\r\n它返回的值是一个形如 `[object Object]` 的字符串，比如：\r\n\r\n```\r\nconsole.log(toString.call('123'))        // [object String]\r\nconsole.log(toString.call(null))         // [object Null]\r\nconsole.log(toString.call(true))         // [object Boolean]\r\nconsole.log(toString.call({}))           // [object Object]\r\nconsole.log(toString.call([]))           // [object Array]\r\nconsole.log(toString.call(function(){})) // [object Function]\r\nconsole.log(toString.call(new Map))      // [object Map]\r\nconsole.log(toString.call(new WeakSet))  // [object WeakSet]\r\n```\r\n\r\n通常会编写一个函数，对返回的字符串从第8位做一个截取，截取到倒数第一位，再去做类型比较。\r\n\r\n## Symbol.toStringTag：自定义类型\r\n\r\n上面的 Object.prototype.toString 方法，之所以对不同的数据类型，返回不同的标识字符串，就是因为 `Symbol.toStringTag` 。\r\n\r\n`Symbol.toStringTag` 是一个内置符号属性，它的值是一个字符串，用于表示一个对象的默认描述，也就是调用 Object.prototype.toString 会返回的内容，比如：\r\n\r\n```\r\nlet obj = {}\r\nobj[Symbol.toStringTag] = 'ABC'\r\nconsole.log(Object.prototype.toString.call(obj)) // [object ABC]\r\n```\r\n\r\n对于自定义对象，调用上面的方法，都只会返回 `[object Object]`。此时就可以使用 `Symbol.toStringTag` 来指定一个确定的类型了，比如：\r\n\r\n```\r\nclass Person{\r\n    get[Symbol.toStringTag](){\r\n        return 'Person'\r\n    }\r\n}\r\nlet person = new Person()\r\n​\r\nconsole.log(Object.prototype.toString.call(person)) // [object Person]\r\n```\r\n\r\n## Object.prototype.isPrototypeOf：和 instanceof 类似\r\n\r\nisPrototypeOf 和 instanceof 类似，都是基于原型链和原型对象去做判断的。它用来检查一个对象是否存在于另一个对象的原型链上。\r\n\r\n```\r\nfunction Person() {\r\n    \r\n}\r\n​\r\nlet person = new Person()\r\n​\r\nconsole.log(Person.prototype.isPrototypeOf(person))\r\n```\r\n\r\n## Array.isArray：专业检测数组三十年\r\n\r\n起初以为它是 ES6 提供的新方法，后来得知其实属于 ES 5.1 规范。\r\n\r\n看名字就知道，它是专门用于检测数组类型的，该方法的命名真实言简意赅。\r\n\r\n```\r\nArray.isArray([]) // true\r\n```\r\n\r\n## Number.isNaN\r\n\r\n这个方法就是真的属于 ES6 标准了。\r\n\r\n我们知道，JS 中有一个特殊的“数字” NaN，表示 not a number，不是一个数字，但它却归属于数字类型：\r\n\r\n```\r\nconsole.log(typeof NaN) // 'number'\r\n```\r\n\r\nNaN 用于表示不是一个数字，它不等于任何值，包括它本身。在 ES6 之前，windows 对象提供了一个全局方法 `isNaN`，用于判断一个数字是不是 NaN：\r\n\r\n```\r\nisNaN(10) // false\r\nisNaN('abc') // true\r\nisNaN(NaN) // true\r\n```\r\n\r\n可以发现，isNaN 对于字符串的检测结果也是 NaN。但这其实并不严谨，它对要判断的数据做了一个隐式类型转换，先转为数字再进行判断。而NaN 的检测应该仅限于数字类型，所以 ES6 提供了 Number.isNaN 方法：\r\n\r\n```\r\nNumber.isNaN(NaN) // true\r\nNumber.isNaN('123') // false\r\n```\r\n\r\n它能判断一个值是否严格等于NaN。\r\n\r\n## 等比较：与固定值进行比较\r\n\r\n直接通过与一个特定的值进行比较，从而判断数据的类型，比如：\r\n\r\n```\r\nlet value = null\r\nconsole.log(value === null) // true\r\n​\r\n// 同时判断一个值是 undefined 或者 null\r\nlet value\r\nconsole.log(value == null) // true\r\n```\r\n\r\n## 总结\r\n\r\n本文整理了 JS 中常用的判断数据类型的方法，其中 typeof 和 Object.prototype.toString 使用场景是最多的，对一些特殊的数据类型，比如 null，NaN，自定义类型，可以选择其他的方式去进行判断，做到灵活运用。\r\n\r\n关于数据类型的检测， 如果你还有其他的方式，欢迎评论补充，一起学习。\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\r\n\r\n"
    },
    {
        "article_id": "7188513053292363834",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7774b97b70a043a880d1a933537d7205~tplv-k3u1fbpfcp-watermark.image?",
        "title": "学习计算机网络？你首先要了解这些",
        "preview": "1️⃣ 因特网概述 2️⃣ 电路交换、分组交换、报文交换 3️⃣ 计算机网络的性能指标 4️⃣ 计算机网络体系结构",
        "author": "Zhan_",
        "view_count": 1185,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/5bf779df49463bd6eb5e5e1d5f496300~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: smartblue\r\n---\r\n> 📣 大家好，我是Zhan，一名个人练习时长一年半的**大二后台练习生**\r\n> \r\n> 📣 这篇文章是 `深入浅出计算机网络` 中 `计网概述` 的学习笔记\r\n> \r\n> 📣 如果有不对的地方，欢迎各位指正 🙏🏼\r\n> \r\n> 📣 **与君同舟渡，达岸各自归** \r\n\r\n---\r\n## 🔔 本篇速览\r\n- 1️⃣ 因特网概述\r\n- 2️⃣ 电路交换、分组交换、报文交换\r\n- 3️⃣ 计算机网络的性能指标\r\n- 4️⃣ 计算机网络体系结构\r\n\r\n---\r\n## 一、因特网概述\r\n### 📡 1.网络、互联网、因特网\r\n> 似乎在我们的日常生活中总是会提到这三个名词：**网络、互联网、因特网**，看起来它们似乎指的是同一个东西，但实际上只是我们没有做很好的区分，就让我们分别来看看它们分别代表着什么：\r\n\r\n**网络**就是几部计算机主机或者是网络打印机之类的接口设备，透过**有线链路**或者是**无线网络**的技术，将这些主机与设备连接起来，使得数据可以透过网络媒体(网络线以及其他网络卡等硬件)来传输的一种方式：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3e2d4cd6dd477fbb9b6b91c2298e5e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而**网络与网络之间进行互联**也就是我们所说的**互联网**，而互联所需要的设备就是路由器，通过路由器我们可以连接多个网络，即**若干网络通过路由器互联形成互联网**：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b05f27ac5924b9f907fcd9a5c49edd6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而**因特网就是世界上最大的互联网**，也就是说世界上的网络都通过路由器连接形成了这个世界上最大的、全球通用的互联网\r\n\r\n### 📲 2.ISP(Internet Service Provider)\r\n> 在日常的使用网络的过程中，我们需要连接网络进行与其他网络的互联，在这个过程中我们会**被分配IP地址**，用于我们进行网络的互联，那么这些IP地址从何而来呢？\r\n\r\n无论是我们的WIFI、蜂窝数据，都有它的运营商：`中国移动、中国电信、中国联通……`，他们就是负责分配IP给我们的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff72e1454700462cb5bbef50e4bc1f27~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n因特网已经发展成为基于ISP的多层次结构的互联网络，就这样层层代理下来：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0690d47efd04ad4ad8ef837bba5a7fb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n## 二、三种交换方式\r\n> 网络之间进行通信的方式有着以下三种方式，尽管随着时间的推移，**现在我们基本上使用分组交换**，但是发展的历程还是值得我们去探究的：\r\n### 1.电路交换\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03122977959742ecb52b95583756da1e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n1. 在使用电路交换打电话之前，先拨号建立连接：\r\n\\t1. 当拨号的信息通过许多交换机到达被叫用户所连接的交换机时，该交换机就向用户的电话机**振铃**\r\n\\t2. 在被叫用户摘机且摘机信号传**送回**到主叫用户所连接的交换机后，呼叫即完成，这时从主叫端到被叫端就**建立了一条连接**。\r\n2. 通话过程。\r\n3. 通话结束挂机后，挂机信令告诉这些交换机，使交换机**释放**刚才这条物理通路。\r\n4. 这种必须经过“**建立连接--通信--释放连接**”三个步骤的连网方式称为面向连接的。电路交换必定是面向连接的。\r\n\r\n可是在当今的计算机网络中，我们以`微信`举例，如果说刘德华是我的好友，但是我不一定时时刻刻给他发信息，那么连接一直占用，线路上真正用来传输数据的时间很少，也就是说**线路的传输效率一般都会很低**，因为**计算机之间的数据传送是突发式**的。\r\n\r\n### 2.分组交换\r\n> 其实这里有点容易联想到**长连接和短连接**，很明显：如果我们以长连接的方式去进行数据的通信，**效率是很低**的，而采用短连接，对于一条消息我们就建立一次连接，会有不少的建立连接和销毁连接的**开销**，那么我们也不建立连接和释放连接，我们采用**分组交换**的方法：\r\n\r\n现在需要把信息从H1传到H3，我们并不建立H1与H3的连接：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef828500a674d7d8943ea6b96c329f6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而是把信息分成多段，给每段加上一个头部，头部中我们会存放一些信息，如：\r\n- 是消息的第几段\r\n- 目标主机的IP地址\r\n- 消息是否被篡改\r\n- .......\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13bae32e4c2248bd831ddee1db294e35~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nH3拿到分组的消息后，就能根据头部进行组装还原报文信息，而在这个过程中H2起到的作用就是缓存分组，然后根据头部信息转发给H3\r\n\r\n### 3.报文交换\r\n> **报文交换是分组交换的前身**，也就是对于一整个报文加上一个头部然后传输出去\r\n\r\n这样做的坏处就是：\r\n1. 中间结点H2需要缓存空间就要大很多，而如果**缓存空间不足**就会发生丢包\r\n2. 并且中间结点需要缓存下来整个报文信息才会进行转发，而分组交换只需要缓存一个小的分组就可以开始进行转发了，因此**缓存时延要长很多**\r\n听起来可能有点抽象，我们在下面的对比中通过图像的方式来理解一下这三种交换\r\n\r\n### 4.对比\r\n> 我们纵轴为时间轴，横轴为数据的传播，可以画出三种交换的交换过程：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae3161681aa24c31b6cf2f70739b1ba0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n- 如果需要连续的传送大量的数据，并且数据传送的时间远大于建立连接的时间，我们可以采用**电路交换**\r\n- **报文交换**和**分组交换**都不需要建立连接，这样我们可以提高通信线路的**利用率**\r\n- 通过图我们也可以发现分组交换所需要的**时延**远小于报文交换，这样还能够避免长时间占用链路\r\n\r\n---\r\n## 三、八大性能指标\r\n> 计算机网络的性能如何，我们通常使用以下八个指标来进行衡量，其中有我们比较熟悉的：速率、带宽、丢包率，也有一些陌生的名词：吞吐量、时延、时延带宽积、往返时间、利用率，下文我们将来探讨一下这八个性能指标\r\n\r\n### 1.速率\r\n这个是我们经常会接触到衡量网络的一个主要标准，我们可能经常看到下载速度`10MB/s`这样的字眼，这个似乎不用讲太多，大伙懂得都懂，但是还是想提一嘴计量单位的相关问题：\r\n\r\n**思考**：有一个待发送的数据块，大小为100MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间？\r\n\r\n**错误示范**： 100 / 100 = 1\r\n\r\n**正确答案**：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8784ae8bb1043c6a6e6b8751770e91f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**解析**：这里就不得不提到**数据量的单位**和**速率的单位**了，见下表：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b520a99155a04c06873c35034a6e6792~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n### 2.带宽\r\n在计算机网络中，带宽用来表示网络的**通信线路能够传输数据的能力**，也就是从一点到另外一点能够通过的**最大数据量**，例如我要把水从A运到B，带宽就是水管的大小，可以不装满水管，但是单位时间能够流过的最大只能是水管大小\r\n\r\n而数据的传输的速率由**主机接口速率、线路带宽、路由器的接口速率**三者共同决定，取它们的最小值就是数据的传输速率，其实有点类似于木桶效应：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33cc49a3a56747cba0c3ece7a1deefb1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n### 3.吞吐量\r\n吞吐量是指**单位时间内通过网络的实际数据量**，包括上传和下载的数据量，我们以下面这个例子来讲：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d3fe5f573054ded9f5dd914423cec4a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此处的`吞吐量 = 20Mb/s + 600kb/s + 1Mb/s = 21.6Mb/s`\r\n\r\n---\r\n### 4.时延\r\n> 时延这个词听起来好像有点陌生，但是我们换一个词就很熟悉了——`延迟`\r\n\r\n时延是指数据从**网络的一端到另外一端所耗费的时间**，而在交换的过程中有哪些地方需要耗费时间呢，我们以下面这个场景为例，具体分析一下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95c8e97d00c949ec942a0ff02f486b17~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是说把分组发送出去以及在传播过程都需要时间，而在路由器需要进行排队和处理也需要时间，路由器还需要发送和传播的时间，我们可以通过下面这个图更清晰的看出：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/008de5fa77314234873afa94b746e8a5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果我们使用分组交换，图像就会变为：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3344959ee3ea4a7a91026ec49056154f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n### 5.时延带宽积\r\n时延带宽积可以理解为：**以比特为单位的链路长度**，我们可以知道链路中有多少个比特，`时延带宽积 = 时延 × 带宽`，我们可以用下面这个例子来帮助我们理解\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02e997c652a343d0a096e4333089f2be~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n### 6.往返时间\r\n往返时间：从发送端发送数据分组开始，发送端接受到接收端返回的确认消息为止，总共耗费的时间，也就是“**一次握手的时间**”\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc29f47637e4b878d839e8f1b77161f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n---\r\n### 7.利用率\r\n> 对于一条链路，它上面有信息传过去我们就称它被利用了，那么利用率的概念就比较明确了：\r\n\r\n**链路利用率**：某条链路有百分之几的时间是被利用的，也就是有多少时间是有数据通过传输的，完全空闲的链路的利用率为零\r\n\r\n**网络利用率**：是指网络中所有链路的链路利用率的加权平均\r\n\r\n当然，并不是链路利用率越大越好，因为随着利用率的增大，链路引起的时延就会迅速增加，因此一般会把信道的利用率不超过50%\r\n\r\n---\r\n### 8.丢包率\r\n> 在传输过程中可能出现误码，被路径中的交换机发现检测到了，就会把它丢弃了，那么信息无法成功传达，也就是我们所说的丢包\r\n\r\n除了上面所说的情况，由于信道堵塞，也就是信道的内存的不够，就会根据丢弃策略丢掉分组的信息，一般丢包率可以反映网络的拥塞情况：\r\n- 无拥塞时路径丢包率 0\r\n- 轻度拥塞时路径丢包率 1%~4%\r\n- 严重拥塞时路径丢包率 5%~15%\r\n\r\n---\r\n## 四、体系结构\r\n> 计算机网络是一个非常复杂的系统，因此我们一般通过分层，可以把庞大复杂的问题转化为若干较小的局部问题，而对于计算机网络的分层我们有两套标准：\r\n### 1.OSI 参考模型\r\n**OSI参考模型**是法律标准，把计算机网络分为了七层：`应用层、表示层、会话层、运输层、网络层、数据链路层、物理层`\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1306ba8e5c01462a9a2d6e30b874b4f6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是实际上我们使用的标准并不是法律的标准，而是我们下面要介绍的`TCP/IP参考模型`，`OSI参考模型`失败的原因是：\r\n- 专家没有实操经验，完成标准的时候没有商业驱动力\r\n- 协议的实现太复杂\r\n- 标准的制定周期太长\r\n- 层次划分不合理，其中有多个层有重复的功能\r\n\r\n### 2.TCP|IP 参考模型\r\n`TCP/IP参考模型`是我们的实际使用的标准，把分层减少到了四层：`应用层、运输层、网络层、网络接口层`，这种参考模型层次之间的功能耦合更少，实现起来也容易。而我们在讨论的时候一般使用另外一种参考模型，也就是多了一层数据链路层：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/525e40ce782d43d88ea02fd8573958f0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n## 💬 总结\r\n本篇博客讲述了入门计算机网络所需要具备的知识：\r\n- 首先是从专业的角度来讲解了一下**因特网、互联网**\r\n- 关于网络之间的交换信息的方式，我们也是分别讲解了**三种交换方式**，以及它们的各自的优缺点，我们比较后也是一般使用**分组交换**\r\n- 然后讲解了一下我们衡量计算机网络的**八个指标**：速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率、丢包率，其中我们分析的比较多的是**时延**，对于其他几个概念都有了一个基础的了解\r\n- 最后讲解了我们在分析计算机网络的时候使用的模型，通过分层把计算机网络这个大整体分为一层层进行理解，这里我们提到了两种模型：**OSI、TCP/IP参考模型**\r\n- 但是我们并没有细致的讲解各层，后续的博客我们会依次剖析各层，深入了解计算机网络\r\n\r\n---\r\n## ✒写在最后\r\n> 都看到这里啦~，给个点赞再走呗~，也欢迎各位大佬指正以及补充，在评论区一起交流，共同进步！也欢迎加微信一起交流：**Goldfish7710**。咱们明天见~\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6bbbf514a0d400499d136975931a45b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7189199523406118967",
        "snapshot": "",
        "title": "2022年度人气创作者榜单 瓜分奖池第七天&第八天名单公布",
        "preview": "第八天公布 2022年度人气创作者榜单评选第八天，共有 343 名创作者参与瓜分总值 9000 元奖池。 名次 用户名 用户ID 榜单票数 新增票数 所在奖池 瓜分金额 1 宫水三叶的刷题日记 261",
        "author": "稀土君",
        "view_count": 1375,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/46218f0e66a164ea7d3b554b8e411dbd~300x300.image",
        "category": "阅读",
        "content": "## 第八天公布\r\n\r\n2022年度人气创作者榜单评选第八天，共有 343 名创作者参与瓜分总值 9000 元奖池。\r\n\r\n名次  | 用户名               | 用户ID             | 榜单票数  | 新增票数  | 所在奖池 | 瓜分金额  |\r\n| --- | ----------------- | ---------------- | ----- | ----- | ---- | ----- |\r\n| 1   | 宫水三叶的刷题日记         | 2612095355996743 | 61537 | 18756 | 300  | 63.01 |\r\n| 2   | Yestodorrow       | 78820567681902   | 59158 | 19260 | 300  | 64.7  |\r\n| 3   | 若川                | 1415826704971918 | 44081 | 11923 | 300  | 40.05 |\r\n| 4   | HullQin           | 615367094054285  | 21276 | 4243  | 300  | 14.25 |\r\n| 5   | 冴羽                | 712139234359182  | 21224 | 6546  | 300  | 21.99 |\r\n| 6   | 小满zs              | 2463384809252397 | 19955 | 5766  | 300  | 19.37 |\r\n| 7   | Sunshine_Lin      | 1292681407377624 | 16566 | 4519  | 300  | 15.18 |\r\n| 8   | 苏三说技术             | 465848661970824  | 16331 | 5715  | 300  | 19.2  |\r\n| 9   | 海拥                | 2040341402229751 | 16116 | 5010  | 300  | 16.83 |\r\n| 10  | 扫地盲僧              | 3016715636842622 | 15214 | 7565  | 300  | 25.41 |\r\n| 11  | yechaoa           | 659362706101735  | 14502 | 5106  | 300  | 47.88 |\r\n| 12  | 代码诗人_             | 3069492194710797 | 11530 | 9707  | 300  | 91.03 |\r\n| 13  | 法医                | 1574156383557255 | 10256 | 2390  | 300  | 22.41 |\r\n| 14  | why技术             | 3702810893364350 | 8399  | 2285  | 300  | 21.43 |\r\n| 15  | 刘悦的技术博客           | 3491704662919207 | 7811  | 2266  | 300  | 21.25 |\r\n| 16  | CUGGZ             | 3544481220801815 | 7679  | 2105  | 300  | 19.74 |\r\n| 17  | 不要秃头啊             | 932829447855975  | 7632  | 2072  | 300  | 19.43 |\r\n| 18  | 前端贰货道士            | 2129086177097096 | 7410  | 1894  | 300  | 17.76 |\r\n| 19  | 洛神灬殇              | 3966693683772462 | 7373  | 2207  | 300  | 20.7  |\r\n| 20  | 秦风0214            | 1195887458270190 | 7062  | 1959  | 300  | 18.37 |\r\n| 21  | 岛民小强              | 1750078239809790 | 6862  | 1911  | 900  | 50.94 |\r\n| 22  | 彭旭锐               | 1063982987230392 | 6861  | 2187  | 900  | 58.29 |\r\n| 23  | 前端周公子             | 96412752681079   | 6235  | 1258  | 900  | 33.53 |\r\n| 24  | NewBoy            | 3755587450709592 | 5702  | 1441  | 900  | 38.41 |\r\n| 25  | 园宵                | 831705151963870  | 5576  | 1415  | 900  | 37.72 |\r\n| 26  | 来碗盐焗星球            | 3316551988553709 | 5184  | 1248  | 900  | 33.26 |\r\n| 27  | 齐舞647             | 3421335918753102 | 5156  | 677   | 900  | 18.04 |\r\n| 28  | wjl110            | 4314919626348647 | 5028  | 913   | 900  | 24.34 |\r\n| 29  | Applehope         | 457814750554375  | 4866  | 956   | 900  | 25.48 |\r\n| 30  | 杨同学technotes      | 2594503173605767 | 4329  | 1196  | 900  | 31.88 |\r\n| 31  | codercao          | 78820566386071   | 4278  | 1202  | 900  | 32.04 |\r\n| 32  | 掘金安东尼             | 1521379823340792 | 4261  | 1312  | 900  | 34.97 |\r\n| 33  | MiyueFE           | 747323639208391  | 4222  | 1243  | 900  | 33.13 |\r\n| 34  | bug菌              | 695333581765240  | 4044  | 982   | 900  | 26.17 |\r\n| 35  | isboyjc           | 2999123452373735 | 4018  | 904   | 900  | 24.1  |\r\n| 36  | 一骑绝尘蛙             | 3509296848192216 | 3931  | 990   | 900  | 26.39 |\r\n| 37  | ClyingDeng        | 2735240661441591 | 3869  | 878   | 900  | 23.4  |\r\n| 38  | WinsonWu          | 1433418894956925 | 3846  | 1567  | 900  | 41.77 |\r\n| 39  | 季夏廿九              | 3650034333668302 | 3759  | 1043  | 900  | 27.8  |\r\n| 40  | iwhao             | 3122268755206334 | 3751  | 873   | 900  | 23.27 |\r\n| 41  | 寒月十九              | 1693704615893799 | 3713  | 1104  | 900  | 29.43 |\r\n| 42  | Petterp           | 3491704662136541 | 3706  | 947   | 900  | 25.24 |\r\n| 43  | 王中阳Go             | 2189882892232029 | 3670  | 969   | 900  | 25.83 |\r\n| 44  | Ethan_Zhou        | 1151943916391965 | 3630  | 869   | 900  | 23.16 |\r\n| 45  | Swift社区           | 3192637497025335 | 3589  | 806   | 900  | 21.48 |\r\n| 46  | 快跑啊小卢_            | 3360527239635373 | 3490  | 1162  | 900  | 30.97 |\r\n| 47  | 前端小蜗              | 61995432544503   | 3465  | 1146  | 900  | 30.55 |\r\n| 48  | JAVA旭阳            | 3438928100329646 | 3430  | 868   | 900  | 23.14 |\r\n| 49  | 小阿杰               | 2040300414187416 | 3318  | 919   | 900  | 24.5  |\r\n| 50  | ArvinC            | 580166250665006  | 3298  | 780   | 900  | 20.79 |\r\n| 51  | 小杜杜               | 703321119406919  | 3288  | 912   | 2000 | 56.02 |\r\n| 52  | 猪痞恶霸              | 431430802343479  | 3277  | 817   | 2000 | 50.18 |\r\n| 53  | Zuo               | 747323635537159  | 3221  | 976   | 2000 | 59.95 |\r\n| 54  | 优弧                | 852876722177533  | 3144  | 748   | 2000 | 45.94 |\r\n| 55  | 𝓼𝓲𝓭𝓲𝓸𝓽      | 2828360557003479 | 3122  | 1293  | 2000 | 79.42 |\r\n| 56  | 知否技术              | 140339735966695  | 3093  | 806   | 2000 | 49.51 |\r\n| 57  | 阿杆                | 4182956056773160 | 3012  | 889   | 2000 | 54.6  |\r\n| 58  | 代码与野兽             | 571401777717031  | 2974  | 324   | 2000 | 19.9  |\r\n| 59  | 布鲁斯要蓝调            | 3065888803654648 | 2970  | 664   | 2000 | 40.78 |\r\n| 60  | FuncJin           | 87580250747917   | 2969  | 746   | 2000 | 45.82 |\r\n| 61  | 掘金最后一个老实人         | 1231899345822152 | 2883  | 1147  | 2000 | 70.45 |\r\n| 62  | 不瑶碧莲              | 1099967744455774 | 2867  | 644   | 2000 | 39.56 |\r\n| 63  | Dream_juvenile    | 4265760847829512 | 2822  | 1262  | 2000 | 77.51 |\r\n| 64  | Cobyte            | 668147376989517  | 2784  | 769   | 2000 | 47.23 |\r\n| 65  | 磊叔的技术博客           | 3227821827961806 | 2764  | 821   | 2000 | 50.43 |\r\n| 66  | 钱得乐               | 606586151903320  | 2691  | 689   | 2000 | 42.32 |\r\n| 67  | 跟着飞哥学编程           | 132360371967448  | 2690  | 109   | 2000 | 6.69  |\r\n| 68  | vaelcy            | 166781498952974  | 2633  | 536   | 2000 | 32.92 |\r\n| 69  | 子不语Any            | 3051900007626103 | 2563  | 582   | 2000 | 35.75 |\r\n| 70  | 许进进               | 852876754422039  | 2488  | 668   | 2000 | 41.03 |\r\n| 71  | 清欢bx              | 3315782800389390 | 2464  | 629   | 2000 | 38.63 |\r\n| 72  | 前端胖头鱼             | 3438928099549352 | 2452  | 137   | 2000 | 8.41  |\r\n| 73  | 默海笑               | 3246223221632151 | 2435  | 548   | 2000 | 33.66 |\r\n| 74  | 奔波儿灞取经            | 1407028359070766 | 2428  | 708   | 2000 | 43.49 |\r\n| 75  | 荣顶                | 2858385963749223 | 2406  | 747   | 2000 | 45.88 |\r\n| 76  | 吓死羊了              | 3536444974974957 | 2334  | 531   | 2000 | 32.61 |\r\n| 77  | 聪小陈               | 1838039174227006 | 2264  | 423   | 2000 | 25.98 |\r\n| 78  | 逍丶                | 2960327966986621 | 2226  | 616   | 2000 | 37.84 |\r\n| 79  | 南山种子外卖跑手          | 475439118171927  | 2203  | 514   | 2000 | 31.57 |\r\n| 80  | HoMeTown          | 4116184668057390 | 2196  | 245   | 2000 | 15.05 |\r\n| 81  | jerryfans         | 2946346894254094 | 2188  | 641   | 2000 | 39.37 |\r\n| 82  | 叶一一               | 70822370479901   | 2164  | 419   | 2000 | 25.74 |\r\n| 83  | 熊的猫               | 4441682709585128 | 2155  | 610   | 2000 | 37.47 |\r\n| 84  | 大眼睛图图             | 1271464955742839 | 2149  | 658   | 2000 | 40.42 |\r\n| 85  | 姚明振               | 1310273589748558 | 2138  | 665   | 2000 | 40.85 |\r\n| 86  | 新生代农民工No1         | 273091408183054  | 2128  | 695   | 2000 | 42.69 |\r\n| 87  | 魏铁锤               | 2344622318171309 | 2117  | 299   | 2000 | 18.36 |\r\n| 88  | 叶秋学长              | 2397403183068775 | 2102  | 450   | 2000 | 27.64 |\r\n| 89  | 清秋                | 940837682306830  | 2100  | 583   | 2000 | 35.81 |\r\n| 90  | 茶无味的一天            | 2682464103060541 | 2097  | 622   | 2000 | 38.2  |\r\n| 91  | CoderHing         | 1992782705853159 | 2086  | 869   | 2000 | 53.38 |\r\n| 92  | 夏志121             | 224730096864541  | 2065  | 667   | 2000 | 40.97 |\r\n| 93  | 一一哥Sun            | 1086730598890727 | 2058  | 797   | 2000 | 48.95 |\r\n| 94  | 一条会coding的Shark   | 233526039432445  | 2045  | 645   | 2000 | 39.62 |\r\n| 95  | 进军的王小二            | 3808364011470030 | 2037  | 621   | 2000 | 38.14 |\r\n| 96  | 纪先生               | 123624772082791  | 2035  | 447   | 2000 | 27.46 |\r\n| 97  | 尚影嫣               | 105206371061245  | 2015  | 559   | 2000 | 34.33 |\r\n| 98  | 夕水                | 4054654613988718 | 2004  | 566   | 2000 | 34.76 |\r\n| 99  | 19组清风             | 307518987049112  | 2002  | 553   | 2000 | 33.97 |\r\n| 100 | 二流小码农             | 1398234520239095 | 1924  | 696   | 2000 | 42.75 |\r\n| 101 | 阿佩佩               | 4455656639440856 | 1898  | 376   | 1800 | 41.95 |\r\n| 102 | 前端那些年             | 1714893871392045 | 1886  | 554   | 1800 | 61.81 |\r\n| 103 | ndz               | 976022056736765  | 1865  | 458   | 1800 | 51.1  |\r\n| 104 | 三掌柜               | 1636485994149022 | 1842  | 419   | 1800 | 46.75 |\r\n| 105 | 低调的牛魔王            | 3501266760638312 | 1841  | 510   | 1800 | 56.9  |\r\n| 106 | Kagol             | 1504599026445150 | 1813  | 427   | 1800 | 47.64 |\r\n| 107 | 石云升               | 642537280772456  | 1722  | 396   | 1800 | 44.18 |\r\n| 108 | 战场小包              | 4424090519078430 | 1709  | 1236  | 1800 | 137.9 |\r\n| 109 | Ziu               | 4420463502826087 | 1697  | 453   | 1800 | 50.54 |\r\n| 110 | CodeFox           | 4001878054283358 | 1643  | 542   | 1800 | 60.47 |\r\n| 111 | 王有志               | 26044011123624   | 1489  | 359   | 1800 | 40.05 |\r\n| 112 | 格格步入              | 395479916231565  | 1441  | 345   | 1800 | 38.49 |\r\n| 113 | 前端南玖              | 219558057873005  | 1421  | 261   | 1800 | 29.12 |\r\n| 114 | Bug终结者_           | 4108235439082231 | 1370  | 285   | 1800 | 31.8  |\r\n| 115 | Finbird           | 1293455879050157 | 1354  | 258   | 1800 | 28.78 |\r\n| 116 | 桃小瑞               | 1196739061361437 | 1342  | 440   | 1800 | 49.09 |\r\n| 117 | 初心酱               | 2225067266945213 | 1338  | 370   | 1800 | 41.28 |\r\n| 118 | 蚂蚁背大象             | 1151943918492855 | 1328  | 311   | 1800 | 34.7  |\r\n| 119 | 我不是外星人            | 2418581313687390 | 1321  | 275   | 1800 | 30.68 |\r\n| 120 | 小野学Java           | 1610150032974477 | 1281  | 179   | 1800 | 19.97 |\r\n| 121 | 楚楚北北              | 682131179450493  | 1270  | 153   | 1800 | 17.07 |\r\n| 122 | XboxYan           | 3579665587900030 | 1231  | 368   | 1800 | 41.06 |\r\n| 123 | 想赚点零花钱            | 2885580832641213 | 1211  | 290   | 1800 | 32.35 |\r\n| 124 | 郑居中               | 1486991861517405 | 1201  | 233   | 1800 | 25.99 |\r\n| 125 | 十七喜欢前端            | 1306665624546712 | 1197  | 234   | 1800 | 26.11 |\r\n| 126 | 在下uptown          | 870468940210797  | 1188  | 211   | 1800 | 23.54 |\r\n| 127 | TT_Close          | 2858385964538663 | 1180  | 322   | 1800 | 35.92 |\r\n| 128 | somliy            | 888061128621021  | 1126  | 361   | 1800 | 40.28 |\r\n| 128 | Somnus_小凯         | 2049145403616814 | 1126  | 404   | 1800 | 45.07 |\r\n| 129 | 遇渐渐               | 2374598790494718 | 1102  | 236   | 1800 | 26.33 |\r\n| 130 | 一个前端人             | 3658793548527869 | 1089  | 0     | 1800 | 0     |\r\n| 131 | 云雨雪               | 430664291451335  | 1085  | 306   | 1800 | 34.14 |\r\n| 132 | 大鸡腿同学             | 3526889030825928 | 1043  | 272   | 1800 | 30.35 |\r\n| 133 | 桑小榆呀              | 444664871131214  | 1041  | 173   | 1800 | 19.3  |\r\n| 134 | 鳄鱼儿               | 3751996066103758 | 1023  | 232   | 1800 | 25.88 |\r\n| 135 | 用户7210340961494   | 3576077040754397 | 1019  | 222   | 1800 | 24.77 |\r\n| 136 | 卷帘依旧              | 993614243310711  | 991   | 152   | 1800 | 16.96 |\r\n| 137 | 忆想不到的晖            | 817692384431470  | 973   | 216   | 1800 | 24.1  |\r\n| 138 | JYeontu           | 440244290727294  | 960   | 207   | 1800 | 23.09 |\r\n| 138 | 秃头小苏              | 1359414174686455 | 960   | 121   | 1800 | 13.5  |\r\n| 139 | 小孔融               | 1297881580452344 | 933   | 328   | 1800 | 36.59 |\r\n| 140 | __不想说话__          | 1626932940391191 | 910   | 487   | 1800 | 54.33 |\r\n| 141 | Mool              | 3536482414111101 | 845   | 64    | 1800 | 7.14  |\r\n| 142 | 芝麻粒儿              | 4265760844943479 | 828   | 151   | 1800 | 16.85 |\r\n| 143 | 小可爱杀手             | 1416588234064232 | 825   | 192   | 1800 | 21.42 |\r\n| 144 | zxhtom            | 1099167357226904 | 812   | 177   | 1800 | 19.75 |\r\n| 145 | codeniu           | 1732486058223176 | 805   | 172   | 1800 | 19.19 |\r\n| 146 | 吃猫的鱼_             | 1398234521016328 | 799   | 242   | 1800 | 27    |\r\n| 147 | 李坤                | 571401774831662  | 776   | 168   | 1800 | 18.74 |\r\n| 148 | 新一代螺丝工            | 1468603264407022 | 769   | 225   | 1800 | 25.1  |\r\n| 149 | 微之风               | 1195873720345623 | 762   | 201   | 1800 | 22.42 |\r\n| 150 | 鲁班代师              | 676954895299566  | 758   | 209   | 1800 | 23.32 |\r\n| 150 | LolitaAnn在掘金      | 1802854802665351 | 758   | 351   | 1800 | 39.16 |\r\n| 151 | CoderBin          | 1627704066072712 | 752   | 187   | 1500 | 30.37 |\r\n| 152 | jecyu             | 1486195450470023 | 751   | 184   | 1500 | 29.88 |\r\n| 153 | xcc               | 1433418894961021 | 750   | 291   | 1500 | 47.26 |\r\n| 154 | XINO              | 585368953697591  | 747   | 157   | 1500 | 25.5  |\r\n| 155 | 夏沫的梦              | 207133830037005  | 740   | 219   | 1500 | 35.56 |\r\n| 156 | iiopsd            | 1412196457264638 | 731   | 194   | 1500 | 31.5  |\r\n| 156 | JavaEdge在掘金       | 26044012176424   | 731   | 74    | 1500 | 12.02 |\r\n| 157 | 芥末拌饭              | 2181850638084542 | 724   | 161   | 1500 | 26.14 |\r\n| 158 | 莫浅子               | 4007048825275837 | 721   | 154   | 1500 | 25.01 |\r\n| 159 | 前端bubucuo         | 3878732755375742 | 720   | 193   | 1500 | 31.34 |\r\n| 160 | 奔跑的水瓜             | 2313028193750087 | 706   | 136   | 1500 | 22.09 |\r\n| 161 | 沐华                | 3368559359825448 | 704   | 128   | 1500 | 20.79 |\r\n| 162 | 骑山地车的自由           | 1275089219491143 | 700   | 283   | 1500 | 45.96 |\r\n| 163 | 嵌入式视觉             | 3034307824977127 | 698   | 98    | 1500 | 15.91 |\r\n| 164 | 李之阳               | 888061128084471  | 697   | 155   | 1500 | 25.17 |\r\n| 165 | Pika              | 3615671881575853 | 696   | 153   | 1500 | 24.85 |\r\n| 166 | RiemannHypothesis | 1680474815073805 | 688   | 140   | 1500 | 22.73 |\r\n| 167 | 阿兵云原生             | 3465271329953806 | 685   | 226   | 1500 | 36.7  |\r\n| 168 | 清风无影              | 2933911241099150 | 682   | 143   | 1500 | 23.22 |\r\n| 169 | 牛不灭               | 3241803321706509 | 680   | 159   | 1500 | 25.82 |\r\n| 170 | 安小轩               | 2506542244693773 | 674   | 160   | 1500 | 25.98 |\r\n| 171 | Cora              | 1380642337591822 | 664   | 127   | 1500 | 20.62 |\r\n| 172 | 嘿嘿Z               | 219558054997710  | 658   | 101   | 1500 | 16.4  |\r\n| 173 | 靖安                | 1126375892717582 | 653   | 483   | 1500 | 78.43 |\r\n| 174 | 穆雄雄               | 2550465587590430 | 635   | 229   | 1500 | 37.19 |\r\n| 175 | 六号积极分子            | 3984285871118728 | 618   | 133   | 1500 | 21.6  |\r\n| 176 | 佑子呀               | 3545242100302920 | 616   | 209   | 1500 | 33.94 |\r\n| 177 | wayn              | 4406498336980103 | 607   | 148   | 1500 | 24.03 |\r\n| 178 | 能给我说晚安吗           | 35653327783341   | 605   | 163   | 1500 | 26.47 |\r\n| 179 | 二当家的白帽子           | 2771185768884824 | 600   | 148   | 1500 | 24.03 |\r\n| 180 | 菜菜的后端私房菜          | 2840793779284760 | 599   | 136   | 1500 | 22.09 |\r\n| 181 | zxg_神说要有光         | 2788017216685118 | 595   | 86    | 1500 | 13.97 |\r\n| 182 | _祯不错_             | 3334168064041383 | 594   | 144   | 1500 | 23.38 |\r\n| 183 | 鸭鸭世界第一可爱          | 3087084383119918 | 592   | 323   | 1500 | 52.45 |\r\n| 184 | 宁轩                | 3334188415845838 | 587   | 76    | 1500 | 12.34 |\r\n| 185 | 上进小菜猪             | 814056073093864  | 572   | 136   | 1500 | 22.09 |\r\n| 186 | 小小达人              | 3140657811033176 | 571   | 124   | 1500 | 20.14 |\r\n| 187 | Brucebat          | 448256475144199  | 568   | 128   | 1500 | 20.79 |\r\n| 188 | 阿李贝斯              | 1028798615654669 | 567   | 168   | 1500 | 27.28 |\r\n| 188 | 我们一起              | 4226983805066103 | 567   | 152   | 1500 | 24.68 |\r\n| 189 | UOrb              | 201965869217166  | 565   | 187   | 1500 | 30.37 |\r\n| 189 | 程序员Better         | 2999123453419294 | 565   | 149   | 1500 | 24.2  |\r\n| 190 | 萱辰01              | 1767670430837710 | 562   | 160   | 1500 | 25.98 |\r\n| 191 | TechMerger        | 4011435956644013 | 559   | 152   | 1500 | 24.68 |\r\n| 192 | Daisy_            | 4292966598050942 | 558   | 177   | 1500 | 28.74 |\r\n| 193 | 江子麟               | 251160253172541  | 557   | 136   | 1500 | 22.09 |\r\n| 194 | 颜海镜               | 2313028192178791 | 554   | 241   | 1500 | 39.14 |\r\n| 194 | 流浪法师              | 1081575171693773 | 554   | 152   | 1500 | 24.68 |\r\n| 195 | 董员外               | 3966693685594072 | 553   | 119   | 1500 | 19.32 |\r\n| 196 | 颜如玉               | 3685218708622535 | 543   | 140   | 1500 | 22.73 |\r\n| 197 | 辉夜真是太可爱啦          | 1855631359481847 | 542   | 136   | 1500 | 22.09 |\r\n| 198 | JavaCub           | 1732486057956589 | 537   | 136   | 1500 | 22.09 |\r\n| 199 | Ciusyan           | 4332537967820215 | 534   | 112   | 1500 | 18.19 |\r\n| 200 | 梦想实现家_Z           | 4103831109771406 | 531   | 88    | 1500 | 14.29 |\r\n| 200 | 挽烽                | 1596913940446152 | 531   | 166   | 1500 | 26.96 |\r\n| 200 | 进击的大葱             | 1099167358791549 | 531   | 177   | 1500 | 28.74 |\r\n| 201 | 海绵宝宝_0113         | 4262159845963517 | 528   | 120   | 1200 | 21.07 |\r\n| 202 | 程序员读书             | 1697301685345773 | 525   | 114   | 1200 | 20.01 |\r\n| 202 | 薛定谔的猫酱            | 1855631359229479 | 525   | 137   | 1200 | 24.05 |\r\n| 203 | 东方淼淼              | 2340210500177752 | 522   | 120   | 1200 | 21.07 |\r\n| 204 | 孤独的红心             | 3875112810972200 | 520   | 125   | 1200 | 21.95 |\r\n| 205 | xn213             | 3790771824128190 | 517   | 143   | 1200 | 25.11 |\r\n| 206 | ObliviateOnline   | 1218729385924360 | 514   | 128   | 1200 | 22.47 |\r\n| 206 | moe_              | 2893570336630072 | 514   | 119   | 1200 | 20.89 |\r\n| 207 | 鱼丸仙仙              | 919614985602557  | 512   | 218   | 1200 | 38.27 |\r\n| 208 | chokcoco          | 2330620350437678 | 511   | 85    | 1200 | 14.92 |\r\n| 208 | Masters           | 1239904847411406 | 511   | 96    | 1200 | 16.85 |\r\n| 209 | 前端小凝              | 2867972145679975 | 498   | 136   | 1200 | 23.88 |\r\n| 210 | 一颗卷心菜QAQ          | 585418566017944  | 494   | 104   | 1200 | 18.26 |\r\n| 211 | 呛再首               | 360295545973597  | 491   | 95    | 1200 | 16.68 |\r\n| 212 | 抖音小凯              | 3118673501102935 | 483   | 102   | 1200 | 17.91 |\r\n| 213 | ZZCCCCLL          | 2467732501049879 | 482   | 96    | 1200 | 16.85 |\r\n| 214 | 慕枫技术笔记            | 325111173102669  | 481   | 96    | 1200 | 16.85 |\r\n| 215 | 只会番茄炒蛋            | 3737995264930487 | 475   | 96    | 1200 | 16.85 |\r\n| 216 | 九酒                | 201965869205213  | 473   | 104   | 1200 | 18.26 |\r\n| 217 | 神奇的程序员            | 3984285870859614 | 464   | 112   | 1200 | 19.66 |\r\n| 218 | 狂奔滴小马             | 2189882895384093 | 462   | 104   | 1200 | 18.26 |\r\n| 219 | Linn              | 3350967172733063 | 461   | 112   | 1200 | 19.66 |\r\n| 220 | 修之竹子              | 4476867078522910 | 460   | 96    | 1200 | 16.85 |\r\n| 221 | 金虹桥程序员            | 3579665589472200 | 455   | 187   | 1200 | 32.83 |\r\n| 222 | 程序员界的小学生          | 3236563012050951 | 452   | 129   | 1200 | 22.65 |\r\n| 223 | lebronzhen        | 3122268755999191 | 450   | 105   | 1200 | 18.43 |\r\n| 224 | 末世未然              | 3913917124322062 | 447   | 99    | 1200 | 17.38 |\r\n| 225 | 卡布1达咩             | 4116215813642285 | 439   | 112   | 1200 | 19.66 |\r\n| 225 | 万恶的沫白             | 509788704755416  | 439   | 120   | 1200 | 21.07 |\r\n| 226 | codinglin         | 726107228492253  | 426   | 117   | 1200 | 20.54 |\r\n| 227 | 陈明勇               | 4174180683088269 | 419   | 104   | 1200 | 18.26 |\r\n| 228 | AE860             | 254742426041422  | 416   | 119   | 1200 | 20.89 |\r\n| 229 | 老边                | 3285773734395085 | 412   | 141   | 1200 | 24.75 |\r\n| 229 | Eddie             | 3175045313080615 | 412   | 119   | 1200 | 20.89 |\r\n| 230 | 小花皮猪              | 1504597241776584 | 409   | 96    | 1200 | 16.85 |\r\n| 231 | 沃和莱特              | 2397376970492136 | 406   | 80    | 1200 | 14.05 |\r\n| 232 | 码农参上              | 3853127158081144 | 398   | 49    | 1200 | 8.6   |\r\n| 232 | 语择                | 2594503169684488 | 398   | 64    | 1200 | 11.24 |\r\n| 233 | 公众号iOS逆向          | 3562073404211272 | 396   | 120   | 1200 | 21.07 |\r\n| 234 | 苏世_               | 4353721774387246 | 395   | 289   | 1200 | 50.74 |\r\n| 234 | 那个曾经的少年回来了        | 2242659452477016 | 395   | 64    | 1200 | 11.24 |\r\n| 235 | ho                | 4142615543166653 | 392   | 96    | 1200 | 16.85 |\r\n| 236 | Zeuss             | 4178564219693671 | 391   | 112   | 1200 | 19.66 |\r\n| 237 | 盏灯                | 3122268754677774 | 390   | 192   | 1200 | 33.71 |\r\n| 238 | 竹子爱熊猫             | 862486453028888  | 389   | 90    | 1200 | 15.8  |\r\n| 239 | 来瓶二锅头00           | 3571643070036359 | 385   | 75    | 1200 | 13.17 |\r\n| 239 | 阿乐去买菜             | 1257497032146535 | 385   | 80    | 1200 | 14.05 |\r\n| 240 | 行百里er             | 729731453429159  | 382   | 72    | 1200 | 12.64 |\r\n| 240 | 0o华仔o0            | 624178336634701  | 382   | 45    | 1200 | 7.9   |\r\n| 241 | itbird01          | 3488073967475783 | 378   | 96    | 1200 | 16.85 |\r\n| 242 | 陈言必行              | 2049902560674295 | 375   | 120   | 1200 | 21.07 |\r\n| 243 | lambert9797       | 207127147983815  | 371   | 122   | 1200 | 21.42 |\r\n| 243 | Maic              | 4142615542920680 | 371   | 72    | 1200 | 12.64 |\r\n| 244 | 饼干_               | 2339399368751325 | 370   | 105   | 1200 | 18.43 |\r\n| 245 | 架构精进之路            | 3746752294032328 | 361   | 88    | 1200 | 15.45 |\r\n| 246 | Livingbody        | 4213771487417944 | 360   | 88    | 1200 | 15.45 |\r\n| 247 | 甜点cc              | 852876755212814  | 357   | 88    | 1200 | 15.45 |\r\n| 247 | 柒号华仔              | 110403611263262  | 357   | 87    | 1200 | 15.27 |\r\n| 248 | pekonchan         | 1345457963148734 | 355   | 104   | 1200 | 18.26 |\r\n| 249 | 李知恩               | 2321805117764440 | 354   | 144   | 1200 | 25.28 |\r\n| 249 | Hsiao             | 937216171846712  | 354   | 96    | 1200 | 16.85 |\r\n| 250 | 几何心凉              | 968044022608488  | 347   | 0     | 1200 | 0     |\r\n| 250 | hauk0101          | 852876752066653  | 347   | 91    | 1200 | 15.98 |\r\n| 251 | 我亚索贼六丶            | 2172290708827703 | 344   | 88    | 1000 | 16.83 |\r\n| 252 | 夏雨，影韵             | 3350967171968750 | 342   | 97    | 1000 | 18.55 |\r\n| 253 | 码bug的小砖家          | 3403743731392936 | 341   | 88    | 1000 | 16.83 |\r\n| 254 | YK菌               | 2409780510207133 | 338   | 73    | 1000 | 13.96 |\r\n| 255 | 摸鱼大队长             | 3060637595346791 | 335   | 56    | 1000 | 10.71 |\r\n| 256 | 伯nulee            | 2277843824292183 | 331   | 76    | 1000 | 14.54 |\r\n| 257 | 百里落云              | 3843548383296686 | 327   | 55    | 1000 | 10.52 |\r\n| 258 | 韦路                | 4204959658948247 | 326   | 96    | 1000 | 18.36 |\r\n| 259 | HashTang          | 1117561754756488 | 325   | 40    | 1000 | 7.65  |\r\n| 259 | 陈梵阿               | 3949919578365751 | 325   | 96    | 1000 | 18.36 |\r\n| 260 | 一依不舍              | 1011206428562957 | 323   | 70    | 1000 | 13.39 |\r\n| 261 | qb                | 201965868945869  | 322   | 72    | 1000 | 13.77 |\r\n| 261 | new_cheng         | 3825956194889880 | 322   | 151   | 1000 | 28.88 |\r\n| 262 | strp_无问           | 3030718965361677 | 321   | 61    | 1000 | 11.67 |\r\n| 263 | 静Yu               | 2225839800062215 | 317   | 64    | 1000 | 12.24 |\r\n| 263 | 前端第一渣男            | 1275089219755047 | 317   | 48    | 1000 | 9.18  |\r\n| 264 | 咕噜咕噜吨吨吨           | 1940000582668615 | 312   | 118   | 1000 | 22.57 |\r\n| 265 | 潘小安               | 3104676568631917 | 310   | 199   | 1000 | 38.06 |\r\n| 265 | 起一个可以中奖的名字        | 2260251637475847 | 310   | 88    | 1000 | 16.83 |\r\n| 266 | 矜辰所致              | 1174692315014200 | 306   | 136   | 1000 | 26.01 |\r\n| 267 | 菜猫子neko           | 2885585707211437 | 303   | 64    | 1000 | 12.24 |\r\n| 267 | 五弦奏南风             | 1447421173043486 | 303   | 136   | 1000 | 26.01 |\r\n| 268 | 源心锁               | 1645288319627576 | 302   | 152   | 1000 | 29.07 |\r\n| 269 | nathan_ll         | 2840793777447358 | 300   | 110   | 1000 | 21.04 |\r\n| 269 | 易保山               | 2225067266683095 | 300   | 64    | 1000 | 12.24 |\r\n| 269 | 北洋                | 2163480089612877 | 300   | 88    | 1000 | 16.83 |\r\n| 270 | 蝎子莱莱爱打怪           | 1239904847403927 | 298   | 125   | 1000 | 23.91 |\r\n| 270 | xing_             | 2665683293060983 | 298   | 87    | 1000 | 16.64 |\r\n| 271 | CookieBoty        | 2717648473821736 | 297   | 40    | 1000 | 7.65  |\r\n| 272 | ElvisCat          | 2770425032236408 | 296   | 64    | 1000 | 12.24 |\r\n| 272 | zz                | 3386151546961294 | 296   | 72    | 1000 | 13.77 |\r\n| 273 | 陈煮酒               | 4063433943168343 | 292   | 63    | 1000 | 12.05 |\r\n| 273 | Bertil            | 457851212932871  | 292   | 64    | 1000 | 12.24 |\r\n| 274 | 来快活呀              | 1556564193327112 | 291   | 64    | 1000 | 12.24 |\r\n| 274 | 程序员江同学            | 668101431009496  | 291   | 64    | 1000 | 12.24 |\r\n| 275 | 不减20斤不改头像         | 3685218708368519 | 290   | 25    | 1000 | 4.78  |\r\n| 276 | jsmask            | 1204720472953240 | 289   | 72    | 1000 | 13.77 |\r\n| 276 | Raymond运维         | 4262187909781751 | 289   | 64    | 1000 | 12.24 |\r\n| 276 | 阳呀呀               | 2400989127119575 | 289   | 64    | 1000 | 12.24 |\r\n| 276 | dz小伟              | 3320963434546077 | 289   | 64    | 1000 | 12.24 |\r\n| 277 | 秋染蒹葭              | 1468603262570615 | 288   | 55    | 1000 | 10.52 |\r\n| 277 | 小小喵               | 545776758180360  | 288   | 72    | 1000 | 13.77 |\r\n| 278 | 黄刀小五              | 518625218528920  | 287   | 136   | 1000 | 26.01 |\r\n| 279 | 掘了                | 1654082381026734 | 285   | 8     | 1000 | 1.53  |\r\n| 279 | 三人行丨              | 3624450346452542 | 285   | 112   | 1000 | 21.42 |\r\n| 280 | 1个俗人              | 3281369725674984 | 284   | 64    | 1000 | 12.24 |\r\n| 281 | 陈冠希希              | 3611265717517064 | 283   | 64    | 1000 | 12.24 |\r\n| 281 | 单总不会亏待你           | 3526889031075454 | 283   | 84    | 1000 | 16.07 |\r\n| 282 | Hani              | 870468941775719  | 282   | 64    | 1000 | 12.24 |\r\n| 283 | 黑土豆               | 3421335917433006 | 281   | 64    | 1000 | 12.24 |\r\n| 284 | 一咻                | 624178334545704  | 278   | 64    | 1000 | 12.24 |\r\n| 285 | 捉虫大师              | 4336129593318679 | 276   | 72    | 1000 | 13.77 |\r\n| 286 | 随身电源              | 3861140568540327 | 275   | 31    | 1000 | 5.93  |\r\n| 287 | itclanCoder       | 2524134426284845 | 274   | 57    | 1000 | 10.9  |\r\n| 288 | JayYuen           | 2981531266857262 | 272   | 64    | 1000 | 12.24 |\r\n| 289 | sherlockkid7      | 3491704662659245 | 269   | 64    | 1000 | 12.24 |\r\n| 289 | Axjy              | 2612095357298727 | 269   | 64    | 1000 | 12.24 |\r\n| 290 | 菁芜                | 1169536103245454 | 268   | 108   | 1000 | 20.66 |\r\n| 291 | 东方小月              | 3193422001474199 | 265   | 64    | 1000 | 12.24 |\r\n| 292 | 龙旋                | 3773179638841950 | 264   | 64    | 1000 | 12.24 |\r\n| 293 | Loken1            | 3035121789441358 | 262   | 0     | 1000 | 0     |\r\n| 294 | 天行无忌              | 4406498333033918 | 257   | 64    | 1000 | 12.24 |\r\n| 294 | 灵扁扁               | 2032371996033511 | 257   | 32    | 1000 | 6.12  |\r\n| 295 | 田埂                | 3281408303578712 | 255   | 8     | 1000 | 1.53  |\r\n| 295 | pdudo             | 2981531267892856 | 255   | 56    | 1000 | 10.71 |\r\n| 296 | 共饮一杯无             | 2506542241824007 | 254   | 64    | 1000 | 12.24 |\r\n| 297 | 别拿鸭丝不当干部          | 2013961031516184 | 253   | 63    | 1000 | 12.05 |\r\n| 298 | 武师叔               | 1464978572059806 | 250   | 64    | 1000 | 12.24 |\r\n| 299 | Quasimodo         | 3193419847964990 | 249   | 64    | 1000 | 12.24 |\r\n| 299 | catgod007         | 3276990342504136 | 249   | 56    | 1000 | 10.71 |\r\n| 300 | 玛卡bug卡            | 141164809564285  | 247   | 64    | 1000 | 12.24\r\n\r\n## 第七天公布\r\n\r\n2022年度人气创作者榜单评选第七天，共有 360 名创作者参与瓜分总值 9000 元奖池。\r\n\r\n名次  | 用户名               | 用户ID             | 榜单票数  | 新增票数  | 所在奖池 | 瓜分金额   |\r\n| --- | ----------------- | ---------------- | ----- | ----- | ---- | ------ |\r\n| 1   | 宫水三叶的刷题日记         | 2612095355996743 | 42781 | 14808 | 300  | 65.43  |\r\n| 2   | Yestodorrow       | 78820567681902   | 39898 | 16878 | 300  | 74.58  |\r\n| 3   | 若川                | 1415826704971918 | 32158 | 10236 | 300  | 45.23  |\r\n| 4   | HullQin           | 615367094054285  | 17033 | 3999  | 300  | 17.67  |\r\n| 5   | 冴羽                | 712139234359182  | 14678 | 4204  | 300  | 18.58  |\r\n| 6   | 小满zs              | 2463384809252397 | 14189 | 3938  | 300  | 17.4   |\r\n| 7   | Sunshine_Lin      | 1292681407377624 | 12047 | 3935  | 300  | 17.39  |\r\n| 8   | 海拥                | 2040341402229751 | 11106 | 3621  | 300  | 16     |\r\n| 9   | 苏三说技术             | 465848661970824  | 10616 | 3386  | 300  | 14.96  |\r\n| 10  | yechaoa           | 659362706101735  | 9396  | 2887  | 300  | 12.76  |\r\n| 11  | 法医                | 1574156383557255 | 7866  | 1981  | 300  | 30.8   |\r\n| 12  | 扫地盲僧              | 3016715636842622 | 7649  | 3872  | 300  | 60.2   |\r\n| 13  | why技术             | 3702810893364350 | 6114  | 2380  | 300  | 37     |\r\n| 14  | CUGGZ             | 3544481220801815 | 5574  | 1511  | 300  | 23.49  |\r\n| 15  | 不要秃头啊             | 932829447855975  | 5560  | 1722  | 300  | 26.77  |\r\n| 16  | 刘悦的技术博客           | 3491704662919207 | 5545  | 1684  | 300  | 26.18  |\r\n| 17  | 前端贰货道士            | 2129086177097096 | 5516  | 1591  | 300  | 24.74  |\r\n| 18  | 洛神灬殇              | 3966693683772462 | 5166  | 1786  | 300  | 27.77  |\r\n| 19  | 秦风0214            | 1195887458270190 | 5103  | 1412  | 300  | 21.95  |\r\n| 20  | 前端周公子             | 96412752681079   | 4977  | 1357  | 300  | 21.1   |\r\n| 21  | 岛民小强              | 1750078239809790 | 4951  | 1414  | 900  | 46.53  |\r\n| 22  | 彭旭锐               | 1063982987230392 | 4674  | 1576  | 900  | 51.86  |\r\n| 23  | 齐舞647             | 3421335918753102 | 4479  | 841   | 900  | 27.68  |\r\n| 24  | NewBoy            | 3755587450709592 | 4261  | 1202  | 900  | 39.56  |\r\n| 25  | 园宵                | 831705151963870  | 4161  | 1156  | 900  | 38.04  |\r\n| 26  | wjl110            | 4314919626348647 | 4115  | 881   | 900  | 28.99  |\r\n| 27  | 来碗盐焗星球            | 3316551988553709 | 3936  | 1073  | 900  | 35.31  |\r\n| 28  | Applehope         | 457814750554375  | 3910  | 943   | 900  | 31.03  |\r\n| 29  | 杨同学technotes      | 2594503173605767 | 3133  | 1039  | 900  | 34.19  |\r\n| 30  | isboyjc           | 2999123452373735 | 3114  | 795   | 900  | 26.16  |\r\n| 31  | codercao          | 78820566386071   | 3076  | 1204  | 900  | 39.62  |\r\n| 32  | bug菌              | 695333581765240  | 3062  | 862   | 900  | 28.37  |\r\n| 33  | ClyingDeng        | 2735240661441591 | 2991  | 850   | 900  | 27.97  |\r\n| 34  | MiyueFE           | 747323639208391  | 2979  | 971   | 900  | 31.95  |\r\n| 35  | 掘金安东尼             | 1521379823340792 | 2949  | 651   | 900  | 21.42  |\r\n| 36  | 一骑绝尘蛙             | 3509296848192216 | 2941  | 879   | 900  | 28.93  |\r\n| 37  | iwhao             | 3122268755206334 | 2878  | 957   | 900  | 31.49  |\r\n| 38  | Swift社区           | 3192637497025335 | 2783  | 764   | 900  | 25.14  |\r\n| 39  | Ethan_Zhou        | 1151943916391965 | 2761  | 779   | 900  | 25.64  |\r\n| 40  | Petterp           | 3491704662136541 | 2759  | 805   | 900  | 26.49  |\r\n| 41  | 季夏廿九              | 3650034333668302 | 2716  | 814   | 900  | 26.79  |\r\n| 42  | 王中阳Go             | 2189882892232029 | 2701  | 764   | 900  | 25.14  |\r\n| 43  | 代码与野兽             | 571401777717031  | 2650  | 1315  | 900  | 43.28  |\r\n| 44  | 寒月十九              | 1693704615893799 | 2609  | 652   | 900  | 21.46  |\r\n| 45  | 跟着飞哥学编程           | 132360371967448  | 2581  | 731   | 900  | 24.06  |\r\n| 46  | JAVA旭阳            | 3438928100329646 | 2562  | 735   | 900  | 24.19  |\r\n| 47  | ArvinC            | 580166250665006  | 2518  | 732   | 900  | 24.09  |\r\n| 48  | 猪痞恶霸              | 431430802343479  | 2460  | 492   | 900  | 16.19  |\r\n| 49  | 小阿杰               | 2040300414187416 | 2399  | 637   | 900  | 20.96  |\r\n| 50  | 优弧                | 852876722177533  | 2396  | 834   | 900  | 27.45  |\r\n| 51  | 小杜杜               | 703321119406919  | 2376  | 725   | 2000 | 51.12  |\r\n| 52  | 快跑啊小卢_            | 3360527239635373 | 2328  | 850   | 2000 | 59.94  |\r\n| 53  | 前端小蜗              | 61995432544503   | 2319  | 1120  | 2000 | 78.98  |\r\n| 54  | 前端胖头鱼             | 3438928099549352 | 2315  | 594   | 2000 | 41.89  |\r\n| 55  | 布鲁斯要蓝调            | 3065888803654648 | 2306  | 604   | 2000 | 42.59  |\r\n| 56  | 知否技术              | 140339735966695  | 2287  | 604   | 2000 | 42.59  |\r\n| 57  | WinsonWu          | 1433418894956925 | 2279  | 1644  | 2000 | 115.93 |\r\n| 58  | Zuo               | 747323635537159  | 2245  | 753   | 2000 | 53.1   |\r\n| 59  | 不瑶碧莲              | 1099967744455774 | 2223  | 564   | 2000 | 39.77  |\r\n| 59  | FuncJin           | 87580250747917   | 2223  | 660   | 2000 | 46.54  |\r\n| 60  | 阿杆                | 4182956056773160 | 2123  | 565   | 2000 | 39.84  |\r\n| 61  | vaelcy            | 166781498952974  | 2097  | 590   | 2000 | 41.6   |\r\n| 62  | Cobyte            | 668147376989517  | 2015  | 617   | 2000 | 43.51  |\r\n| 63  | 钱得乐               | 606586151903320  | 2002  | 599   | 2000 | 42.24  |\r\n| 64  | 子不语Any            | 3051900007626103 | 1981  | 488   | 2000 | 34.41  |\r\n| 65  | HoMeTown          | 4116184668057390 | 1951  | 221   | 2000 | 15.58  |\r\n| 66  | 磊叔的技术博客           | 3227821827961806 | 1943  | 543   | 2000 | 38.29  |\r\n| 67  | 默海笑               | 3246223221632151 | 1887  | 502   | 2000 | 35.4   |\r\n| 68  | 聪小陈               | 1838039174227006 | 1841  | 494   | 2000 | 34.84  |\r\n| 69  | 清欢bx              | 3315782800389390 | 1835  | 499   | 2000 | 35.19  |\r\n| 70  | 𝓼𝓲𝓭𝓲𝓸𝓽      | 2828360557003479 | 1829  | 895   | 2000 | 63.11  |\r\n| 71  | 代码诗人_             | 3069492194710797 | 1823  | 474   | 2000 | 33.43  |\r\n| 72  | 许进进               | 852876754422039  | 1820  | 590   | 2000 | 41.6   |\r\n| 73  | 魏铁锤               | 2344622318171309 | 1818  | 334   | 2000 | 23.55  |\r\n| 74  | 吓死羊了              | 3536444974974957 | 1803  | 491   | 2000 | 34.62  |\r\n| 75  | 叶一一               | 70822370479901   | 1745  | 379   | 2000 | 26.73  |\r\n| 76  | 掘金最后一个老实人         | 1231899345822152 | 1736  | 93    | 2000 | 6.56   |\r\n| 77  | 奔波儿灞取经            | 1407028359070766 | 1720  | 473   | 2000 | 33.35  |\r\n| 78  | 南山种子外卖跑手          | 475439118171927  | 1689  | 505   | 2000 | 35.61  |\r\n| 79  | 荣顶                | 2858385963749223 | 1659  | 660   | 2000 | 46.54  |\r\n| 80  | 叶秋学长              | 2397403183068775 | 1652  | 289   | 2000 | 20.38  |\r\n| 81  | 逍丶                | 2960327966986621 | 1610  | 526   | 2000 | 37.09  |\r\n| 82  | 纪先生               | 123624772082791  | 1588  | 164   | 2000 | 11.56  |\r\n| 83  | Dream_juvenile    | 4265760847829512 | 1560  | 619   | 2000 | 43.65  |\r\n| 84  | jerryfans         | 2946346894254094 | 1547  | 484   | 2000 | 34.13  |\r\n| 85  | 熊的猫               | 4441682709585128 | 1545  | 530   | 2000 | 37.37  |\r\n| 86  | 阿佩佩               | 4455656639440856 | 1522  | 633   | 2000 | 44.64  |\r\n| 87  | 清秋                | 940837682306830  | 1517  | 492   | 2000 | 34.69  |\r\n| 88  | 大眼睛图图             | 1271464955742839 | 1491  | 540   | 2000 | 38.08  |\r\n| 89  | 茶无味的一天            | 2682464103060541 | 1475  | 483   | 2000 | 34.06  |\r\n| 90  | 姚明振               | 1310273589748558 | 1473  | 420   | 2000 | 29.62  |\r\n| 91  | 尚影嫣               | 105206371061245  | 1456  | 555   | 2000 | 39.14  |\r\n| 92  | 19组清风             | 307518987049112  | 1449  | 439   | 2000 | 30.96  |\r\n| 93  | 夕水                | 4054654613988718 | 1438  | 526   | 2000 | 37.09  |\r\n| 94  | 新生代农民工No1         | 273091408183054  | 1433  | 498   | 2000 | 35.12  |\r\n| 95  | 三掌柜               | 1636485994149022 | 1423  | 447   | 2000 | 31.52  |\r\n| 96  | 进军的王小二            | 3808364011470030 | 1416  | 442   | 2000 | 31.17  |\r\n| 97  | ndz               | 976022056736765  | 1407  | 429   | 2000 | 30.25  |\r\n| 98  | 一条会coding的Shark   | 233526039432445  | 1400  | 525   | 2000 | 37.02  |\r\n| 99  | 夏志121             | 224730096864541  | 1398  | 707   | 2000 | 49.86  |\r\n| 100 | Kagol             | 1504599026445150 | 1386  | 484   | 2000 | 34.13  |\r\n| 101 | 前端那些年             | 1714893871392045 | 1332  | 441   | 1800 | 54.43  |\r\n| 102 | 低调的牛魔王            | 3501266760638312 | 1331  | 465   | 1800 | 57.4   |\r\n| 103 | 石云升               | 642537280772456  | 1326  | 345   | 1800 | 42.58  |\r\n| 104 | 一一哥Sun            | 1086730598890727 | 1261  | 288   | 1800 | 35.55  |\r\n| 105 | Ziu               | 4420463502826087 | 1244  | 373   | 1800 | 46.04  |\r\n| 106 | 二流小码农             | 1398234520239095 | 1228  | 618   | 1800 | 76.28  |\r\n| 107 | CoderHing         | 1992782705853159 | 1217  | 761   | 1800 | 93.93  |\r\n| 108 | 前端南玖              | 219558057873005  | 1160  | 293   | 1800 | 36.17  |\r\n| 109 | 王有志               | 26044011123624   | 1130  | 286   | 1800 | 35.3   |\r\n| 110 | 楚楚北北              | 682131179450493  | 1117  | 137   | 1800 | 16.91  |\r\n| 111 | 小野学Java           | 1610150032974477 | 1102  | 519   | 1800 | 64.06  |\r\n| 112 | CodeFox           | 4001878054283358 | 1101  | 645   | 1800 | 79.61  |\r\n| 113 | 格格步入              | 395479916231565  | 1096  | 292   | 1800 | 36.04  |\r\n| 113 | Finbird           | 1293455879050157 | 1096  | 318   | 1800 | 39.25  |\r\n| 114 | 一个前端人             | 3658793548527869 | 1089  | 13    | 1800 | 1.6    |\r\n| 115 | Bug终结者_           | 4108235439082231 | 1085  | 373   | 1800 | 46.04  |\r\n| 116 | 我不是外星人            | 2418581313687390 | 1046  | 342   | 1800 | 42.21  |\r\n| 117 | 蚂蚁背大象             | 1151943918492855 | 1017  | 255   | 1800 | 31.48  |\r\n| 118 | 在下uptown          | 870468940210797  | 977   | 233   | 1800 | 28.76  |\r\n| 119 | 郑居中               | 1486991861517405 | 968   | 189   | 1800 | 23.33  |\r\n| 119 | 初心酱               | 2225067266945213 | 968   | 277   | 1800 | 34.19  |\r\n| 120 | 十七喜欢前端            | 1306665624546712 | 963   | 235   | 1800 | 29.01  |\r\n| 121 | 想赚点零花钱            | 2885580832641213 | 921   | 264   | 1800 | 32.59  |\r\n| 122 | 桃小瑞               | 1196739061361437 | 902   | 273   | 1800 | 33.7   |\r\n| 123 | 桑小榆呀              | 444664871131214  | 868   | 184   | 1800 | 22.71  |\r\n| 124 | 遇渐渐               | 2374598790494718 | 866   | 330   | 1800 | 40.73  |\r\n| 125 | XboxYan           | 3579665587900030 | 863   | 335   | 1800 | 41.35  |\r\n| 126 | TT_Close          | 2858385964538663 | 858   | 189   | 1800 | 23.33  |\r\n| 127 | 卷帘依旧              | 993614243310711  | 839   | 210   | 1800 | 25.92  |\r\n| 127 | 秃头小苏              | 1359414174686455 | 839   | 190   | 1800 | 23.45  |\r\n| 128 | 用户7210340961494   | 3576077040754397 | 797   | 224   | 1800 | 27.65  |\r\n| 129 | 鳄鱼儿               | 3751996066103758 | 791   | 197   | 1800 | 24.32  |\r\n| 130 | Mool              | 3536482414111101 | 781   | 141   | 1800 | 17.4   |\r\n| 131 | 云雨雪               | 430664291451335  | 779   | 333   | 1800 | 41.1   |\r\n| 132 | 大鸡腿同学             | 3526889030825928 | 771   | 163   | 1800 | 20.12  |\r\n| 133 | somliy            | 888061128621021  | 765   | 308   | 1800 | 38.02  |\r\n| 134 | 忆想不到的晖            | 817692384431470  | 757   | 209   | 1800 | 25.8   |\r\n| 135 | JYeontu           | 440244290727294  | 753   | 198   | 1800 | 24.44  |\r\n| 136 | Somnus_小凯         | 2049145403616814 | 722   | 468   | 1800 | 57.77  |\r\n| 137 | 芝麻粒儿              | 4265760844943479 | 677   | 162   | 1800 | 20     |\r\n| 138 | JavaEdge在掘金       | 26044012176424   | 657   | 78    | 1800 | 9.63   |\r\n| 139 | zxhtom            | 1099167357226904 | 635   | 189   | 1800 | 23.33  |\r\n| 140 | 小可爱杀手             | 1416588234064232 | 633   | 168   | 1800 | 20.74  |\r\n| 140 | codeniu           | 1732486058223176 | 633   | 145   | 1800 | 17.9   |\r\n| 141 | 李坤                | 571401774831662  | 608   | 164   | 1800 | 20.24  |\r\n| 142 | 小孔融               | 1297881580452344 | 605   | 391   | 1800 | 48.26  |\r\n| 143 | 嵌入式视觉             | 3034307824977127 | 600   | 140   | 1800 | 17.28  |\r\n| 144 | XINO              | 585368953697591  | 590   | 140   | 1800 | 17.28  |\r\n| 145 | 沐华                | 3368559359825448 | 576   | 147   | 1800 | 18.14  |\r\n| 146 | 奔跑的水瓜             | 2313028193750087 | 570   | 141   | 1800 | 17.4   |\r\n| 147 | jecyu             | 1486195450470023 | 567   | 161   | 1800 | 19.87  |\r\n| 147 | 莫浅子               | 4007048825275837 | 567   | 126   | 1800 | 15.55  |\r\n| 148 | CoderBin          | 1627704066072712 | 565   | 162   | 1800 | 20     |\r\n| 149 | 芥末拌饭              | 2181850638084542 | 563   | 148   | 1800 | 18.27  |\r\n| 150 | 微之风               | 1195873720345623 | 561   | 207   | 1800 | 25.55  |\r\n| 151 | 吃猫的鱼_             | 1398234521016328 | 557   | 166   | 1500 | 30.5   |\r\n| 151 | 嘿嘿Z               | 219558054997710  | 557   | 90    | 1500 | 16.54  |\r\n| 152 | 鲁班代师              | 676954895299566  | 549   | 141   | 1500 | 25.91  |\r\n| 153 | RiemannHypothesis | 1680474815073805 | 548   | 126   | 1500 | 23.15  |\r\n| 154 | 新一代螺丝工            | 1468603264407022 | 544   | 146   | 1500 | 26.83  |\r\n| 155 | Pika              | 3615671881575853 | 543   | 154   | 1500 | 28.29  |\r\n| 156 | 李之阳               | 888061128084471  | 542   | 161   | 1500 | 29.58  |\r\n| 157 | 清风无影              | 2933911241099150 | 539   | 119   | 1500 | 21.86  |\r\n| 158 | Cora              | 1380642337591822 | 537   | 179   | 1500 | 32.89  |\r\n| 158 | iiopsd            | 1412196457264638 | 537   | 197   | 1500 | 36.2   |\r\n| 159 | 前端bubucuo         | 3878732755375742 | 527   | 138   | 1500 | 25.36  |\r\n| 160 | 牛不灭               | 3241803321706509 | 521   | 140   | 1500 | 25.72  |\r\n| 160 | 夏沫的梦              | 207133830037005  | 521   | 146   | 1500 | 26.83  |\r\n| 161 | 安小轩               | 2506542244693773 | 514   | 142   | 1500 | 26.09  |\r\n| 162 | 宁轩                | 3334188415845838 | 511   | 92    | 1500 | 16.9   |\r\n| 163 | zxg_神说要有光         | 2788017216685118 | 509   | 115   | 1500 | 21.13  |\r\n| 164 | 六号积极分子            | 3984285871118728 | 485   | 111   | 1500 | 20.39  |\r\n| 165 | 战场小包              | 4424090519078430 | 473   | 172   | 1500 | 31.6   |\r\n| 166 | 菜菜的后端私房菜          | 2840793779284760 | 463   | 112   | 1500 | 20.58  |\r\n| 167 | 阿兵云原生             | 3465271329953806 | 459   | 141   | 1500 | 25.91  |\r\n| 167 | xcc               | 1433418894961021 | 459   | 156   | 1500 | 28.66  |\r\n| 167 | wayn              | 4406498336980103 | 459   | 140   | 1500 | 25.72  |\r\n| 168 | 二当家的白帽子           | 2771185768884824 | 452   | 85    | 1500 | 15.62  |\r\n| 169 | _祯不错_             | 3334168064041383 | 450   | 156   | 1500 | 28.66  |\r\n| 170 | 小小达人              | 3140657811033176 | 447   | 112   | 1500 | 20.58  |\r\n| 171 | 梦想实现家_Z           | 4103831109771406 | 443   | 113   | 1500 | 20.76  |\r\n| 172 | 能给我说晚安吗           | 35653327783341   | 442   | 169   | 1500 | 31.05  |\r\n| 173 | Brucebat          | 448256475144199  | 440   | 113   | 1500 | 20.76  |\r\n| 174 | 上进小菜猪             | 814056073093864  | 436   | 125   | 1500 | 22.97  |\r\n| 175 | 董员外               | 3966693685594072 | 434   | 105   | 1500 | 19.29  |\r\n| 176 | chokcoco          | 2330620350437678 | 426   | 103   | 1500 | 18.92  |\r\n| 177 | __不想说话__          | 1626932940391191 | 423   | 258   | 1500 | 47.4   |\r\n| 178 | Ciusyan           | 4332537967820215 | 422   | 119   | 1500 | 21.86  |\r\n| 179 | 江子麟               | 251160253172541  | 421   | 133   | 1500 | 24.44  |\r\n| 180 | 骑山地车的自由           | 1275089219491143 | 417   | 117   | 1500 | 21.5   |\r\n| 181 | 程序员Better         | 2999123453419294 | 416   | 132   | 1500 | 24.25  |\r\n| 182 | Masters           | 1239904847411406 | 415   | 120   | 1500 | 22.05  |\r\n| 182 | 我们一起              | 4226983805066103 | 415   | 166   | 1500 | 30.5   |\r\n| 183 | 程序员读书             | 1697301685345773 | 411   | 126   | 1500 | 23.15  |\r\n| 184 | 海绵宝宝_0113         | 4262159845963517 | 408   | 105   | 1500 | 19.29  |\r\n| 185 | LolitaAnn在掘金      | 1802854802665351 | 407   | 160   | 1500 | 29.4   |\r\n| 185 | 佑子呀               | 3545242100302920 | 407   | 183   | 1500 | 33.62  |\r\n| 185 | TechMerger        | 4011435956644013 | 407   | 119   | 1500 | 21.86  |\r\n| 186 | 辉夜真是太可爱啦          | 1855631359481847 | 406   | 84    | 1500 | 15.43  |\r\n| 186 | 穆雄雄               | 2550465587590430 | 406   | 235   | 1500 | 43.18  |\r\n| 187 | 颜如玉               | 3685218708622535 | 403   | 29    | 1500 | 5.33   |\r\n| 188 | 萱辰01              | 1767670430837710 | 402   | 140   | 1500 | 25.72  |\r\n| 188 | 流浪法师              | 1081575171693773 | 402   | 126   | 1500 | 23.15  |\r\n| 188 | 东方淼淼              | 2340210500177752 | 402   | 115   | 1500 | 21.13  |\r\n| 189 | JavaCub           | 1732486057956589 | 401   | 99    | 1500 | 18.19  |\r\n| 190 | 阿李贝斯              | 1028798615654669 | 399   | 78    | 1500 | 14.33  |\r\n| 191 | 呛再首               | 360295545973597  | 396   | 118   | 1500 | 21.68  |\r\n| 192 | 孤独的红心             | 3875112810972200 | 395   | 111   | 1500 | 20.39  |\r\n| 192 | moe_              | 2893570336630072 | 395   | 104   | 1500 | 19.11  |\r\n| 193 | 一颗卷心菜QAQ          | 585418566017944  | 390   | 72    | 1500 | 13.23  |\r\n| 194 | 薛定谔的猫酱            | 1855631359229479 | 388   | 112   | 1500 | 20.58  |\r\n| 195 | ObliviateOnline   | 1218729385924360 | 386   | 113   | 1500 | 20.76  |\r\n| 195 | ZZCCCCLL          | 2467732501049879 | 386   | 112   | 1500 | 20.58  |\r\n| 196 | 慕枫技术笔记            | 325111173102669  | 385   | 112   | 1500 | 20.58  |\r\n| 197 | 抖音小凯              | 3118673501102935 | 381   | 87    | 1500 | 15.98  |\r\n| 197 | Daisy_            | 4292966598050942 | 381   | 119   | 1500 | 21.86  |\r\n| 198 | 只会番茄炒蛋            | 3737995264930487 | 379   | 105   | 1500 | 19.29  |\r\n| 199 | UOrb              | 201965869217166  | 378   | 92    | 1500 | 16.9   |\r\n| 200 | xn213             | 3790771824128190 | 374   | 98    | 1500 | 18.01  |\r\n| 201 | 九酒                | 201965869205213  | 369   | 99    | 1200 | 21.74  |\r\n| 202 | 挽烽                | 1596913940446152 | 365   | 57    | 1200 | 12.52  |\r\n| 203 | 修之竹子              | 4476867078522910 | 364   | 112   | 1200 | 24.59  |\r\n| 204 | 前端小凝              | 2867972145679975 | 362   | 119   | 1200 | 26.13  |\r\n| 205 | 狂奔滴小马             | 2189882895384093 | 358   | 91    | 1200 | 19.98  |\r\n| 206 | 进击的大葱             | 1099167358791549 | 354   | 118   | 1200 | 25.91  |\r\n| 207 | 神奇的程序员            | 3984285870859614 | 352   | 69    | 1200 | 15.15  |\r\n| 208 | Linn              | 3350967172733063 | 349   | 105   | 1200 | 23.06  |\r\n| 208 | 码农参上              | 3853127158081144 | 349   | 92    | 1200 | 20.2   |\r\n| 209 | 末世未然              | 3913917124322062 | 348   | 95    | 1200 | 20.86  |\r\n| 210 | 几何心凉              | 968044022608488  | 347   | 14    | 1200 | 3.07   |\r\n| 211 | lebronzhen        | 3122268755999191 | 345   | 98    | 1200 | 21.52  |\r\n| 212 | 0o华仔o0            | 624178336634701  | 337   | 41    | 1200 | 9      |\r\n| 213 | 语择                | 2594503169684488 | 334   | 82    | 1200 | 18.01  |\r\n| 214 | 那个曾经的少年回来了        | 2242659452477016 | 331   | 83    | 1200 | 18.23  |\r\n| 215 | 卡布1达咩             | 4116215813642285 | 327   | 98    | 1200 | 21.52  |\r\n| 216 | 沃和莱特              | 2397376970492136 | 326   | 49    | 1200 | 10.76  |\r\n| 217 | 程序员界的小学生          | 3236563012050951 | 323   | 84    | 1200 | 18.44  |\r\n| 218 | 万恶的沫白             | 509788704755416  | 319   | 270   | 1200 | 59.29  |\r\n| 219 | 陈明勇               | 4174180683088269 | 315   | 91    | 1200 | 19.98  |\r\n| 220 | 小花皮猪              | 1504597241776584 | 313   | 63    | 1200 | 13.83  |\r\n| 220 | 颜海镜               | 2313028192178791 | 313   | 105   | 1200 | 23.06  |\r\n| 221 | 行百里er             | 729731453429159  | 310   | 84    | 1200 | 18.44  |\r\n| 221 | 来瓶二锅头00           | 3571643070036359 | 310   | 115   | 1200 | 25.25  |\r\n| 222 | codinglin         | 726107228492253  | 309   | 84    | 1200 | 18.44  |\r\n| 223 | 阿乐去买菜             | 1257497032146535 | 305   | 107   | 1200 | 23.49  |\r\n| 224 | Maic              | 4142615542920680 | 299   | 49    | 1200 | 10.76  |\r\n| 224 | 竹子爱熊猫             | 862486453028888  | 299   | 73    | 1200 | 16.03  |\r\n| 225 | AE860             | 254742426041422  | 297   | 67    | 1200 | 14.71  |\r\n| 226 | ho                | 4142615543166653 | 296   | 62    | 1200 | 13.61  |\r\n| 227 | 鱼丸仙仙              | 919614985602557  | 294   | 230   | 1200 | 50.5   |\r\n| 228 | Eddie             | 3175045313080615 | 293   | 105   | 1200 | 23.06  |\r\n| 229 | HashTang          | 1117561754756488 | 285   | 21    | 1200 | 4.61   |\r\n| 230 | itbird01          | 3488073967475783 | 282   | 105   | 1200 | 23.06  |\r\n| 231 | 摸鱼大队长             | 3060637595346791 | 279   | 77    | 1200 | 16.91  |\r\n| 231 | Zeuss             | 4178564219693671 | 279   | 91    | 1200 | 19.98  |\r\n| 232 | 掘了                | 1654082381026734 | 277   | 7     | 1200 | 1.54   |\r\n| 233 | 公众号iOS逆向          | 3562073404211272 | 276   | 98    | 1200 | 21.52  |\r\n| 234 | 架构精进之路            | 3746752294032328 | 273   | 77    | 1200 | 16.91  |\r\n| 235 | 百里落云              | 3843548383296686 | 272   | 82    | 1200 | 18.01  |\r\n| 235 | Livingbody        | 4213771487417944 | 272   | 77    | 1200 | 16.91  |\r\n| 236 | 老边                | 3285773734395085 | 271   | 72    | 1200 | 15.81  |\r\n| 237 | 柒号华仔              | 110403611263262  | 270   | 77    | 1200 | 16.91  |\r\n| 238 | 甜点cc              | 852876755212814  | 269   | 35    | 1200 | 7.69   |\r\n| 238 | 鸭鸭世界第一可爱          | 3087084383119918 | 269   | 148   | 1200 | 32.5   |\r\n| 238 | 前端第一渣男            | 1275089219755047 | 269   | 42    | 1200 | 9.22   |\r\n| 239 | 金虹桥程序员            | 3579665589472200 | 268   | 106   | 1200 | 23.28  |\r\n| 240 | 饼干_               | 2339399368751325 | 265   | 161   | 1200 | 35.35  |\r\n| 240 | YK菌               | 2409780510207133 | 265   | 76    | 1200 | 16.69  |\r\n| 240 | 不减20斤不改头像         | 3685218708368519 | 265   | 97    | 1200 | 21.3   |\r\n| 241 | Loken1            | 3035121789441358 | 262   | 0     | 1200 | 0      |\r\n| 242 | strp_无问           | 3030718965361677 | 260   | 68    | 1200 | 14.93  |\r\n| 243 | Hsiao             | 937216171846712  | 258   | 104   | 1200 | 22.84  |\r\n| 244 | CookieBoty        | 2717648473821736 | 257   | 51    | 1200 | 11.2   |\r\n| 245 | hauk0101          | 852876752066653  | 256   | 55    | 1200 | 12.08  |\r\n| 245 | 我亚索贼六丶            | 2172290708827703 | 256   | 77    | 1200 | 16.91  |\r\n| 246 | 陈言必行              | 2049902560674295 | 255   | 112   | 1200 | 24.59  |\r\n| 246 | 伯nulee            | 2277843824292183 | 255   | 87    | 1200 | 19.1   |\r\n| 247 | 一依不舍              | 1011206428562957 | 253   | 70    | 1200 | 15.37  |\r\n| 247 | 静Yu               | 2225839800062215 | 253   | 63    | 1200 | 13.83  |\r\n| 247 | 码bug的小砖家          | 3403743731392936 | 253   | 78    | 1200 | 17.13  |\r\n| 248 | pekonchan         | 1345457963148734 | 251   | 56    | 1200 | 12.3   |\r\n| 249 | qb                | 201965868945869  | 250   | 58    | 1200 | 12.74  |\r\n| 250 | lambert9797       | 207127147983815  | 249   | 126   | 1200 | 27.67  |\r\n| 251 | 田埂                | 3281408303578712 | 247   | 56    | 1000 | 12.1   |\r\n| 252 | 夏雨，影韵             | 3350967171968750 | 245   | 113   | 1000 | 24.41  |\r\n| 253 | 随身电源              | 3861140568540327 | 244   | 55    | 1000 | 11.88  |\r\n| 254 | 菜猫子neko           | 2885585707211437 | 239   | 58    | 1000 | 12.53  |\r\n| 255 | 易保山               | 2225067266683095 | 236   | 56    | 1000 | 12.1   |\r\n| 256 | 秋染蒹葭              | 1468603262570615 | 233   | 63    | 1000 | 13.61  |\r\n| 257 | ElvisCat          | 2770425032236408 | 232   | 56    | 1000 | 12.1   |\r\n| 258 | 韦路                | 4204959658948247 | 230   | 84    | 1000 | 18.14  |\r\n| 259 | 陈煮酒               | 4063433943168343 | 229   | 56    | 1000 | 12.1   |\r\n| 259 | 陈梵阿               | 3949919578365751 | 229   | 21    | 1000 | 4.54   |\r\n| 260 | 小鑫同学              | 3966693685871694 | 228   | 0     | 1000 | 0      |\r\n| 260 | Bertil            | 457851212932871  | 228   | 56    | 1000 | 12.1   |\r\n| 261 | 来快活呀              | 1556564193327112 | 227   | 56    | 1000 | 12.1   |\r\n| 261 | 程序员江同学            | 668101431009496  | 227   | 56    | 1000 | 12.1   |\r\n| 262 | 阳呀呀               | 2400989127119575 | 225   | 56    | 1000 | 12.1   |\r\n| 262 | dz小伟              | 3320963434546077 | 225   | 56    | 1000 | 12.1   |\r\n| 262 | Raymond运维         | 4262187909781751 | 225   | 56    | 1000 | 12.1   |\r\n| 262 | 灵扁扁               | 2032371996033511 | 225   | 84    | 1000 | 18.14  |\r\n| 263 | zz                | 3386151546961294 | 224   | 67    | 1000 | 14.47  |\r\n| 264 | 起一个可以中奖的名字        | 2260251637475847 | 222   | 77    | 1000 | 16.63  |\r\n| 265 | 1个俗人              | 3281369725674984 | 220   | 56    | 1000 | 12.1   |\r\n| 266 | 陈冠希希              | 3611265717517064 | 219   | 56    | 1000 | 12.1   |\r\n| 267 | Hani              | 870468941775719  | 218   | 55    | 1000 | 11.88  |\r\n| 268 | jsmask            | 1204720472953240 | 217   | 56    | 1000 | 12.1   |\r\n| 268 | 黑土豆               | 3421335917433006 | 217   | 55    | 1000 | 11.88  |\r\n| 268 | itclanCoder       | 2524134426284845 | 217   | 77    | 1000 | 16.63  |\r\n| 269 | 小小喵               | 545776758180360  | 216   | 55    | 1000 | 11.88  |\r\n| 270 | 一咻                | 624178334545704  | 214   | 56    | 1000 | 12.1   |\r\n| 270 | 周小末天天开心           | 3162625868044903 | 214   | 56    | 1000 | 12.1   |\r\n| 271 | 北洋                | 2163480089612877 | 212   | 57    | 1000 | 12.31  |\r\n| 272 | xing_             | 2665683293060983 | 211   | 76    | 1000 | 16.41  |\r\n| 273 | 李知恩               | 2321805117764440 | 210   | 56    | 1000 | 12.1   |\r\n| 274 | JayYuen           | 2981531266857262 | 208   | 56    | 1000 | 12.1   |\r\n| 275 | sherlockkid7      | 3491704662659245 | 205   | 56    | 1000 | 12.1   |\r\n| 275 | Leecason          | 3667626519169182 | 205   | 62    | 1000 | 13.39  |\r\n| 275 | Axjy              | 2612095357298727 | 205   | 56    | 1000 | 12.1   |\r\n| 276 | 捉虫大师              | 4336129593318679 | 204   | 56    | 1000 | 12.1   |\r\n| 277 | 东方小月              | 3193422001474199 | 201   | 55    | 1000 | 11.88  |\r\n| 278 | 龙旋                | 3773179638841950 | 200   | 56    | 1000 | 12.1   |\r\n| 279 | 单总不会亏待你           | 3526889031075454 | 199   | 76    | 1000 | 16.41  |\r\n| 279 | pdudo             | 2981531267892856 | 199   | 44    | 1000 | 9.5    |\r\n| 280 | 盏灯                | 3122268754677774 | 198   | 126   | 1000 | 27.21  |\r\n| 281 | 咕噜咕噜吨吨吨           | 1940000582668615 | 194   | 152   | 1000 | 32.83  |\r\n| 282 | catgod007         | 3276990342504136 | 193   | 49    | 1000 | 10.58  |\r\n| 282 | 一条小尾鱼             | 2568104847618935 | 193   | 97    | 1000 | 20.95  |\r\n| 282 | 天行无忌              | 4406498333033918 | 193   | 56    | 1000 | 12.1   |\r\n| 282 | drinkwd           | 3632442148403879 | 193   | 56    | 1000 | 12.1   |\r\n| 283 | 度假的鱼              | 1772852175972669 | 192   | 56    | 1000 | 12.1   |\r\n| 284 | nathan_ll         | 2840793777447358 | 190   | 125   | 1000 | 27     |\r\n| 284 | 共饮一杯无             | 2506542241824007 | 190   | 49    | 1000 | 10.58  |\r\n| 284 | 别拿鸭丝不当干部          | 2013961031516184 | 190   | 56    | 1000 | 12.1   |\r\n| 285 | 程序员追风             | 1855631359745352 | 186   | 14    | 1000 | 3.02   |\r\n| 285 | 武师叔               | 1464978572059806 | 186   | 56    | 1000 | 12.1   |\r\n| 286 | 任侠                | 2471357867635390 | 185   | 56    | 1000 | 12.1   |\r\n| 286 | Quasimodo         | 3193419847964990 | 185   | 56    | 1000 | 12.1   |\r\n| 287 | 南方者               | 2840793779295133 | 184   | 49    | 1000 | 10.58  |\r\n| 288 | 小黄瓜没有刺            | 3227821869648253 | 183   | 48    | 1000 | 10.37  |\r\n| 288 | 玛卡bug卡            | 141164809564285  | 183   | 56    | 1000 | 12.1   |\r\n| 289 | 粥里有勺糖             | 1028798615918983 | 180   | 56    | 1000 | 12.1   |\r\n| 290 | 我是紫菜苔             | 325111172052701  | 179   | 70    | 1000 | 15.12  |\r\n| 291 | 宁在春               | 2859142558267559 | 178   | 60    | 1000 | 12.96  |\r\n| 291 | 宇宙之一粟             | 3526889034751639 | 178   | 64    | 1000 | 13.82  |\r\n| 292 | Jack魏             | 1697301685871367 | 177   | 35    | 1000 | 7.56   |\r\n| 293 | coderSlow         | 3544455068018126 | 175   | 0     | 1000 | 0      |\r\n| 293 | pixel_revolve     | 4319326875166695 | 175   | 56    | 1000 | 12.1   |\r\n| 294 | 张立梵               | 444666099280519  | 174   | 56    | 1000 | 12.1   |\r\n| 294 | ZacheryZHANG      | 3646411140243304 | 174   | 49    | 1000 | 10.58  |\r\n| 295 | CatWatermelon     | 3280598430652264 | 173   | 0     | 1000 | 0      |\r\n| 295 | 南城FE              | 3378115131237863 | 173   | 49    | 1000 | 10.58  |\r\n| 295 | 蝎子莱莱爱打怪           | 1239904847403927 | 173   | 35    | 1000 | 7.56   |\r\n| 295 | 三人行丨              | 3624450346452542 | 173   | 69    | 1000 | 14.9   |\r\n| 296 | Java升级之路          | 4152228298371582 | 172   | 56    | 1000 | 12.1   |\r\n| 296 | 咖妃                | 3500457305053528 | 172   | 42    | 1000 | 9.07   |\r\n| 297 | new_cheng         | 3825956194889880 | 171   | 52    | 1000 | 11.23  |\r\n| 298 | 靖安                | 1126375892717582 | 170   | 42    | 1000 | 9.07   |\r\n| 298 | 矜辰所致              | 1174692315014200 | 170   | 70    | 1000 | 15.12  |\r\n| 299 | Zhujiang          | 3913917127985240 | 169   | 48    | 1000 | 10.37  |\r\n| 300 | 我犟不过你             | 3668388983878573 | 168   | 42    | 1000 | 9.07   |\r\n| 300 | 架构悟道              | 1028798616709294 | 168   | 56    | 1000 | 12.1   |\r\n| 300 | 前端我废了             | 2383396941348136 | 168   | 56    | 1000 | 12.1"
    },
    {
        "article_id": "7189082888926101564",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb530c4bcad54c8eb871d6a9ef38f79b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022年我写了哪些CSS文章？",
        "preview": "2022 全年共计发布了 41 篇关于 CSS 的原创文章。为了方便查阅学习，花了一点时间分类整理了一下，按照时间倒序排序如下 CSS 如何根据背景色自动切换黑白文字？ CSS 如何实现羽化效果？ 万",
        "author": "XboxYan",
        "view_count": 606,
        "collect_count": 9,
        "comment_count": 3,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/6ad9f8f04c5046a2d19268a134eb9c11~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy \r\nhighlight: atom-one-dark-reasonable\r\n---\r\n\r\n> 欢迎关注我的公众号：**前端侦探**\r\n\r\n2022 全年共计发布了 `41` 篇关于 `CSS` 的原创文章。为了方便查阅学习，花了一点时间分类整理了一下，按照时间倒序排序如下\r\n\r\n## [CSS 如何根据背景色自动切换黑白文字？](https://juejin.cn/post/7181328175774269500 \\\"CSS 如何根据背景色自动切换黑白文字？\\\")\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ba1774204043f89e9c46f3ec85c809~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## [CSS 如何实现羽化效果？](https://juejin.cn/post/7176094306124431421 \\\"CSS 如何实现羽化效果？\\\")\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72c3232ba604be9a514123f4f80da8d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## [万能的CSS 渐变！单标签绘制一个足球场](https://juejin.cn/post/7173498560380403719 \\\"万能的CSS 渐变！单标签绘制一个足球场\\\")\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aac83b138ae4a54835fd54740efac80~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS、SVG、Canvas对特殊字体的绘制与导出](https://juejin.cn/post/7170993410050883591 \\\"CSS、SVG、Canvas对特殊字体的绘制与导出\\\")\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2766ea3c10cc47e0be6d31a10d5f25e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 绘制一个3d掘金 logo](https://juejin.cn/post/7168355537396957198 \\\"CSS 绘制一个3d掘金 logo\\\")\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd646438a2b1439792a6fe1528349655~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [还在用 JS 做节流吗？CSS 也可以防止按钮重复点击](https://juejin.cn/post/7165828047520661534)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0149a2bfc61a4bfe9476e4817977b380~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [由 transform 被占用引发的思考🤔](https://juejin.cn/post/7163460109488619556)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589001cd47a74d0b85cc87d393be8d33~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [提升滚动体验！CSS 如何设置自动滚动定位的“安全”间距？](https://juejin.cn/post/7160870228904116237)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e2ee9a54a274831ab72880f7f5ab162~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\r\n\r\n## [CSS 实现自适应文本的头像](https://juejin.cn/post/7158325950227152909)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f20963f7038441083da245235ebb862~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 画一只可爱的猫咪](https://juejin.cn/post/7156040321090977806)\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9edf414e0034f4a88e9029443c0216f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [两分钟小技巧！如何阻止 macOS 的触底弹性滚动和双指手势导航](https://juejin.cn/post/7155668452857315336)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b86e48aa12d4bfea94e0eb5b916906a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS transition 小技巧！如何保留 hover 的状态？](https://juejin.cn/post/7147874468587634702)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19a9bef8bcb9428d905f7e9b455d095c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [借助 :has 实现3d轮播图](https://juejin.cn/post/7145277775711043620)\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1fd60806b345ea80136762c506e856~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [CSS 有了:has伪类可以做些什么？](https://juejin.cn/post/7143121853853204516)\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a9bc56eb39245149b5f26d5abd975b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\r\n\r\n## [还在用定时器吗？借助 CSS 来监听事件](https://juejin.cn/post/7143051955810598926)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6931535445419cb2bcf2165dc7b942~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [如何让CSS计数器支持小数的动态变化？](https://juejin.cn/post/7137480392730214414)\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777fc74d71c3409084eac4fefe3725c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [自定义计数器小技巧！CSS 实现长按点赞累积动画](https://juejin.cn/post/7134888044783960078)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1febd495ae414a5b982ef87e2f2a145b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [Windows滚动条如何美化成 macOS 那样？](https://juejin.cn/post/7132291477404647431)\r\n\r\n\r\n![SfKl1I.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb6efdad8014b0b91d3d594d5b357b6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## [今҈天҈真҈是҈热҈化҈了҈！](https://juejin.cn/post/7124137800751906846)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36710211eaea4f22abde441c4da119c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS color-scheme 和夜间模式](https://juejin.cn/post/7121532248527994893)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdae91e00e654120b67eeb706b90d446~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [动画合成小技巧！CSS 实现动感的倒计时效果](https://juejin.cn/post/7118986223300902926)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21766ed81f474356b1c8e48967d70ee8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS层级小技巧！如何在滚动时自动添加头部阴影？](https://juejin.cn/post/7116350466518319111)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b69a113f759414c8acdb5ba2012c8d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [视觉还原小技巧！CSS 实现角标效果](https://juejin.cn/post/7113756072262762532)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b78a6d27a514185a37e17094fde30e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS实现可拉伸调整尺寸的分栏布局](https://juejin.cn/post/7111143230468521997)\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b123d489a244b0b6ca0d7ee5aa86d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [CSS 实现头像名称首字符自动占位](https://juejin.cn/post/7105942729506422820)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/438e850a87264d2e8abf8fa361b4ed86~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 变量自动变色技术](https://juejin.cn/post/7103402278308675620)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc5fd190fae4b9fa3c0a43ba6bc1ad9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 实现树状结构目录](https://juejin.cn/post/7095580369537204238)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e34aa6c518c4ee8b3bd5d2b348c03ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 绘制一个时钟](https://juejin.cn/post/7090364550809124901)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5f8e10da664485830f2a0a8552cb3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 实现切角效果](https://juejin.cn/post/7087774534996066334)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36c402112e74e8585d669fd9912f4e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [了解一下 ::target-text 选择器](https://juejin.cn/post/7085172697419743246)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06caf577a25344519933922507f3aa22~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [还在使用定时器吗？CSS 也能实现电子时钟](https://juejin.cn/post/7083339388511322143)\r\n\r\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f90eeac95017433f87f93a5c034955ce~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)\r\n\r\n## [CSS 也能自动补全字符串？](https://juejin.cn/post/7077394490566131719)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b4a658250bb4a5990c51a2ceb895456~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [纯 CSS 美化滑动输入条 input range](https://juejin.cn/post/7074774487815684110)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0612d5e326648a4b63440cef02d7b61~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 实现透明方格的 3 种方式](https://juejin.cn/post/7072175448301994020)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b799d39f29e94393930a5c8026346778~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS & SVG foreignObject 实现文字镂空波浪动画](https://juejin.cn/post/7069611855513124895)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ca68a121fe4bee8d453b3ed2fb69ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 实现按钮点击动效的套路](https://juejin.cn/post/7064404257436336135)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13cdd2f376f14ade840a1036ea8b4b9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n## [CSS 实现 Ant Design官网Logo彩蛋效果](https://juejin.cn/post/7056976054103048228)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b6ffe7b34e741aea3d7141ea2a21886~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)\r\n\r\n\r\n以上就是 2022 年关于 CSS 的全部文章了，还有其他关于 HTML、JS、DOM等方面可以自行查阅。\r\n\r\n欢迎喜欢 CSS 的各位关注我，也欢迎加我微信`XboxYan`，一起交流，共同进步。\r\n\r\n> 欢迎关注我的公众号：**前端侦探**\r\n\r\n提前祝大家新年快乐~"
    },
    {
        "article_id": "7188770620216180794",
        "snapshot": "",
        "title": "从 Java 的角度初识 Go 语言 ｜ 青训营笔记",
        "preview": "本系列文章试图从一名 Java 开发者（有时也会穿插其他语言）的角度窥探 Go 语言，并以注释的方式提及 Go 与 Java 的一些区别，方便 Java 开发者迅速入门 Go 语言。",
        "author": "HikariLan贺兰星辰",
        "view_count": 2306,
        "collect_count": 27,
        "comment_count": 13,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/d3a8b9b04b7a81cf737f1fba08ed3141~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: cyanosis\r\n---\r\n**这是我参与「第五届青训营」伴学笔记创作活动的第 1 天**\r\n\r\n# 前言\r\n\r\n本系列文章试图从一名 Java 开发者（有时也会穿插其他语言）的角度窥探 Go 语言，并以注释的方式提及 Go 与 Java 的一些区别，方便 Java 开发者迅速入门 Go 语言。\r\n\r\n# 什么是 Go 语言？\r\n\r\n与 Java 相同，Go 是一门高性能，高并发，语法简单，学习曲线平缓的**强类型和静态类型**语言，其拥有丰富的标准库，完善的工具链，支持快速编译，跨平台且**支持垃圾回收（GC）** ；\r\n\r\n与 Java 不同的是，其并不是一门虚拟机语言，不需要通过中间代码表示（例如 JVM Bytecode）和虚拟机（VM）支持代码运行，其以直接将目标代码**静态链接**并编译到目标平台的形式跨平台。\r\n\r\n虽然 Go 和 C/C++ 类似，人们也经常讲 Go 讲述为“更好的 C/C++”，但 **Go 的竞争领域并不是 C/C++ 所适合的领域**，相反，Go 更适合 Java 所适合的 Web 工程等领域。**理论上，Go 可以提供比 Java 更好的性能和吞吐量**。\r\n\r\nGo 是一门由 Google 主导开发的语言，目前已经更新至 1.19 版本。\r\n\r\n# 入门 Go 语言\r\n\r\n## 选择 IDE\r\n\r\n要想开发 Go 程序，则需要 Go 开发环境，可以前往 [Go 官网](https://go.dev/) 并遵循 [安装文档](https://go.dev/doc/install) 安装对应平台的 Go 开发环境。这些开发环境包括 Go 编译器，工具和库。和 Java 不同的是，不存在类似于 JRE（Java Runtime Environment）一样的东西，**用户可以直接运行编译后对应平台的可执行文件，无须运行时支持**。\r\n\r\n接下来，我们当然还需要 IDE 来便捷我们的开发。有两种主流 IDE 可选：**[VSCode](https://code.visualstudio.com/) 和 [GoLand](https://www.jetbrains.com/go/)**。前者是由微软开发的开源代码编辑器，后者则是由 Jetbrains 公司开发，基于著名 Java IDE IntelliJ IDEA 构建的功能强大的 IDE。\r\n\r\n此两种 IDE 的区别是，前者更像手动挡，后者则是自动挡。对于进阶需求，VSCode 为你带来的可自定义性会更强；**但是对于新手，个人还是推荐使用 GoLand**。\r\n\r\n值得一提的是，GoLand 是一款付费软件，在购买前，你有机会进行 30 天的使用；或者，如果你是一名在校大学生，你可以向 Jetbrains 申请一份[免费的教育许可证](https://www.jetbrains.com/community/education/#students)，其允许你在学业期间免费使用 Jetbrains 的全套工具链；如果你已申请并通过 [GitHub Education](https://education.github.com/discount_requests/pack_application) 学生包，那么你也可以通过此学生包获得 Jetbrains 教育许可证。\r\n\r\n## 学习基础语法\r\n\r\n### Hello World\r\n\r\n```go\r\npackage main\r\n​\r\nimport (\r\n    \\\"fmt\\\"\r\n)\r\n​\r\nfunc main(){\r\n    fmt.Println(\\\"hello world\\\")\r\n}\r\n```\r\n\r\n以上是使用 Go 语言输出 Hello World 的代码。可以看出，Go 语言的入口点是 `main` 函数（注意 Go 语言同时存在函数和方法，前者可以认为是 Java 的静态方法或者 Rust 的关联函数，后者可以认为是非静态方法）；除此之外，`fmt.Println` 类似于 `System.out.println`，可将一段数据打印在标准输出流中。\r\n\r\n应当注意到，在 Go 语言中，`;`不是必要的，当一行中只存在一个语句时，则不必显式的为语句末添加 `;`。\r\n\r\n你可能注意到，`Println` 中的 `P` 是大写的，你可能会主观的认为这是 Go 语言的命名习惯，就像 C# 开发者那样。但实际上，在 Go 语言中，**函数/方法首字母大写意味着可被其他包调用**，否则只能在该包被调用，这就类似于 Java 中 `public` 和 `protected` 访问修饰符的区别。\r\n\r\n### 变量\r\n\r\n与 Java 不同，Go 语言的变量是类型后置的，你可以这样创建一个类型为 `int` 的变量：\r\n\r\n```go\r\nvar a int = 1\r\n```\r\n\r\n当然，允许在同一行声明多个变量：\r\n\r\n```go\r\nvar b,c int = 1, 2\r\n```\r\n\r\nGo 支持变量类型自动推断，也就是说，当我们立即为一个变量进行初始化时，其类型是可以省略的：\r\n\r\n```go\r\nvar d = true\r\n```\r\n\r\n相反，如果我们未为一个变量初始化，则必须显式指定变量类型，此时，变量会被以初始值自动初始化：\r\n\r\n```go\r\nvar e float64 // got 0\r\n```\r\n\r\n可以通过 `:=` 符号以一种简单的方式（也是实际上最常用的方式）声明一个变量：\r\n\r\n```go\r\nf := 3.2 // 等价于 var f = 3.2\r\n```\r\n\r\n最后，可以使用 `const` 关键字代替 `var` 关键字来创建一个常量（不可变变量）：\r\n\r\n```go\r\nconst h string = \\\"constant\\\"\r\n```\r\n\r\n### 流程控制\r\n\r\n对于流程控制这一部分，其实各语言都大差不差，所以就简略讲讲。\r\n\r\n#### 选择语句\r\n\r\nGo 支持 `if`，`else if`，`else`, `switch` 进行选择控制。\r\n\r\n```go\r\nif 7%2 == 0 {\r\n    fmt.Println(\\\"7 is even\\\")\r\n} else {\r\n    fmt.Println(\\\"7 is odd\\\")\r\n}\r\n​\r\nif num := 9; num < 0 {\r\n    fmt,Println(num,\\\"is negative\\\")\r\n} else if num < 10 {\r\n    fmt.Println(num, \\\"has 1 digit\\\")\r\n} else {\r\n    fmt.Println(num, \\\"has mutiple digits\\\")\r\n}\r\n```\r\n\r\n你可能会注意到，其他语言中，`if`（其他类似）后应当紧跟一个括号，括号内才是表达式，但是在 Go 中，这个括号是*可选*的，我们也建议不要使用括号。\r\n\r\n要注意的是，`if` 表达式后面的括号是**必需**的，即使是对于单行语句块，您也必须添加括号，而不能像其他语言那样直接省略。\r\n\r\n```go\r\na := 2\r\nswitch a {\r\n    case 0, 1:\r\n        fmt.Println(\\\"zero or one\\\")\r\n    case 2:\r\n        fmt.Println(\\\"two\\\")\r\n    default:\r\n        fmt.Println(\\\"other\\\")\r\n}\r\n```\r\n\r\n这便是最简单，也是和其他语言最相似的 `switch` 语句，对一个 `a` 变量进行扫描，并根据不同的值输出不同的字符串。\r\n\r\n当然，你也可以直接省略 `switch` 后的变量，来获得一个更加宽松的 `switch` 语句：\r\n\r\n```go\r\nt := time.Now()\r\nswitch {\r\n    case t.Hour() < 12:\r\n        fmt.Println(\\\"It's before noon\\\")\r\n    default:\r\n        fmt.Println(\\\"It's after noon\\\")\r\n}\r\n```\r\n\r\n需要注意的是，与其他语言恰好相反，`switch` 语句中每个 `case` 的 `break` 是隐式存在的，也就是说，每个 `case` 的逻辑会在执行完毕后立刻退出，而不是跳转到下一个 `case`。\r\n\r\n要想跳转到下一个 `case`，则应该使用 `fallthrough` 关键字：\r\n\r\n```go\r\nv := 42\r\nswitch v {\r\ncase 100:\r\n    fmt.Println(100)\r\n    fallthrough\r\ncase 42:\r\n    fmt.Println(42)\r\n    fallthrough\r\ncase 1:\r\n    fmt.Println(1)\r\n    fallthrough\r\ndefault:\r\n    fmt.Println(\\\"default\\\")\r\n}\r\n// Output:\r\n// 42\r\n// 1\r\n// default\r\n```\r\n\r\n需要注意的是，`fallthrough` 关键字只能存在于 `case` 的末尾，也就是说，如下做法是错误的：\r\n\r\n```go\r\nswitch {\r\ncase f():\r\n    if g() {\r\n        fallthrough // Does not work!\r\n    }\r\n    h()\r\ndefault:\r\n    error()\r\n}\r\n```\r\n\r\n但是，你可以使用 `goto` + 标签的方式来变相的解决这个问题。但是由于 `goto` 无论在任何语言的任何地方都应当是不被推荐使用的语法，因此此处不作继续探讨。想要继续了解的可以前往 [Go Wiki](https://github.com/golang/go/wiki/Switch#:~:text=However%2C%20you%20can%20work%20around%20this%20by%20using%20a%20%27labeled%27%20fallthrough%3A) 查看。\r\n\r\n#### 循环语句\r\n\r\n在 Go 语言中不区分 `for` 和 `while`。你可以通过这样的方式创建一个最普遍的 `for` 语句：\r\n\r\n```go\r\nfor j := 7; j < 9; j++ {\r\n    fmt.Println(j)\r\n}\r\n```\r\n\r\n或者，将 `for` 语句中的三段表达式改为一个布尔值表达式，即可得到一个类似于其它语言的 `while` 语句：\r\n\r\n```go\r\ni := 1\r\nfor i <= 3 {\r\n    fmt.Println(i)\r\n    i = i + 1\r\n}\r\n```\r\n\r\n又或者，不为 `for` 语句填写任何表达式，你将得到一个无限循环，除非使用 `break` 关键字跳出循环，否则这个循环永远也不会停止，这看起来有些类似于 Java 的 `while(true) {}` 或是 Rust 的 `loop {}`：\r\n\r\n```go\r\nfor {\r\n    fmt.Println(\\\"loop\\\")\r\n}\r\n```\r\n\r\n当然，我们也可以使用 `for range` 循环的方式来遍历一个数组，切片，集合乃至映射（`Map`）。\r\n\r\n当我们使用 `for range` 语句遍历一个数组，切片或是集合的时候，我们将得到该集合元素的索引（`idx`）和对应值（`num`）：\r\n\r\n```go\r\nnums := []int{2, 3, 4}\r\nsum := 0\r\nfor idx, num := range nums {\r\n    fmt.Println(\\\"range to index:\\\", idx)\r\n    sum += num\r\n}\r\n// Will got following output:\r\n// range to index: 0\r\n// range to index: 1\r\n// range to index: 2\r\n// sum: 9\r\nfmt.Println(\\\"sum:\\\", sum)\r\n```\r\n\r\n或者，当我们遍历一个 `Map` 时，将得到键（`k`）和值（`v`）：\r\n\r\n```go\r\nm := make(map[string]int)\r\n    m[\\\"hello\\\"] = 0\r\n    m[\\\"world\\\"] = 1\r\n    // If key and value both needed\r\n    for k, v := range m {\r\n        // Will got following output:\r\n        // key: hello, value: 0\r\n        // key: world, value: 1\r\n        fmt.Printf(\\\"key: %v, value: %v\\\r\n\\\", k, v)\r\n    }\r\n    // Or only need key\r\n    for k := range m {\r\n        // Will got following output:\r\n        // key: hello\r\n        // key: world\r\n        fmt.Printf(\\\"key: %v\\\", k)\r\n    }\r\n```\r\n\r\n如果我们不需要循环中的某个值，则可以使用 `_` 符号代替变量名来遮蔽该变量（其他语言也有类似的做法，但是在 Go 中，此操作是必须的，因为**未被使用的变量或导入会被 Go 编译器认为是一个 `error`**）：\r\n\r\n```go\r\n// When only `v` variable needed\r\nfor _, v := range m {\r\n    //... \r\n}\r\n```\r\n\r\nGo 语言没有 `do-while` 循环或其平替。可以通过这种方式手动编写一个近似的 `do-while` 循环：\r\n\r\n```go\r\nfor {\r\n    work()\r\n    if !condition {\r\n        break\r\n    }\r\n}\r\n```\r\n\r\n很显然，`break` 和 `continue` 都是支持的，其用法和其他语言完全相同，在此直接略过。\r\n\r\n### 数组，切片和映射\r\n\r\n#### 数组\r\n\r\n可以使用以下方式声明一个指定长度的数组：\r\n\r\n```go\r\nvar a [5]int\r\na[4] = 100\r\n```\r\n\r\n声明了一个名为 `a` ，大小为 5 的 `int` 数组，并将其最后一个元素的值设置为 `100`。\r\n\r\n直接使用 `:=` 进行声明当然也是可行的：\r\n\r\n```go\r\nb := [5]int{1, 2, 3, 4, 5}\r\n```\r\n\r\n声明了一个名为 `b`，大小为 5，数组内元素初始值为 `1,2,3,4,5` 的 `int` 数组。\r\n\r\n当然，多维数组也是可以的：\r\n\r\n```go\r\nvar twoD [2][3]int\r\n```\r\n\r\n创建了一个名为 `twoD` 的二维数组。\r\n\r\n值得一提的是，当一个数组未被显式初始化元素值时，将采用元素默认值填充数组。\r\n\r\n可以这样使用索引从数组中取出一个值：\r\n\r\n```go\r\nfmt.Println(b[4]) // 5\r\n```\r\n\r\n当我们试图访问一个超出数组长度的索引，编译器将会拒绝为我们编译，并返回一个编译错误：\r\n\r\n```go\r\nfmt.Println(b[5]) // error: invalid argument: index 5 out of bounds [0:5]\r\n```\r\n\r\n#### 切片\r\n\r\n数组是定长的，因此在实际业务中使用的并不是很多，因此，更多情况下我们会使用**切片**代替数组。\r\n\r\n就像它的名字一样，切片（`slice`）某个数组或集合的一部分，切片是可变容量的，其工作原理类似于 Java 的 `ArrayList`，当切片容量不足时，便会自动扩容然后返回一个新的切片给我们。\r\n\r\n可以使用如下方式声明一个切片：\r\n\r\n```go\r\ns := make([]string, 3)\r\n```\r\n\r\n声明了一个长度为 3，容量为 3 的 `string` 切片。\r\n\r\n切片的类型标识看起来和数组很像，但是实际上他们是不同的东西。**切片并不需要在 `[]` 内指定一个长度，而数组是需要的。**\r\n\r\n需要注意的是，切片的 **长度(length)** 和 **容量(capacity)** 是两个完全不同的东西，前者才是切片实际的长度，后者则是一个阈值，当切片长度达到该阈值时才会对切片进行扩容。\r\n\r\n当然，也可以直接指定一个切片的长度和容量：\r\n\r\n```go\r\ns2 := make([]string, 0, 10)\r\n```\r\n\r\n创建了一个长度为 0 ，容量为 10 的 `string` 切片。\r\n\r\n可以直接像数组一样为切片元素赋值：\r\n\r\n```go\r\ns[0] = \\\"a\\\"\r\ns[1] = \\\"b\\\"\r\ns[2] = \\\"c\\\"\r\n```\r\n\r\n也可以使用 `append` 方法为数组添加新的元素：\r\n\r\n```go\r\ns = append(s, \\\"d\\\")\r\ns = append(s, \\\"e\\\", \\\"f\\\")\r\n```\r\n\r\n并返回更新后的切片。\r\n\r\n可以使用 `copy` 方法将一个切片内的元素复制到另一个切片中：\r\n\r\n```go\r\nc := make([]string, len(s))\r\ncopy(c, s)\r\n```\r\n\r\n使用 `len` 方法获得一个数组，切片的长度。\r\n\r\n可以使用和数组相同的方式从切片中获得一个值：\r\n\r\n```go\r\nfmt.Println(s[5])\r\n```\r\n\r\n但是不同的是，当我们试图越界访问一个切片时，编译器并不会给我们一个错误（因为切片的长度是不确定的），然而，这会得到一个 `panic`，并使程序直接结束运行：\r\n\r\n```go\r\nfmt.Println(s[6]) // panic: runtime error: index out of range [6] with length 6\r\n```\r\n\r\n可以使用以下切片操作从**数组和切片**中截取元素：\r\n\r\n```go\r\nfmt.Println(s[2:5]) // [c d e]\r\n```\r\n\r\n将返回一个新的切片，该切片的元素是 `s` 切片的第 2 个元素到第 4 个值（左闭右开）。\r\n\r\n注意，在这种切片操作中，`:` 左边和右边的数字**均可被省略**，也就是说：\r\n\r\n```go\r\nfmt.Println(s[:5]) // [a b c d e]\r\n```\r\n\r\n将返回切片第 0 个元素到第 4 个元素的切片。\r\n\r\n```go\r\nfmt.Println(s[2:]) // [c d e f]\r\n```\r\n\r\n将返回切片第 2 个元素到最后一个元素的切片。\r\n\r\n```go\r\nfmt.Println(s[:]) // [a b c d e f]\r\n```\r\n\r\n将返回切片的整个切片（副本）。\r\n\r\n#### 映射\r\n\r\n映射（`Map`）是一个无序 1 对 1 键值对。可以使用如下方式声明一个 Map：\r\n\r\n```go\r\nm := make(map[string]int)\r\n```\r\n\r\n声明了一个键（`key`）为 `string` 类型，值（`value`）为 `int` 类型的 Map。\r\n\r\n当然，也可以提前初始化 Map 内的值：\r\n\r\n```go\r\nm2 := map[string]int{\\\"one\\\" : 1, \\\"two\\\" : 2}\r\n```\r\n\r\n可以使用类似于数组和切片的赋值语法为 Map 赋值，只不过，将索引换成了 `key`，目标值换为了 `value`：\r\n\r\n```go\r\nm[\\\"one\\\"] = 1\r\nm[\\\"two\\\"] = 2\r\n```\r\n\r\n使用 `len` 方法获得一个 Map 内包含键值对的长度。\r\n\r\n```go\r\nfmt.Println(len(m)) // 2\r\n```\r\n\r\n可以使用和数组和切片类似的方式从切片中获得一个值，只不过，将索引换成了 `key`：\r\n\r\n```go\r\nfmt.Println(m[\\\"one\\\"]) // 1\r\n```\r\n\r\n但实际上，这种写法是非常不好的，因为，当我们试图访问一个不存在的 `key`，那么 Map 会给我们返回一个初始值：\r\n\r\n```go\r\nfmt.Println(m[\\\"unknown\\\"]) // 0, wtf?\r\n```\r\n\r\n因此，我们需要接收第二个值 —— 一个布尔值，来判断该键是否在 `Map` 中存在：\r\n\r\n```go\r\nr, ok := m[\\\"unknown\\\"]\r\nfmt.Println(r, ok) // 0 false\r\n```\r\n\r\n最后，使用 `delete` 函数从一个 Map 中移除指定的键：\r\n\r\n```go\r\ndelete(m, \\\"one\\\")\r\n```\r\n\r\n### 函数，指针，结构体与结构体方法\r\n\r\n#### 函数\r\n\r\n可以通过这种语法声明一个带参有返回值函数：\r\n\r\n```go\r\nfunc add(a int, b int) int {\r\n    return a + b\r\n}\r\n```\r\n\r\n声明了一个名为 `add`，拥有两个类型为 `int`，名称分别为 `a` 和 `b` 的形参，返回值为 `int` 的函数。\r\n\r\n如果不需要返回值，则可以直接省略，就像 `main` 函数那样：\r\n\r\n```go\r\nfunc main() {\r\n    // ...\r\n}\r\n```\r\n\r\n#### 指针\r\n\r\nGo 语言支持指针操作，但默认情况下（不考虑 `unsafe`），指针必须指向一个合法对象，而不是一个可能不存在的内存地址，你也不能使用指针进行地址运算（因此，与其说指针，不如称之为*引用*更加合适）：\r\n\r\n```go\r\nfunc add2(n int) {\r\n    n += 2\r\n}\r\n​\r\nfunc add2ptr(n *int) {\r\n    *n += 2\r\n}\r\n​\r\nfunc main() {\r\n    n := 5\r\n    add2(n) // not working\r\n    fmt.Println(n) // 5\r\n    add2ptr(&n)\r\n    fmt.Println(n) // 7\r\n}\r\n```\r\n\r\n使用 `*type` 声明一个指针变量，使用 `*` 对一个变量进行解引用，使用 `&` 获取一个变量的指针（引用）。\r\n\r\n支持指针的 Go 也侧面印证了，默认情况下，**Go 的方法传参均为传值，而不是传引用**，如果不传入指针而直接传入一个值的话，则方法实参会被复制一份再传入。\r\n\r\n#### 结构体\r\n\r\nGo 不是一门面向对象（OO）的语言，因此，Go 并没有类（Class）或是其他类似概念，取而代之的，是同类语言中均拥有的**结构体（Struct）** 。\r\n\r\n使用如下方式来声明一个结构体：\r\n\r\n```go\r\ntype user struct {\r\n    name     string\r\n    password string\r\n}\r\n```\r\n\r\n然后，使用如下方式初始化一个结构体：\r\n\r\n```go\r\na := user{name: \\\"wang\\\", password: \\\"1024\\\"}\r\nfmt.Printf(\\\"%+v\\\r\n\\\", a) // {name:wang password:1024}\r\n```\r\n\r\n如果未对一个结构体进行初始化，则结构体成员将采用默认值：\r\n\r\n```go\r\nvar b user\r\nfmt.Printf(\\\"%+v\\\r\n\\\", b) // {name: password:}\r\n```\r\n\r\n可以使用 `.` 来访问结构体成员\r\n\r\n```go\r\nfmt.Println(a.name) // wang\r\nfmt.Println(a.password) // 1024\r\n```\r\n\r\n#### 结构体方法\r\n\r\n如果将函数类比为 Java 中的静态方法，那么结构体方法则可以类比为 Java 中的非静态方法（类成员函数）。\r\n\r\n使用如下方式声明一个用于检查用户密码是否匹配的方法：\r\n\r\n```go\r\nfunc (u user) checkPassword(password string) bool {\r\n    return u.password == password\r\n}\r\n```\r\n\r\n使用如下方式声明一个用于重置用户密码为指定值的方法（注意此处结构体是一个指针，只有这样才可以避免值拷贝，修改原结构体）：\r\n\r\n```go\r\nfunc (u *user) resetPassword(password string) {\r\n    u.password = password\r\n}\r\n```\r\n\r\n然后即可直接调用：\r\n\r\n```go\r\na.resetPassword(\\\"2048\\\")\r\nfmt.Println(a.checkPassword(\\\"2048\\\")) // true\r\n```\r\n\r\n### Go 错误处理\r\n\r\n与 Java 不同，Go 语言并不支持 `throw`，`try-catch` 这样的操作，与 Rust 比较类似，Go 通过跟随返回值返回返回错误对象来代表方法执行中是否出现了错误 —— 如果返回的值错误对象为 `nil`，则代表没有发生错误，函数正常执行。\r\n\r\n但是，由于 Go 并没有 Rust 那么强大的模式识别，因此，其错误处理并不能像 Rust 那样便捷有效，并时常饱受诟病（经典的`if err != nil`）\r\n\r\n以下方法试图从一个 `user` 切片中查找是否存在指定名称的 `user`，如果存在，则返回其指针，否则，返回一个错误。\r\n\r\n要实现此功能，需要导入 `errors` 包：\r\n\r\n```go\r\nimport (\r\n    \\\"errors\\\"\r\n)\r\n```\r\n\r\n声明函数：\r\n\r\n```go\r\nfunc findUser(users []user, name string) (v *user, err error){\r\n    for _,u := range users {\r\n        if u.name == name {\r\n            return &u, nil\r\n        }\r\n    }\r\n    return nil, errors.New(\\\"not found\\\")\r\n}\r\n```\r\n\r\n`findUser` 函数返回了多个值，这样，我们便可以创建两个变量直接接收它们（类似于 ES6 或 Kotlin 的 `解构赋值` 语法）。\r\n\r\n调用函数：\r\n\r\n```go\r\nfunc main(){\r\n    u, err := findUser([]user{{\\\"wang\\\", \\\"1024\\\"}}, \\\"wang\\\")\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    fmt.Println(u.name) // wang\r\n    \r\n    if u, err := findUser([]user{{\\\"wang\\\", 1024}}, \\\"li\\\"); err != nil {\r\n        fmt.Println(err) // not found\r\n        return\r\n    } else {\r\n        fmt.Println(u.name)\r\n    }\r\n}\r\n```\r\n\r\n当函数执行完毕后，我们便可通过判断 `err` 是否为 `nil` 来得知错误是否发生，然后进行下一步操作。\r\n\r\n### Go 标准库\r\n\r\n与 Java 相同，Go 拥有一个非常强大的标准库，包含了字符串操作，字符串格式化，日期与时间处理，JSON 解析，数字解析，进程信息等功能，此处略过不提。\r\n\r\n值得一提的是，对于日期和时间处理，Go 使用 `2006-01-02 15:04:05` 来表达日期和时间模板，而不是传统的 `yyyy-MM-dd HH:mm:ss`。\r\n\r\n### Go 语言实战\r\n\r\n在这一部分，**字节内部课：Go 语言上手 - 基础语法**通过三个简单的小项目带领学生学习了 Go 语言语法及其标准库使用：一个经典的猜数字游戏，给定一个随机数，让用户猜测这个数并给出与这个数相比是大了还是小了；一个在线词典，通过 HTTP 爬虫爬取其他在线词典网站的结果并返回；一个 SOCKS5 代理，简单的实现了 SOCKS 5 的握手流程，并给予回答。\r\n\r\n# 引用\r\n\r\n该文章部分内容来自于以下课程或网页：\r\n\r\n-   字节内部课：Go 语言上手 - 基础语法\r\n-   [2 patterns for a do-while loop in Go · YourBasic Go](https://yourbasic.org/golang/do-while-loop/)\r\n-   [Go Cheat Sheet & Quick Reference](https://quickref.me/go)\r\n-   [Switch · golang/go Wiki (github.com)](https://github.com/golang/go/wiki/Switch)\r\n-   [Go 语言教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/go/go-tutorial.html)\r\n\r\n# 分发\r\n\r\n​\r\n\r\nThis work is licensed under [CC BY-SA 4.0<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6e08b1d06641d79a5204013eaea03f~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" height=\\\"22px\\\" /><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c0b1147bb3b43208339bac50dd5429a~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" height=\\\"22px\\\" /><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b8083a3740a432e87ce108150b7b172~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" height=\\\"22px\\\" />](http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1)\r\n\r\n​\r\n"
    },
    {
        "article_id": "7189425732471717944",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e7550de92740d2b9ed993095cf5968~tplv-k3u1fbpfcp-watermark.image?",
        "title": "「兔了个兔」创意投稿--鸡兔同笼",
        "preview": "我正在参加「兔了个兔」创意投稿大赛。基于 vue3 实现了一个简单的H5版本「鸡兔同笼」答题小游戏。 #码上掘金# 哥哥们，快来点赞，收藏，分享，帮我白嫖优弧出分力吧[惊喜][惊喜][惊喜]",
        "author": "bycandy",
        "view_count": 1130,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/9a648b44dc38e0aca63b4ee594e75414~300x300.image",
        "category": "前端",
        "content": "> “我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")”\r\n\r\n# 游戏介绍\r\n游戏有两个模式 `答题模式`、`出题模式`。\r\n`答题模式` 下可以点击下方的鹅毛笔进行答题，答题模式下输入兔子数量和鸡的数量。  \r\n如：`12,13`  \r\n点击 `下一题` 会重新随机出一道题。\r\n点击 `出题` 会进入 `出题模式`，`出题模式` 下输入头数和脚数系统会解出题目答案。  \r\n如：`35,94`  \r\n*（为了更好的游戏体验，请在H5模式下打开）*\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ea40658b7b469d92a5b9450c88b73e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 题目动画\r\n\r\n将题目存为数组，每行一句。\r\n该函数接收两个参数 `头数` 和 `脚数` ,然后将这两个数据通过 `handleNumToStr` 函数转为中文数字。   \r\n如 `21` 转为 `二十一`，然后将结果拼接到题目中并返回。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0fe1c11a70a439f8dad1ec3b224d84d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n`setPoetryList` 函数通过遍历生成的题目将返回的数组分割成单个字符的数字。遇到换行使用 `\\\r\n` 代替。  \r\n第一行是题目不需要动画，所以需单独处理一下。\r\n```js\r\n[\r\n    '雉兔同笼',\r\n    '今有雉兔同笼，',\r\n    '上有三百一十九头，',\r\n    '下有九百六十四足，',\r\n    '问雉兔各几何？'\r\n]\r\n```\r\n转换为\r\n```js\r\n['雉兔同笼', '\\\r\n', '今', '有', '雉', '兔', '同', '笼', '，', '\\\r\n', '上', '有', '三', '百', '一', '十', '九', '头', '，', '\\\r\n', '下', '有', '九', '百', '六', '十', '四', '足', '，', '\\\r\n', '问', '雉', '兔', '各', '几', '何', '？']\r\n```\r\n然后使用定时器循环 `push` 到 `state.poetryList` 中产生动画效果。\r\n\r\n![carbon.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4743ba5c1bb740fa963899d3fbdc6ea4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n动画定时器我没有采用原生的 `setInterval` 而是使用了 `setIntervalPrecision`。 他是一个用 `windowrequestAnimationFrame()` 特性实现的定时器。\r\n该定时器的原理来自： [使用 requestAnimationFrame 实现定时器，解决 setInterval 执行次数丢失问题](https://www.cnblogs.com/whosmeya/p/14135507.html)。  \r\n我重构并优化了他的代码并使用 `ts` 对其进行了重写。\r\n在重构时，我选择了使用 `轮询定时任务` 的方式，减少了在多定时器情况下 `requestAnimationFrame` 函数的调用次数以及死循环与函数闭包的产生数量。  \r\n\r\n## 旧写法\r\n每次调用定时器会生成一个loop函数闭包，且loop函数中会循环调用 `requestAnimationFrame` ,也就是调用 `n` 次定时器会产生 `n` 闭包以及 `n` 次死循环、每次屏幕刷新会执行 `n` 次 `requestAnimationFrame` 函数。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4888f739336a4dd1ab01e0781b77e01c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 新写法\r\n新写法使用全局任务总线去调度任务，每次调用定时器会将当前任务 `push` 到队列中，整个生命周期中只生成 `1` 个闭包和死循环。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0396dec5d230491db828a00bb5e86c80~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n# 计算鸡兔数量\r\n\r\n在计算鸡兔数量部分，我选择采用了相对简单的**抬腿法**。  \r\n> 题：`今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？`  \r\n> 题解：假如鸡与兔子都抬起两只脚，这时地上没有一只鸡是站着的 `2 - 2 = 0` ，每只兔子还剩两只脚站在地上 `4 - 2 = 2`，此时还剩下 `94 - 35 × 2 = 24` 只脚 ，又因每只兔子有两只脚在地上，所以有 `24 ÷ 2 = 12` 只兔子，总共 `35` 个头，兔子占了 `12` 个，就有 `35 - 12 = 23`只鸡。  \r\n更多方法请查看[百度百科--鸡兔同笼](https://baike.baidu.com/item/%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC/5907332)\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1f72895d7441469c959100f3f68146~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 随机出题\r\n\r\n这里限定了不会超过 `999` 只脚（因为我没有这个字体库的完整版）。  \r\n因为脚数不超过 `999` 则兔子最大的可能数为 `999 / 4 = 249 只`。所有先使用随机数取 `0-249`。  \r\n然后兔子占用的脚数为 `4 * 兔子数量` ， 使用 `最大脚数-兔子脚数` 得到鸡的最大脚数。  \r\n然后使用随机数取 `0-鸡的最大脚数`，得到鸡的数量。  \r\n最后调用题目动画生成题目。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e97c632ffe4ce380183875f8aece1a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 答案验证\r\n\r\n将用户输入的兔子数和吉数相加得到总数，计算 `兔子数 * 4 + 鸡数 * 2` 得到脚的总数，然后与题目数据对比。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e517dd9cfae4cd49ba5634ce8fa36e4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 字库\r\n\r\n字体库地址：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b397cae8fe674a8bb806256557197209~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n由于字库需要账号下载，虽然我没得账号去下载，但是我通过控制面板的 `Network` 发现了他在字库请求接口:\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0e994c01f34ca098c6b4aa9d1504b3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n其中 `words=` 后面接的是字符的 `Unicode` 编码。  \r\n于是我写了个简单的函数处理我需要的字符字体\r\n```js\r\nlet str = '今有雉兔同笼上有头下有足，问各几何？零一二三四五六七八九十百答曰：未知'\r\nlet str1 = str.split('').map(v=>{\r\n    return v.codePointAt().toString(16)\r\n}).join(',');\r\nconsole.log(str1);\r\nlet str2 = str.split('').map(v=>{\r\n    return `\\\\\\\\U+${v.codePointAt().toString(16)}`\r\n}).join(',');\r\nconsole.log(str2);\r\n```\r\n\r\n其中 `src` 是字体库链接， `unicode-range` 现在该字体库包含的字符范围。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e8345d2f644cfb9cfac28b128c5172~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 在线体验地址（码上掘金）\r\n\r\n[jcode](https://code.juejin.cn/pen/7189255196781117499)\r\n\r\n# git仓库地址\r\n\r\n[「兔了个兔」创意投稿--鸡兔同笼：https://github.com/fuxichen/jiaotusanku/tree/main](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffuxichen%2Fjiaotusanku%2Ftree%2Fmain \\\"https://github.com/fuxichen/jiaotusanku/tree/main\\\")"
    },
    {
        "article_id": "7189439353402163255",
        "snapshot": "",
        "title": "【AI】用 GPT 帮小兔子画肖像",
        "preview": "继帮小兔子完成了作一首诗词，写一篇文章之后，小兔子又有新的想法了；小兔子说，新年到了，她想要一张自画像，但是她自己又画不来，拜托博主用 GPT 帮她画一个；人美心善的博主当然是欣然答应了；",
        "author": "𝓼𝓲𝓭𝓲𝓸𝓽",
        "view_count": 1122,
        "collect_count": 8,
        "comment_count": 8,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/aa1bec7ccfdd579622cb025d7a4cbcee~300x300.image",
        "category": "人工智能",
        "content": "---\r\ntheme: mk-cute\r\nhighlight: a11y-dark\r\n---\r\n\r\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061)\r\n\r\n# 前言\r\n\r\n这不兔年到了，薅薅兔毛；\r\n\r\n继帮小兔子完成了 [作一首诗词](https://juejin.cn/post/7188032977408884794)，[写一篇文章](https://juejin.cn/post/7189142672064380989) 之后，小兔子又有新的想法了；\r\n\r\n**小兔子说，新年到了，她想要一张自画像，但是她自己又画不来，拜托博主用 GPT 帮她画一个；**\r\n\r\n人美心善的博主当然是欣然答应了；\r\n\r\n\r\n# 训练\r\n\r\n准备一批训练集和一批验证集作为预训练的数据集，对两个数据集的图文对进行相似性打分，筛选 score 大于0.2的作为最终的预训练数据集；\r\n\r\n初始化 text encoder，先只训练 text encoder，以便保留原始模型的生成能力且实现中文概念的对齐；\r\n\r\n最终在一百万的图文对上训练了一个 epoch；\r\n\r\n# 应用\r\n\r\n1、导入对应的包：\r\n```py\r\nfrom diffusers import StableDiffusionPipeline\r\n```\r\n\r\n***TIPS***\r\n> 要注意 transform 和 torch 的版本，因为新旧版本有所改动，会出现版本不兼容的情况，要么就是修改源码，省力点的就直接将这两个包更新到最新；\r\n> \r\n> 博主这里的版本更新变动如下：\r\n> - transform : 4.17.0 -> 4.25.1\r\n> - torch : 1.6.0 -> 1.13.0\r\n\r\n2、初始化：\r\n```py\r\npipe = StableDiffusionPipeline.from_pretrained(check_point).to(\\\"cuda\\\")\r\n```\r\n\r\n3、得到结果：\r\n```py\r\nprompt = '兔子,新年,油画'\r\nimg = pipe(prompt, ...).images[0]  \r\n```\r\n\r\n<div>\r\n    <img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/758d3e6ae55f48dc8ca51503e08124b4~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"30%\\\" />\r\n    <img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dfc1528fd654a4ea4edcf55e63927e7~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"30%\\\" />\r\n    <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f0942198df3484e8ca2f376ba7896c6~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"\\\" width=\\\"30%\\\" />\r\n</div>\r\n\r\n# 解决问题\r\n\r\n---\r\n\r\n`cannot import name 'EntryNotFoundError' from 'huggingface_hub.utils'`\r\n\r\n这个报错可以从字面进行理解，就是说没有 `utils` 中没有 `EntryNotFoundError`，直接进入源码进行查看：\r\n```py\r\n...\r\n\r\nfrom huggingface_hub.utils import EntryNotFoundError, RepositoryNotFoundError, RevisionNotFoundError\r\n\r\n...\r\n\r\nexcept RepositoryNotFoundError:\r\n    raise EnvironmentError(\r\n        f\\\"{pretrained_model_name_or_path} is not a local folder and is not a valid model identifier\\\"\r\n        \\\" listed on 'https://huggingface.co/models'\\\r\nIf this is a private repository, make sure to pass a\\\"\r\n        \\\" token having permission to this repo with `use_auth_token` or log in with `huggingface-cli\\\"\r\n        \\\" login`.\\\"\r\n    )\r\nexcept RevisionNotFoundError:\r\n    raise EnvironmentError(\r\n        f\\\"{revision} is not a valid git identifier (branch name, tag name or commit id) that exists for\\\"\r\n        \\\" this model name. Check the model page at\\\"\r\n        f\\\" 'https://huggingface.co/{pretrained_model_name_or_path}' for available revisions.\\\"\r\n    )\r\nexcept EntryNotFoundError:\r\n    raise EnvironmentError(\r\n        f\\\"{pretrained_model_name_or_path} does not appear to have a file named {cls.config_name}.\\\"\r\n    )\r\n```\r\n\r\n发现只用在了 **抛出异常** 这块代码里，因此博主一开始就直接将这一段注释掉了，结果还有下一个报错；\r\n\r\n---\r\n\r\n`cannot import name 'ModelOutput' from 'transformers.utils'`\r\n\r\n这个报错就属于是新旧版本的变动了，直接查看官方文档；\r\n\r\n博主原先的 `transformers` 版本是 4.17.0，`ModelOutput` 是在 `transformers.file_utils` 里面的，如下图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d744dd525394566a0c1ead7610aeb93~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n而在最新的 `transformers` 版本 4.25.1 中，`ModelOutput` 是在 `transformers.utils` 里的，因此才引起的这个报错；\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9eb453d136d4f34b273189749d9e2b9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n当然可能在前面几个版本就已经改动了，这里博主只看了最新版本的官方文档；\r\n\r\n---\r\n\r\n`module 'torch.nn' has no attribute 'SiLU'`\r\n\r\n这个也是因为版本问题造成的；\r\n\r\n博主之前的 `torch` 版本是 1.6.0，可以看到官方文档 `torch.nn` 中并没有 `SiLU`：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28a8b0e18af49a58a02a596eccf2ff0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但是下个版本 1.7.0 就有了，不过博主最后还是更新到了 1.13.0 版本：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df9070b4034441a93993118b1d71f99~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 后记\r\n\r\n以上就是 ***【AI】用 GPT 帮小兔子画肖像*** 的全部内容了。\r\n\r\n希望本篇博文对大家有所帮助！\r\n\r\n系列文章：\r\n- [【AI】用 GPT 帮小兔子作首诗](https://juejin.cn/post/7188032977408884794)\r\n- [【AI】用 GPT 帮小兔子写文章](https://juejin.cn/post/7189142672064380989)\r\n- [【AI】用 GPT 帮小兔子画肖像](https://juejin.cn/post/7189439353402163255)\r\n\r\n>📝 上篇精讲：[【AI】用 GPT 帮小兔子写文章](https://juejin.cn/post/7189142672064380989)\r\n>\r\n>💖 我是 **𝓼𝓲𝓭𝓲𝓸𝓽**，期待你的关注；\r\n>\r\n>👍 创作不易，请多多支持；\r\n>\r\n>🔥 系列专栏：[AI](https://juejin.cn/column/7160294356350402590) [NLP](https://juejin.cn/column/7176136174090584121)\r\n"
    },
    {
        "article_id": "7188689278824611899",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bef972edfa4404eb8b7c0a075c8f621~tplv-k3u1fbpfcp-watermark.image?",
        "title": "图形编辑器：标尺功能的实现",
        "preview": "大家好，我是前端西瓜哥。今天我们来实现图形编辑器的标尺功能。 标尺指的是画布上边和左边的两个有刻度的尺子，作用让用户知道他正在编辑的视口所在位置范围。 我们的需求是：间隔特定的长度，绘制一个刻度，并显",
        "author": "前端西瓜哥",
        "view_count": 1269,
        "collect_count": 16,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/01e816fe86e88925a74bfe05b8ce49a4~300x300.image",
        "category": "前端",
        "content": "> 文章首发于我的公众号：前端西瓜哥\r\n\r\n大家好，我是前端西瓜哥。今天我们来实现图形编辑器的标尺功能。\r\n\r\n> 项目地址：\r\n> \r\n> https://github.com/F-star/suika\r\n> \r\n> 线上体验：\r\n> \r\n> https://blog.fstars.wang/app/suika/\r\n\r\n标尺指的是画布上边和左边的两个有刻度的尺子，作用让用户知道他正在编辑的视口所在位置范围。\r\n\r\n我们的需求是：间隔特定的长度，绘制一个刻度，并显示这个刻度在 X 轴或 Y 轴上的位置。\r\n\r\n先看最终实现效果：\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6763b320a4c0485e93f18b387d2dca2b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n标尺功能演示\r\n\r\n可以看到，视口移动后，标尺上的刻度能正确地改变。此外缩放画布，标尺的步长会发生改变，保持一个比较适合的密度。\r\n\r\n实现思路\r\n----\r\n\r\n总体实现思路：\r\n\r\n1.  确定刻度尺的步长（step）。步长是和画布缩放比（zoom）相关的，zoom 越大，step 就越小；\r\n    \r\n2.  计算出需要绘制的所有刻度。分别为从视口从左侧到右侧，从上边到下边的范围；\r\n    \r\n3.  绘制。绘制上也是有考量的，先绘制背景，然后绘制刻度，最后绘制分界线。\r\n    \r\n\r\n## 步长选择\r\n\r\n步长会根据 zoom 进行设置，目的是让视口中的标尺能绘制适宜密度的刻度。\r\n\r\n**假设我们的步长固定为 50，不跟随 zoom 改变**，在 100% 看起来效果不错：\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12ab46eff72d470bad786d1b8f12cd0d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但当你缩小时，会变成下面这样：\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a260ec356ec04722889d5303909de2be~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n密度过大，导致数字重叠。同样，放大时则过于稀疏，刻度很难才见到一个，没能发挥标尺的效用。\r\n\r\n所以，步长不能定死，要根据 zoom 灵活选择。\r\n\r\n步长怎么计算呢？\r\n\r\n理论上步长可以是 50，那么 51 好像也行，3 也行。但更建议使用 5 的倍数、2 的倍数、25 的倍数这些作为步长。\r\n\r\n因为没有什么理论参考，所以我还是选择参考市面上的设计工具的步长变化设计。\r\n\r\n比如 figma，zoom 落在 `[100%, 200%)` 的步长为 50，`[200%, 500%)` 则是 10 等等。\r\n\r\n我的实现为：\r\n\r\n```ts\r\nconst getStepByZoom = (zoom: number) => {\r\n  // 可用的步长列表\r\n  const steps = [1, 2, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000];\r\n  // 看着 figma 的 step 变化想出的一个奇怪的规律\r\n  // 然后找出可选步长列表最近的并大于它的 step 作为最终步长\r\n  const step = 50 / zoom;\r\n  for (let i = 0, len = steps.length; i < len; i++) {\r\n    if (steps[i] >= step) return steps[i];\r\n  }\r\n  return steps[0];\r\n};\r\n\r\nconst step = getStepByZoom(zoom);\r\n```\r\n\r\n计算范围\r\n----\r\n\r\n这里我讲解水平（x 轴）方向的情况。垂直方向同理，就不赘叙了。\r\n\r\n首先计算出视口最左侧和最右侧的 x 坐标值。\r\n\r\n> 需要视口坐标转场景坐标的知识，如果你不懂，看我这篇文章：\r\n> \r\n> 《[图形编辑器：场景坐标、视口坐标以及它们之间的转换](https://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486576&idx=1&sn=baa2d57c0dfee35c5b65a965eb180b64&chksm=e948c91bde3f400d379a802f416c9fb0d4b7473005f31e35e0ddbc5b30b8c85ab11267150d86&scene=21#wechat_redirect)》\r\n\r\n```js\r\nlet startXInScene = viewport.x + startXInViewport / zoom; // 视口坐标转场景\r\nlet endXInScene = viewport.width + startYInViewport / zoom; // 视口坐标转场景\r\n```\r\n\r\n然后找离它们最近的落在刻度上的值。\r\n\r\n对此，我实现了一个 getClosestVal 方法。\r\n\r\n```ts\r\n/**\r\n * 找出离 value 最近的 segment 的倍数值\r\n */\r\nconst getClosestVal = (value: number, segment: number) => {\r\n  const n = Math.floor(value / segment);\r\n  const left = segment * n;\r\n  const right = segment * (n + 1);\r\n  return value - left <= right - value ? left : right;\r\n};\r\n\r\nstartXInScene = getClosestVal(startXInScene, step);\r\nendXInScene = getClosestVal(endXInScene, step);\r\n```\r\n\r\n得到起点和终点，我们可以开始循环了，从 startXInScene 开始，每次循环加一个 step，直至达到末尾为止。\r\n\r\n```js\r\nctx.textAlign = 'center'; // 文字水平居中对齐\r\n\r\nwhile (startXInScene <= endXInScene) {\r\n  ctx.strokeStyle = setting.rulerMarkStroke;\r\n  ctx.fillStyle = setting.rulerMarkStroke;\r\n  // 场景转回视口再绘制。刻度线不能直接在场景中绘制，因为缩放变换会导致线的粗细变化\r\n  const x = (startXInScene - viewport.x) * zoom;\r\n  // 绘制刻度\r\n  ctx.beginPath();\r\n  ctx.moveTo(x, y);\r\n  ctx.lineTo(x, y + setting.rulerMarkSize);\r\n  ctx.stroke();\r\n  ctx.closePath();\r\n  // 刻度值则用场景坐标的值\r\n  ctx.fillText(String(startXInScene), x, y - 4);\r\n  // +step，指针移动\r\n  startXInScene += step;\r\n}\r\n```\r\n\r\n垂直方向的标尺同理，只是稍微特殊的是刻度值文字需要多做一个 -90 度的旋转。\r\n\r\n```ts\r\nexport const rotateInCanvas = (\r\n  ctx: CanvasRenderingContext2D,\r\n  angle: number,\r\n  cx: number,\r\n  cy: number\r\n) => {\r\n  ctx.translate(cx, cy);\r\n  ctx.rotate(angle);\r\n  ctx.translate(-cx, -cy);\r\n};\r\n\r\nrotateInCanvas(ctx, -HALF_PI, x, y);\r\n```\r\n\r\n绘制顺序\r\n----\r\n\r\n绘制顺序需要注意一下，先后顺序为：\r\n\r\n1.  绘制两个标尺的背景色；\r\n    \r\n2.  绘制刻度值；\r\n    \r\n3.  用一个和背景色同色的矩形盖掉左上角那个方形，那个地方不能有刻度值，不如两个标尺的刻度会重叠。你也可以在绘制刻度值时，用裁切（ctx.clip）不让绘制到那个方形区域上；\r\n    \r\n4.  绘制两条分割线；\r\n    \r\n\r\n最后\r\n--\r\n\r\n标尺实现大致如此，并不复杂。\r\n\r\n我是前端西瓜哥，欢迎关注我，学习更多前端知识。\r\n\r\n  \r\n\r\n* * *\r\n\r\n相关阅读，  \r\n\r\n[图形编辑器：旋转选中的元素](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486587&idx=1&sn=b9287d217ff8215afe5f00b45600a5a5&chksm=e948c910de3f40062c4df058e18e16195b68a138f68fda09e07af93e394f59abfaa3c803198f&scene=21#wechat_redirect)  \r\n\r\n[图形编辑器：场景坐标、视口坐标以及它们之间的转换](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486576&idx=1&sn=baa2d57c0dfee35c5b65a965eb180b64&chksm=e948c91bde3f400d379a802f416c9fb0d4b7473005f31e35e0ddbc5b30b8c85ab11267150d86&scene=21#wechat_redirect)  \r\n\r\n[图形编辑器——矩形选区是如何实现选中多个图形的？](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247483989&idx=1&sn=ebd008733a7a799369e4af45560c41fd&chksm=e948c73ede3f4e28d3e2e44b36640da4c9589db569840e58eeea738d21088114d1c7781a8ea0&scene=21#wechat_redirect)  \r\n\r\n[在容器内显示图片的五种方案：contain、cover、fill、none、scale-down](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247483971&idx=1&sn=e67ee2754c2cd19c5538bd43d0067bfc&chksm=e948c728de3f4e3ee9e0f749ad4edb49ff080142c181b184d13b182908fbdb1aa5263329f69b&scene=21#wechat_redirect)  \r\n\r\n[计算机图形学：变换矩阵](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486545&idx=1&sn=aef92c6d6730f51d81d8042b20337dc1&chksm=e948c93ade3f402c8642988847565908f7558d7c458e60b1a5570b8ad15d139ce3b24a6af1b9&scene=21#wechat_redirect)  \r\n\r\n[快速检索碰撞图形：四叉树碰撞检测](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486514&idx=1&sn=a0955c250eacfe9aa60a14771904d9f9&chksm=e948c959de3f404f576c013ad2256d59838e9d30e0afa3c383b60a01aa3c092fb7a318c018b4&scene=21#wechat_redirect)  \r\n\r\n[Canvas 性能优化：脏矩形渲染](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486441&idx=1&sn=4bf97c88b37be63f864684a1172b82c4&chksm=e948ce82de3f4794a923bb2f834d1e717ed90febb6c4802c6fe82aaa3fd83cc741c20140fee0&scene=21#wechat_redirect)  \r\n\r\n[如何在 Canvas 上实现图形拾取？](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247486426&idx=1&sn=08c42c5382094679781fd74c4fa64f9c&chksm=e948ceb1de3f47a7ac4e604e4ae3ce97f2be2e2f137116b9c29d11b8c5a09dd99a61b401e8c4&scene=21#wechat_redirect)  \r\n\r\n[来，教你开发一款图形编辑器](http://mp.weixin.qq.com/s?__biz=MzI0NTc2NTEyNA==&mid=2247483902&idx=1&sn=61f401d8ac5e0ef95ab19bad98bc0205&chksm=e948c495de3f4d8310ab6f68e991b1e8b59c5797502f63129453f62ca9bc221799f9ce3c5293&scene=21#wechat_redirect)"
    },
    {
        "article_id": "7188889051486191672",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/488a4b577d7d483a88976fd0a5c5aeec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "webpack 性能优化方案",
        "preview": "前言 原文来自 我的个人博客 webpack 作为前端目前使用最广泛的打包工具，在面试中也是经常会被问到的。 比较常见的面试题包括： 可以配置哪些属性来进行 webpack 性能优化？ 前端有哪些常见",
        "author": "前端要努力QAQ",
        "view_count": 1214,
        "collect_count": 20,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0d8af8d13eb8a8af305cd6133d64d13b~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: devui-blue\r\nhighlight: vs2015\r\n---\r\n# 前言\r\n\r\n原文来自 [我的个人博客](http://yejiwei.com/post/98)\r\n\r\n`webpack` 作为前端目前使用最广泛的打包工具，在面试中也是经常会被问到的。\r\n\r\n比较常见的面试题包括：\r\n- 可以配置哪些属性来进行 **`webpack` 性能优化？**\r\n- **前端有哪些常见的性能优化？**（除了其他常见的，也完全可以从 `webpack` 来回答）\r\n\r\n\r\n`webpack` 的性能优化比较多，我们可以对其进行分类：\r\n1. **打包后的结果**，上线时的性能优化。（比如分包处理、减小包体积、CDN服务器等）\r\n2. **优化打包速度**，开发或者构建时优化打包速度。（比如 `exclude`、`cache-loader` 等）\r\n\r\n大多数情况下，我们会更加侧重于 **第一种**，因为这对线上的产品影响更大。\r\n\r\n\r\n虽然在大多数情况下，`webpack` 都帮我们做好了该有的性能优化：\r\n- 比如配置 `mode` 为 `production` 或者 `development` 时，默认 `webpack` 的配置信息；\r\n- 但是我们也可以针对性的进行自己的项目优化；\r\n\r\n本章，就让我们来学习一下 `webpack` 性能优化的更多细节\r\n\r\n<!-- more -->\r\n\r\n\r\n# 1. 代码分离 Code Spliting\r\n\r\n\r\n**代码分离（Code Spliting）** 是 `webpack` 一个非常重要的特性，它主要的目的是**将代码剥离到不同的 `bundle`** 中，之后我们可以**按需加载**，或者**并行加载这些文件**。\r\n\r\n什么意思呢？举个例子：\r\n- 当 **没有使用代码分离** 时：\r\n    1. `webpack` 将项目中的所有代码都打包到 **一个** `index.js` 文件中（假如这个文件有 `10M`）\r\n    2. 当我们在生产环境去访问页面时，浏览器必须得将这 `10M` 的 `index.js` 文件全部下载解析执行后页面才会开始渲染。\r\n    3. 假如此时的网速是 `10M/s`，那么光是去下载这个 `index.js` 文件会花去 `1s` 。（这 `1s` 中内页面是白屏的）\r\n    4. 在改动了部分代码第二次打包后，因为是全新的文件，浏览器又要重新下载一次\r\n- 当 **使用代码分离** 时：\r\n    1. `webpack` 将项目中的所有代码都打包到是 **多个** `js` 文件中（我们假设每个文件都为 `1M`）\r\n    2. 当我们在生产环境去访问页面时，此时浏览器将 `1M` 的 `index.js` 文件下载就只需要 `0.1s` 了，至于其它的文件，可以选择需要用到它们时候加载或者和 `index.js` 文件并行的下载\r\n    3.  在改动了部分代码第二次打包后，浏览器可以值下载改动过的代码文件，对于没改动过的文件可以直接从缓存中拿去。\r\n\r\n通过以上的例子，相信大家应该能理解 **代码分离** 的好处了，那么在 `webpack` 如何能实现代码分离呢？\r\n\r\n`webpack` 常用的代码分离方式有**三种**：\r\n1. 入口起点：使用 `entry` 配置手动分离代码；\r\n2. 防止重复：使用 `EntryDependencies` 或者 `SplitChunksPlugin` 去重和分离代码：\r\n3. 动态导入：通过模块的内联函数用来分离代码\r\n\r\n\r\n## 1.1 方式一：多入口起点\r\n\r\n这是迄今为止最简单直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。\r\n\r\n\r\n先来看看如何从 `main bundle` 中分离 `another module`(另一个模块)\r\n\r\n### 1.1.1 没有代码分离时\r\n\r\n创建一个小的 `demo`：\r\n\r\n1. 首先我们创建一个目录，初始化 `npm`，然后在本地安装 `webpack`、`webpack-cli`、`loadsh`\r\n\r\n```shell\r\nmkdir webpack-demo\r\ncd webpack-demo\r\nnpm init -y\r\nnpm install webpack webpack-cli lodash --save-dev\r\n```\r\n2. 创建 `src/index.js`：\r\n```js\r\nimport _ from \\\"lodash\\\";\r\n\r\nconsole.log(_);\r\n```\r\n3. 创建 `src/another-module.js`：\r\n\r\n```js\r\nimport _ from 'lodash';\r\n\r\nconsole.log(_);\r\n```\r\n4. 创建 `webpack.config.js`：\r\n```\r\nconst path = require(\\\"path\\\");\r\n\r\nmodule.exports = {\r\n  mode: \\\"development\\\",\r\n  entry: \\\"./src/index.js\\\",\r\n  output: {\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n    filename: \\\"main.js\\\",\r\n  },\r\n};\r\n```\r\n5. 在 `package.json` 中添加命令：\r\n\r\n```json\r\n\\\"scripts\\\": {\r\n  \\\"build\\\": \\\"webpack\\\"\r\n},\r\n```\r\n6. 执行命令进行打包：\r\n```shell\r\nnpm run build\r\n```\r\n\r\n7. 生成如下构建结果：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5822faf6960740f9ab72b63448a0c940~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到此时生成了一个 `554KB` 的 `main.js` 文件\r\n\r\n### 1.1.2 有代码分离时\r\n\r\n接下来我们从 `main bundle` 中分离出 `another module`(另一个模块)\r\n\r\n1. 修改 `webpack.config.js`\r\n\r\n```diff\r\nconst path = require(\\\"path\\\");\r\nmodule.exports = {\r\n  mode: \\\"development\\\",\r\n-  entry: './src/index',\r\n+  entry: {\r\n+    index: './src/index',\r\n+    another: './src/another-module.js'\r\n+  },\r\n  output: {\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n-    filename: \\\"main.js\\\",\r\n+    filename: \\\"[name].main.js\\\",\r\n  },\r\n};\r\n```\r\n2. 打包，生成如下构建结果：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0fefda6a584e62999ba996a5bdf6cc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们发现此时已经成功打包出 `another.bundle.js` 和 `index.bundle.js` 两个文件了，但是文件的大小似乎有些问题，怎么两个都是 `554KB`？\r\n\r\n正如前面提到的，这种方式存在一些隐患：\r\n\r\n1. 如果入口 `chunk` 之间包含一些重复的模块，那些重复模块都会被引入到各个 `bundle` 中。\r\n2. 这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。\r\n\r\n\r\n以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 `./src/index.js` 中也引入过 `lodash`，这样就在两个 `bundle` 中造成重复引用。在下一小节我们将移除重复的模块。\r\n\r\n\r\n### 1.1.3 优化：移除重复的模块\r\n\r\n在通过多入口分离代码的方式中，我们可以通过配置 `dependOn` 这个选项来解决重复模块的问题，它的原理就是从两个文件中抽出一个共享的模块，然后再让这两个模块依赖这个共享模块。\r\n\r\n\r\n1. 修改 `webpack.config.js` 配置文件：\r\n\r\n```diff\r\n const path = require('path');\r\n\r\n module.exports = {\r\n   mode: 'development',\r\n   entry: {\r\n-   index: './src/index.js',\r\n-    another: './src/another-module.js',\r\n+    index: {\r\n+     import: './src/index.js',\r\n+     dependOn: 'shared',\r\n+   },\r\n+   another: {\r\n+     import: './src/another-module.js',\r\n+     dependOn: 'shared',\r\n+   },\r\n+   shared: ['lodash'],\r\n   },\r\n   output: {\r\n     filename: '[name].bundle.js',\r\n     path: path.resolve(__dirname, 'dist'),\r\n   },\r\n };\r\n```\r\n\r\n2. 打包，生成如下构建结果：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d881058704ea466eb594961a20a356f1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到 `index.mian.js` 和 `another.mian.js` 中重复引用的部分被抽离成了 `shared.main.js` 文件，且 `index.mian.js` 和 `another.mian.js` 文件大小也变小了。\r\n\r\n\r\n## 1.2 方式二：splitChunks 模式\r\n\r\n另外一种分包的模式是 **`splitChunks`**，它底层是使用 **`SplitChunksPlugin`** 来实现的：\r\n\r\n> [`SplitChunksPlugin`](https://www.webpackjs.com/plugins/split-chunks-plugin) 插件可以将公共的依赖模块提取到已有的入口 `chunk` 中，或者提取到一个新生成的 `chunk`。\r\n\r\n\r\n因为该插件 **`webpack`** 已经默认安装和集成，所以我们并 **不需要单独安装和直接使用该插**件；只需要提供 **`SplitChunksPlugin`** 相关的配置信息即可\r\n\r\n\r\n`webpack` 提供了 `SplitChunksPlugin` 默认的配置，我们也可以手动来修改它的配置：\r\n- 比如默认配置中，`chunks` 仅仅针对于异步（`async`）请求，我们可以设置为 `initial` 或者 `all` ，\r\n\r\n\r\n### 1.2.1 splitChunk 的配置\r\n\r\n1. 在 `1.1.2` 的基础上修改 `webpack.cofig.js`：\r\n\r\n```diff\r\n  const path = require('path');\r\n\r\n  module.exports = {\r\n    mode: 'development',\r\n    entry: {\r\n      index: './src/index.js',\r\n      another: './src/another-module.js',\r\n    },\r\n    output: {\r\n      filename: '[name].bundle.js',\r\n      path: path.resolve(__dirname, 'dist'),\r\n    },\r\n+   optimization: {\r\n+     splitChunks: {\r\n+       chunks: 'all',\r\n+     },\r\n+   },\r\n  };\r\n```\r\n\r\n2. 打包，生成如下构建结果：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d49dda96ac943539d4c9b6e358d7448~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n使用 `optimization.splitChunks` 配置选项之后，现在应该可以看出，`index.bundle.js` 和 `another.bundle.js` 中已经移除了重复的依赖模块。需要注意的是，插件将 `lodash` 分离到单独的 `chunk`，并且将其从 `main` `bundle` 中移除，减轻了大小。\r\n\r\n除了 `webpack` 默认继承的 `SplitChunksPlugin` 插件，社区中也有提供一些对于代码分离很有帮助的 `plugin` 和 `loader`，比如：\r\n- [`mini-css-extract-plugin`](https://webpack.docschina.org/plugins/mini-css-extract-plugin/): 用于将 CSS 从主应用程序中分离。\r\n\r\n\r\n### 1.2.2 SplitChunks 自定义配置解析\r\n\r\n关于 [`optimization.splitChunks`](https://webpack.docschina.org/plugins/split-chunks-plugin/) 文档上有很详细的记载，我这里讲你叫几个常用的：\r\n\r\n**1. Chunks:**\r\n- 默认值是 `async`\r\n- 另一个值是 `initial`，表示对通过的代码进行处理\r\n- `all` 表示对同步和异步代码都进行处理\r\n\r\n**2. `minSize` ：**\r\n- 拆分包的大小, 至少为 `minSize；\r\n- 如果一个包拆分出来达不到 `minSize` ,那么这个包就不会拆分；\r\n\r\n**3. `maxSize`：**\r\n-  将大于maxSize的包，拆分为不小于minSize的包；\r\n\r\n\r\n**4. cacheGroups：**\r\n- 用于对拆分的包就行分组，比如一个 `lodash` 在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打包；\r\n- `test` 属性：匹配符合规则的包；\r\n- `name` 属性：拆分包的 `name` 属性；\r\n- `filename` 属性：拆分包的名称，可以自己使用 `placeholder` 属性；\r\n\r\n1. 修改 `webpack.config.js`\r\n```js\r\nconst path = require(\\\"path\\\");\r\n\r\nmodule.exports = {\r\n  mode: \\\"development\\\",\r\n  entry: {\r\n    index: \\\"./src/index.js\\\",\r\n    another: \\\"./src/another-module.js\\\",\r\n  },\r\n  output: {\r\n    filename: \\\"[name].bundle.js\\\",\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n  },\r\n  optimization: {\r\n    splitChunks: {\r\n      chunks: \\\"all\\\",\r\n      // 拆分包的最小体积\r\n      // 如果一个包拆分出来达不到 minSize，那么这个包就不会拆分（会被合并到其他包中）\r\n      minSize: 100,\r\n      // 将大于 maxSize 的包，拆分成不小于 minSize 的包\r\n      maxSize: 10000,\r\n\r\n      // 自己对需要拆包的内容进行分组\r\n      cacheGroups: {\r\n        自定义模块的name: {\r\n          test: /node_modules/,\r\n          filename: \\\"[name]_vendors.js\\\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n2. 打包，生成如下构建结果：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f2fb40731d49d2b1f974fceaf84d46~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 1.3 方式三：动态导入(dynamic import)\r\n\r\n\r\n另外一个代码拆分的方式是动态导入时，`webpack` 提供了两种实现动态导入的方式：\r\n\r\n- 第一种，使用 `ECMAScript` 中的 `import()` 语法来完成，也是目前推荐的方式；\r\n- 第二种，使用 `webpack` 遗留的 `require.ensure`，目前已经不推荐使用；\r\n\r\n**动态 `import` 使用最多的一个场景是懒加载（比如路由懒加载）**\r\n\r\n### 1.3.1 import 方式\r\n\r\n接着从 `1.1.2` 小节代码的基础上修改：\r\n\r\n1. 修改 `webpack.confg.js`：\r\n```js\r\nconst path = require(\\\"path\\\");\r\n\r\nmodule.exports = {\r\n  entry: \\\"./src/index.js\\\",\r\n  mode: \\\"development\\\",\r\n  entry: {\r\n    index: \\\"./src/index.js\\\",\r\n  },\r\n  output: {\r\n    filename: \\\"[name].bundle.js\\\",\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n  },\r\n};\r\n```\r\n\r\n2. 删除 `src/another-module.js` 文件\r\n\r\n3. 修改 `src/index.js`，不再使用 `statically import` (静态导入) `lodash`，而是通过 `dynamic import`(动态导入) 来分离出一个 `chunk`：\r\n\r\n```js\r\nconst logLodash = function () {\r\n  import(\\\"lodash\\\").then(({ default: _ }) => {\r\n    console.log(_);\r\n  });\r\n};\r\n\r\nlogLodash();\r\n```\r\n\r\n之所以需要 `default`，是因为 `webpack 4` 在导入 `CommonJS` 模块时，将不再解析为 `module.exports` 的值，而是为 `CommonJS` 模块创建一个 `artificial namespace` 对象。\r\n\r\n4. 打包，生成如下构建结果：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761f82d9a33e48de836ea65531acdb83~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n由于 `import()` 会返回一个 `promise`，因此它可以和 `async` 函数一起使用。下面是如何通过 `async` 函数简化代码：\r\n\r\n```js\r\nconst logLodash = async function () {\r\n  const { default: _ } = await import(\\\"lodash\\\");\r\n\r\n  console.log(_);\r\n};\r\n\r\nlogLodash();\r\n```\r\n\r\n\r\n### 1.3.2 动态导入的文件命名\r\n因为动态导入通常是一定会打包成独立的文件的，所以并不会再 `cacheGroups` 中进行配置；\r\n\r\n它的命名我们通常会在 `output` 中，通过 `chunkFilename` 属性来命名：\r\n\r\n1. 修改 `webpack.config.js`\r\n```diff\r\nconst path = require(\\\"path\\\");\r\n\r\nmodule.exports = {\r\n  entry: \\\"./src/index.js\\\",\r\n  mode: \\\"development\\\",\r\n  entry: {\r\n    index: \\\"./src/index.js\\\",\r\n  },\r\n  output: {\r\n    filename: \\\"[name].bundle.js\\\",\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n+    chunkFilename: \\\"chunk_[name].js\\\"\\\"\r\n  },\r\n};\r\n\r\n```\r\n2. 打包构建：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32aadec66f9a441cae216649cac5392a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果对打包后的 `[name]` 不满意，还可以通过 `magic comments`（魔法注释）来修改：\r\n\r\n1， 修改 `src/index.js`：\r\n```js\r\nconst logLodash = async function () {\r\n  const { default: _ } = await import(/*webpackChunkName: 'lodash'*/ \\\"lodash\\\");\r\n\r\n  console.log(_);\r\n};\r\n\r\nlogLodash();\r\n```\r\n2. 打包构建\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d3453b7eb4b4beca9d233330c8b7357~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n## 1.4 CDN 加速\r\n`CDN` 称之为 **内容分发网络**（`Content Delivery Network 或 Content Distribution Network`，缩写：`CDN`）\r\n- 它是指通过相互连接的网络系统，利用最靠近每个用户的服务器；\r\n- 更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户；\r\n- 来提供高性能、可扩展性及低成本的网络内容传递给用户；\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ffdbeb7763c4185adef7fb4564aa974~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在开发中，我们使用 `CDN` 主要是两种方式：\r\n- 方式一：打包的所有静态资源，放到 `CDN` 服务器，用户所有资源都是通过 `CDN` 服务器加载的；\r\n- 方式二：一些第三方资源放到 `CDN` 服务器上；\r\n\r\n\r\n### 1.4.1 配置自己的 CDN 服务器\r\n\r\n如果所有的静态资源都想要放到 `CDN` 服务器上，我们需要购买自己的 `CDN` 服务器；\r\n- 目前阿里、腾讯、亚马逊、`Google` 等都可以购买 `CDN` 服务器；\r\n- 我们可以直接修改 `publicPath`，在打包时添加上自己的 `CDN` 地址；\r\n\r\n1. 在 `1.3.1` 的基础上安装 `HtmlWebpackPlugin` 插件：\r\n```shell\r\nnpm install --save-dev html-webpack-plugin\r\n```\r\n2.  修改 `webpack.config.js` 文件:\r\n\r\n```diff\r\nconst path = require(\\\"path\\\");\r\nconst HtmlWebpackPlugin = require(\\\"html-webpack-plugin\\\");\r\n\r\nmodule.exports = {\r\n  entry: \\\"./src/index.js\\\",\r\n  mode: \\\"development\\\",\r\n  entry: {\r\n    index: \\\"./src/index.js\\\",\r\n  },\r\n  output: {\r\n    filename: \\\"[name].bundle.js\\\",\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n    chunkFilename: \\\"chunk_[name].js\\\",\r\n+   publicPath: \\\"https://yejiwei.com/cdn/\\\",\r\n  },\r\n  plugins: [new HtmlWebpackPlugin()],\r\n};\r\n```\r\n\r\n2. 打包构建\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5c873107a344f89f8a7fd10c1a5adb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以发现我们打包后的 `script` 标签自动添加了 `CDN` 服务器地址的前缀。\r\n\r\n### 1.4.2 配置第三方库的CDN服务器\r\n\r\n通常一些比较出名的开源框架都会将打包后的源码放到一些比较出名的、免费的 `CDN` 服务器上：\r\n- 国际上使用比较多的是 `unpkg`、`JSDelivr`、`cdnjs`；\r\n- 国内也有一个比较好用的 `CDN` 是 `bootcdn` ；\r\n\r\n\r\n在项目中，我们如何去引入这些 `CDN` 呢？\r\n- 第一，在打包的时候我们不再需要对类似于 `lodash` 或者 `dayjs` 这些库进行打包；\r\n- 第二，在 `html` 模块中，我们需要自己加入对应的 `CDN` 服务器地址；\r\n    \r\n1.  创建 `public/index.html` 模版，手动加上对应 `CDN` 服务器地址\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n  <head>\r\n    <meta charset=\\\"UTF-8\\\" />\r\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\" />\r\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\r\n    <title>Document</title>\r\n    <script src=\\\"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.core.min.js\\\"></script>\r\n  </head>\r\n  <body></body>\r\n</html>\r\n```\r\n2.  在 `1.3.1` 的基础上修改 `webpack.config.js`配置，来排除一些库的打包并配置 `html` 模版：\r\n```diff\r\nconst path = require(\\\"path\\\");\r\nconst HtmlWebpackPlugin = require(\\\"html-webpack-plugin\\\");\r\n\r\nmodule.exports = {\r\n  entry: \\\"./src/index.js\\\",\r\n  mode: \\\"development\\\",\r\n  entry: {\r\n    index: \\\"./src/index.js\\\",\r\n  },\r\n  output: {\r\n    filename: \\\"[name].bundle.js\\\",\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n    chunkFilename: \\\"chunk_[name].js\\\",\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n+     template: \\\"./public/index.html\\\",\r\n    }),\r\n  ],\r\n+ externals: {\r\n+   lodash: \\\"_\\\",\r\n+ },\r\n};\r\n\r\n```\r\n3. 打包构建\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb895fac1a104978944ccc29f54eb05c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b72b20b982f942da862b5e1c48733a89~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 1.5 补充\r\n\r\n以下补充了解即可（一些细节）\r\n### 1.5.1 解决注释的单独提取\r\n如果将 `webpack.config.js` 的 `mode` 改为 `production` 也就是生产环境时，经常会看到一写 `.txt` 后缀的注释文件\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/773ec98242d045c39c3d1c0bdd848e78~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这是因为在 `production` 默认情况下，`webpack` 再进行分包时，有对包中的注释进行单独提取。\r\n\r\n这个包提取是由另一个插件(`TerserPlugin` 后面会细说) 默认配置的原因，如果想去掉可以做以下配置：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597dced532124c34aa61e9c389f66253~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 1.5.2 chunkIds 的生成方式\r\n\r\n`optimization.chunkIds` 配置用于告知 `webpack` 模块的 `id` 采用什么算法生成。\r\n\r\n**有三个比较常见的值：**\r\n- **`natural`**：按照数字的顺序使用 `id`；\r\n- **`named`**：`development下` 的默认值，一个可读的（你能看的懂得）名称的 `id`；\r\n- **`deterministic`**：确定性的，在不同的编译中不变的短数字 `id`\r\n    - 在 `webpack4` 中是没有这个值的；\r\n    - 那个时候如果使用 `natural`，那么在一些编译发生变化时，就需要重新进行打包就会有问题；\r\n\r\n**最佳实践：**\r\n- 开发过程中，我们推荐使用 `named`；\r\n- 打包过程中，我们推荐使用 `deterministic`；\r\n\r\n### 1.5.3. runtimeChunk 的配置\r\n\r\n**配置 `runtime` 相关的代码是否抽取到一个单独的 `chunk` 中：**\r\n- `runtime` 相关的代码指的是在运行环境中，对**模块进行解析、加载、模块信息相关的代码**；\r\n- 比如我们的 `index` 中通过 `import` 函数相关的代码加载，就是通过 `runtime` 代码完成的；\r\n**抽离出来后，有利于浏览器缓存的策略：**\r\n- 比如我们修改了业务代码（`main`），那么 `runtime` 和 `component`、`bar`的 `chunk` 是不需要重新加载的；\r\n- 比如我们修改了 `component`、`bar` 的代码，那么 `main` 中的代码是不需要重新加载的；\r\n设置的值：\r\n- `true/multiple`：针对每个入口打包一个 `runtime` 文件；\r\n- `single`：打包一个 `runtime` 文件；\r\n- 对象：`name` 属性决定 `runtimeChunk` 的名称；\r\n\r\n> 对于每个 `runtime chunk`，导入的模块会被分别初始化，因此如果你在同一个页面中引用多个入口起点，请注意此行为。你或许应该将其设置为 `single`，或者使用其他只有一个 `runtime` 实例的配置。\r\n\r\n### 1.5.4. Prefetch 和 Preload\r\n\r\n**`webpack v4.6.0+` 增加了对预获取和预加载的支持。**\r\n\r\n在声明 `import` 时，使用下面这些内置指令，来告知浏览器：\r\n- **`prefetch`(预获取)**：将来某些导航下可能需要的资源\r\n- **`preload`(预加载)**：当前导航下可能需要资源\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26105bb556fd467aa566f45e37e9f0c8~tplv-k3u1fbpfcp-zoom-1.image)\r\n**与 `prefetch` 指令相比，`preload` 指令有许多不同之处：**\r\n\r\n\r\n- `preload chunk` 会在父 `chunk` 加载时，以并行方式开始加载。`prefetch chunk` 会在父 `chunk` 加载结束后开始加载。\r\n- `preload chunk` 具有中等优先级，并立即下载。`prefetch chunk` 在浏览器闲置时下载。\r\n- `preload chunk` 会在父 `chunk` 中立即请求，用于当下时刻。`prefetch chunk` 会用于未来的某个时刻。\r\n\r\n\r\n推荐使用 `prefetch` ，因为它是在未来闲置的时候下载，有些东西是不需要立即下载的，这样做不会因为请求不重要的资源而占用网络带宽。\r\n\r\n\r\n# 2. Shimming 预制依赖\r\n\r\n`shimming` 是一个概念，是某一类功能的统称：\r\n- 翻译过来我们称之为 **垫片**，相当于给我们的代码填充一些垫片来处理一些问题；\r\n- 比如我们现在依赖一个第三方的库，这个第三方的库本身依赖 `lodash` ，但是默认没有对 `lodash` 进行导入（认为全局存在 `lodash`），那么我们就可以通过 `ProvidePlugin` 来实现 `shimming` 的效果；\r\n\r\n\r\n> **注意**：`webpack` 并不推荐随意的使用 `shimming`。`Webpack` 背后的整个理念是使前端开发更加模块化；也就是说，需要编写具有封闭性的、不存在隐含依赖（比如全局变量）的彼此隔离的模块；\r\n\r\n## 2.1 Shimming 预支全局变量\r\n\r\n假如一个文件中我们使用了 `axios`，但是没有对它进行引入，那么下面的代码是会报错的；\r\n```js\r\naxios.get('XXXXX').then(res => {\r\n    console.log(res)\r\n})\r\n\r\nget('XXXXX').then(res => {\r\n    console.log(res)\r\n})\r\n```\r\n\r\n我们可以通过使用 `ProvidePlugin` 来实现 `shimming` 的效果：\r\n\r\n1. 修改 `webpack.config.js`：\r\n\r\n```js\r\nnew ProvidePlugin({\r\n    axios: 'axios',\r\n    get: ['axios','get']\r\n})\r\n```\r\n\r\n- **`ProvidePlugin`** 能够帮助我们在每个模块中，通过一个变量来获取一个 `package`；\r\n- 如果 `webpack` 看到这个模块，它将在最终的 `bundle` 中引入这个模块；\r\n- 另外 `ProvidePlugin` 是 **`webpack`默认的一个插件**，所以不需要专门导入；\r\n\r\n\r\n**这段代码的本质是告诉webpack**： 如果你遇到了至少一处用到 `axios` 变量的模块实例，那请你将 `axios package` 引入进来，并将其提供给需要用到它的模块。\r\n\r\n\r\n# 3. TerserPlugin 代码压缩\r\n\r\n在了解 `TerserPlugin` 插件前，我们先来认识一下什么是 `Terser` 。\r\n\r\n## 3.1 Terser 介绍\r\n\r\n**什么是 `Terser` 呢？**\r\n\r\n- `Terser` 是一个 `JavaScript` 的解释（`Parser`）、`Mangler`（绞肉机）/ `Compressor`（压缩机）的工具集；\r\n- 早期我们会使用 `uglify-js` 来压缩、丑化我们的 `JavaScript` 代码，但是目前已经不再维护，并且不支持 `ES6+` 的语法；\r\n- `Terser` 是从 `uglify-es fork` 过来的，并且保留它原来的大部分 `API` 以及适配 `uglify-es` 和 `uglify-js@3` 等；\r\n\r\n\r\n**也就是说，`Terser` 可以帮助我们压缩、丑化我们的代码，让我们的 `bundle` 变得更小。**\r\n\r\n我们现在就来用一下 `Terser`，因为 `Terser` 是一个独立的工具，所以它可以单独安装：\r\n```\r\n# 全局安装\r\nnpm install terser -g\r\n# 局部安装\r\nnpm install terser -D\r\n```\r\n\r\n可以在命令行中使用 Terser：\r\n\r\n```\r\nterser [input files] [options]\r\n# 举例说明\r\nterser js/file1.js -o foo.min.js -c -m\r\n```\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c9c23528a834cdcb70595c97bb73a10~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n我们这里来讲解几个 [`Compress option`](https://github.com/terser/terser#compress-options) 和 [`Mangle(乱砍) option`](https://github.com/terser/terser#mangle-options)：\r\n\r\n**`Compress option`：**\r\n- arrows：class或者object中的函数，转换成箭头函数；\r\n- arguments：将函数中使用 arguments[index]转成对应的形参名称；\r\n- dead_code：移除不可达的代码（tree shaking）；\r\n\r\n**`Mangle option`：**\r\n- toplevel：默认值是false，顶层作用域中的变量名称，进行丑化（转换）；\r\n- keep_classnames：默认值是false，是否保持依赖的类名称；\r\n- keep_fnames：默认值是false，是否保持原来的函数名称；\r\n\r\n## 3.2 Terser 在 webpack 中配置（JS 的压缩）\r\n\r\n**真实开发中，我们不需要手动的通过 `terser` 来处理我们的代码，我们可以直接通过 `webpack` 来处理：**\r\n\r\n- 在 `webpack` 中有一个 `minimizer` 属性，在 `production` 模式下，默认就是使用`TerserPlugin` 来处理我们的代码的；\r\n- 如果我们对默认的配置不满意，也可以自己来创建 `TerserPlugin` 的实例，并且覆盖相关的配置；\r\n\r\n修改 `webpack.config.js` 配置：\r\n```js\r\nconst TerserPlugin = require(\\\"terser-webpack-plugin\\\");\r\n\r\n...\r\n\r\noptimization: {\r\n  // 打开minimize，让其对我们的代码进行压缩（默认production模式下已经打\r\n  minimize: true,\r\n  minimizer: [\r\n    new TerserPlugin({\r\n      // extractComments：默认值为true，表示会将注释抽取到一个单独的文件中；\r\n      // 在开发中，我们不希望保留这个注释时，可以设置为false；\r\n      extractComments: false,\r\n\r\n      // parallel：使用多进程并发运行提高构建的速度，默认值是true\r\n      // 并发运行的默认数量： os.cpus().length - 1；\r\n      // 我们也可以设置自己的个数，但是使用默认值即可；\r\n      // parallel: true,\r\n\r\n      // terserOptions：设置我们的terser相关的配置\r\n      terserOptions: {\r\n        // 设置压缩相关的选项；\r\n        compress: {\r\n          unused: false,\r\n        },\r\n        // 设置丑化相关的选项，可以直接设置为true；\r\n        mangle: true,\r\n        // 顶层变量是否进行转换；\r\n        toplevel: true,\r\n        // 保留类的名称；\r\n        keep_classnames: true,\r\n        // 保留函数的名称；\r\n        keep_fnames: true,\r\n      },\r\n    }),\r\n  ],\r\n},\r\n```\r\n\r\n## 3.3 CSS 的压缩\r\n\r\n上面我们讲了 `JS` 的代码压缩，而在我们的前端项目中另一类占大头的代码就是 `CSS` ：\r\n- `CSS` 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等；\r\n- `CSS` 的压缩我们可以使用另外一个插件：`css-minimizer-webpack-plugin`；\r\n- [`css-minimizer-webpack-plugin`](https://www.webpackjs.com/plugins/css-minimizer-webpack-plugin/) 是使用 `cssnano` 工具来优化、压缩 `CSS`（也可以单独使用）；\r\n\r\n\r\n1. 安装 `css-minimizer-webpack-plugin`:\r\n\r\n```shell\r\nnpm install css-minimizer-webpack-plugin -D\r\n```\r\n\r\n2. 在 `optimization.minimizer` 中配置：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5e8423b6af44e84ac8b4ab4e242ed33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 4. Tree Shaking\r\n\r\n**什么是 `Tree Shaking` ？**\r\n\r\n- `Tree Shaking` 是一个术语，在计算机中表示消除死代码（`dead_code`）；\r\n- 最早的想法起源于 `LISP`，用于消除未调用的代码（纯函数无副作用，可以放心的消除，这也是为什么要求我们在进行函数式编程时，尽量使用纯函数的原因之一）；\r\n- 后来 `Tree Shaking` 也被应用于其他的语言，比如 `JavaScript`、`Dart`；\r\n\r\n\r\n**`JavaScript` 的 `Tree Shaking`：**\r\n\r\n- 对 `JavaScript` 进行 `Tree Shaking` 是源自打包工具 `rollup`；\r\n- 这是因为 `Tree Shaking` 依赖于 `ES Module` 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）；\r\n- `webpack2` 正式内置支持了 `ES2015` 模块，和检测未使用模块的能力；\r\n- 在 `webpack4` 正式扩展了这个能力，并且通过 `package.json` 的 `sideEffects` 属性作为标记，告知 `webpack` 在编译时，哪里文件可以安全的删除掉；\r\n- `webpack5` 中，也提供了对部分 `CommonJS` 的 `tree shaking` 的支持；\r\n    ✓ https://github.com/webpack/changelog-v5#commonjs-tree-shaking\r\n\r\n\r\n## 4.1 webpack 实现 Tree Shaking\r\n\r\n`webpack` 实现 `Tree Shaking` 采用了两种不同的方案：\r\n1. **`usedExports`**：通过标记某些函数是否被使用，之后通过 `Terser` 来进行优化的；\r\n2. **`sideEffects`**：跳过整个模块/文件，直接查看该文件是否有副作用；\r\n\r\n`usedExports` 按 `sideEffects` 这两个东西的优化是不同的事情。\r\n> 引用官方文档的话： The sideEffects and usedExports（more konwn as tree shaking）optimizations are two different things\r\n\r\n下面我们分别来演示一下这两个属性的使用\r\n### 4.1.1 usedExports\r\n\r\n1. 新建一个 `webpack-demo`。\r\n```shell\r\nmkdir webpack-demo\r\ncd webpack-demo\r\nnpm init -y\r\nnpm install webpack webpack-cli lodash --save-dev\r\n```\r\n2. 创建 `src/math.js` 文件：\r\n\r\n```js\r\nexport const add = (num1, num2) => num1 + num2;\r\nexport const sub = (num1, num2) => num1 - num2;\r\n```\r\n在这个问价中仅是导出了两个函数方法\r\n\r\n3. 创建 `src/index.js` 文件：、\r\n\r\n```js\r\nimport { add, sub } from \\\"./math\\\";\r\n\r\nconsole.log(add(1, 2));\r\n```\r\n在 `index.js` 中 导入了刚刚创建的两个函数，但是只使用了 `add`\r\n\r\n4. 配置 `webpack.config.js`：\r\n\r\n```js\r\nconst path = require(\\\"path\\\");\r\n\r\nmodule.exports = {\r\n  mode: \\\"development\\\",\r\n  devtool: false,\r\n  entry: \\\"./src/index.js\\\",\r\n  output: {\r\n    path: path.resolve(__dirname, \\\"dist\\\"),\r\n    filename: \\\"main.js\\\",\r\n  },\r\n  optimization: {\r\n    usedExports: true,\r\n  },\r\n};\r\n```\r\n为了可以看到 `usedExports` 带来的效果，我们需要设置为 `development` 模式。因为在 `production` 模式下，`webpack` 默认的一些优化会带来很大的影响。\r\n\r\n5. 设置 `usedExports` 为 `true` 和 `false` 对比打包后的代码：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd773ff00304513a251ba6e9ee8fec9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51f2b8be26745439f25226a91e06359~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n仔细观察上面两张图可以发现当设置 `usedExports: true` 时，`sub` 函数没有导出了，另外会多出一段注释：`unused harmony export mul`；这段注释的意义是会告知 `Terser` 在优化时，可以删除掉这段代码。\r\n\r\n\r\n**这个时候，我们将 `minimize` 设置 `true`：**\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e915f5eb3d79471c819ade789f20f271~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edc8e8f37cfb435e820567573131c2d5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n- `usedExports` 设置为 `false` 时，`sub` 函数没有被移除掉；\r\n- `usedExports` 设置为 `true` 时，`sub` 函数有被移除掉；\r\n\r\n**所以，`usedExports` 实现 `Tree Shaking` 是结合 `Terser` 来完成的。**\r\n\r\n### 4.1.2 sideEffects\r\n\r\n在一个纯粹的 `ESM` 模块世界中，很容易识别出哪些文件有副作用。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 `webpack compiler` 哪些代码是“纯粹部分”。\r\n\r\n通过 `package.json` 的 `\\\"sideEffects\\\"` 属性，来实现这种方式。\r\n\r\n```json\r\n{\r\n  \\\"name\\\": \\\"your-project\\\",\r\n  \\\"sideEffects\\\": false\r\n}\r\n```\r\n如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 `false`，来告知 `webpack` 它可以安全地删除未用到的 `export`。\r\n\r\n> `\\\"side effect(副作用)\\\"` 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 `export` 或多个 `export`。举例说明，例如 `polyfill`，它影响全局作用域，并且通常不提供 `export`。\r\n\r\n如果你的代码确实有一些副作用，可以改为提供一个数组：\r\n\r\n```json\r\n{\r\n  \\\"name\\\": \\\"your-project\\\",\r\n  \\\"sideEffects\\\": [\\\"./src/some-side-effectful-file.js\\\"]\r\n}\r\n```\r\n\r\n> 注意，所有导入文件都会受到 `tree shaking` 的影响。这意味着，如果在项目中使用类似 `css-loader` 并 `import` 一个 `CSS` 文件，则需要将其添加到 `side effect` 列表中，以免在生产模式中无意中将它删除：\r\n\r\n```json\r\n{\r\n  \\\"name\\\": \\\"your-project\\\",\r\n  \\\"sideEffects\\\": [\\\"./src/some-side-effectful-file.js\\\", \\\"*.css\\\"]\r\n}\r\n```\r\n\r\n## 4.2 CSS 实现 Tree Shaking\r\n\r\n上面将的都是关于 `JavaScript` 的 `Tree Shaking` ，对于 `CSS` 同样有对应的 `Tree Shaking` 操作。\r\n\r\n- 在早期的时候，我们会使用 `PurifyCss` 插件来完成 `CSS` 的 `tree shaking`，但是目前该库已经不再维护了（最新更新也是在 `4` 年前了）；\r\n\r\n- 目前我们可以使用另外一个库来完成 `CSS` 的 `Tree Shaking`：`PurgeCSS`，也是一个帮助我们删除未使用的 `CSS` 的工具；\r\n\r\n\r\n1. 安装 `PurgeCss` 的 `webpack` 插件：\r\n\r\n```shell\r\nnpm install purgecss-webpack-plugin -D\r\n```\r\n\r\n2. 在 `webpack.config.js` 中配置 `PurgeCss`\r\n\r\n```\r\nnew PurgeCSSPlugin({\r\n  paths: glob.sync(`${path.resolve(__dirname, '../src')}/**/*`, { nodir: true }),\r\n  only: ['bundle', 'vendor']\r\n})\r\n```\r\n\r\n- `paths`：表示要检测哪些目录下的内容需要被分析，这里我们可以使用 `glob`；\r\n- 默认情况下，`Purgecss` 会将我们的 `html` 标签的样式移除掉，如果我们希望保留，可以添加一个 `safelist` 的属性；\r\n\r\n`purgecss` 也可以对 `less`、`sass`文件进行处理（它是对打包后的 `css` 进行 `tree shaking` 操作）；\r\n\r\n## 4.3 Scope Hoisting\r\n\r\n`Scope Hoisting` 是从 `webpack3` 开始增加的一个新功能，它的功能是对作用域进行提升，并且让 `webpack` 打包后的**代码更小、运行更快**；\r\n\r\n\r\n**默认情况下 `webpack` 打包会有很多的函数作用域，包括一些（比如最外层的）`IIFE`：**\r\n- 无论是从最开始的代码运行，还是加载一个模块，都需要执行一系列的函数\r\n- `Scope Hoisting` 可以将函数合并到一个模块中来运行；（作用域提升，在主模块里直接运行它，而不是去加载一些单独的模块）\r\n\r\n\r\n**使用 `Scope Hoisting` 非常的简单，`webpack` 已经内置了对应的模块：**\r\n\r\n- 在 `production` 模式下，默认这个模块就会启用；\r\n- 在 `development` 模式下，我们需要自己来打开该模块；\r\n\r\n```js\r\nnew webpack.optimize.ModuleConcatenationPlugin()\r\n```\r\n\r\n# 5. webpack 对文件压缩\r\n\r\n经过前几小节的代码压缩优化（`Tree Shaking` 的优化、`Terser` 的优化、`CSS` 压缩的优化），基本上已经没有什么可以通过删除一些代码再压缩文件的方法了（变量、空格、换行符、注释、没用的代码都已经处理了）\r\n\r\n但是我们还有一种通过压缩算法从对**文件压缩**的方式来继续减小包的体积（就像在 winodows 将文件夹压缩成 `zip` 一样，只不过我们这里是对单个js文件进行压缩）\r\n\r\n\r\n**目前的压缩格式非常的多：**\r\n- `compress` – `UNIX` 的 `“compress”` 程序的方法（历史性原因，不推荐大多数应用使用，应该使用 `gzip`或 `deflate`）；\r\n- `deflate` – 基于 `deflate` 算法（定义于RFC 1951）的压缩，使用 `zlib` 数据格式封装；\r\n- `gzip` – `GNU zip` 格式（定义于RFC 1952），是目前使用比较广泛的压缩算法；\r\n- `br` – 一种新的开源压缩算法，专为 `HTTP` 内容的编码而设计；\r\n\r\n\r\n在 `webpack` 中的配置：\r\n1. 安装 `CompressionPlugin`\r\n\r\n```shell\r\nnpm install compression-webpack-plugin -D\r\n```\r\n\r\n2. 配置 `webpack.config.js`：\r\n\r\n```js\r\nnew CompressionPlugin({\r\n    test: /].(css|js)$/, // 匹配哪些文件需要压缩\r\n    // threshold: 500, // 设置文件从多大开始压缩\r\n    minRatio: 0.7, // 至少的压缩比例\r\n    algorithm: \\\"gzip, // 才用的压缩算法\r\n    // include\r\n    // exclude\r\n})\r\n```\r\n\r\n# 6. HTML 文件中代码的压缩\r\n\r\n我们之前使用了 `HtmlWebpackPlugin` 插件来生成 `HTML` 的模板，事实上它还有一些其他的配置：\r\n\r\n- inject：设置打包的资源插入的位置\r\n    - true、 false 、body、head\r\n- cache：设置为true，只有当文件改变时，才会生成新的文件（默认值也是true）\r\n- minify：默认会使用一个插件html-minifier-terser\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e8b0536a6e34ec5a852688aee3d3090~tplv-k3u1fbpfcp-zoom-1.image)\r\n"
    },
    {
        "article_id": "7188324325831737402",
        "snapshot": "",
        "title": "MySQL数据同步ES的4种方法，你能想到几种？",
        "preview": "这期给大家分享一个电商中常见的场景——MySQL数据同步Elasticsearch。那么问题来了，商品上架，数据一般写入到MySQL的数据库中，那么用于检索的数据又是怎么同步到Elasticsearc",
        "author": "三分恶",
        "view_count": 1692,
        "collect_count": 38,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1035af1f1261526990c117454a5e3fab~300x300.image",
        "category": "后端",
        "content": "大家好，我是老三，这期给大家分享一个电商中常见的场景——MySQL数据同步Elasticsearch。\r\n\r\n![商品检索](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b766ec442a14dbc84a8b4caec0a6914~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n大家应该都在各种电商网站检索过商品，那么检索商品一般都是通过什么实现呢？搜索引擎Elasticsearch。\r\n\r\n那么问题来了，商品上架，数据一般写入到MySQL的数据库中，那么用于检索的数据又是怎么同步到Elasticsearch的呢？\r\n\r\n![MySQL同步ES](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/381ff4e873854198803febfe7d1e9bc8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 1.同步双写\r\n\r\n这是能想到的最直接的方式，在写入MySQL，直接也同步往ES里写一份数据。\r\n\r\n![同步双写](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae13aa11f2748a08b28a848f92763d0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对于这种方式：\r\n\r\n- 优点：实现简单\r\n- 缺点：\r\n  - 业务耦合，商品的管理中耦合大量数据同步代码\r\n  - 影响性能，写入两个存储，响应时间变长\r\n  - 不便扩展：搜索可能有一些个性化需求，需要对数据进行聚合，这种方式不便实现\r\n\r\n# 2.异步双写\r\n\r\n我们也很容易想到异步双写的办法，上架商品的时候，先把商品数据丢进MQ，为了解耦合，我们一般会拆分一个搜索服务，由搜索服务去订阅商品变动的消息，来完成同步。\r\n\r\n![异步双写](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba62a22bee514a8ebd928bede2a68dda~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n前面说的，一些数据需要聚合处理成类似宽表的结构怎么办呢？例如商品库的商品品类、spu、sku表是分开的，但是查询是跨维度的，在ES里再聚合一次效率就低一些，最好就是把商品的数据给聚合起来，在ES里以类似大宽表的形式存储，这样一来查询效率就高一些。\r\n\r\n![多维度多条件查询](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9de3a7ed10f54bb0910917459e3d0420~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这种其实没什么好办法，基本上还是得搜索服务直接查库，或者远程调用，再查询一遍商品的数据库，就是所谓的回查。\r\n\r\n![回查完成聚合](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e21e318158754544bf3ceb95ac22ae4f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这种方式：\r\n\r\n- 优点：\r\n  - 解耦合，商品服务无需关注数据同步\r\n  - 实时性较好，使用MQ，正常情况下，同步完成在秒级\r\n- 缺点：\r\n  - 引入了新的组件和服务，增加了复杂度\r\n\r\n# 3.定时任务\r\n\r\n假如我们要快速搞搞，数据量有没那么大，怎么办呢？定时任务也可以。\r\n\r\n![定时任务](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b59c719c924e6d9579e4b2a2c13a2a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n定时任务，最麻烦的一点是频率不好选，频率高的话，会非自然地形成业务的波峰，导致存储的CPU、内存占用波峰式上升，频率低的话实时性比较差，而且也有波峰的情况。\r\n\r\n这种方式：\r\n\r\n- 优点：实现比较简单\r\n- 缺点：\r\n  - 实时性难以保证\r\n  - 对存储压力较大\r\n\r\n# 4.数据订阅\r\n\r\n还有一种方式，就是最时兴的数据订阅。\r\n\r\nMySQL通过binlog订阅实现主从同步，各路数据订阅框架比如canal就依据这个原理，将client组件伪装成从库，来实现数据订阅。\r\n\r\n![MySQL主从同步](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88d9b280b01243fbba752f345a5dca7c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们以应用最广泛的canal为例，canal通过`canal-adapter`，支持多种适配器，其中就有ES适配器，通过一些配置，启动之后，就可以直接把MySQL数据同步到ES，这个过程是零代码的。\r\n\r\n![canal同步数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0b68cadcaf4459a6df830e13adb9b9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是，和老板了解过，使用canal看起来很美好，帮我们把同步的事情都干了，但其实，还是要写代码。为什么呢？\r\n\r\n前面提到的多张表数据聚合，canal的支持没那么好，所以还是得回查。这时候用canal-adapter就不合适了，需要自己实现canal-client，监听和聚合数据，写入ES：\r\n\r\n![数据订阅+回查](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d305c1ffac0d4f27bcbb44632d25f877~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n这种看起来和异步双写比较像，但是第一降低了商品服务的耦合，第二数据的实时性更好。\r\n\r\n所以使用数据订阅：\r\n\r\n- 优点：\r\n  - 业务入侵较少\r\n  - 实时性较好\r\n\r\n至于数据订阅框架的选型，主流的大体上是这些：\r\n\r\n|          | Cancal                  | Maxwell                 | Python-Mysql-Rplication |\r\n| -------- | ----------------------- | ----------------------- | ----------------------- |\r\n| 开源方   | 阿里巴巴                | Zendesk                 | 社区                    |\r\n| 开发语言 | Java                    | Java                    | Python                  |\r\n| 活跃度   | 活跃                    | 活跃                    | 活跃                    |\r\n| 高可用   | 支持                    | 支持                    | 不支持                  |\r\n| 客户端   | Java/Go/PHP/Python/Rust | 无                      | Python                  |\r\n| 消息落地 | Kafka/RocketMQ 等       | Kafka/RabbitNQ/Redis 等 | 自定义                  |\r\n| 消息格式 | 自定义                  | JSON                    | 自定义                  |\r\n| 文档详略 | 详细                    | 详细                    | 详细                    |\r\n| Boostrap | 不支持                  | 支持                    | 不支持                  |\r\n\r\n\r\n\r\n除了MySQL同步ES，MySQL同步到其它的数据存储，例如HBase，其实大体上都是类似的几种方法。\r\n\r\n<br>\r\n\r\n<hr>\r\n\r\n\r\n**参考：**\r\n\r\n[1]. https://www.infoq.cn/article/1afyz3b6hnhprrg12833\r\n\r\n[2].https://www.iamle.com/archives/2900.html\r\n\r\n[3].https://blog.51cto.com/lianghecai/4755693\r\n\r\n[4].https://qinyuanpei.github.io/posts/1333693167/\r\n\r\n[5].https://github.com/alibaba/canal/wiki/ClientAdapter\r\n\r\n<hr>\r\n\r\n"
    },
    {
        "article_id": "7162461841027760135",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c74c850381248ddafa3705593830aa6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "十月份火火火的 GitHub 开源项目",
        "preview": "本篇文章盘点 10 月份 GitHub 上比较受欢迎的开源项目，你可以点击上方的 #每月盘点 查看历史盘点的开源项目合集。",
        "author": "逛逛GitHub",
        "view_count": 11607,
        "collect_count": 136,
        "comment_count": 7,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8e6d13ed687541e576f001e5a89e4244~300x300.image",
        "category": "前端",
        "content": "本篇文章盘点 10 月份 GitHub 上比较受欢迎的开源项目，你可以点击上方的 #每月盘点 查看历史盘点的开源项目合集。\r\n\r\n本期推荐开源项目目录：  \r\n\r\n\r\n1. 命令行记录神器\r\n\r\n2. 口袋妖怪全息效果 CSS 样式\r\n\r\n3. 金庸群侠传 3D 重制版\r\n\r\n4. curl\r\n\r\n5. 开源的视频播放器\r\n\r\n* * *\r\n\r\n# 01\r\n\r\n命令行记录神器\r\n\r\n开源项目 vhr 上周开源，截止目前已经获得了 3.7k 的 Star。想必你也经常录制一个 Gif 或者视频，来演示在 Terminal 上的一些命令。而开源项目 vhr 就是一个很好用的工具，可以生成终端的 Gif，帮助你能够方便演示你的命令，比如下面的 Gif 图就是使用 vhr 生成的。\r\n\r\n编程语言：Go\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0713a7feb7d4cad9360eb5b0c313a03~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源地址：https://github.com/charmbracelet/vhs\r\n\r\n# 02\r\n\r\n口袋妖怪全息效果 CSS 样式\r\n\r\n这个开源项目是一组高级 CSS 样式，可为口袋妖怪卡片的表面创建逼真的全息效果，在 GitHub 开源一天内就获得了 2k 左右的 Star。\r\n\r\n建议大家去体验一下效果，如何使用 CSS + JS + HTML 做出如此逼真的卡组效果，光泽都能看的一清二楚。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23ca5a9fb214b648c432f13fdc1aaec~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4b3e2476fb4097bf6ff417ff874dc3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源地址：https://github.com/simeydotme/pokemon-cards-css\r\n\r\n# 03\r\n\r\n金庸群侠传 3D 重制版\r\n\r\n金庸群侠传是 1996 年发布的中文角色扮演游戏，直到现在都有一群忠实的玩家用户。由于是 1996 年，这个游戏的画面相对粗糙，分辨率也特别低。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9eb48a1445744ed97f8a7ad36cc178b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源项目《群侠传，启动》 是一个开源的武侠 RPG 游戏框架，旨在致敬经典游戏《金庸群侠传》，至今已经获得了 5.8K 的 Star。\r\n\r\n来看看使用 使用 Unity 引擎重制的效果：\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87c329897df14997926b04bc3efd56b6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffe204a3d2e49c1a52da7b28c065f2c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源地址：https://github.com/jynew/jynew\r\n\r\n# 04\r\n\r\ncurl\r\n\r\ncurl 大家应该非常熟悉，是工作中常用的命令行工具，用来请求 Web 服务器。在 GitHub 上获得了 27k 的 Star。\r\n\r\n获得如此多的 Star 因为 curl 的功能强大，命令行参数多达几十种。熟练使用，常常可以取代 Postman 这一类的图形界面调试工具。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/048e94c1d6ea4b4c9f601e174ebdf63a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源地址：https://github.com/curl/curl\r\n\r\n# 05\r\n\r\n开源的视频播放器\r\n\r\nJellyfin 是一批开发者资源开发的视频播放器，或者说是媒体解决方案。使用 Jellyfin 可以保持、管理你的视频、音乐或者图片。\r\n\r\n采用 C# 构建，界面简单简洁，在 GitHub 上已经获得了 17.4K 的 Star。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca4247a6de3429e86196d44cb3424d9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5baccc7b39142dd807b64eeff500a0b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开源地址：https://github.com/jellyfin/jellyfin\r\n\r\n历史盘点\r\n\r\n逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：\r\n\r\n```\r\n开源地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo\r\n```\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398b314d46694282b7d239077027d024~tplv-k3u1fbpfcp-zoom-1.image)"
    },
    {
        "article_id": "7153255870447484936",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/209a2dd2090d443495c92b127ca67d7c~tplv-k3u1fbpfcp-watermark.image?",
        "title": " 刚插上网线，电脑怎么知道自己的IP是什么？",
        "preview": "今天这篇文章，很有意思，它来源于我曾经的一次真实面试里的其中一个小问题。当时是终面，面我的是那家公司的技术顾问，在面试前hr还让我看了他的履历，是一位1996年就进了麻省理工计算机系的大佬。。。",
        "author": "小白debug",
        "view_count": 22898,
        "collect_count": 440,
        "comment_count": 60,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/57eb1e789b5e8b164056a7294fd9fece~300x300.image",
        "category": "后端",
        "content": "> 本文为掘金社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n\r\n\r\n今天这篇文章，很有意思，它来源于我曾经的一次真实面试里的其中一个**小问题**。当时是终面，面我的是那家公司的**技术顾问**，在面试前hr还让我看了他的履历，是一位**1996年就进了麻省理工计算机系的大佬**。\r\n\r\n属实有被震惊到，什么概念？1996年，没记错的话那是个用**BP机和大哥大**的年代？有几个人能用上电脑？又有几个人有这种机会能出国深造。\r\n\r\n这是哪部**爽文小说**的主人公剧情？\r\n\r\n就算放到现在，这也是非常强的事情。\r\n\r\n我这辈子是没希望了，也不知道我的儿子或者孙子辈有没有机会能做到。\r\n\r\n也就是说，这位大佬，至少**领先了我两代人**。\r\n\r\n那一天，我感受到了，那种跨越时代的碾压感。\r\n\r\n<br>\r\n\r\n好了，不讲骚话了，直接开始主题吧。\r\n\r\n<br>\r\n\r\n我们知道，如果你知道某台电脑的IP，就可以向这个IP发起连接请求，建立连接后就可以操作收发数据。\r\n\r\n![五层网络协议对应的消息体变化分析](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66522ef3b87846b398244fdd614a3d29~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n要发送的数据，会在网络层里加入**IP头**。\r\n\r\n![ip报头](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b91f3bbe605408b9bc0c1b5e8af28f0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里面最重要的是**发送端和接收端的IP地址**。这个IP地址就像是一个门牌号一样，有了它，数据包就能在这个纷繁复杂的网络世界里找到该由谁来接收这个数据包。\r\n\r\n所以说上面的网络通信离不开IP。\r\n\r\n<br>\r\n\r\n假设我有一台新买的电脑，**还没联网**呢，这时候拿着新买的网线，插入网线口，网线插口亮起来了。\r\n\r\n然后就可以开始用它上网了。\r\n\r\n<br>\r\n\r\n那么问题来了。\r\n\r\n**刚插上网线，电脑怎么知道自己的IP是什么**？怎么就突然能上网了呢？\r\n\r\n这个话题，我们从**DHCP**聊起吧。\r\n\r\n<br>\r\n\r\n### DHCP是什么\r\n\r\n插上网线之后，获得IP的方式主要有两种。\r\n\r\n第一种是，自己**手动在电脑里配**。像下图那样，是macOS的一个截图，在选择**手动**配置之后，除了**IP地址**还需要配上**子网掩码**和**路由器的地址**。\r\n\r\n![手动配IP](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67f45e23b661494eb6a4958905e59d5e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这就很不科学了，电脑又不只是卖给程序员，这几个词对于大部分普通人来说，比**赋能抓手闭环**这种黑话还要难理解。\r\n\r\n大部分人没事都不应该去配这玩意。\r\n\r\n有没有办法可以让这些IP信息自动获得？\r\n\r\n有，这就是**第二种**获取IP的方式，**DHCP**（**D**ynamic **H**ost **C**onfiguration **P**rotocol，**动态主机配置协议**）。\r\n\r\n![DHCP自动生成IP](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be24ca2249ba41ceb359d9ad59281f7f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过DHCP，在联网之后可以自动获取到本机需要的**IP地址，子网掩码还有路由器地址**。\r\n\r\n<br>\r\n\r\n### DHCP的工作原理\r\n\r\nDHCP的工作原理也非常简单。\r\n\r\n说白了，就是向某个**管IP分配的服务器**，也就是**DHCP服务器**，申请IP地址。其实一般家里用的路由器就自带这个功能。\r\n\r\n整个操作流程分为**4个**阶段。\r\n\r\n![DHCP协议](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e26c9a958b864283adeb02566143f0a9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n- **DHCP Discover：**在联网时，本机由于没有IP，也不知道DHCP服务器的IP地址是多少，所以根本不知道该向谁发起请求，于是索性选择**广播**，向本地网段内所有人发出消息，询问\\\"**谁能给个IP用用**\\\"。\r\n- **DHCP Offer：**不是DHCP服务器的机子会忽略你的广播消息，而DHCP服务器收到消息后，会在自己维护的一个IP池里拿出一个空闲IP，通过**广播**的形式给回你的电脑。\r\n- **DHCP Request：**你的电脑在拿到IP后，再次发起**广播**，就说\\\"这个IP我要了\\\"。\r\n- **DHCP ACK：**DHCP服务器此时再回复你一个ACK，意思是\\\"ok的\\\"。你就正式获得这个IP在**一段时间（比如24小时）**里的使用权了。后续**只要IP租约不过期**，就可以一直用这个IP进行通信了。\r\n\r\n<br>\r\n\r\n到这里，问题来了\r\n\r\n<br>\r\n\r\n#### 为什么要有第三和第四阶段\r\n\r\n大家有没有发现，**在Offer阶段，其实你的机子就已经拿到了IP了，为什么还要有后面的Request和ACK呢？是不是有些多此一举？**\r\n\r\n这是因为本地网段内，可能有**不止一台DHCP服务器**，在你广播之后，每个DHCP服务器都有可能给你发Offer。\r\n\r\n本着先到先得的原则，你的机子一般会对第一个到的Offer响应DHCP Request，目的是为了确认offer，在你确认Offer这段时间内，DHCP服务器确认这个IP还没被分出去，你才可以安心使用这个IP。\r\n\r\n**像不像你找工作的过程？**\r\n\r\n你海投简历（**DHCP Discover**），然后拿到了多个offer(**DHCP Offer**)。\r\n\r\n这时候事情还没完，你一般会跟HR说：\\\"**你给我两天时间，我要跟家里人商量下**\\\"。\r\n\r\nHR也会对你说：\\\"**那你尽快确认，我这边还有不少候选人等着**\\\"。\r\n\r\n之后你考虑下来觉得不错，跟HR说要接这个Offer（**DHCP Request**），HR看了下这个**岗位还在**，才能确认让你第二天来上班（**DHCP ACK**）。如果这个公司的岗位已经招到其他候选人了，第四阶段的消息就会改为发**DHCP NAK**，意思是拒绝了你的接Offer请求。\r\n\r\n<br>\r\n\r\n### DHCP抓包\r\n\r\n光看原理是有些枯燥，我们可以尝试下抓包看下数据。\r\n\r\n在命令行里执行下面的命令，可以强行让电脑的`en0`网卡重新走一遍DHCP流程。\r\n\r\n```shell\r\nsudo ipconfig set en0 DHCP\r\n```\r\n\r\n> en0可以替换成其他网卡，比如eth0啥的。\r\n\r\n这时候就可以抓到相关的数据包。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c64f8ba9b14bbdaaf33ad1278c91da~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们可以看到蓝色的四个数据包，分别对应上面提到的四个DHCP阶段。\r\n\r\n其中第二阶段中的DHCP Offer里会返回给我们需要的**IP、子网掩码、路由器地址以及DNS服务器地址**。\r\n\r\n![offer阶段](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9d94f59a67f465ebd59f106164dd87f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n<br>\r\n\r\n另外，通过抓包，我们可以发现DHCP是应用层的协议，**基于传输层UDP协议**进行数据传输。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe8ffacba84470dbd486c7e81a83e05~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n那么问题又来了。\r\n\r\n<br>\r\n\r\n### 为什么DHCP用UDP，能不能改用TCP？\r\n\r\n按道理说，UDP能做到的，TCP一般也能做到。但**这次真不行**。\r\n\r\n主要原因还是因为**TCP是面向连接的，而UDP是无连接的**。\r\n\r\n所谓\\\"连接\\\"，他就只有一个发送端和一个接收端，就跟水管一样。\r\n\r\n而DHCP由于一开始并不知道要跟谁建立连接，所以只能通过广播的形式发送消息，注意，小细节，**广播**。\r\n\r\n![广播寻找DHCP服务器.drawio](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06422ae266234cbdbbb9573004e9bc9c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n同样是在本地网段内发广播消息，UDP只需要发给`255.255.255.255`。**它实际上并不是值某个具体的机器，而是一个特殊地址**，这个地址有特殊含义，只要设了这个目的地址，就会在一定本地网段内进行**广播**。\r\n\r\n而TCP却不同，它需要先建立连接，但实际上`255.255.255.255`对应的机器并不存在，因此也不能建立连接。如果同样要做到广播的效果，就需要先得到本地网段内所有机器的IP，然后**挨个建立连接，再挨个发消息**。这就很低效了。\r\n\r\n**因此DHCP选择了UDP，而不是TCP**。\r\n\r\n<br>\r\n\r\n### 为什么第二阶段不是广播，而是单播。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f69636fa6dd54f9ba0ab0d70aaa313ba~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n另外一个小细节不知道大家注意到没，上面在提到 DHCP Offer 阶段时，提到的是DHCP服务器会**使用广播的形式**回复。但抓个包下来却**发现并不是广播，而是单播**。\r\n\r\n其实，这是DHCP协议的一个**小优化**。原则上大家在DHCP offer阶段，都用广播，那肯定是最稳的，**目标机器**收到后自然就会进入第三阶段DHCP Request。而**非目标机器**，收到后解包后发现目的机器的mac地址跟自己的不同，也会丢掉这个包。\r\n\r\n但是问题就出在，这个非目的机器需要每次都在网卡**收到包，并解完包**，才发现原来这不是给它的消息，这。。。真，**有被打扰到。**\r\n\r\n如果本地网段内这样的包满天飞，也浪费机器性能。\r\n\r\n如果能用单播，那当然是最好的。但这时候目的机器其实并没有IP地址，有些系统在这种情况下能收单播包，有些则认为不能收，这个跟系统的实现有关。因此，对于能收单播包的系统，会在发**DHCP Discover**阶段设一个 **Broadcast flag = 0 (unicast)** 的标志位，告诉服务器，支持单播回复，于是服务器就会在**DHCP Offer阶段以单播的形式进行回复**。\r\n\r\n![Discover要求使用单播回复](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f6555d41994a9ea9fb55d299ad374f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n<br>\r\n\r\n### 是不是每次联网都要经历DHCP四个阶段？\r\n\r\n只要想联网，就需要IP，要用IP，就得走DHCP协议去分配。\r\n\r\n但大家也发现了，DHCP第一阶段和第二阶段都可能会发**广播**消息。对于家用电脑还好，插个网线，之后就雷打不动。但像手机这样的**移动设备**，是要带着到处跑的，坐个地铁，进个电梯，公司里到处走走，都可能会涉及到网络切换。\r\n\r\n这每次都要来一个完整的四阶段，各种广播消息满天飞，其实对网络环境不太友好。\r\n\r\n于是问题叒来了，**是不是每次联网都要经历DHCP四个阶段？**\r\n\r\n**当然不需要。**\r\n\r\n我们会发现每次断开wifi再打开wifi时，机子会经历一个**从没网到有网**的过程。\r\n\r\n这时候去抓个包，会发现。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc480e95c69d46d49735035b5a1e8cd2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其实只发生了DHCP的第三和第四阶段。这是因为机子记录了曾经使用过 `192.168.31.170`这个IP，重新联网后，会优先再次请求这个IP，这样就省下了第一第二阶段的广播了。\r\n\r\n另外需要注意的是，抓包图里`DHCP Request`之所以出现两次，是因为**第一次Request发出后太久没得到回应，因此重发。**\r\n\r\n### DHCP分配下来的IP一定不会重复吗？\r\n\r\n一般来说DHCP服务器会在它维护的IP池里找到一个没人用的IP分配给机子，\r\n\r\n这个IP如果重复分配了，那本地网段内就会出现两个**同样的IP**，这个IP下面却对应两个**不同的mac地址**。但其他机器上的**ARP缓存**中却只会记录其中一条**mac地址到IP的映射关系**。\r\n\r\n于是，数据在传递的过程中就会出错。\r\n\r\n**因此本地网段内IP必须唯一。**\r\n\r\n**那么DHCP分配下来的IP有没有可能跟别的IP是重复的？**\r\n\r\n都这么问了，那肯定是可能的。\r\n\r\n有两个常见的情况会出现**IP重复**。\r\n\r\n- 文章开头提到，IP是可以自己手动配的，自己配的IP是有可能跟其他DHCP分配下来的IP是相同的。解决方案也很简单，尽量不要手动去配IP，统一走DHCP。或者在DHCP服务器里维护的IP范围里，将这条IP剔除。\r\n- 一个本地网段内，是可以有多个DHCP服务器的，而他们维护的**IP地址范围是有可能重叠的**，于是就有可能将相同的IP给到不同的机子。解决方案也很简单，修改两台DHCP服务器的维护的IP地址范围，让它们不重叠就行了。\r\n\r\n不过吧，上面的解决方案，都需要有权限去修改**DHCP服务器**。\r\n\r\n<br>\r\n\r\n#### 得到**DHCP ACK**之后立马就能使用这个IP了吗？\r\n\r\n这就好像在问，拿到offer之后你是第一时间就去上班吗？\r\n\r\n不。\r\n\r\n你会先告诉你的同事同学朋友，甚至会发朋友圈。\r\n\r\n你的机子也一样。\r\n\r\n在得到**DHCP ACK**之后，机子不会立刻就用这个IP。\r\n\r\n而是会先发**三条ARP消息**。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2751fc6f8a7b4847afeb9dfde7d14b34~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n大家知道**ARP消息的目的是通过IP地址去获得mac地址**。所以**普通的ARP消息里，是填了IP地址，不填mac地址的**。\r\n\r\n但这三条ARP协议，比较特殊，它们叫**无偿ARP**（`Gratuitous ARP`），特点是它会把**IP和mac地址都填好了**，而且**填的还是自己的IP和mac地址**。\r\n\r\n目的有两个。\r\n\r\n- 一个是为了告诉本地网段内所有机子，从现在起，xx IP地址属于xx mac地址，让大家记录在ARP缓存中。\r\n- 另一个就是看下本地网段里有没有其他机子也用了这个IP，如果有冲突的话，那需要重新再走一次DHCP流程。\r\n\r\n<br>\r\n\r\n**在三次无偿ARP消息之后，确认没有冲突了，才会开始使用这个IP地址进行通信。**\r\n\r\n这种行为，实际上就跟你拿了offer之后**发了这么个朋友圈**没啥区别。\r\n\r\n而且，**还连发了三条**。\r\n\r\n![别骂了，图是P的，我没这么发过](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bea360608b643f8b2eb70dd7a7db1b4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n秀offer，offer冲突了不可怕。秀对象秀冲突了才可怕。\r\n\r\n如果你朋友圈里有这种人，答应我，**删了吧**。\r\n\r\n<br>\r\n\r\n### 总结\r\n\r\n- 电脑插上网线，联网后会通过DHCP协议动态申请一个IP，同时获得子网掩码，路由器地址等信息。\r\n- DHCP分为四个阶段，分别是 Discover，Offer， Request和ACK。如果曾经连过这个网，机器会记录你上次使用的IP，再次连接时优先使用原来的那个IP，因此只需要经历第三第四阶段。\r\n- DHCP是应用层协议，考虑到需要支持广播功能，底层使用的是UDP协议，而不是TCP协议。\r\n- DHCP分配下来的IP是有可能跟某台手动配置的IP地址重复的。\r\n- DHCP得到IP之后还会发3次无偿ARP通告，在确认没有冲突后开始使用这个IP。\r\n\r\n<br>\r\n\r\n最后给大家留个问题吧。我们上面的IP都是从DHCP服务器上申请的，在服务器返回DHCP Offer的时候，可以看到上面写了DHCP服务器的IP。比如`192.168.31.1`，这明显是个局域网内的IP，但这能说明，你的DHCP服务器一定在这个局域网里吗？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b82677dcc06447709f4c8603cfbc9231~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n<br>\r\n\r\n### 参考资料\r\n\r\n《图解TCPIP》\r\n\r\n<br>\r\n\r\n### 最后\r\n\r\n兄弟们。\r\n\r\n按照惯例，我应该在这里唯唯诺诺的求大家叫我两声**靓仔**的。\r\n\r\n但我今天不想。\r\n\r\n因为越是这样，评论区里叫我diao毛的兄弟就越多。\r\n\r\n**上海这几天降温了，难怪你们能说出如此冰冷的话。**\r\n\r\n但是。\r\n\r\n只要你们还能给我文章右下角来个**点赞和收藏**的话。\r\n\r\n这口气，我还能忍。\r\n\r\n<br>\r\n\r\n###### 别说了，关注我，一起在知识的海洋里呛水吧"
    },
    {
        "article_id": "7163447762053251109",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35ca10c26c6403293bbbe04cc407cb5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "优雅回答watch和computed的区别和选择？",
        "preview": "有人说面试造火箭，进去拧螺丝；其实个人觉得问的问题是项目中涉及的点 || 热门的技术栈都是很好的面试体验，不要是旁门左道冷门的知识，实际上并不会用到的。 Vue中的watch和computed的区别？",
        "author": "Dignity_呱",
        "view_count": 7140,
        "collect_count": 131,
        "comment_count": 31,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c6084ef8bfcf6e37087a1455a905668~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\nhighlight: arduino-light\r\n\r\n---\r\n\r\n\r\n\r\n## 前言\r\n\r\n- [常网IT](http://zhengzemin.cn:3000)戳我呀！\r\n- [常网IT源码](https://github.com/git-Dignity/vueAndTsAndKoa2)上线啦！\r\n- 本篇录入[吊打面试官](https://juejin.cn/column/7163273718213378055)专栏，希望能祝君拿下Offer一臂之力，各位看官感兴趣可移步🚶。\r\n- 有人说面试造火箭，进去拧螺丝；其实个人觉得问的问题是项目中涉及的点 || 热门的技术栈都是很好的面试体验，不要是旁门左道冷门的知识，实际上并不会用到的。\r\n- 请问Vue中的watch和computed的区别和选择是是什么？\r\n\r\n---\r\n\r\n> 前几个月备考时，有所启发。<br />\r\n> 学而不思则罔，思而不学则殆。<br />\r\n> 大概的意思是：只读书学习，而不思考问题，就会罔然无知没有收获；只思考而不读书学习，就会疑惑而不能肯定。\r\n\r\n\r\n\r\n\r\n## 一、问题剖析\r\n\r\nwatch和computed的区别以及选择？\r\n\r\n其实这个问题在项目实战中很常见，面试官到底想考察我们什么？怎么去回答比较好，我个人觉得可以从以下四个方面去回答这个面试题。\r\n\r\n* 先看看computed, watch两个的定义，并说一下使用上的差异？\r\n* 在使用场景上的差异，怎么去选择？\r\n* 一些使用上的细节、注意事项\r\n* vue3代替vue2的变化\r\n\r\n\r\n\r\n## 二、回：watch和computed的区别？\r\n\r\n### 第一：先看看computed, watch两个的定义，并说一下使用上的差异？\r\n\r\n听到这个**第一**就想起楚雨荨...\r\n\r\n\r\n言归问题。\r\n\r\n计算属性可以**从组件数据产生出新的数据**，经常的使用方式是设置一个函数，返回计算之后的结果。\r\n\r\n可能面试官会突然问到computed和methods的区别？\r\n\r\ncomputed和methods的差异是它具备缓存性，如果依赖项不变时不会重新计算。\r\n\r\n侦听器**可以检测某个响应式数据的变化并执行副作用**，常见用法是传递一个函数，执行副作用，`watch`没有返回值，但可以执行**异步**操作等复杂逻辑。（一般用来请求接口）\r\n\r\n### 第二：在使用场景上的差异，怎么去选择？\r\n\r\n计算属性computed常用场景是**简化**在`template`模板中的复杂表达式，模板中出现太多逻辑判断会造成模板不易维护。\r\n\r\n侦听器Watch常用场景是状态变化之后做一些异步操作。\r\n\r\n至于选择哪种方案时，个人觉得有异步请求的用Wach，其他情况能用计算属性就首选计算属性。\r\n\r\n### 第三：一些使用上的细节、注意事项\r\n\r\n使用过程中有一些细节，比如计算属性可以成为既可读get又可写set的计算属性。watch可以额外设置`deep、immediate`等选项。\r\n\r\n> 当我们需要深度监听对象中的属性时，可以打开`deep：true`选项，这样便会对对象中的每一项进行监听。但是这样会带来性能问题，优化的话可以使用字符串形式监听。\r\n\r\n### 第四\r\n\r\nvue3中watch选项发生了一些变化，例如不再能侦测一个点操作符之外的字符串形式的表达式；\r\n\r\n作者并不是无脑的去掉该API功能，一个东西的离开必定有新事物的产生。\r\n\r\n就如reactivity API中出现了`watch、watchEffect`可以取代vue2的watch选项。\r\n\r\n> 面试官心里想：哎哟，我问你vue2，还会引申到vue3的角度回答，有点意思。\r\n\r\n\r\n## 追问：说说computed的原理是什么？\r\n\r\n小伙子还不错，基底还是可以的，让我继续看看你的深根扎实不。\r\n\r\n其实，上面回答之后，这个问题就告一段落了，但也有面试官抓着问题不放，继续追问下去。\r\n\r\n🙋那你说说computed的原理是什么？\r\n\r\n### vue 响应式原理\r\n\r\ncomputed 原理，首先得讲 vue 响应式原理，因为 computed 的实现是基于 `Watcher` 对象的。 那么 vue 的响应式原理是什么呢？众所周知，vue 是基于 `Object.defineProperty` 实现监听的。在 vue 初始化数据 data 和 computed 数据过程中。会涉及到以下几个对象：\r\n\r\n* `Observe` 对象（观察者）\r\n* `Dep` 对象（订阅者）\r\n* `Watch` 对象 `Observe` 对象是在 data 执行响应式时候调用，因为 computed 属性基于响应式属性，所以其不需要创建 Observe 对象。 Dep 对象主要功能是做依赖收集，有个属性维护多个 Watch 对象，当更新时候循环调用每个 Watch 执行更新。 Watch 对象主要是用于更新，而且是收集的重点对象。\r\n\r\n### computed的两种定义方式\r\n\r\n这里谈到 computed 计算属性，首先要知道，其有两种定义方式。\r\n\r\n一种是方法，另一种是 `get，set` 属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如 data 的属性、vuex 的属性。\r\n\r\nvue 在创建 computed 属性时候，会循环所有计算属性，每一个计算属性会创建一个 watch，并且在通过 `defineProperty` 定义监听，在 get 中，计算属性工作是做依赖收集，在 set 中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为 computed 是懒执行，也就是说第一次初始化之后，便不会执行计算，下一次变更执行重新计算是在 set 中。\r\n\r\n### 依赖收集的时机\r\n\r\n另一个补充点是依赖收集的时机，computed 收集时机和 data 一样，是在组件挂载前，但是其收集对象是自己属性对应的 watch，而 data 本身所有数据对应一个 watch。\r\n\r\n\r\n面试官摸了摸胡子，拍了拍我，明天来报道。\r\n\r\n![3.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25022a80acab41f58ed1050e34ea037c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n\r\n\r\n## 后记\r\n\r\n所以知道为什么同样的问题，有的人可以拿10k，有的可以拿20k，都是在面试过程中体现，中级还是高级。\r\n\r\n面试到最后，面试官：你还有什么想问的吗？如果前面有道题回答不上来的，我会在这个环节问一下面试官的思路。\r\n\r\n问题不知道的就说不知道，强行乱七八糟的说，只会影响整个面试环节的整体。不会因为你这个问题没有涉及过而不要你，一般整个过程有两三道是你自己理解深入回答得不错的，80%过了。\r\n\r\n孔子说过，知之为知之，不知为不知，是知也。\r\n\r\n\r\n\r\n我是[Dignity_呱](https://juejin.cn/user/3368559359295966/posts)，来交个朋友呀，有朋自远方来，不亦乐乎呀！[深夜末班车](https://juejin.cn/pin/7168024168540143623)\r\n\r\n\r\n> 👍 如果对您有帮助，您的点赞是我前进的润滑剂。\r\n\r\n\r\n\r\n## 以往推荐\r\n\r\n [前端仔，快把dist部署到Nginx上](https://juejin.cn/post/7022812216848023560)\r\n \r\n [多图详解，一次性啃懂原型链（上万字）](https://juejin.cn/post/7010942653915201543)\r\n\r\n [老湿说的万物皆对象，你也信？](https://juejin.cn/post/6999452525703364622)\r\n\r\n [Vue-Cli3搭建组件库](https://juejin.cn/post/6890116253449453575)\r\n\r\n [Vue实现动态路由（和面试官吹项目亮点）](https://juejin.cn/post/6872344841293037582)\r\n\r\n [项目中你不知道的Axios骚操作（手写核心原理、兼容性）](https://juejin.cn/post/6863745313711226887)\r\n\r\n [VuePress搭建项目组件文档](https://juejin.cn/post/6854573219773415437)\r\n\r\n [vue-typescript-admin-template后台管理系统](https://juejin.cn/post/6844904115349241863)\r\n\r\n \r\n\r\n\r\n## 原文链接\r\n\r\n[https://juejin.cn/post/7163447762053251109/](https://juejin.cn/post/7163447762053251109/)\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7176428890896728101",
        "snapshot": "",
        "title": "项目终于用上了插入式注解，真香！",
        "preview": "大家好，我是不才陈某~ 插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。 了解过",
        "author": "码猿技术专栏",
        "view_count": 10843,
        "collect_count": 133,
        "comment_count": 15,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/24/1710d2d313678bc6~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "**大家好，我是不才陈某~**\r\n\r\n插入式注解处理器在《深入理解Java虚拟机》一书中有一些介绍（前端编译篇有提到），但一直没有机会使用，直到碰到这个需求，觉得再合适不过了，就简单用了一下，这里做个记录。\r\n\r\n了解过lombok底层原理的都知道其使用的就是的插入式注解，那么今天笔者就以真实场景演示一下插入式注解的使用。\r\n\r\n**公众号：码猿技术专栏**\r\n\r\n**作者：不才陈某**\r\n\r\n## 需求\r\n\r\n我们为公司提供了一套通用的JAVA基础组件包，组件包内有不同的模块，比如熔断模块、负载均模块、rpc模块等等，这些模块均会被打成jar包，然后发布到公司的内部代码仓库中，供其他人引入使用。\r\n\r\n这份代码会不断的迭代，我们希望可以通过`promethus`来监控现在公司内使用各版本代码库的比例，希望达到的效果图如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f88d94844ba74f3daf725343a8068593~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n我们希望看到每一个版本的使用率，这有利于我们做版本兼容，必要的时候可以对古早版本使用者溯源。\r\n\r\n## 问题\r\n\r\n需求似乎很简单，但真要获取自身的jar版本号还是挺麻烦的，有个比较简单但阴间的办法，就是给每一个组件都加上当前的jar版本号，写到配置文件里或者直接设置成常量，这样上报promethus时就可以直接获取到jar包版本号了，这个方法虽然可以解决问题，但每次迭代版本都要跟着改一遍所有组件包的版本号数据，过于麻烦。\r\n\r\n有没有更好的解决办法呢？比如我们可不可以在gradle打包构建时拿到jar包的版本号，然后注入到每个组件中去呢？就像lombok那样，不需要写get、set方法，只需要加个注解标记就可以自动注入get、set方法。\r\n\r\n比如我们可以给每个组件定义一个空常量，加上自定义的注解：\r\n\r\n```java\r\n@TrisceliVersion\r\npublic static final String version = \\\"\\\";\r\n```\r\n\r\n然后像lombok生成set/get方法那样注入真正的版本号：\r\n\r\n```java\r\n@TrisceliVersion\r\npublic static final String version = \\\"1.0.31-SNAPSHOT\\\";\r\n```\r\n\r\n参考lombok的实现，这其实是可以做到的，下面来看解决方案。\r\n\r\n## 解决\r\n\r\njava中解析一个注解的方式主要有两种：编译期扫描、运行期反射，这是lombok `@Setter`的实现：\r\n\r\n```java\r\n@Target({ElementType.FIELD, ElementType.TYPE})\r\n@Retention(RetentionPolicy.SOURCE)\r\npublic @interface Setter {\r\n  \\t// 略...\r\n}\r\n```\r\n\r\n可以看到`@Setter`的`Retention`是`SOURCE`类型的，也就是说这个注解只在编译期有效，它甚至不会被编入class文件，所以lombok无疑是第一种解析方式，那用什么方式可以在编译期就让注解被解析到并执行我们的解析代码呢？答案就是定义插入式注解处理器（通过JSR-269提案定义的`Pluggable Annotation Processing API`实现）\r\n\r\n插入式注解处理器的触发点如下图所示：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed6883baf87d45f190eac7a005e9b049~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n\r\n也就是说插入式注解处理器可以帮助我们在编译期修改抽象语法树（AST）！所以现在我们只需要自定义一个这样的处理器，然后其内部拿到jar版本信息（因为是编译期，可以找到源码的path，源码里随便搞个文件存放版本号，然后用java io读取进来即可），再将注解对应语法树上的常量值设置成jar包版本号，语法树变了，最终生成的字节码也会跟着变，这样就实现了我们想在编译期给常量version注入值的愿望。\r\n\r\n自定义一个插入式注解处理器也很简单，首先要将自己的注解定义出来：\r\n\r\n```java\r\n@Documented\r\n@Retention(RetentionPolicy.SOURCE) //只在编译期有效，最终不会打进class文件中\r\n@Target({ElementType.FIELD}) //仅允许作用于类属性之上\r\npublic @interface TrisceliVersion {\r\n}\r\n```\r\n\r\n然后定义一个继承了`AbstractProcessor`的处理器：\r\n\r\n```java\r\n/**\r\n * {@link AbstractProcessor} 就属于 Pluggable Annotation Processing API\r\n */\r\npublic class TrisceliVersionProcessor extends AbstractProcessor {\r\n\r\n    private JavacTrees javacTrees;\r\n    private TreeMaker treeMaker;\r\n    private ProcessingEnvironment processingEnv;\r\n\r\n    /**\r\n     * 初始化处理器\r\n     *\r\n     * @param processingEnv 提供了一系列的实用工具\r\n     */\r\n    @SneakyThrows\r\n    @Override\r\n    public synchronized void init(ProcessingEnvironment processingEnv) {\r\n        super.init(processingEnv);\r\n        this.processingEnv = processingEnv;\r\n        this.javacTrees = JavacTrees.instance(processingEnv);\r\n        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\r\n        this.treeMaker = TreeMaker.instance(context);\r\n    }\r\n\r\n\r\n    @Override\r\n    public SourceVersion getSupportedSourceVersion() {\r\n        return SourceVersion.latest();\r\n    }\r\n\r\n    @Override\r\n    public Set<String> getSupportedAnnotationTypes() {\r\n        HashSet<String> set = new HashSet<>();\r\n        set.add(TrisceliVersion.class.getName()); // 支持解析的注解\r\n        return set;\r\n    }\r\n\r\n    @Override\r\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\r\n        for (TypeElement t : annotations) {\r\n            for (Element e : roundEnv.getElementsAnnotatedWith(t)) { // 获取到给定注解的element（element可以是一个类、方法、包等）\r\n                // JCVariableDecl为字段/变量定义语法树节点\r\n                JCTree.JCVariableDecl jcv = (JCTree.JCVariableDecl) javacTrees.getTree(e);\r\n                String varType = jcv.vartype.type.toString();\r\n                if (!\\\"java.lang.String\\\".equals(varType)) { // 限定变量类型必须是String类型，否则抛异常\r\n                    printErrorMessage(e, \\\"Type '\\\" + varType + \\\"'\\\" + \\\" is not support.\\\");\r\n                }\r\n                jcv.init = treeMaker.Literal(getVersion()); // 给这个字段赋值，也就是getVersion的返回值\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 利用processingEnv内的Messager对象输出一些日志\r\n     *\r\n     * @param e element\r\n     * @param m error message\r\n     */\r\n    private void printErrorMessage(Element e, String m) {\r\n        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, m, e);\r\n    }\r\n\r\n    private String getVersion() {\r\n        /**\r\n         * 获取version，这里省略掉复杂的代码，直接返回固定值\r\n         */\r\n        return \\\"v1.0.1\\\";\r\n    }\r\n```\r\n\r\n定义好的处理器需要`SPI机制`被发现，所以需要定义`META.services`：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8c7dbd730e4d4c8618f83866845ab8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 测试\r\n\r\n新建测试模块，引入刚才写好的代码包：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1adb76311cbd41c4b75856706fea72ff~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n这是Test类：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa91276e490d458591b5f68f30aa94af~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n现在我们只需要让gradle build一下，新得到的字节码中该字段就有值了：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dda42b6a8e0e4153963a40e1afa566b9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n这只是**插入式注解处理器**功能的冰山一角，既然它可以通过修改抽象语法树来控制生成的字节码，那么自然就有人能充分利用其特性来实现一些很酷的插件，比如lombok，我们再也不用写诸如set/get这种模板式的代码了，只要我们足够有创意，就可以让基于这一套API实现的插件在功能上有很大的发挥空间。"
    },
    {
        "article_id": "7147897102398390308",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe509227efe40dab4ed1c041b95fb24~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vite项目屏幕适配的两种方案，超详细！",
        "preview": "Vite项目屏幕适配的两种方案：1、基于px转rem的适配方案。 2、基于scale等比缩放的适配方案。",
        "author": "潇潇夜雨丶",
        "view_count": 25876,
        "collect_count": 923,
        "comment_count": 71,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1b96055bfc12bf245c76610299ce0cc0~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: vue-pro\r\nhighlight: a11y-light\r\n---\r\n## 前言\r\n最近项目组小美同学貌似遇到了一个棘手的问题，总是一副闷闷不乐的样子。\r\n\r\n本着都是一个项目组，应该互相帮助、共用解决问题的用意，我向小美发出了信息。\r\n\r\n我：“看你最近一直不怎么开心，遇到什么问题了吗？”\r\n\r\n小美：“最近一直在查阅vue3项目屏幕适配的资料，发现网上资料都是vue2+webpack有关的，不知道如何适配vite项目？o(╥﹏╥)o”\r\n\r\n我：“OK，交给哥了，我来帮你摆平！”\r\n\r\n小美：“❤( ´･ᴗ･` )❤”\r\n\r\n> 觉得文章不错、或对自己开发有所帮助，欢迎点赞收藏！❤❤❤\r\n\r\n## 基于rem的适配方案\r\n### rem是什么？\r\nrem是指相对于根元素的字体大小的单位，在日常开发过程中我们通常把根元素（html/body）的字体设置为10px,方便于我们计算（此时子元素的1rem就相当于10px）。\r\n### 适用场景\r\n不固定宽高比的Web应用，适用于绝大部分业务场景\r\n![px2rem.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dff5429951ce4068bc19ae37bdbcc6af~tplv-k3u1fbpfcp-watermark.image?)\r\n### 项目实战\r\n1. 安装依赖\r\n```js\r\nnpm i postcss-pxtorem autoprefixer amfe-flexible --save-dev\r\n```\r\n>postcss-pxtorem 是PostCSS的插件，用于将像素单元生成rem单位</br>\r\nautoprefixer 浏览器前缀处理插件</br>\r\namfe-flexible 可伸缩布局方案 替代了原先的`lib-flexible` 选用了当前众多浏览器兼容的`viewport`\r\n2. 项目根目录创建 `postcss.config.js` 文件\r\n![QQ图片20220927110819.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc6ec08fb25b44aeaa9254e725389169~tplv-k3u1fbpfcp-watermark.image?)\r\n```js\r\nmodule.exports = {\r\n\\tplugins: {\r\n\\t\\tautoprefixer: {\r\n\\t\\t\\toverrideBrowserslist: [\r\n\\t\\t\\t\\t\\\"Android 4.1\\\",\r\n\\t\\t\\t\\t\\\"iOS 7.1\\\",\r\n\\t\\t\\t\\t\\\"Chrome > 31\\\",\r\n\\t\\t\\t\\t\\\"ff > 31\\\",\r\n\\t\\t\\t\\t\\\"ie >= 8\\\",\r\n\\t\\t\\t\\t\\\"last 10 versions\\\", // 所有主流浏览器最近10版本用\r\n\\t\\t\\t],\r\n\\t\\t\\tgrid: true,\r\n\\t\\t},\r\n\\t\\t\\\"postcss-pxtorem\\\": {\r\n\\t\\t\\trootValue: 192, // 设计稿宽度的1/ 10 例如设计稿按照 1920设计 此处就为192\r\n\\t\\t\\tpropList: [\\\"*\\\", \\\"!border\\\"], // 除 border 外所有px 转 rem\r\n\\t\\t\\tselectorBlackList: [\\\".el-\\\"], // 过滤掉.el-开头的class，不进行rem转换\r\n\\t\\t},\r\n\\t},\r\n};\r\n```\r\n3. `main.ts/js` 文件中导入依赖\r\n```js\r\nimport \\\"amfe-flexible/index.js\\\";\r\n```\r\n4. 项目重启\r\n## 基于scale的适配方案\r\n在CSS3中，我们可以使用transform属性的scale()方法来实现元素的缩放效果。缩放，指的是“缩小”和“放大”的意思。\r\n- transform: scaleX(x); / 沿x轴方向缩放/\r\n- transform: scaleY(y); / 沿y轴方向缩放/\r\n- transform: scale(); / 同时沿x轴和y轴缩放/\r\n\r\n### 适用场景\r\n固定宽高比的Web应用，如大屏或者固定窗口业务应用\r\n![scale.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9efd3e99a284af9b561a9ee7c623498~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 项目实战\r\n1. 新建`resize.ts/js`文件\r\n![QQ图片20220927111729.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679548a8cd874f47bd8d6ae5a777e6ad~tplv-k3u1fbpfcp-watermark.image?)\r\n```js\r\nimport { ref } from \\\"vue\\\";\r\n\r\nexport default function windowResize() {\r\n\\t// * 指向最外层容器\r\n\\tconst screenRef = ref();\r\n\\t// * 定时函数\r\n\\tconst timer = ref(0);\r\n\\t// * 默认缩放值\r\n\\tconst scale = {\r\n\\t\\twidth: \\\"1\\\",\r\n\\t\\theight: \\\"1\\\",\r\n\\t};\r\n    \r\n\\t// * 设计稿尺寸（px）\r\n\\tconst baseWidth = 1920;\r\n\\tconst baseHeight = 1080;\r\n\r\n\\t// * 需保持的比例（默认1.77778）\r\n\\tconst baseProportion = parseFloat((baseWidth / baseHeight).toFixed(5));\r\n\\tconst calcRate = () => {\r\n\\t\\t// 当前宽高比\r\n\\t\\tconst currentRate = parseFloat(\r\n\\t\\t\\t(window.innerWidth / window.innerHeight).toFixed(5)\r\n\\t\\t);\r\n\\t\\tif (screenRef.value) {\r\n\\t\\t\\tif (currentRate > baseProportion) {\r\n\\t\\t\\t\\t// 表示更宽\r\n\\t\\t\\t\\tscale.width = (\r\n\\t\\t\\t\\t\\t(window.innerHeight * baseProportion) /\r\n\\t\\t\\t\\t\\tbaseWidth\r\n\\t\\t\\t\\t).toFixed(5);\r\n\\t\\t\\t\\tscale.height = (window.innerHeight / baseHeight).toFixed(5);\r\n\\t\\t\\t\\tscreenRef.value.style.transform = `scale(${scale.width}, ${scale.height})`;\r\n\\t\\t\\t} else {\r\n\\t\\t\\t\\t// 表示更高\r\n\\t\\t\\t\\tscale.height = (\r\n\\t\\t\\t\\t\\twindow.innerWidth /\r\n\\t\\t\\t\\t\\tbaseProportion /\r\n\\t\\t\\t\\t\\tbaseHeight\r\n\\t\\t\\t\\t).toFixed(5);\r\n\\t\\t\\t\\tscale.width = (window.innerWidth / baseWidth).toFixed(5);\r\n\\t\\t\\t\\tscreenRef.value.style.transform = `scale(${scale.width}, ${scale.height})`;\r\n\\t\\t\\t}\r\n\\t\\t}\r\n\\t};\r\n\r\n\\tconst resize = () => {\r\n\\t\\tclearTimeout(timer.value);\r\n\\t\\ttimer.value = window.setTimeout(() => {\r\n\\t\\t\\tcalcRate();\r\n\\t\\t}, 200);\r\n\\t};\r\n\r\n\\t// 改变窗口大小重新绘制\r\n\\tconst windowDraw = () => {\r\n\\t\\twindow.addEventListener(\\\"resize\\\", resize);\r\n\\t};\r\n\r\n\\t// 改变窗口大小重新绘制\r\n\\tconst unWindowDraw = () => {\r\n\\t\\twindow.removeEventListener(\\\"resize\\\", resize);\r\n\\t};\r\n\r\n\\treturn {\r\n\\t\\tscreenRef,\r\n\\t\\tcalcRate,\r\n\\t\\twindowDraw,\r\n\\t\\tunWindowDraw,\r\n\\t};\r\n}\r\n\r\n```\r\n2. 相关界面引入`resize.ts/js`\r\n![QQ图片20220927112000.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/464430e5a9fc458a924482d0d3d7bb9f~tplv-k3u1fbpfcp-watermark.image?)\r\n```js\r\n<template>\r\n    <div class=\\\"screen-container\\\">\r\n        <div class=\\\"screen-content\\\" ref=\\\"screenRef\\\">\r\n            <span class=\\\"screen-title\\\">基于scale的适配方案</span>\r\n            <img class=\\\"screen-img\\\" src=\\\"https://img2.baidu.com/it/u=1297807229,3828610143&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=281\\\" alt=\\\"\\\">\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script setup lang=\\\"ts\\\">\r\nimport windowResize from '../../utils/resize';\r\nimport {onMounted, onUnmounted} from 'vue';\r\n\r\nconst { screenRef, calcRate, windowDraw, unWindowDraw } = windowResize()\r\n\r\nonMounted(() => {\r\n    // 监听浏览器窗口尺寸变化\r\n    windowDraw()\r\n    calcRate()\r\n})\r\n\r\nonUnmounted(() => {\r\n    unWindowDraw();\r\n})\r\n\r\n</script>\r\n\r\n<style lang=\\\"scss\\\" scoped>\r\n.screen-container {\r\n    height: 100%;\r\n    background-color: lightcyan;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n\r\n    .screen-content {\r\n        width: 1920px;\r\n        height: 1080px;\r\n        background-color: #fff;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        flex-direction: column;\r\n\r\n        .screen-title {\r\n            font-size: 32px;\r\n        }\r\n\r\n        .screen-img {\r\n            margin-top: 20px;\r\n        }\r\n    }\r\n}\r\n</style>\r\n```\r\n## 写在最后\r\n\r\n推荐两个作者参与的开源项目，如果项目有帮助到你，欢迎star！\r\n\r\n一个简单的基于Vue3、TS、Vite、qiankun技术栈的`后台管理项目`：[https://www.xkxk.tech](https://www.xkxk.tech)\r\n\r\n一个基于Vue3、Vite的`炫酷大屏项目`：[https://screen.xkxk.tech](https://screen.xkxk.tech)"
    },
    {
        "article_id": "7188706213356372026",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39cbc26f991645228319d80266b5dfef~tplv-k3u1fbpfcp-watermark.image?",
        "title": "你知道从Java8到Java19有哪些变化？",
        "preview": "前言 Java 是一种流行的编程语言，在其整个历史中经历了许多变化和更新。自 1995 年发布以来，Java 语言已经发展到包括范围广泛的新特性和改进。在本文中，我们将了解从 Java 8 开始的每个",
        "author": "JAVA旭阳",
        "view_count": 1175,
        "collect_count": 24,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e7ff7e07aaf9c553f05da5741e7badfa~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: cyanosis\r\n---\r\n## 前言\r\n\r\nJava 是一种流行的编程语言，在其整个历史中经历了许多变化和更新。在本文中，我们将了解从 Java 8 开始的每个 Java 版本中引入的一些关键特性。\r\n\r\n## Java 8\r\n\r\n-   **Lambda 表达式**：Java 8 引入了一个称为 lambda 表达式的新功能，它允许在 Java 中进行函数式编程。此功能使开发人员能够使用匿名函数并将它们作为参数传递给方法。\r\n-   **Stream API**：Java 8 还引入了 Stream API，它允许开发人员以函数式的方式对数据集合执行操作。Stream API 允许以并行且高效的方式对大型数据集执行过滤、映射和归约等操作。\r\n-   **日期和时间 API**：Java 8 还引入了一个新的日期和时间 API，它提供了一种更健壮和可读的方式来处理 Java 中的日期和时间操作。\r\n-   **接口中的默认方法和静态方法**：Java 8 允许接口具有默认方法和静态方法。它允许在不破坏现有实现的情况下将新功能添加到现有接口。\r\n\r\n## Java 9\r\n\r\n-   **模块化系统**：Java 9 引入了 Java 平台模块系统 (JPMS)，它允许 Java 开发人员将 JDK 划分为一组可以单独管理的模块。\r\n-   **JShell**：Java 9 引入了 JShell，这是一个交互式命令行工具，允许开发人员快速测试和运行 Java 代码片段。\r\n-   **改进Prcoess API**：Java 9 引入了改进了Process API，使开发人员可以更轻松地处理和管理操作系统进程。\r\n-   **改进的 HTTP/2 客户端**：Java 9 引入了改进的 HTTP/2 客户端，它比以前的 HTTP 客户端更快、更高效。\r\n\r\n## Java 10\r\n\r\n-   **局部变量类型推断var**：Java 10 引入了局部变量类型推断，它允许开发人员使用“var”关键字而不是指定局部变量的类型。\r\n\r\n```\r\nvar a = 20；你\r\n```\r\n\r\n-   **额外的 Unicode 语言标签扩展**：Java 10 向现有的 Locale 类添加了额外的 Unicode 语言标签扩展。\r\n-   **垃圾收集器接口**：Java 10 引入了垃圾收集器接口，它允许开发人员通过 Java 虚拟机 (JVM) 创建和使用自定义垃圾收集器。\r\n-   **额外的根证书**：Java 10 包含额外的根证书，以提高基于 Java 的应用程序的安全性。\r\n\r\n## Java 11\r\n\r\n-   **Lambda 参数的局部变量语法**：Java 11 引入了一种新的 lambda 参数语法，允许开发人员将 var 关键字用于 lambda 参数，类似于它用于局部变量的方式。\r\n-   **HttpClient API**：Java 11 引入了一个新的 HttpClient API，允许开发人员更轻松、更高效地处理 HTTP 请求和响应。\r\n-   **String 和 Lining API 改进**：Java 11 在 String 类中引入了几个新方法，例如 ` strip()  `和 `repeat()`，在 Lining 类中引入了一些新方法，例如 `lines()` 和 `isBlank()`。\r\n\r\n## Java 12\r\n\r\n-   `Switch` **表达式**：Java 12 引入了 switch 表达式，它允许开发人员将 switch 语句用作表达式，而不仅仅是语句。\r\n\r\n```\r\nString s = switch (score){\r\n            case 'A' -> \\\"优秀\\\";\r\n            case 'B' -> \\\"良好\\\";\r\n            case 'C' -> \\\"中\\\";\r\n            case 'D' -> \\\"及格\\\";\r\n            case 'F' -> \\\"不及格\\\";\r\n            default -> \\\"成绩输入错误\\\";\r\n        };\r\n```\r\n\r\n-   **文本块**：Java 12 引入了文本块，它允许开发人员以更易读和更方便的方式编写多行字符串文字。\r\n\r\n```\r\nSystem.out.println(\\\"\\\"\\\"\r\n    Hello,\r\n    multiline\r\n    text blocks!\r\n    \\\"\\\"\\\");\r\n\r\nString json = \\\"\\\"\\\"\r\n    {\r\n        greeting: \\\"hello\\\",\r\n        audience: \\\"text blocks\\\",\r\n        punctuation: \\\"!\\\"\r\n    }\r\n    \\\"\\\"\\\";\r\n```\r\n\r\n-   **提高 JVM Constants API 的性能**：Java 12 改进了 JVM Constants API 的性能，这使开发人员可以更有效地访问类文件常量。\r\n-   **Shenandoah垃圾收集器**：一种低停顿时间的垃圾收集器，Java 12 引入了 Shenandoah，这是一种新的垃圾收集器，它承诺比其他现有的垃圾收集器具有更短的停顿时间。\r\n\r\n## Java 13\r\n\r\n-   **文本块（预览功能）** ：Java 13 改进了 Java 12 中引入的文本块功能，使其更稳定、更易于使用。\r\n-   `Switch` **表达式（预览功能）** ：Java 13 还改进了 Java 12 中引入的`switch`表达式功能，使其更具表现力和功能。\r\n-   **旧版** ` Socket API  `**的重新实现**：Java 13 重新实现了旧版 `Socket API`，它提供了一种更现代、更高效的 Java 套接字处理方式。\r\n-   **新的字符串方法**：Java 13 增加了几个新的字符串方法，例如 `indent()` 和 `transform()`，允许开发人员以更方便的方式操作和格式化字符串。\r\n-   **改进的错误处理**：Java 13 改进了 JVM 中处理错误的方式，提供有关错误原因的更多详细信息，并使诊断和修复问题变得更加容易。\r\n\r\n如您所见，Java 的每个版本都为该语言带来了新的特性和改进。Java 8 中添加的 Lambda 表达式和 Stream API 改变了开发人员编写代码和执行数据操作的方式。Java 9 中 JPMS 的引入和 Java 11 中 HttpClient API 的引入，提高了基于 Java 的应用程序的性能和安全性。Java 12 和 13 中的 Switch Expressions 和 Text Blocks 等预览功能提供了更具表现力和更强大的代码编写方式。\r\n\r\n## Java 14\r\n\r\n-   `instanceof` **的模式匹配**：Java 14 为 instanceof 运算符引入了模式匹配，它允许开发人员将对象与模式匹配并提取其组件，类似于在函数式编程语言中的实现方式。\r\n\r\n```\r\nif (obj instanceof String s) {\r\n    // 如果类型匹配 直接使用\r\n} else {\r\n    // 如果类型不匹配则不能直接使用\r\n}\r\n```\r\n\r\n-   `Records`：Java 14 引入了记录，它允许开发人员以更简洁和表达的方式声明类，类似于其他语言中的数据类。\r\n\r\n```\r\n// 直接这样定义类\r\nrecord Point(int x, int y) { }\r\n```\r\n\r\n-   **有用的** `NullPointerExceptions`：Java 14 引入了一项新功能，它在 NullPointerExceptions 中提供了更多信息，从而更容易识别异常原因并修复问题。\r\n-   `Switch`**表达式（标准特性）** ：Java 14 将 Java 12 中引入的 Switch Expressions 特性作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n-   **文本块（标准特性）** ：Java 14 也将 Java 12 中引入的文本块特性作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n\r\n## Java 15\r\n\r\n-   **密封类**：Java 15 引入了密封类，允许开发人员指定哪些类可以扩展特定类或实现特定接口。\r\n-   **隐藏类**：Java 15 引入了隐藏类，这些类不是公共 API 的一部分，只能由定义它们的类使用。\r\n-   `instanceof` **的模式匹配（预览版）** ：Java 15 改进了 Java 14 中引入的 instanceof 特性的模式匹配，增加了对在单个语句中匹配多个模式的支持。\r\n-   `Foreign-Memory Access API`：Java 15 引入了`  Foreign-Memory Access API `，它允许开发人员以安全高效的方式访问和操作 Java 堆之外的内存。\r\n\r\n## Java 16\r\n\r\n-   `Records` **（标准功能）** ：Java 16 将 Java 14 中引入的 Records 功能作为标准功能，这意味着它现在是 Java 语言的永久组成部分。\r\n-   ****`instanceof` **的模式匹配（标准特性）** ：Java 16 将 Java 14 中引入的 `instanceof` 特性的模式匹配作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n-   打包工具：Java 16 引入了打包工具，它允许开发人员将他们的 Java 应用程序打包为不同平台（例如 Windows、Linux 和 macOS）的本机可执行文件。\r\n-   `Concurrent Thread-Stack Processing`：Java 16 引入了一个新特性，允许 JVM 并发处理线程栈，从而提高了性能。\r\n\r\n## Java 17\r\n\r\n-   `Concise Method Bodies` **（预览功能）** ：Java 17 引入了“`Concise Method Bodies`”功能，它允许开发人员使用更简洁和可读性更高的语法来定义方法。\r\n-   **改进的弃用警告**：Java 17 改进了弃用警告功能，现在提供有关弃用元素以及如何替换它们的更详细信息。\r\n-   `Hidden Classes` **（标准特性）** ：Java 17 将 Java 15 中引入的 Hidden Classes 特性作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n-   ****`Foreign-Memory Access API` **（标准功能）** ：Java 17 将 Java 15 中引入的 Foreign-Memory Access API 功能作为标准功能，这意味着它现在是 Java 语言的永久组成部分。\r\n\r\n## Java 18\r\n\r\n-   `Records` **（预览功能）** ：Java 18 改进了 Java 14 中引入的`Records`功能，增加了对更复杂的记录类型的支持，并在记录的使用方式上提供了更大的灵活性。\r\n-   `Concise Method Bodies` **（标准特性）** ：Java 18 将 Java 17 中引入的 Concise Method Bodies 特性作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n-   **改进的类型推断**：Java 18 改进了类型推断功能，现在允许开发人员使用更复杂的类型并执行更高级的类型检查。\r\n-   **改进的安全性**：Java 18 通过引入增强的类文件验证和改进的访问控制等新功能，提高了基于 Java 的应用程序的安全性。\r\n\r\n## Java 19\r\n\r\n-   `Records` **（标准特性）** ：Java 19 将 Java 14 中引入的 Records 特性作为标准特性，这意味着它现在是 Java 语言的永久组成部分。\r\n-   **改进的垃圾收集**：Java 19 通过引入新的算法和策略来提高 JVM 的性能和效率，从而改进了垃圾收集功能。\r\n-   **改进的错误处理**：Java 19 通过提供有关错误的更多详细信息并使诊断和修复问题变得更加容易，改进了错误处理功能。\r\n-   **改进的并发性**：Java 19 通过引入新的类和方法改进了并发特性，使开发人员更容易编写多线程代码。\r\n-   **改进的安全性**：Java 19 通过引入增强的类文件验证和改进的访问控制等新功能，提高了基于 Java 的应用程序的安全性。\r\n\r\n## 总结\r\n\r\n上面罗列了Java8 到Java19新增的功能特性，但并不详尽，每个版本的 Java 中还引入了其他功能和改进。处列出的某些功能在某些版本中可能处于“预览”或实验状态，但该列表包括它们成为标准功能的时间。还值得注意的是，甲骨文宣布他们将每 6 个月发布一次新版本的 Java，因此该语言的更新将会更加频繁。\r\n> 欢迎关注个人公众号【JAVA旭阳】交流学习\r\n"
    },
    {
        "article_id": "7169595614743920654",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a827ff891c1436b904f2c81c5ad87c9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为了让线上代码可追溯,  我开发了这个vite插件",
        "preview": "为了让线上代码可追溯, 我开发了这个vite插件, 让想在控制台输出一下前端代码的一些构建信息， 比如打包时间、打包的人, 代码分支、commit是那个，方便在控制台追溯",
        "author": "浏览器API调用工程师",
        "view_count": 4347,
        "collect_count": 70,
        "comment_count": 19,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3a7164e8729a54bf8a5e51a7c2bb6157~300x300.image",
        "category": "前端",
        "content": "`人生的第一个vite插件`\r\n# 前言\r\n**想在控制台输出一下前端代码的一些构建信息， 比如打包时间、打包的人, 代码分支、commit是那个，方便在控制台追溯。**\r\n\r\n\r\n感兴趣的可以我9月写的这篇 https://juejin.cn/post/7140516996428333070, 当时把这段逻辑集成到了代码了里。\r\n\r\n后来同事的其他项目觉得这个不错，也准备整一个，那总不能复制一份？\r\n\r\n**于是我想开发一个`vite的插件`让同事们可以直接引用。**\r\n\r\n`这是我写的第一个vite插件`大佬们嘴下留情\r\n\r\n# 背景\r\n 遇到的问题\r\n ## 1、场景一\r\n \r\n 前端多人协同开发的情况下，比方测试站， 你发的代码， 貌似被人覆盖了，测试说不对啊， 你很烦， 这时你问: 谁发过吗， 没人说话， **倘若控制台可以追溯 谁 在几点 发布了什么 commit信息等等...那就不用迷茫了**。\r\n \r\n ## 2、打印出来可以帮助排查问题\r\n 开发说: 代码发了，  客户说： 我这边还是不行。\r\n \r\n 开发说： 刷新试试， 客户说: 我都刷了好几次了还是不行。\r\n \r\n 开发陷入了沉思\r\n \r\n 这是经常会有的对话\r\n \r\n 倘若控制台有打包信息，**倘若控制台可以追溯 谁 在几点 发布了什么 commit信息等等...那就可以确定代码是发成功了**。\r\n \r\n \r\n # 插件介绍\r\n \r\n[ vite-plugin-aliyun-flow](https://www.npmjs.com/package/vite-plugin-aliyun-flow) 流水线打印构建信息插件, 可以准确的在前端控制台看到当前运行代码的构建人、构建时间、分支、最新的COMMIT信息等， 方便追溯线上代码。\r\n\r\n\r\n**插件效果**\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef4a492211a844179597b2147005896d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n# 使用\r\n阿里云效流水线flow\r\n\r\n\r\n安装\r\n\r\nhttps://www.npmjs.com/package/vite-plugin-aliyun-flow\r\n\r\n```\r\nnpm i vite-plugin-aliyun-flow --D\r\n```\r\n\r\n在vite.config.js/ts中配置\r\n\r\n```\r\nimport vitePluginAliFlow from \\\"vite-plugin-aliyun-flow\\\";\r\n\r\n// plugins\r\nplugins: [\r\n    // 这里只需配置项目名称即可，其他信息都会从流水线自动抓取\r\n    vitePluginAliFlow({ projectName: '绩效'}),\r\n    ...\r\n]\r\n```\r\n\r\n### [](https://www.npmjs.com/package/vite-plugin-aliyun-flow#%E6%8F%92%E4%BB%B6%E5%8F%82%E6%95%B0)插件参数\r\n\r\n目前版本只有一个项目名称配置\r\n\r\n```\r\ninterface options {\r\n    projectName?: string; // 项目名称 没有配置的话会取 package.json里的name字段\r\n}\r\n```\r\n\r\n\r\n# 实现思路\r\n\r\n\r\n\r\n## 确定输出的信息列表\r\n\r\n### 1、打包时间 buildTime\r\n\r\n我的思路是vite插件执行的时候获取当前时间就可以， 就是打包时间。\r\n\r\n### 2、构建时nodejs的版本\r\n\r\n这个我们用的是阿里云流水线， 我在想应该可以在流水线的运行时，全局变量获取到。\r\n\r\n### 3、分支信息\r\n\r\n同上\r\n\r\n### 4、commit信息\r\n\r\n同上\r\n\r\n### 5、流水线执行人\r\n\r\n同上\r\n\r\n## 从流水线运行时, 获取环境变量里用的到的数据\r\n\r\n\r\n\r\n### 1、打印一下 process.env 查看有哪儿些信息\r\n\r\n信息量有点大呀\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db49a0ca9bac42bab97d92e926dad4d8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n或者查看阿里云文档也可以 [help.aliyun.com/document_de…](https://link.juejin.cn/?target=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F153688.html \\\"https://help.aliyun.com/document_detail/153688.html\\\")\r\n\r\n### 2、 找寻我们需要的子段\r\n```\r\nCI_RUNTIME_VERSION // 构建时nodejs的版本\r\nEXECUTOR_NAME // 流水线执行人\r\nCI_COMMIT_REF_NAME // 分支名\r\nCI_COMMIT_TITLE // commit信息中文\r\nCI_COMMIT_ID // commit哈希\r\n```\r\n\r\n## 写vite插件\r\nvite插件文档 https://cn.vitejs.dev/guide/api-plugin.html\r\n\r\n\r\n我这个用一句话概括就是在打包的时候拿到了我要的信息，然后组装成了js字符串，插到了`index.html`的`script`标签里，运行中的时候可以执行就行了。\r\n\r\n### 1、代码中获取流水线环境变量\r\nprocess.env 为什么可以获取，因为打包的时候是用nodejs打包， process.env就是获取执行时环境变量的\r\n```\r\nconst env = process.env\r\n```\r\n\r\n### 2、创建输出的js文件\r\n这边单独写了个js文件, 写这些个输出\r\n\r\n内容如下, 并且通过style给console加了颜色 背景 字体大小\r\n\r\n最后通过插件读取这个js字符串, 和变量拼在一起。\r\n\r\n```\r\n// 1. 将css样式内容放入数\r\nconst styles = [\r\n    'color: white',\r\n    'background: green',\r\n    'font-size: 19px',\r\n    'border: 1px solid #fff',\r\n    'text-shadow: 2px 2px black',\r\n    'padding: 5px',\r\n].join(';');\r\n\r\nconsole.log(`%c${__APP_INFO__.projectName}, 当前版本: V${__APP_INFO__.pkg.version}`, styles);\r\n\r\nconsole.log(\r\n    `%c打包时间: ${__APP_INFO__.lastBuildTime}`,\r\n    styles,\r\n);\r\nconsole.log(__GLOBAL_ENV_, __GLOBAL_ENV_);\r\n\r\nconsole.log(`%c构建Node.js版本: ${__GLOBAL_ENV_.CI_RUNTIME_VERSION || '-'}`, styles);\r\n\r\nconsole.log(`%c流水线执行人: ${__GLOBAL_ENV_.EXECUTOR_NAME || '-'}`, styles);\r\n\r\nconsole.log(`%c分支: ${__GLOBAL_ENV_.CI_COMMIT_REF_NAME || '-'}`, styles);\r\nconsole.log(\r\n    `%cCOMMIT信息: ${__GLOBAL_ENV_.CI_COMMIT_TITLE || '-'} ${\r\n        __GLOBAL_ENV_.CI_COMMIT_ID || '-'\r\n    }`,\r\n    styles,\r\n);\r\n```\r\n### 3、拿到需要的信息, 拼接js字符串\r\n\r\nextStr 就是上一步的js字符串\r\n\r\n\r\n而后通过 `htmlStr` 把 `__APP_INFO__`、`__GLOBAL_ENV_` （这两是咱们要的信息）和 extStr 组装了起来。\r\n\r\n\r\n\r\n```js\r\n// 获取环境变量\r\nconst env = process.env\r\n// 获取当前项目包信息\r\nconst pkg: any = fs.readFileSync(process.cwd() + '/package.json', 'utf-8')\r\n// 获取输出的js文件\r\nconst extStr: string = fs.readFileSync(path.join(__dirname, '../src/external.js'), 'utf-8')\r\n\r\nconst { name, version } = JSON.parse(pkg);\r\n// 项目名称、 版本号、打包时间\r\nconst __APP_INFO__ = {\r\n    projectName: options.projectName || name,\r\n    pkg: { name, version },\r\n    lastBuildTime: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n};\r\n// 把输出的变量一起拼接js字符串\r\nconst HtmlStr: string = `const __GLOBAL_ENV_ = ${JSON.stringify(env)};\r\nconst __APP_INFO__ = ${JSON.stringify(__APP_INFO__)};\r\n\\\r\n ${extStr}`\r\n```\r\n\r\n### 4、输出到index.html的body下面\r\n**transformIndexHtml vite暴露的方法，可以修改输出的index.html**\r\n\r\n如下就是 把HtmlStr放在script标签里输出到html的body下\r\n```js\r\n\r\ntransformIndexHtml(html): HtmlTagDescriptor[] {\r\n    return [\r\n        {\r\n            tag: 'script',\r\n            attrs: { defer: true },\r\n            children: HtmlStr,\r\n            injectTo: 'body'\r\n        },\r\n    ]\r\n}\r\n```\r\n### 完整代码\r\n\r\n```js\r\nimport type { Plugin, HtmlTagDescriptor } from 'vite';\r\nimport dayjs from 'dayjs';\r\nimport path from 'path';\r\nimport fs from 'fs';\r\n\r\ninterface AliflowOptions {\r\n    projectName?: string\r\n}\r\n\r\nexport default function Aliflow(options: AliflowOptions): Plugin {\r\n    // 流水线环境变量\r\n    const env = process.env\r\n    // 当前项目包信息\r\n    const pkg: any = fs.readFileSync(process.cwd() + '/package.json', 'utf-8')\r\n    // 输出的js\r\n    const extStr: string = fs.readFileSync(path.join(__dirname, '../src/external.js'), 'utf-8')\r\n\r\n    const { name, version } = JSON.parse(pkg);\r\n    // 项目名称、包版本、打包时间等\r\n    const __APP_INFO__ = {\r\n        projectName: options.projectName || name,\r\n        pkg: { name, version },\r\n        lastBuildTime: dayjs().format('YYYY-MM-DD HH:mm:ss'),\r\n    };\r\n    // 拼接输出的js字符串 最后查到script标签里\r\n    const HtmlStr: string = `const __GLOBAL_ENV_ = ${JSON.stringify(env)};\r\n    const __APP_INFO__ = ${JSON.stringify(__APP_INFO__)};\r\n    \\\r\n ${extStr}`\r\n\r\n    return {\r\n        name: 'vite-plugin-aliuyun-flow',\r\n        apply: 'build',\r\n        transformIndexHtml(html): HtmlTagDescriptor[] {\r\n            // 将htmlStr插到body里\r\n            return [\r\n                {\r\n                    tag: 'script',\r\n                    attrs: { defer: true },\r\n                    children: HtmlStr,\r\n                    injectTo: 'body'\r\n                },\r\n            ]\r\n        }\r\n\r\n    };\r\n}\r\n```\r\n  \r\n\r\n# 代码\r\n\r\n已经开源至github\r\ngithub仓库地址 https://github.com/zhangbowy/vite-plugin-aliyun-flow\r\n\r\n\r\n# 总结\r\n\r\n以上我们通过写vite插件注入打包信息， 让线上项目控制台可以追溯构建信息， 更好的排查问题。\r\n\r\n"
    },
    {
        "article_id": "7159366401097433095",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5704bdbb4214a2885bcf0939685fc2c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "是时候用UnoCSS来美化你的组件了",
        "preview": "在日常的开发中，为了避免重复造轮子，浪费开发的时间，我们经常会使用到第三方组件库，如element plus、vant-ui等知名组件库，而在一些开发中往往为了项目的整体美观性",
        "author": "八岁小孩学编程",
        "view_count": 6274,
        "collect_count": 83,
        "comment_count": 16,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/1783f69ba94992589a9c66002a4028c6~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\n---\r\n## 前言\r\n\r\n在日常的开发中，为了避免重复造轮子，浪费开发的时间，我们经常会使用到第三方组件库，如`element plus`、`vant-ui`等知名组件库，而在一些开发中往往为了项目的整体美观性，我们都不会直接拿着第三方组件库就直接拿来使用，会对其进行修改，使其更加贴合项目的整体UI风格，这个时候我们就可以将第三方组件库进行抽离，封装成`公共组件库`，而这种对第三方组件库进行封装的操作就被称为`二次封装`。\r\n\r\n### 二次封装的好处\r\n\r\n-   更遵守代码的简介之道✌️\r\n-   便于项目后期的维护🤪\r\n-   组件复用性更强🪄\r\n\r\n## Unocss介绍\r\n\r\n既然要对原第三方组件库进行封装，就难免对其`样式`进行修改，修改css往往是最让人头疼的(起码对我来说是这样的🥹)，这时候我看见了`antfu`老师的[重新构想原子化CSS](https://antfu.me/posts/reimagine-atomic-css-zh),强烈建议先将这篇文章阅读后再看下去，会让你对`原子化CSS`有着更深的认识,这里用大神的话来概括一下就是:\r\n\r\n> 原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。\r\n\r\n而Unocss便是antfu老师做出的`具有高性能且极具灵活性的即时原子化 CSS 引擎。`至于为什么是引擎而不是一个CSS框架，是因为Unocss并**没有提供任何的核心工具类**，所有功能都可以通过`预设和内联配置`来提供\r\n\r\n### Unocss的优势\r\n\r\n-   灵活性(属性化模式、上万个`纯CSS图标`、无需担心样式冲突)🪄\r\n-   样式复用性强🐼\r\n-   不用想类名！(这点对于起名困难的人来说帮助太大了)🤣\r\n\r\n既然`二次封装`和`Unocss`都能够大大提高开发效率，让大家心情愉悦，那么接下来我们便试一试让这两件事情合在一起的样子，这里便拿`element plus`的`loading加载组件`进行简单的二次封装，再用`Unocss`来进行美化\r\n\r\n## 二次封装的核心\r\n\r\n这里是使用的`vue3`的组件封装方法，与`vue2`的封装方法还是有些许区别的，关于`vue2`的封装方法请看[红尘老师的文章](https://juejin.cn/post/6943534547501858824#heading-4)\r\n\r\n### $attrs\r\n\r\n> 一个包含了组件所有透传 attributes 的对象。\r\n\r\n这是vue官方对`$attrs`下的定义，是指由父组件传入，且没有被子组件声明为 props 或是组件自定义事件的 attributes 和事件处理函数。比如在组件当中我们用`<div>`标签嵌套了一个`<button>`的时候，想要让`class`或者`v-on`的监听器这类的透传attribute能直接应用在内部的`<button>`上，这时候我们就可以采用`v-bind=\\\"$attrs\\\"`来实现\r\n\r\n### v-on监听器继承\r\n\r\n`vue3`当中直接删除了2里的`$listeners`事件监听器，现在直接将其功能融合到了`$attrs`中。例如写一个点击事件，在组件封装中，我们原子组件的点击，仍会触发父组件的onclick事件\r\n\r\n```\r\n  <!-- 子组件 -->\r\n<button>click me</button>\r\n  <!-- 父组件 -->\r\n<MyButton @click=\\\"onClick\\\" />\r\n```\r\n\r\n## 组件的封装\r\n\r\n### 项目初始化\r\n\r\n命令行输入:\r\n\r\n```\r\npnpm create vite element-plus-unocss --template vue\r\n```\r\n\r\n使用`vite+pnpm`快速初始化项目\r\n\r\n```\r\ncd element-plus-unocss\r\npnpm i\r\npnpm run dev\r\n```\r\n\r\n成功运行后，项目的初始化便完成了\r\n\r\n### 引入组件库\r\n\r\n我们要封装的组件是`element plus`，故在此引入：\r\n\r\n```\r\npnpm install element-plus\r\n```\r\n\r\n这里我们还是按照官方推荐的[自动导入](https://element-plus.org/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5)，这里就不多赘述了，直接附上了官网的链接，点击进行配置即可，接下来才是重点\r\n\r\n### 二次封装\r\n\r\n这里我们选择`loading`加载组件进行演示，在`components`中添加我们要封装的子组件`loading.vue`，直接复制官方的[链接例子](https://element-plus.org/zh-CN/component/loading.html)皆可(可以适当做一点删减)：\r\n\r\n```\r\n<template>\r\n  <el-button\r\n    v-loading.fullscreen.lock=\\\"fullscreenLoading\\\"\r\n    type=\\\"primary\\\"\r\n    @click=\\\"openFullScreen1\\\"\r\n  >\r\n    Click me\r\n  </el-button>\r\n</template>\r\n​\r\n<script lang=\\\"ts\\\" setup>\r\nimport { ref } from 'vue'\r\nimport { ElLoading } from 'element-plus'\r\n​\r\nconst fullscreenLoading = ref(false)\r\nconst openFullScreen1 = () => {\r\n  fullscreenLoading.value = true\r\n  setTimeout(() => {\r\n    fullscreenLoading.value = false\r\n  }, 2000)\r\n}\r\n</script>\r\n```\r\n\r\n这时候我们再创建`Myloading.vue`组件，再在其中进行引入，并对其代码进行修改:\r\n\r\n```\r\n<template>\r\n  <Loading\r\n    v-bind=\\\"$attrs\\\"\r\n    element-loading-text=\\\"正在努力加载~\\\"\r\n    element-loading-background=\\\"rgba(122, 122, 122, 0.8)\\\"\r\n  />\r\n</template>\r\n​\r\n<script setup>\r\nimport Loading from \\\"./loading.vue\\\";\r\n</script>\r\n<style>\r\n.el-loading-mask .el-loading-spinner .el-loading-text {\r\n  font-size: 20px;\r\n}\r\n</style>\r\n```\r\n\r\n运行结果如下：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abbe34f9a5c24859b081f3f3f8fd4937~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这时候便代表着我们组件的`二次封装`成功了\r\n\r\n## UnoCSS美化组件\r\n\r\n这个时候我们发现，似乎这个`click me`看上去死气沉沉的，完全没有让人点击的欲望，那么有什么方法可以让这个按钮给人一种呼之欲出，让人很想点击呢？这时候我们就可以请出我们的重量级人物`UnoCSS`了\r\n\r\n### 安装并引入UnoCss\r\n\r\n```\r\npnpm i -D unocss\r\n```\r\n\r\n对`vite.config.js`进行配置：\r\n\r\n```\r\nimport Unocss from 'unocss/vite'\r\n​\r\nexport default {\r\n  plugins: [\r\n    Unocss({ /* options */ }),\r\n  ],\r\n}\r\n```\r\n\r\n并将`UnoCSS`引入到`main.js`中：`import 'uno.css'`\r\n\r\n### 配置预设\r\n\r\n配置预设是我认为`UnoCSS`的一个重要优势，只需要几个简单的预设，就能在几分钟搭建出属于自己的`自定义框架`，，`属性化`的特点就是antfu老师的`Windi CSS`的特点之一了，在`UnoCSS`中也将这一特点给保留了下来。这里我们就安装`preset-attributify`和`unocss/preset-uno`:\r\n\r\n```\r\npnpm i -D @unocss/preset-attributify\r\npnpm i -D @unocss/preset-uno\r\n```\r\n\r\n修改后的`vite.config.js`：\r\n\r\n```\r\nimport { defineConfig } from 'vite'\r\nimport AutoImport from 'unplugin-auto-import/vite'\r\nimport Components from 'unplugin-vue-components/vite'\r\nimport { ElementPlusResolver } from 'unplugin-vue-components/resolvers'\r\nimport Unocss from '@unocss/vite'\r\nimport presetUno from '@unocss/preset-uno'\r\nimport presetAttributify from '@unocss/preset-attributify'\r\n\r\nimport vue from '@vitejs/plugin-vue'\r\nexport default defineConfig({\r\n    plugins: [vue(), AutoImport({\r\n            resolvers: [ElementPlusResolver()],\r\n        }),\r\n        Components({\r\n            resolvers: [ElementPlusResolver()],\r\n        }),\r\n        Unocss({\r\n            presets: [presetUno(), presetAttributify()]\r\n        })\r\n    ]\r\n})\r\n```\r\n\r\n此时我们便有了一个`默认预设+属性模式`的自定义框架了，之后写了一长串的css类后，就会直接按照`属性模式`进行分组，代码更加整洁，可读性大大加强：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b111aa26454efc861138a5ab1a27aa~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 修改组件的样式\r\n\r\n我们为了让按钮看上去更有点击的欲望，我们可以尝试给`click me`加上一个跳跃的动画，这时候我们打开`UnoCSS`的`playground`，发现官方的演示里面就有着反复跳跃的样式，我们直接cv一下，修改我们的子组件:\r\n\r\n```\r\n<div  class=\\\"\r\n      text-5xl\r\n      fw300\r\n      animate-bounce-alt\r\n      animate-count-infinite\r\n      animate-duration-1s\\\"\r\n    >\r\n      click me\r\n</div>\r\n```\r\n\r\n这时候我们感觉默认的按钮字体颜色似乎有些太深了，这时候我们再在父组件进行修改:\r\n\r\n```\r\n<Loading\r\n    element-loading-text=\\\"正在努力加载~\\\"\r\n    v-bind=\\\"$attrs\\\"\r\n    element-loading-background=\\\"rgba(122, 122, 122, 0.8)\\\"\r\n    class=\\\"text-lg \r\n           fw300 \r\n           m2 \r\n           op70\\\"\r\n  />\r\n```\r\n\r\n> 这里如果我们想要知道cv的到底是什么内容，我们可以下载一个UnoCSS插件，直接在vscode中搜索即可，安装后再放在上面就会显示出这个类源码，便于后续的开发\r\n\r\n好了，让我们来看看美化后的按钮的模样：\r\n\r\n![GIF 2022-10-22 23-10-45.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3a226a258e4eaeac829ce6d991f512~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n不停的跳动，是不是让人更有想要点击的欲望呢😂\r\n\r\n## 结语\r\n\r\n`UnoCSS`作为原子化CSS的新秀，让人眼前一亮，它吸取了前辈`taiwind CSS`的优势，融合了自己的`windiCSS`的特色，让它出奇的好用，尽管现在的它仍在测试版，但还是很推荐大家去尝试一下的，绝对会让你有种**什么？还可以这样**的感觉，还可以用`UnoCSS`来搭建一个属于你自己的组件库，这里贴一个自己的组件库项目，就是对UnoCSS的一次尝试:<https://github.com/isolcat/CatIsol-UI>,组件库`预览地址`：`https://catisol.js.org`(顺带一提，这个文档是`vitepress`搭建的，也是antfu老师的作品)\r\n\r\n结合本文所说的组件二次封装，相信你们也可以做出一个很有意思的项目的，期待有更多让人眼前一亮的项目出现，能给我这个菜狗开开眼😽\r\n"
    },
    {
        "article_id": "7153815682399322143",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3820929e254986a0ddf6c3af9ec590~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022 最受欢迎的 CSS 类名、ID 和选择器是什么",
        "preview": "与 2020 年和 2021 年一样，网络上最受欢迎的类名是 active，Font Awesome 的 fa，fa-* 前缀仍然排在第二和第三。",
        "author": "zkj",
        "view_count": 3115,
        "collect_count": 15,
        "comment_count": 16,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/ec3c3974733386dc8f9883779e1833b8~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: nico\r\n---\r\n持续创作，加速成长！这是我参与「掘金日新计划 · 10 月更文挑战」的第7天，[点击查看活动详情](https://juejin.cn/post/7147654075599978532 \\\"https://juejin.cn/post/7147654075599978532\\\")\r\n\r\n## 介绍\r\nCSS 是用于布局、格式化网页和其他媒体的语言。它和用于结构的 HTML 和用于行为的 JavaScript 是网络的三种主要语言。\r\n\r\n在过去的几年中，出现了一系列新的 CSS 功能。其中许多是从开发人员已经使用 JavaScript 或预处理器所做的事情中获得灵感的，而另一些则提供了几年前不可能完成的事情的方法。提供新功能是一回事，但开发人员是否真的在他们的生产网页和应用程序中使用它们？\r\n\r\n## 类名\r\n![](https://almanac.httparchive.org/static/images/2022/css/top-selector-classes.png)\r\n\r\n---\r\n与 2020 年和 2021 年一样，网络上最受欢迎的类名是 active，Font Awesome 的 fa，fa-* 前缀仍然排在第二和第三。\r\n\r\nwp-* 类名已经攀升至第四位，它们现在出现在 31% 的页面上，2021 年为 20%，这些在新的 WordPress 块编辑器中使用，还有诸如 has-large-font-size 的类名。\r\n\r\nclearfix 已经从前 20 名中消失了，现在只出现在 10% 的页面上，这非常清楚地表明基于浮动的布局正在从网络上消失。\r\n\r\n## ID\r\n![](https://almanac.httparchive.org/static/images/2022/css/top-selector-ids.png)\r\n\r\n---\r\ncontent 再次成为最流行的 ID 名称，其次是 footer 和 header。以 fb_ 开头的 ID 表示使用 Facebook 小部件。\r\n\r\n2021，7% 的页面上出现了以 rc- 开头的 ID，表明使用了谷歌的 reCAPTCHA 系统，尽管被 Facebook 的 ID 挤出前十位，但仍然以同样的频率出现。\r\n\r\n## 伪类\r\n![](https://almanac.httparchive.org/static/images/2022/css/pseudo-classes.png)\r\n\r\n---\r\n:hover、:focus 和 :active 用户操作伪类再次位居前三名。否定伪类 :not() 也继续流行，:root 可能用于创建自定义属性。\r\n\r\n去年有人指出 :focus-visible，一种以更符合用户期望的方式对焦点元素进行样式设置的方法出现在不到 1% 的页面中。自 2022 年 3 月以来，该属性已在所有三个主要引擎中可用，现在在 10% 的桌面和 9% 的移动页面上都可以找到。\r\n\r\n## 伪元素\r\n![](https://almanac.httparchive.org/static/images/2022/css/pseudo-elements.png)\r\n\r\n---\r\n我们过滤掉了任何带前缀的，特定于浏览器的伪元素，这些通常用于选择界面组件或浏览器的部分。\r\n\r\n自去年以来，使用 ::before 和 ::after 有所增加。这些用于将生成的内容插入到文档中。通过检查 content 属性的使用，可以看到它最常用于插入空字符串，用于样式目的。生成的内容是一种无需添加元素即可设置网格区域样式的方法，也许这有助于这些属性的使用量增加。\r\n\r\n伪元素 ::marker 使用率现在已经达到 1%，这表明人们正在慢慢开始利用选择和样式列表标记的能力。\r\n\r\n## 属性选择器\r\n![](https://almanac.httparchive.org/static/images/2022/css/attribute-selectors.png)\r\n\r\n---\r\n最受欢迎的属性选择器是 type，出现在 54% 的页面上。然后分别是 class 37%、disabled 25% 和 dir 17% 出现在页面上的比例。\r\n\r\n## Sass\r\n![](https://almanac.httparchive.org/static/images/2022/css/sass-function-calls.png)\r\n\r\n---\r\n像 Sass 这样的预处理器可以被看作是开发人员使用 CSS 无法实现的一个很好的指标。但是，随着 CSS 越来越强大，开发人员的一个常见问题是我们是否还需要使用 Sass。我们可以从自定义属性使用的增加中看出，一种常见的预处理器使用是拥有变量或常量的能力——而现在有了内置的 CSS 等价物。\r\n\r\n![](https://almanac.httparchive.org/static/images/2022/css/sass-nesting.png)\r\n\r\n---\r\nCSS 嵌套的未来规范目前也正在 CSS 工作组开发和讨论中。嵌套在 SCSS 表中很常见，可以通过查找 & 字符来识别。\r\n\r\n## 参考资料\r\n- [https://almanac.httparchive.org/en/2022/css](https://almanac.httparchive.org/en/2022/css)"
    },
    {
        "article_id": "7166475010121400334",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce793846787642bfb36c4c4d27f09fc5~tplv-k3u1fbpfcp-watermark.image?",
        "title": "排序算法-希尔排序",
        "preview": "希尔排序 概念 希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。 希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。 它通过比较相距一定间隔",
        "author": "淹死的鱼r",
        "view_count": 1165,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/a98d97d1551ef3d414a0e48f53780352~300x300.image",
        "category": "前端",
        "content": "## 希尔排序\r\n### 概念\r\n希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。\r\n\r\n希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。\r\n\r\n它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。\r\n\r\n\r\n### 过程\r\n希尔排序就是按照一定的gap值，不断地对数组进行插入排序。不一样的希尔排序算法可能采用不一样的gap值。经典希尔算法的gap值为N/2, N/4, ...... 直到gap值为1，这里的N为数组的长度。\r\n\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3425e7c58df436c9d699a82c35bbbca~tplv-k3u1fbpfcp-zoom-1.image)\r\n举个例子：\r\n``[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]`` ,采取**间隔 5** (gap = length/2)。创建一个位于 5 个位置间隔的所有值的虚拟子列表。下面这些值是 ``{8, 3}, {9, 5}, {1, 4}, {7, 6}, {2, 0}``，我们这五个子序列分别进行插入排序。结果为 ``[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]`` 。\r\n\r\n接下来我们采取**间隔 2**（gap = 5/2），继续按位于2个间隔的所有值进行插入排序，这个间隔将产生以下两个子虚拟列表：``[3, 1, 0, 9, 7]`` 与 ``[5, 6, 8, 4, 2]``，都进行插入排序，结果为 ``[0, 2, 1, 4, 3, 5, 7, 6, 9, 8]``。\r\n\r\n最后我们采取**间隔 1** (gap = 2/2)，也就是对整个序列进行插入排序（此时的序列已经基本有序了），结果为 ``[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]``。\r\n\r\n### 实现\r\n```js\r\n/**e\r\n * @description: 希尔排序\r\n * @param {Array} \r\n */\r\n\r\nfunction shellSort(arr) {\r\n\\tlet gap = arr.length\r\n\\twhile(gap > 1) {\r\n\\t\\tgap = Math.floor(gap/2)\r\n\\t\\tfor (let i = 1; i < arr.length; i++) {\r\n\\t\\t\\tlet temp = arr[i]\r\n\\t\\t\\tlet j = i - gap\r\n\\t\\t\\tfor ( ; j >= 0 && temp < arr[j]; j = j-gap) {\r\n\\t\\t\\t\\tarr[j+gap] = arr[j]\r\n\\t\\t\\t}\r\n\\t\\t\\tarr[j+gap] = temp\r\n\\t\\t}\r\n\\t}\r\n}\r\n\r\nshellSort([8, 9, 1, 7, 2, 3, 5, 4, 6, 0])\r\n```\r\n\r\n### 希尔排序与直接插入排序区别\r\n希尔排序是插入排序的优化：\r\n\r\n>1.当数组长度很大时，使用插入排序有个弊端，就是如果最小值排在很末端的时候，插入排序需要从末端开始，逐个往前比较到第一个位置，很低效。而希尔排序通过分组的方式，直接让前端跟末端的元素进行比较，解决了插入排序的这个弊端。\r\n\r\n\r\n>2.当一开始 增量n 很大的时候，每一个子数组的元素很少，所以对每个子数组用插入排序进行内部排序是很高效的；而后随着增量n不断减小，这个数组是越来越有序的，此时使用插入排序也是很有利的。\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7187978853074567225",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c748afb663884dd78df9cbda5f06bf60~tplv-k3u1fbpfcp-watermark.image?",
        "title": "聊聊刚入行也可以理解的JavaScript运行机制",
        "preview": "前言 大家好，我是梁木由，一个有想头的前端。JavaScript知识点真是无穷无尽，今天来理解下JavaScript运行机制。 JavaScript单线程机制 JavaScript是一门单线程语言，就",
        "author": "梁木由",
        "view_count": 967,
        "collect_count": 6,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/bda64942fb9146b39558f8809f3b04cb~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: juejin\r\nhighlight: github\r\n---\r\n## 前言\r\n\r\n`大家好，我是梁木由，一个有想头的前端。JavaScript知识点真是无穷无尽，今天来理解下JavaScript运行机制。`\r\n\r\n## JavaScript单线程机制\r\n\r\n**JavaScript是一门单线程语言**，就注定它同一时间内就只能做一件事，只能自上而下执行，那么如果上一行解析时间很长，那下面代码就会被阻塞，那对用户而言体验感是非常不友好的。于是**JavaScript**出现了**同步任务**和**异步任务**。\r\n\r\n## JavaScript事件循环\r\n\r\n### 同步\r\n\r\n程序的执行顺序与任务的排列顺序是一致的、同步的。比如要烧水煮饭，需等水开了，再去煮\r\n\r\n### 异步\r\n\r\n在做这件事的同时，你还可以去处理其他事情。比在烧水的同时，可以去切菜\r\n\r\n看看同步任务与异步任务的执行过程\r\n\r\n![image-20230113102810251.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0260e9e2f0fa4b22816c20cad5cf3d60~tplv-k3u1fbpfcp-watermark.image?)\r\n我们先来看一个问题\r\n\r\n```\r\nsetTimeout(() => {\r\n  console.log('setTimeout')\r\n})\r\n​\r\nnew Promise((resolve) => {\r\n  console.log('promise')\r\n  resolve()\r\n}).then(() => {\r\n  console.log('then')\r\n})\r\n​\r\nconsole.log('console')\r\n```\r\n\r\n根据上述，那么执行结果应该是\r\n\r\n```\r\npromise\r\nconsole\r\nsetTimeout\r\nthen\r\n```\r\n\r\n哎不对呀，与实际输出结果不相符\r\n\r\n```\r\npromise\r\nconsole\r\nthen\r\nsetTimeout\r\n```\r\n\r\n### 宏任务与微任务\r\n\r\n我们知道，虽然都是异步任务，但是`promise`和`setTimeout`却是不同的异步任务，异步任务有两种\r\n\r\n-   宏任务（`script`，`setTimeout`，`setInterval`，`Ajax`，UI渲染，`I/O`，`postMessage`等）\r\n-   微任务（`promise`，`process.nextTick`）\r\n\r\n不同的任务也会进入不同的队列中，所以在执行异步任务时也会进入不同的事件队列\r\n\r\n![image-20230113105003985.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26e9e96139364cfa824c3ce7bb5d9138~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样的话，就理解为什么输出结果是\r\n\r\n```\r\npromise\r\nconsole\r\nthen\r\nsetTimeout\r\n```\r\n\r\n### 事件循环\r\n\r\n那给组合一下看看整体的事件循环机制\r\n\r\n![image-20230113112603431.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff86e09d1e634a4a9c6dfdbe54e36b02~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 总结\r\n\r\n-   异步任务分类：宏任务，微任务\r\n-   同步任务和异步任务分别进入不同的执行\\\"场所\\\"\r\n-   先执行主线程执行栈中的宏任务\r\n-   执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中\r\n-   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\r\n-   主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。\r\n"
    },
    {
        "article_id": "7188322897310515257",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1fbb55dc683437e96e78f6f572f45b2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "视野修炼-技术周刊第20期",
        "preview": "1. 2022年JavaScript明星项目 2. 优雅又迅速的ts文件执行方 式 3. 拉取Gt仓库代码更迅速的方式。。。",
        "author": "粥里有勺糖",
        "view_count": 2798,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5877bbfbefbd0c812f684b56f769b478~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: smartblue\r\n---\r\n\r\n\r\n欢迎来到第 20 期的【视野修炼 - 技术周刊】，下面是本期的精选内容简介。\r\n\r\n🔥强烈推荐\r\n1. 2022 年 JavaScript 明星项目\r\n2. 优雅又迅速的ts文件执行方式\r\n3. 拉取Git仓库代码更迅速的方式\r\n\r\n🔧开源&工具\r\n\r\n4. Roadmap2.0 - 学习路线指导网站\r\n5. publint.dev\r\n6. lightningcss\r\n\r\n📚文章&资讯\r\n\r\n7. 英：The year 2022 for pnpm\r\n8. 张鑫旭：前端原生API实现条形码二维码的JS解析识别\r\n9. 英：:has()伪类的表单样式\r\n\r\n**​推荐大家关注一下最后的推荐内容（周刊的主要内容来源渠道）**\r\n\r\n下面开始本期内容的介绍，预计阅读时间 8 分钟\r\n\r\n## 🔥强烈推荐\r\n### 1. [2022 年 JavaScript 明星项目](https://risingstars.js.org/2022/zh)\r\n由 `Best of JS` 整理的 2022 年明星项目榜单出炉了\r\n\r\n>今年的冠军是一个带有微笑标志的美味面包，用微笑开启新的一年是不错的开始!\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86fc4caf1bf048ebbd180ff155ddf9a8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![总览图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d75e3914d484822be1d818cb958cc9a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n是不是有很多没有见过的新面孔？是不是很多不认识（\\\"快去认认标\\\"）？`🥔：后面单独开篇文章介绍其中一些库`\r\n\r\n下面总结一下榜单内容\r\n* 年度总冠军: Bun 🏆：一个专注性能与开发者体验的全新 JavaScript 运行时\r\n* 前端框架：在 2022 年，React 仍然是冠军，但如果考虑到 Vue.js 的星星在 v2 和 v3 版本的仓库中被分割，那么 Vue.js 的受欢迎程度也很接近\r\n* React生态：Next.js，tRPC（类型安全的API开发框架 ）\r\n* Vue生态：Slidev(markdown写PPT)，Nuxt.js\r\n* 后端&全栈：Next.js，tRPC（类型安全的API开发框架 ）- 还是这2哥们儿\r\n* 构建工具：Vite，Turbopack（前段时间炒的很火）\r\n* css in js：UnoCSS（即时按需原子化CSS引擎），vanilla-extract（0运行时依赖样式表）\r\n* 桌面开发：Tarui，Electron\r\n* 状态管理：Zustand（React），Pinia（Vue）\r\n\r\n### 2. 优雅又迅速的ts文件执行方式\r\n**bunx + tsx**\r\n\r\n* bunx 是 [Bun](https://bun.sh/) 添加的一个全局指令，类似 `npm` 下的 npx\r\n* tsx：全称`TypeScript Execute` 指基于 `esbuild` 增强Node实现直接执行 TS 的工具\r\n\r\n按照官网介绍执行本地包会快 100 倍\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad760ff172874e44aeaf0e0d9d9fb5fb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当然得先安装 bun，一行代码即可\r\n```sh\r\ncurl -fsSL https://bun.sh/install | bash\r\n```\r\n\r\n于是，执行ts脚本可以像这样\r\n\r\n```sh\r\n首次执行可以使用下面的指令设置一下bun拉包的镜像源（npmmirror 中国镜像站）\r\n\r\necho '[install]\r\n# Default registry\r\n# can be a URL string or an object\r\nregistry = \\\"https://registry.npmmirror.com/\\\"' >~/bunfig.toml\r\n\r\n运行脚本\r\nbunx tsx test.ts\r\n```\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2302d67f8fed45a6bc26476d9b218080~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上个演示，直观对比感受一下速度\r\n\r\n![bunx调用tsx](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92a43e21b476471092f49d471708074f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以直观感受到非常的快，没有丝毫等待的迹象，npx 却有明显的等待时长\r\n\r\n当然可以配置一下 `alias` 缩短敲的指令\r\n\r\n比如笔者终端执行用的 `zsh` 就在 `~/.zshrc`里添加\r\n```sh\r\nalias bt='bunx tsx'\r\n\r\n# 然后执行应用配置\r\nsource ~/.zshrc\r\n```\r\n下面就可以用 `bt` 代替 `bunx tsx`\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cbd0991b3224cb9b2b207fac7df6e92~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 3. [拉取Git仓库代码更迅速的方式](https://mp.weixin.qq.com/s/6VaV70zbnfzWBRxHGbmTcw)\r\n* 方式1：`git clone --depth 1 <url>`\r\n  * 只会下载的内容质包含最近一次 `commit` 信息，代码完整\r\n  * **缺点:** ① 切换不到历史 commit ② 切换不到别的分支\r\n* ⭐️方式2：`git clone --filter=blob:none <url>`\r\n  * 只下载 commits 历史以及 HEAD 的文件\r\n  * 每次checkout都会触发一次从remote下载源文件\r\n\r\n比较推荐方式2：大家在拉取大型仓库的时候可以实践一下\r\n\r\n虽然方式1更快，但后续要正常操作要麻烦一点，方式2没有额外操作步骤\r\n\r\n## 🔧开源&工具\r\n### 4. [Roadmap2.0](https://github.com/kamranahmedse/developer-roadmap) - 学习路线指导网站\r\n>推荐收藏这个网站，总会用上的\r\n\r\n新版使用 `astro` + `tailwindcss` 构建\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff32dd48813248dd947d1c6edf609e3a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n### 5. [publint.dev](https://publint.dev/vue@3.2.45)\r\n\r\n检测你的 package.json 有没有问题\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c92930cae1e34844adb559642b5a78d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 6. [lightningcss](https://github.com/parcel-bundler/lightningcss/tree/master)\r\npostcss的替代品，近期发布了 v1.18.0版本，支持js插件扩展\r\n* parcel css 内置了所有 postcss 最佳预设，即开即用\r\n* parcel css 的 visitor api 设计完全吊打\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5556103a5d4561bb859f91fa25115c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nwebpack可以安装 [lightningcss-loader](https://github.com/fz6m/lightningcss-loader) 在项目中体验\r\n## 📚文章&资讯\r\n### 7. [英：The year 2022 for pnpm](https://pnpm.io/zh/blog/2022/12/30/yearly-update)\r\n>\\\"2022 年暴涨 5 倍下载量，彻底击败 lerna ，作者还在乌克兰每天只有几小时有电，勤勉的维护项目，不断的出新活，respect ！\\\"\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c1862e9061040dc878756e3c7c6b0a8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 8. [张鑫旭：前端原生API实现条形码二维码的JS解析识别](https://www.zhangxinxu.com/wordpress/2023/01/js-parse-barcode-qrcode-barcodedetector/)\r\n\r\n利用 BarcodeDetector API 实现，实践详见原文\r\n\r\n当然目前的兼容性较差\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37718b7ce4144f7881b84c04f34af5f8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 9. [英：:has()伪类的表单样式](https://webkit.org/blog/13096/css-has-pseudo-class/#styling-form-states-without-js)\r\n文章作者利用`:has`实现了许多之前需要 js 协助才能实现的交互样式\r\n\r\n这里贴个例子，详细demo见原文\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e60b1e26236642b5ae771ae8ae08ae43~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n篇幅有限，如果你还没看够，可移步后面的推荐渠道，继续游览，历史周刊（<20）移步[博客](https://sugarat.top/weekly/index.html)\r\n\r\n## ⭐️强力推荐关注\r\n* [阮一峰: 科技爱好者周刊](https://www.ruanyifeng.com/blog/archives.html) - 记录每周值得分享的科技内容，周五发布\r\n* [云谦：MDH 前端周刊](https://www.yuque.com/chencheng/mdh-weekly) - 前端资讯和分享\r\n* [童欧巴：前端食堂](https://github.com/Geekhyt/weekly) - 你的前端食堂，吃好每一顿饭\r\n* [rottenpen：FE News](https://rottenpen.zhubai.love/) - 分享前端，生活\r\n* [知识星球：咲奈的平行时空](https://public.zsxq.com/groups/28851452458181.html) - 前端前沿技术、资讯、方法论分享\r\n\r\n"
    },
    {
        "article_id": "7187963986875252795",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38a238f5d91a491d8aef8c9e7ba8a98e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "使用 TypeScript 定义业务字典",
        "preview": "在业务开发中，简单的枚举值往往会衍生出许多关联的字段定义。面对需要定义复杂业务字典的场景，本文将使用 TypeScript 实现一个定义业务字典的工具函数，并且支持类型提示。",
        "author": "网易云音乐技术团队",
        "view_count": 3228,
        "collect_count": 97,
        "comment_count": 12,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/335727a1f67e82416e203e9516f61273~300x300.image",
        "category": "前端",
        "content": "\r\n> 本文作者：htl\r\n\r\n## 业务字典\r\n\r\n在业务开发中，我们常常需要定义一些枚举值。假设我们正在开发一款音乐应用，我们需要定义音乐的类型，以便在业务代码中进行业务逻辑判断：\r\n\r\n```js\r\nconst MUSIC_TYPE = {\r\n  POP: 1,\r\n  ROCK: 2,\r\n  RAP: 3,\r\n  // ...\r\n};\r\n\r\nif (data.type === MUSIC_TYPE.POP) {\r\n  // 当音乐类型为流行音乐时，执行某些逻辑\r\n}\r\n```\r\n\r\n随着业务逻辑的扩展，简单的枚举值往往会衍生出许多关联的字典。比如，我们需要定义一个音乐的类型对应的名称\r\n\r\n```js\r\nconst MUSIC_TYPE_NAMES = {\r\n  [MUSIC_TYPE.POP]: '流行音乐',\r\n  [MUSIC_TYPE.ROCK]: '摇滚音乐',\r\n  [MUSIC_TYPE.RAP]: '说唱音乐',\r\n  // ...\r\n};\r\n\r\n// 展示音乐类型名称\r\n<div>{MUSIC_TYPE_NAMES[data.type]}</div>\r\n```\r\n\r\n或者需要定义一个音乐类型对应的图标：\r\n\r\n```jsx\r\nconst MUSIC_TYPE_ICONS = {\r\n  [MUSIC_TYPE.POP]: 'pop.svg',\r\n  [MUSIC_TYPE.ROCK]: 'rock.svg',\r\n  [MUSIC_TYPE.RAP]: 'rap.svg',\r\n  // ...\r\n};\r\n\r\n// 展示音乐类型图标\r\n<img src={MUSIC_TYPE_ICONS[data.type]} />\r\n```\r\n\r\n在列表场景下，我们可能需要定义一个数组形式的字典：\r\n\r\n```jsx\r\nconst MUSIC_TYPE_LIST = [\r\n  {\r\n    type: MUSIC_TYPE.POP,\r\n    name: '流行音乐',\r\n    icon: 'pop.svg',\r\n  },\r\n  {\r\n    type: MUSIC_TYPE.ROCK,\r\n    name: '摇滚音乐',\r\n    icon: 'rock.svg',\r\n  },\r\n  {\r\n    type: MUSIC_TYPE.RAP,\r\n    name: '说唱音乐',\r\n    icon: 'rap.svg',\r\n  },\r\n  // ...\r\n];\r\n\r\n<div>\r\n  {MUSIC_TYPE_LIST.map((item) => (\r\n    <div>\r\n      <img src={item.icon} />\r\n      <span>{item.name}</span>\r\n    </div>\r\n  ))}\r\n</div>;\r\n\r\n```\r\n\r\n又或者希望使用 key-object 形式避免从多个字典取值：\r\n\r\n```js\r\nconst MUSIC_TYPE_MAP_BY_VALUE = {\r\n  [MUSIC_TYPE.POP]: {\r\n    name: '流行音乐',\r\n    icon: 'pop.svg',\r\n  },\r\n  [MUSIC_TYPE.ROCK]: {\r\n    name: '摇滚音乐',\r\n    icon: 'rock.svg',\r\n  },\r\n  [MUSIC_TYPE.RAP]: {\r\n    name: '说唱音乐',\r\n    icon: 'rap.svg',\r\n  },\r\n  // ...\r\n};\r\n\r\nconst musicTypeInfo = MUSIC_TYPE_MAP_BY_VALUE[data.type];\r\n\r\n<div>{musicTypeInfo.name}:{musicTypeInfo.icon}</div>;\r\n```\r\n\r\n这些形态各异的业务字典同时存在会给代码带来重复和混乱。\r\n\r\n当我们需要变更或增删某个类型或者类型中的某个值时，需要同时修改多个字典，很容易出现遗漏和错误，尤其是当这些字典定义分布在不同的文件中。\r\n\r\n对于使用者来说，散乱的字典定义也是一种负担。在业务中使用某个字典时，需要先查找已有的字典并理解其定义。如果已有字典不能完全满足需求，可能会有新的字典被定义，进一步增加业务字典的混乱程度。\r\n\r\n## 字典工厂函数\r\n\r\n我们可以实现一个工具函数，将一份定义转换成多种格式的字典。\r\n\r\n首先考虑入参的格式。显然作为原始数据，入参必须能够包含完整的字典信息，包括键，值，所有扩展字段，甚至列表场景中的展示顺序。\r\n\r\n我们可以使用对象数组作为入参：\r\n\r\n```js\r\n/**\r\n * list 示例：\r\n * [\r\n *   {\r\n *    key: 'POP',\r\n *    value: 1,\r\n *    name: '流行音乐',\r\n *   },\r\n *   {\r\n *     key: 'ROCK',\r\n *     value: 2,\r\n *     name: '摇滚音乐',\r\n *   },\r\n *   // ...\r\n * ]\r\n */\r\nfunction defineConstants(list) {\r\n  // ...\r\n}\r\n```\r\n\r\n接下来考虑出参的格式。出参应该是一个对象，包含多种格式的字典：\r\n\r\n```js\r\nconst { KV, VK, LIST, MAP_BY_KEY, MAP_BY_VALUE } = defineConstants([\r\n  {\r\n    key: 'POP',\r\n    value: 1,\r\n    name: '流行音乐',\r\n  },\r\n  {\r\n    key: 'ROCK',\r\n    value: 2,\r\n    name: '摇滚音乐',\r\n  },\r\n  // ...\r\n]);\r\n\r\nKV; // { POP: 1, ROCK: 2, ... }\r\nVK; // { 1: 'POP', 2: 'ROCK', ... }\r\nLIST; // [{ key: 'POP', value: 1, name: '流行音乐' }, { key: 'ROCK', value: 2, name: '摇滚音乐' }, ...]\r\nMAP_BY_KEY; // { POP: { key: 'POP', value: 1, name: '流行音乐' }, ROCK: { key: 'ROCK', value: 2, name: '摇滚音乐' }, ... }\r\nMAP_BY_VALUE; // { 1: { key: 'POP', value: 1, name: '流行音乐' }, 2: { key: 'ROCK', value: 2, name: '摇滚音乐' }, ... }\r\n```\r\n\r\n在实际业务中，我们会为不同的资源定义字典，因此我们需要为工具函数提供命名空间。使用第二个入参为出参中的 key 增加前缀：\r\n\r\n```js\r\nconst {\r\n  MUSIC_TYPE_KV,\r\n  MUSIC_TYPE_VK,\r\n  MUSIC_TYPE_LIST,\r\n  MUSIC_TYPE_MAP_BY_KEY,\r\n  MUSIC_TYPE_MAP_BY_VALUE,\r\n} = defineConstants(\r\n  [\r\n    {\r\n      key: 'POP',\r\n      value: 1,\r\n      name: '流行音乐',\r\n    },\r\n    {\r\n      key: 'ROCK',\r\n      value: 2,\r\n      name: '摇滚音乐',\r\n    },\r\n    // ...\r\n  ],\r\n  'MUSIC_TYPE',\r\n);\r\n```\r\n\r\n至此，我们完成了字典工厂函数的设计。这个函数的 JavaScript 实现并不复杂，你可能已经在一些项目中过见过类似的工具函数，但是实际使用时会发现一个问题。\r\n\r\n## 使用 TypeScript 实现类型提示\r\n\r\n使用字典工厂定义业务字典可以让代码更简洁并且规范字典数据格式。然而，相比直接定义，字典工厂的缺点是无法提供类型提示。\r\n\r\n| 直接定义 | 字典工厂 |\r\n| --- | --- |\r\n| ![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23421646391/e2fa/6a85/dad5/afe4206f9694c0745be1da47d748c97c.png) | ![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23421685593/59c2/5031/0078/ffdded9e271b3ae5a614bb8269e1b3b4.png) | \r\n\r\n这给开发者在两个层面带来了不便，一是在定义字典时需要对工具函数的使用和实现有一定了解，这样才能正确传入参数和解构返回值；二是在使用字典时无法获得类型提示，使用字典的开发者需要回来查看定义了哪些字段和值，同时还需要了解工具函数的使用方式。\r\n\r\n为了解决这个问题，我们可以使用 TypeScript 来实现字典工厂函数。以下内容涉及 TypeScript 类型系统的一些特性和一些技巧。\r\n\r\n### `LIST` 字典的实现\r\n\r\n首先实现最简单的 `LIST` 字典，因为它和入参一模一样：\r\n\r\n```ts\r\ninterface IBaseDef {\r\n  key: PropertyKey;\r\n  value: string | number;\r\n}\r\n\r\nfunction defineConstants<T extends IBaseDef[], N extends string>(\r\n  defs: T,\r\n  namespace?: N,\r\n) {\r\n  const prefix = namespace ? `${namespace}_` : '';\r\n  return {\r\n    [`${prefix}LIST`]: defs,\r\n  };\r\n}\r\n```\r\n\r\n我们用 `IBaseDef` 来规范入参中字典项的类型，它包含 `key` 和 `value` 两个字段。`key` 的类型是 `PropertyKey`，它是 `string | number | symbol` 的联合类型，即 key 的值可以是这三种类型中的任意一种。`value` 的类型是 `string | number`，之所以没有 `symbol` 是因为业务中 `value` 的值可能会从外部获取，而 `key` 的值可以是运行时产生的。这两个字段是定义字典必须的，其他字段可以根据业务需要任意添加。\r\n\r\n在 `defineConstants` 函数中，我们使用范型来分别表示两个入参的类型并且使用 `extends` 关键字来约束范型的类型。`T` 的类型是 `IBaseDef[]`，保证入参 `defs` 的格式符合字典项数组。`N` 的类型是 `string`，保证入参 `namespace` 是一个字符串。\r\n\r\n`namespace` 参数是可选的，如果定义字典时未传入，那么返回的字典 Key 也不会有前缀。因此我们需要创建一个 `prefix` 变量并根据 `namespace` 是否存在来决定它的值。\r\n\r\n然后我们返回一个只有 `LIST` 字典的对象，它的 Key 由 `prefix` 和 `LIST` 拼接而成，值就是入参 `defs`。\r\n\r\n这段代码的运行逻辑没有问题，但是它缺少了返回值的类型定义，通过 IDE 的代码提示并不能获取到正确的字典 key：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23424708350/d196/54e1/a863/4f0f0266e83d4f2045118e5db893b0bf.png)\r\n\r\n当你在 IDE 中查看 `dicts` 的类型时，IDE 并不会真的去执行 JavaScript 代码，而是通过 TypeScript 的类型系统来生成类型。\r\n\r\n因此，我们需要使用类型系统定义 `defineConstants` 的返回类型。\r\n\r\n\r\n```ts\r\ntype ToProperty<\r\n  Property extends string,\r\n  N extends string = '',\r\n> = N extends '' ? Property : `${N}_${Property}`;\r\n```\r\n\r\n这里我们定义了一个类型用于生成字典的 Key。它接收两个范型参数，`Property` 表示字典的属性，`N` 表示字典的命名空间。如果 `N` 为空字符串，那么返回的 Key 就是 `Property`，否则就是 `${N}_${Property}`。\r\n\r\n这段代码中有一些 JavaScript 语法的影子，比如字符串，默认参数值，三元运算符，模板字符串等。但是这些都是在 TypeScript 类型系统中运行的，可以看作是一套独立的语言。例如它并没有 if...else 语句，这里的三元运算实际是[条件类型（Conditional Types）](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)的语法，当 `N` 的类型符合 `''` 时，返回 `Property`，否则返回 `${N}_${Property}`。\r\n\r\n你可以把这样的类型定义看作类型系统中的「函数」。不同于 JavaScript 函数通过入参接收值并且返回新的值，它通过范型接收类型并且返回新的类型。\r\n\r\n现在我们可以使用 `ToProperty` 来生成字典的 Key 的类型：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23440312374/b579/ba04/f359/a6ef5834c855a7cd3021a3fe4cde048b.png)\r\n\r\n接下来使用 `ToProperty` 结合[映射类型 (Mapped Types）](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)和[类型断言（Type Assertions）](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)指定 `defineConstants` 的返回类型：\r\n\r\n```ts\r\nfunction defineConstants<T extends IBaseDef[], N extends string>(\r\n  defs: T,\r\n  namespace?: N,\r\n) {\r\n  const prefix = namespace ? `${namespace}_` : '';\r\n  return {\r\n    [`${prefix}LIST`]: defs,\r\n  } as {\r\n    [Key in ToProperty<'LIST', N>]: T;\r\n  };\r\n}\r\n```\r\n\r\n`as` 关键字在类型系统中表示类型断言，是一种手动指定类型的方法。它允许你告诉编译器一个变量或值的类型是什么，而不是让编译器自动推断。\r\n\r\n而类型映射是一种将已有类型转换为具有指定键值的新类型的方法。我们生成了一个新的对象类型，它的键是 `ToProperty<'LIST', N>`，值是 `T`。\r\n\r\n将这些结合起来，`defineConstants` 函数终于可以返回一个支持类型提示的字典了：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23443224105/0ce5/59c5/a5b6/1a7221e3725f4862a20b61189e9ecafd.png)\r\n\r\n## `KV` 字典的实现\r\n\r\n接下来增加 `KV` 字典，它是一个键值对，键和值分别来自入参字典项中的 `key` 和 `value` 属性。\r\n\r\n```ts\r\nfunction defineConstants<T extends readonly IBaseDef[], N extends string>(\r\n  defs: T,\r\n  namespace?: N,\r\n) {\r\n  const prefix = namespace ? `${namespace}_` : '';\r\n  return {\r\n    [`${prefix}LIST`]: defs,\r\n    [`${prefix}KV`]: defs.reduce(\r\n      (map, item) => ({\r\n        ...map,\r\n        [item.key]: item.value,\r\n      }),\r\n      {},\r\n    ),\r\n  } as MergeIntersection<\r\n    {\r\n      [Key in ToProperty<'LIST', N>]: T;\r\n    } & {\r\n      [Key in ToProperty<'KV', N>]: {\r\n        [Key in ToProperty<'KV', N>]: ToKeyValue<T>;\r\n      };\r\n    }\r\n  >;\r\n}\r\n```\r\n\r\n这段代码增加了`MergeIntersection`，`ToSingleKeyValue` 和 `ToKeyValue` 三个类型转换「函数」，并且将范型 T 进一步约束为 readonly。接下来将一一解释这些类型转换的作用和实现以及为什么 T 必须是 readonly。\r\n\r\n`MergeIntersection` 用于合并交叉类型。\r\n\r\n由于我们的实现中不同字典类型是通过映射类型生成的，我们需要使用[交叉类型（Intersection Types）](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types)将它们合并，当合并多个类型后会变得难以阅读。\r\n\r\n![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23443714213/1029/3b7c/6058/e79b49f47d12a28b5fc801d7ffd67574.png)\r\n\r\n\r\n使用 `MergeIntersection` 可以将交叉类型合并为一个类型，在视觉上更加清晰，也便于后续处理：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23443511385/3762/a5fb/6158/9cc751f6f8198f6eeb106fa1b19d2108.png)\r\n\r\n`MergeIntersection` 的实现：\r\n\r\n```ts\r\ntype MergeIntersection<A> = A extends infer T\r\n  ? { [Key in keyof T]: T[Key] }\r\n  : never;\r\n```\r\n\r\n这里我们再次使用了条件类型和映射类型。而 `infer` 关键字则是[类型推断（Type Inference）](https://www.typescriptlang.org/docs/handbook/type-inference.html)的语法，它可以让我们在条件类型中获取类型变量的具体类型并用于后续的映射类型。\r\n\r\n由于 `infer` 总能推断出一个类型，所以条件类型的第二个结果永远不会出现，因此我们可以使用 `never` 类型。\r\n\r\n`ToSingleKeyValue` 用于将单个字典项转换为键值对：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23443916021/a9e1/a5dc/0198/f905df1999eb33755e21bc159b55cdfb.png)\r\n\r\n`ToSingleKeyValue` 的实现：\r\n\r\n```ts\r\ntype ToSingleKeyValue<T> = T extends {\r\n  readonly key: infer K;\r\n  readonly value: infer V;\r\n}\r\n  ? K extends PropertyKey\r\n    ? {\r\n        [Key in K]: V;\r\n      }\r\n    : never\r\n  : never;\r\n```\r\n\r\n我们使用 `infer` 关键字获取 `key` 和 `value` 的具体类型并且在一个条件类型使用他们。然后在第二个条件类型中明确 `key` 的类型是 `PropertyKey`，因此可以用于映射类型。最后指定映射类型中的键和值。\r\n\r\n`ToKeyValue` 用于将字典项数组转换为键值对：\r\n\r\n![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23444069864/a5d2/b728/958e/d27e65be1be0f31d26e7ae33bc3124cf.png)\r\n\r\n\r\n`ToKeyValue` 的实现：\r\n\r\n```ts\r\ntype ToKeyValue<T> = T extends readonly [infer A, ...infer B]\r\n  ? B['length'] extends 0\r\n    ? ToSingleKeyValue<A>\r\n    : MergeIntersection<ToSingleKeyValue<A> & ToKeyValue<B>>\r\n  : [];\r\n```\r\n\r\n这个实现的关键点是使用类型推断结合展开语法和递归特性实现数组类型的处理。\r\n\r\n我们在第一个条件类型中获取数组的第一个元素和剩余元素，然后在第二个条件类型中判断剩余元素的长度是否为 0。如果为 0，说明数组只有一个元素，我们可以直接使用 `ToSingleKeyValue`进行类型转换。否则转换第一个元素并递归使用 `ToKeyValue` 转换剩余部分，最后使用 `MergeIntersection` 将结果合并。\r\n\r\n在 `defineConstants` 和这些类型转换函数中使用了 `readonly` 关键字，这实际上源于 `defineConstants` 的一个使用限制：在使用 `defineConstants` 时，必须使用 [`const` 断言（`const`\r\nassertions）](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)，即在字典项数组后面加上 `as const`。\r\n\r\n```ts\r\ndefineConstants([\r\n  {\r\n    key: 'POP',\r\n    value: 1,\r\n    name: '流行音乐',\r\n  },\r\n  {\r\n    key: 'ROCK',\r\n    value: 2,\r\n    name: '摇滚音乐',\r\n  },\r\n] as const, 'MUSIC_TYPE');\r\n```\r\n\r\n对于代码中的常量定义，TypeScript 会自动推断变量类型而抹去具体的值。这在通常情况下是合理的，但是对于 `defineConstants` 类型提示的实现是很大的阻碍。如果入参字典项中的值信息丢失，我们也就无法通过类型系统进行类型转换生成字典的类型定义。\r\n\r\n对比是否使用 as const 的区别：\r\n\r\n| no as const |  as const |\r\n| --- | --- |\r\n| ![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23444806600/a838/7ae4/c4c8/517e30cfe9130f84a3686881f01748cb.png) | ![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23444812335/ebd5/f902/411a/5833b21fa829a9f02a9851f736ffe116.png) | \r\n\r\n而使用 const 断言同时也会将字典项的属性在类型系统中变成只读，这也是我们在函数中使用 `readonly` 关键字的原因。\r\n\r\n以上内容基本上覆盖了剩余字典类型转换所需的全部语法和技巧，例如 `VK` 格式只是将键值对换，`MAP_BY_KEY` 只是将值替换为字典项的类型，因此不再赘述。完整的实现可以在[Github Gist](https://gist.github.com/Yelmor/e28ddb1e31a49b2fc0a80bd7fe3bd3c8)获取，也可以直接在这个[CodeSandbox 示例](https://codesandbox.io/s/define-constants-r6dd0n?file=/src/index.ts)中尝试使用效果。\r\n\r\n至此我们已经使用 TypeScript 实现了可以生成带有支持类型提示的业务字典工厂函数，通过这个函数定义和使用业务字典可以在各处获取类型提示。\r\n\r\n定义字典时：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23445043510/31c7/229e/25f4/2abdae3b56fcad76e8edb4e33904d90c.png)\r\n\r\n![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23445075356/c522/69b5/65dc/dca4217088d3b742b553707ddf30a2e7.png)\r\n\r\n使用字典时：\r\n\r\n![](https://p5.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23445103795/4925/a53e/103d/9705bbc6e4ef1fb2a3f76ca3c58fb448.png)\r\n\r\n![](https://p6.music.126.net/obj/wonDlsKUwrLClGjCm8Kx/23445137184/6d38/a83d/12a3/68d3a105ea26c5aca10964ef416500f7.png)\r\n\r\n## 缺陷和不足\r\n\r\n这个工具给作者本人在项目中带来很大的帮助，但还是存在一些缺陷和不足：\r\n\r\n1. 只能在 TypeScript 项目中使用，并且在定义字典时需要使用 `as const` 关键字。\r\n\r\n通常来说一个工具函数以 TypeScript 实现，只要提供良好的类型定义就可以在 JavaScript 项目中方便地使用。\r\n\r\n但是由于 JavaScript 无法支持 `const` 断言或类似功能，这个工具只能在 TypeScript 中使用。\r\n\r\n2. 使用者无法在类型提示中获取注释\r\n\r\n当我们定义一个枚举值时，可能会增加一些注释：\r\n\r\n```ts\r\nenum MusicTypes {\r\n  /**\r\n   * 流行\r\n   */\r\n  POP: 1,\r\n}\r\n```\r\n\r\n开发者在使用这个枚举值时，可以通过 IDE 获取注释内容。然而通过字典工厂函数生成的字典经过转换已经丢失了这些信息。\r\n\r\n3. 无法同时导出类型定义\r\n\r\n`defineConstants` 返回的是字典值，当下游需要引用字典类型时，还需要需要额外导出类型定义：\r\n\r\n``` ts\r\nexport const { MUSIC_TYPE_VALUES } = defineConstants([...], 'MUSIC_TYPE')\r\n\r\n// 导出字典类型\r\nexport type MUSIC_TYPE = MUSIC_TYPE_VALUES[number]\r\n\r\n// 下游类型定义\r\nimport { MUSIC_TYPE } from './constants'\r\n\r\ninterface Music {\r\n  type: MUSIC_TYPE;\r\n  // ...\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n本文针对业务字典定义的场景，使用 TypeScript 实现了一个工具函数，用于生成各种形式且带有类型提示的业务字典。同时指出了这个工具函数的一些使用限制和不足之处。\r\n\r\n\r\n> 本文发布自网易云音乐技术团队，文章未经授权禁止任何形式的转载。我们常年招收各类技术岗位，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！\r\n"
    },
    {
        "article_id": "7187721386071162938",
        "snapshot": "",
        "title": "看不懂JS编译？让Demo教你啊!!!",
        "preview": "背景 由于领导的梦想，最近开始分析JS编译的东西，本文主要从demo入手，概念部分会稍微涉及，更多的请search 概念 什么是编译时、运行时 编译：将源代码翻译成机器能识别的语言（二进制）。编译器负",
        "author": "盐焗小星球",
        "view_count": 666,
        "collect_count": 3,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/0b874a38dc25052c64c10e44db50bb6b~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n# 背景\r\n由于领导的梦想，最近开始分析JS编译的东西，本文主要从demo入手，概念部分会稍微涉及，更多的请search\r\n\r\n# 概念\r\n### 什么是编译时、运行时\r\n- 编译：将源代码翻译成机器能识别的语言（二进制）。<br>编译器负责编译代码。在这个过程中会做一些简单的翻译工作，会进行词法分析,语法分析之类的。<br>编译器检查出来的错误就叫*编译时错误*，这个过程中做的类型检查也就叫编译时类型检查,或静态类型检查(此时没把真把代码放内存中运行起来,而只是把代码当作文本来扫描下)。\r\n- 运行时：就是代码跑起来了，被装载到内存中去了。<br>代码保存在磁盘上没装入内存之前是个文件。只有跑到内存中才开始起作用。<br>而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样。不是简单的扫描代码.而是在内存中做些操作,做些判断以确定我们的程序是否存在错误。\r\n### 解释型语言和编译型语言\r\n- 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件（即exe文件），运行时不需要重新编译，直接用编译后的文件（exe文件）就行了。\r\n  - 优点：执行效率高\r\n  - 缺点：跨平台性差\r\n- 解释型语言：程序不需要编译，程序在运行的过程中才用解释器编译成机器语言，边编译边运行（没有exe文件）。\r\n  - 优点：跨平台性好、每个平台采用自有的编译机制\r\n  - 缺点：执行效率低、因为边编译边执行\r\n### ESModule\r\n- ES6 模块的设计思想是尽量的静态化，它是一边编译一边执行，使得编译时就能确定模块的依赖关系、会检查引入变量/模块是否存在以及输入和输出的变量。\r\n- CommonJS 和 AMD 模块，都是运行时加载，在编译阶段只判断语法层面对不对，如果引入了不存在的变量等只有在执行时才会发现。 。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\r\n\r\n```\r\n// CommonJS模块\r\nlet { stat, exists, readFile } = require('fs');\r\n\r\n// 等同于\r\nlet _fs = require('fs');\r\nlet stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;\r\n```\r\n上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\r\n\r\nES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。不会加载整个fs。\r\n```\r\n// ES6模块\r\nimport { stat, exists, readFile } from 'fs';\r\n```\r\n上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。\r\n\r\n\r\n# Demo\r\n### Demo -> 基础\r\n#### code\r\n这里写了三个js一个html\r\n- 1.js<br>\r\nJS里写了一个特别长的for循环和一个普通方法，注意为了测试编译时长，所以不是简单把for循环次数增大，而是多写了很多代码。\r\n```\r\nfunction printA (){\r\n  console.log(\\\"A\\\");\r\n}\r\n\r\nfunction printB (){\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n  // .... 写了超级多for循环\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n}\r\nexport { printA, printB};\r\n```\r\n- 2.js\r\n```\r\nimport { printA } from \\\"/WorkCode/tests/1.js\\\";\r\nprintA();\r\n```\r\n- 3.js\r\n```\r\nimport { printB } from \\\"/WorkCode/tests/1.js\\\";\r\nprintB();\r\n```\r\n- index.html<br>\r\n是一个\\\"空\\\"的html，2.js 和 3.js 都是通过动态加载script进去的\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n  <head>\r\n    <meta charset=\\\"UTF-8\\\" />\r\n  </head>\r\n  <body>\r\n  </body>\r\n</html>\r\n```\r\n#### action\r\n1. 在cross浏览器（就是可以跨域的chrome，掘金搜一下配一个就行）下打开html，打开F12，然后在console里输入以下代码\r\n```\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./2.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n5000);  // 这里5s是留给自己的操作时间\r\n\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./3.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n7000); \r\n\r\n```\r\n2. 随后立马开启`手动录制`Performance，等待8s左右，停止\r\n3. 查看录制结果\r\n#### 分析结果\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51bc854741214280be909ee8ec127df9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们大致可以看到，就是有两块黄色，第二块明显长很多，按时间也可以知道短的（第一个）是2.js内容，长的是3.js内容，一个个分析\r\n\r\n- 2.j\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e402f962359437a8e26085f6ae32fea~tplv-k3u1fbpfcp-watermark.image?)\r\n可以看出，这里的过程如下：\r\n```\r\n加载2.js\r\n开始编译 2.js，确定模块引用关系（编译时长0.1ms）\r\n\r\n加载1.js\r\n编译1.js（编译时长21.5ms）\r\n\r\n运行2.js（编译时长，很短）\r\n```\r\n\r\n- 3.js\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e07c1af6b7634fa3a862d8650b160e0d~tplv-k3u1fbpfcp-watermark.image?)\r\n```\r\n加载3.js\r\n开始编译 3.js，确定模块引用关系（编译时长0.1ms）\r\n\r\n运行3.js（编译时长50.3ms）\r\n```\r\n\r\n- 分析\r\n\r\n可以看出，虽然都 import 了 1.js ，但只有第一次 import 的时候加载了1.js并编译了其js主体部分。所以我们在后一张图中没发现加载和编译1.js的部分\r\n\r\n而且，可以看到 2.js 和 3.js 代码量一致，但import的方法其大小差距很大（一个3行代码一个n行代码），所以在运行2.js和3.js时，所用的编译时长相差那么大，应该就是编译这两个print函数导致的。其实也就是运行到3.js的时候，发现要执行 printB 方法，这时候才去编译 printB 导致的\r\n\r\n那么可以有以下猜想：\r\n1. 如果提前挂载了1.js，那加载2.js时也不应该出现1.js加载/编译时间\r\n2. 如果还有一个4.js，代码和3.js一样，那么它的编译运行时长应该和3.js差不多\r\n\r\n我们来证明以上猜想\r\n### Demo -> 提前加载1.js\r\n#### code\r\njs代码同上，只需修改html\r\n- index.html<br>\r\nhtml里已经加好了1.js，2.js 和 3.js 都是通过动态加载script进去的\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n  <head>\r\n    <meta charset=\\\"UTF-8\\\" />\r\n  </head>\r\n  <body>\r\n    <script src=\\\"./1.js\\\" type=\\\"module\\\"></script> \r\n  </body>\r\n</html>\r\n```\r\n#### action\r\n同上\r\n#### 分析结果\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4894632b387d43288db7456a35ec202f~tplv-k3u1fbpfcp-watermark.image?)\r\n熟悉的一短一长，但明显短的更短，看分析\r\n- 2.js\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757c5a4cbf124c39af473bc1510b129c~tplv-k3u1fbpfcp-watermark.image?)\r\n```\r\n加载2.js\r\n开始编译 2.js（编译时长0.1ms）\r\n\r\n运行2.js（编译时长，很短）\r\n```\r\n- 3.js\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef4040b87b454cb6b55a0e56d1e0c6db~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n```\r\n加载3.js\r\n开始编译 3.js（编译时长0.1ms）\r\n\r\n运行3.js（编译时长50.8ms）\r\n```\r\n- 分析\r\n\r\n结果和猜想一样，2.js 里并没有1.js的加载编译时长，那么：\r\n> 多次导入同一module，module只会compile一次\r\n\r\n### Demo -> 新增4.js\r\n#### code\r\n增加 4.js，并且在1.js 里增加新方法 printC，其内容与 printB 一样\r\n- 1.js\r\n```\r\n...\r\n\r\nfunction printC (){\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n  // .... 写了超级多for循环\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(i);\r\n  }\r\n}\r\nexport { printA, printB, printC};\r\n\r\n```\r\n- 4.js\r\n```\r\nimport { printC } from \\\"/WorkCode/tests/1.js\\\";\r\nprintC();\r\n```\r\n#### action\r\n其他操作一致，就是定时器函数需要修改如下，并且等待录制的时间需延长（毕竟多了一个js嘛）\r\n```\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./2.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n5000);  // 这里5s是留给自己的操作时间\r\n\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./3.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n7000); \r\n\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./4.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n13000); \r\n```\r\n#### 分析结果\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca49f1478e804083a4e7d4bc5ef60f9a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n现在是1短2长，现在具体我就不贴图了，直接上时间\r\n\r\n\r\n| 文件 | 开始编译时长 | 运行编译时长 |\r\n| --- | --- | --- |\r\n| 2.js | 0.06ms | 0.02ms |\r\n| 3.js | 0.06ms | 52ms |\r\n| 4.js | 0.1ms | 50ms |\r\n\r\n> 函数只有在运行时才会被 compile\r\n\r\n### Demo -> 测试1.js编译时长\r\n我们顺便看下，1.js在export不同数量函数时，本身编译时长有何改变。\r\n#### code\r\n- 1.js\r\n旧的1.js 就只有 printA 和 printB 函数，新的多了 printC，代码在前两个demo里\r\n- index.html\r\nhtml里已经加好了1.js\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n  <head>\r\n    <meta charset=\\\"UTF-8\\\" />\r\n  </head>\r\n  <body>\r\n    <script src=\\\"./1.js\\\" type=\\\"module\\\"></script> \r\n  </body>\r\n</html>\r\n```\r\n#### action\r\n在cross浏览器下打开html，打开F12，然后`自动录制`Performance\r\n注意两次录制的1.js内容是不一样的\r\n#### 分析\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/116fac085a4d484e859d017c569d41d6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n| 1.js | 编译时长 \r\n| --- | ---\r\n| 旧(A、B) | 23.6ms \r\n| 新(A、B、C) | 45ms \r\n\r\n> 方法JS本身代码量太多，即使不执行，compile time也会变长\r\n\r\n### Demo -> 相同方法执行是否缓存?\r\n#### code\r\n4.js改为和3.js一样\r\n- 4.js\r\n```\r\nimport { printB } from \\\"/WorkCode/tests/1.js\\\";\r\nprintB();\r\n```\r\n#### action\r\n其他操作一致，就是定时器函数需要修改如下，不加载2.js（没必要）\r\n```\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./3.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n7000); \r\n\r\nsetTimeout(function(){ \r\n  var script = document.createElement(\\\"script\\\");  \r\n  script.setAttribute(\\\"src\\\",\\\"./4.js\\\");  script.setAttribute(\\\"type\\\",\\\"module\\\");    \r\n  document.body.appendChild(script);   },\r\n13000); \r\n```\r\n#### 分析\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7656deecb3d0443aa0232ef5cc1feafc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们看到还是两个很长的JS时间，但仔细看第一个长块下方有个小块，具体看发现是compile code 时间\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1d5e4456c540808c183d3454f36726~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n而第二个长块是没有 compile 时间的\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f0ffffbad274fcfa03816d456685e0f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n| 文件 |  运行编译时长 |\r\n| --- | --- |\r\n| 3.js | 51ms |\r\n| 4.js | 几乎为0 |\r\n\r\n> 多次调用同一方法，该方法只会在第一次调用时compile\r\n\r\n### Demo -> 相同方法不同入参执行是否缓存?\r\n#### code\r\n将printB方法改为需要入参的\r\n```\r\n// 1.js\r\nfunction printB (j){\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(j);\r\n  }\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(j);\r\n  }\r\n  // .... 写了超级多for循环\r\n  for(let i = 0;i< 1; i++) {\r\n    console.log(j);\r\n  }\r\n}\r\nexport { printA, printB};\r\n```\r\n- 3.js\r\n```\r\nimport { printB } from \\\"/WorkCode/tests/1.js\\\";\r\nprintB(\\\"3\\\");\r\n```\r\n- 4.js\r\n```\r\nimport { printB } from \\\"/WorkCode/tests/1.js\\\";\r\nprintB(\\\"4\\\");\r\n```\r\n#### action\r\n同上\r\n#### 分析\r\n结果同上\r\n\r\n> 带不同入参多次调用同一方法，该方法只会在第一次调用时compile\r\n\r\n# V8\r\n从上一个 Demo 可看出，编译其实是有缓存，那这到底是什么呢？我们将目光投向 chromium V8。关于这块还在了解中，主要是 JIT 技术，所以单独撸了一篇[V8引擎与JIT原理](https://juejin.cn/post/7179130165262286885/) \r\n"
    },
    {
        "article_id": "7189425953662042173",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf313f444454ae5af4924ba81abca0b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "顶刊TIP 2023｜Rethinking无监督行人Re-ID，中科院研究团队表明采样策略是重中之重",
        "preview": "来自中国科学院大学、鹏城实验室和天津大学的研究团队认为模型训练时的采样策略起着同样重要的作用**，作者分析了同一框架和损失函数下各种采样策略之间性能差异的原因",
        "author": "CV顶刊顶会",
        "view_count": 793,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8a2627eb8604780a9ace5d5b2bc28331~300x300.image",
        "category": "人工智能",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ec1692e5804315b50ce4e20f734fd6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 论文标题：Rethinking Sampling Strategies for Unsupervised Person Re-Identification    \r\n> 论文链接：https://ieeexplore.ieee.org/document/9969623   \r\n> 代码仓库：https://github.com/ucas-vg/GroupSampling   \r\n> 作者单位：中国科学院大学、鹏城实验室、天津大学  \r\n\r\n*期刊介绍：IEEE Transactions on Image Processing（IEEE TIP）是图像处理领域公认的顶级国际期刊，是中国计算机学会（CCF）推荐的A类期刊，代表了图像处理领域先进的重大进展，要求论文在理论和工程效果上对图像处理及相关领域具有重要推动作用，其最新的影响因子为[15.8](https://academic-accelerator.com/Real-Time-Impact-of-Journal/IEEE-Transactions-on-Image-Processing)。*    \r\n\r\n**欢迎关注@CV顶刊顶会，认真且严肃的计算机视觉论文前沿报道~**\r\n\r\n**无监督的行人重识别 (person re-identification，re-ID) 是计算机视觉领域中一项具有挑战性的任务**。之前大量的研究集中在框架设计和损失函数上，与人脸识别研究社区非常相似。但究竟显著影响重识别方法性能的因素是什么呢。**来自中国科学院大学、鹏城实验室和天津大学的研究团队认为模型训练时的采样策略起着同样重要的作用**，作者分析了同一框架和损失函数下各种采样策略之间性能差异的原因，**认为模型的过度拟合是导致性能不佳的重要因素**，而在统计层面增强模型的稳定性可以纠正这个问题。受此启发，作者团队提出了一种简单而有效的方法，**称为组抽样（group sampling，GS），它将同一类的样本收集到组中进行归一化组训练，这有助于减轻个体样本的负面影响**。受GS方法控制的伪标签生成的方式可以保证样本更有效地分类到正确的类别中。**它可以调节表征学习的过程，以渐进的方式增强特征表示的统计稳定性**。作者在 Market-1501、DukeMTMC-reID 和 MSMT17 三个标准行人重识别数据集上进行了广泛的实验，实验结果表明GS方法的性能可与最先进的方法相媲美，**并且在与相机无关（camera-agnostic）的实验设置上达到SOTA效果，目前该文已发表在人工智能领域顶级期刊（IEEE Transactions on Image Processing，TIP）上**。\r\n\r\n## 1.引言   \r\n\r\n本文的主要研究对象为**无监督的行人重识别**，通过减少数据注释所需的人力消耗，目前的无监督的行人重识别框架可以扩展到实际的应用中。**最近提出的SpCL[1]是一种self-paced的对比学习框架**，该框架大大提高了无监督人员重识别的性能。**因此本文将 SpCL 作为研究基线，在本文中称为对比基线**。传统的 person re-ID 框架通过构建三元组（即锚点、正例和负例）来学习类间判别表示和类内相似性。相比之下，**对比基线构建了一个记忆库来存储所有样本特征，以便在优化每个锚点时可以直接从记忆库中获取正负样本**。这意味着对于对比基线，不需要通过三元组抽样（triplet sampling）参与训练，但令人惊讶的是，当作者使用最直接的随机抽样代替原来的三重抽样时，模型未能获得预期的结果。\r\n\r\n本文试图分析和解释为什么不同的采样策略会导致这种异常。作者认为，**当采用随机抽样时，个体样本的随机性和倾向性可能会主导整个类的优化方向，从而导致类的特征表示发生变化**。具体来说，具有不同ground-truth标签的样本不断聚合，**类逐渐失去个体身份特征，倾向于恶化特征表示**。用此类形成的伪标签进行监督会导致模型失去区分类内相似性和类间差异的能力，**这种现象我们称之为恶化的过拟合**。相应地，triplet sampling 成功的关键在于它在每个 mini-batch 中从同一类中选择了一定数量的样本。同类样本的分组有助于降低单个样本对模型优化的影响，突出当前类的整体趋势。  \r\n\r\n## 2.采样策略研究    \r\n\r\n### 2.1 常用的几种采样策略   \r\n\r\n广泛用于re-ID训练的采样策略包括**随机采样、Triplet Sampling（三元组采样）和重复增强采样等，其中三元组采样是对比基线中的默认方法**。  \r\n\r\n1）随机抽样：随机抽样是深度学习中最简单也是最常用的抽样策略。它从训练集中随机抽取样本，因此每个 mini-batch 的样本组成是**完全随机**的。\r\n\r\n2）Triplet Sampling：Triplet sampling是在每个mini-batch中抽取一定数量的正样本和负样本。具体来说，它以 $P\\\\times K$ 的方式进行数据采样，即随机选择 $P$ 个类和每个类的 $K$ 个样本。 **当一个类中的样本数大于$K$时，只随机抽取其中的$K$个，其余的将被丢弃。 反之，当数量小于$K$时，部分样本将被重新采样**。\r\n\r\n3）重复增强（Repeated Augmentation，RA）采样：在RA采样中，图像批次数量$\\\\mathcal{B}$是通过从数据集中采样$\\\\lceil|\\\\mathcal{B}| / m\\\\rceil$不同的图像形成的，**它会对同样的样本逐次抽取m次来填充mini-batch**，因此，就 mini-batch 构造而言，RA 抽样与三重抽样的 $P\\\\times K$ 方式非常相似。**不同的是，triplet sampling 侧重于对同一类内的不同实例进行采样，而 RA 是对每个实例重复采样**。   \r\n\r\n作者分别对这几种采样策略进行测试，测试效果如下表所示，可以清楚地看出，与随机采样相比，**三元组采样产生了很大的性能增益**。  \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0454a67d53d2475a8c72b5bcde0ec812~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 2.2 为什么三元组采样如此有效？     \r\n\r\n在对比基线中，利用样本间的特征相似性和差异性将样本分为不同的类，并为每个类分配伪标签，在这种训练策略下，**样本以高度随机的方式在特征空间中更新**。生成的类大致可以分为强类和弱类。强类的特征是样本数量相对较多，且在特征空间中的紧凑性，这意味着该类具有稳定的结构。相反，弱类的样本组成比较松散，这意味着它的结构不稳定，容易断裂。**当一个类中存在大量具有不同标签的样本时，该类的整体特征变得泛化和粗糙，逐渐失去对个体身份的表征，称为恶化的特征表示**。拟合这种具有大量噪声的伪标签，模型陷入学习恶化的特征表示中，从而失去区分类内相似性和类间差异的能力，作者称这种现象为恶化过拟合现象。\r\n\r\n**过度拟合恶化的后果是具有不同真实标签的各种样本混合在一个类中**，如下图中的虚线所示，这样一来，身份的相似结构就淹没在类中，无法正常表达，最终的结果是语义信息的恶化，直接表现为伪标签中噪声的增加，这就是随机抽样导致训练崩溃的原因。     \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfb1822371ed4f6db2b11e3d2a463be4~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n为了应对这一现象，**作者提出使用一种统计稳定性的策略，统计稳定性保证类内的相似性结构不会被破坏**，同时保持其他类之间的一定程度的区分度。只有类别保持其统计稳定性，模型才能不断探索样本之间本质和复杂的相似性，从而能够区分更详细的差异和粗略的相似性，以满足无监督行人重识别的需要。   \r\n\r\n其中triplet sampling是一种较为合理的解决方案，其中有一个重要的参数 $K$，即 mini-batch 中每个人身份的实例数。**该操作使得属于同一类的一组样本同时被训练，强调了该组的整体趋势**。群体中各样本的随机性和自身倾向性减弱，不易从群体中散开。 \r\n\r\n### 2.3 GS采样增强的行人重识别方法  \r\n\r\n虽然triplet sampling相比随机采样等方法实现了显着的性能改进，但其仍然存在一些问题。例如**其需要在欠采样和过采样之间进行权衡，triplet sampling 为每个类随机选择固定数量的样本，这可能会导致过采样或欠采样**。当发生欠采样时，内存库中的一些样本特征无法及时更新。当一个类中的样本数量过少导致过采样时，该类的样本权重会被放大，从而导致样本不平衡的问题，这两种情况都会影响模型的最终性能。  \r\n\r\n作者提出使用分组采样（GS）方法来改善triplet sampling。即首先将 $C_i$ 类中的样本打乱以增加随机性，然后将每 $N$ 个相邻样本打包到每个 $C_i$ 中的一个组中，其中超参数 $N$ 是每个组中的样本数。需要强调的是，当$C_i$中的样本数不能被$N$整除或小于$N$时，其余样本直接打包成一组，不重新采样。最后，将所有组聚集在一起，并打乱这些组的顺序。下图展示了分组采样的实现细节。  \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d87e7f5e0e3a44d78d3d2e2ef348bd74~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n实际算法操作流程如下：  \r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b314a7fc15546f082fb6292c30b9bc1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 3.实验效果    \r\n\r\n本文的实验**在Market-1501、DukeMTMC-reID 和 MSMT17 三个标准行人重识别数据集上进行，实验评价指标使用mAP和CMC**，此外作者强调，本文的实验结果均没有使用后处理操作进行结果增强。  \r\n\r\n我们随机选择了四个身份，并可视化对比了随机抽样方式和GS方法在训练过程中样本在特征空间中的分布情况，如下图所示，对于随机抽样，这四个身份的样本被分成许多簇，每个簇包含多个身份实例。相比之下，GS抽样可以区分不同身份的样本，并且可以将相同身份的样本正确聚类。  \r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ead33ef3887242b3a3a0d3296a98f529~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n此外，作者选取了**从2015年到2021年间的21种re-Id方法**进行了性能对比，对比结果如下表所示，可以看到，本文方法在无需任何相机知识的情况下，仍然能获得具有代表性的重识别性能。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/916395c69dea4118a9d7d292d603300b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 4.总结  \r\n\r\n在本文中，作者对行人重识别任务中的采样策略进行了深入分析，阐述了普通采样方式的缺陷。此外，作者引入了一些新概念，**包括恶化的过度拟合和统计稳定性**，这些概念对有效提高模型性能具有重要意义。例如，由于过度拟合恶化，随机抽样容易出现训练崩溃的现象。相比之下，**本文提出的GS采样方式有助于保持类内的统计稳定性，其有效地减轻了个体样本对统计稳定性的负面影响**，充分发挥了对比基线的潜力。此外作者与目前流行的21中re-Id方法进行了广泛的实验对比，实验效果均证明所提方法的有效性。   \r\n\r\n## 参考  \r\n\r\n[1] Y. Ge, F. Zhu, D. Chen, R. Zhao, and H. Li, “Self-paced contrastive learning with hybrid memory for domain adaptive object re-ID,” in Proc. NeurIPS, 2020, pp. 11309–11321.\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7161036677182898207",
        "snapshot": "",
        "title": "vue高频面试知识点汇总【2022寒冬版】",
        "preview": "很喜欢`‘万变不离其宗’`这句话，希望在不断的思考中找到`Vue`中的`宗`，来解答面试官抛出的各种`Vue`问题，一起加油~",
        "author": "qb",
        "view_count": 11441,
        "collect_count": 869,
        "comment_count": 36,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "很喜欢`‘万变不离其宗’`这句话，希望在不断的思考和总结中找到`Vue`中的`宗`，来解答面试官抛出的各种`Vue`问题，一起加油~\r\n\r\n## 一、`MVVM`原理\r\n在`Vue2`官方文档中没有找到`Vue`是`MVVM`的直接证据，但文档有提到：虽然没有完全遵循`MVVM模型`，但是 Vue 的设计也受到了它的启发，因此在文档中经常会使用`vm`(ViewModel 的缩写) 这个变量名表示 Vue 实例。\r\n\r\n为了感受`MVVM模型`的启发，我简单列举下其概念。\r\n\r\nMVVM是Model-View-ViewModel的简写，由三部分构成：\r\n- Model: 模型持有所有的数据、状态和程序逻辑\r\n- View: 负责界面的布局和显示\r\n- ViewModel：负责模型和界面之间的交互，是Model和View的桥梁\r\n## 二、`SPA`单页面应用\r\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序。我们开发的`Vue`项目大多是借助个官方的`CLI`脚手架，快速搭建项目，直接通过`new Vue`构建一个实例，并将`el:'#app'`挂载参数传入，最后通过`npm run build`的方式打包后生成一个`index.html`，称这种只有一个`HTML`的页面为单页面应用。\r\n\r\n当然，`vue`也可以像`jq`一样引入，作为多页面应用的基础框架。\r\n\r\n## 三、`Vue`的特点\r\n- 清晰的官方文档和好用的`api`，比较容易上手。\r\n- 是一套用于构建用户界面的**渐进式框架**，将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。\r\n- 使用 **Virtual DOM**。\r\n- 提供了**响应式** (Reactive) 和**组件化** (Composable) 的视图组件。\r\n\r\n## 四、`Vue`的构建入口\r\nvue使用过程中可以采用以下两种方式：\r\n- 在vue脚手架中直接使用，参考文档：`https://cn.vuejs.org/v2/guide/installation.html`\r\n- 或者在html文件的头部通过静态文件的方式引入：\r\n`<script src=\\\"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js\\\"></script>`\r\n\r\n那么问题来了，使用的或者引入的到底是什么？<br>\r\n答：引入的是已经打包好的vue.js文件，通过rollup构建打包所得。\r\n\r\n构建入口在哪里？<br>\r\n答：在`vue`源码的package.json文件中：\r\n```\r\n\\\"scripts\\\": {\r\n    // ...\r\n    \\\"build\\\": \\\"node scripts/build.js\\\",\r\n    \\\"build:ssr\\\": \\\"npm run build -- web-runtime-cjs,web-server-renderer\\\",\r\n    \\\"build:weex\\\": \\\"npm run build -- weex\\\",\r\n    // ...\r\n  },\r\n```\r\n通过执行npm run build的时候，会进行scripts/build.js文件的执行，npm run build：ssr和npm run build：weex的时候，将ssr和weex作为参数传入，按照参数构建出不一样的vue.js打包文件。\r\n\r\n所以说，`vue`中的`package.json`文件就是构建的入口，具体构建流程可以参考[vue2入口：构建入口](https://juejin.cn/post/7128225931293884452)。\r\n\r\n## 五、对`import Vue from \\\"vue\\\"`的理解\r\n\r\n在使用脚手架开发项目时，会有一行代码`import Vue from \\\"vue\\\"`，那么这个`Vue`指的是什么。<br >\r\n答：一个构造函数。\r\n```\r\nfunction Vue (options) {\r\n  if (process.env.NODE_ENV !== 'production' &&\r\n    !(this instanceof Vue)\r\n  ) {\r\n    warn('Vue is a constructor and should be called with the `new` keyword')\r\n  }\r\n  this._init(options)\r\n}\r\ninitMixin(Vue)\r\nstateMixin(Vue)\r\neventsMixin(Vue)\r\nlifecycleMixin(Vue)\r\nrenderMixin(Vue)\r\n```\r\n我们开发中引入的`Vue`其实就是这个构造函数，而且这个构造函数只能通过`new Vue`的方式进行使用，否则会在控制台打印警告信息。定义完后，还会通过`initMixin(Vue)`、`stateMixin(Vue)`、`eventsMixin(Vue)`、`lifecycleMixin(Vue)`和`renderMixin(Vue)`的方式为`Vue`原型中混入方法。我们通过`import Vue from \\\"Vue\\\"`引入的本质上就是一个原型上挂在了好多方法的构造函数。\r\n\r\n## 六、对`new Vue`的理解\r\n```\r\n// main.js文件\r\nimport Vue from \\\"vue\\\";\r\nvar app = new Vue({\r\n  el: '#app',\r\n  data() {\r\n    return {\r\n      msg: 'hello Vue~'\r\n    }\r\n  },\r\n  template: `<div>{{msg}}</div>`,\r\n})\r\n\r\nconsole.log(app);\r\n```\r\n`new Vue`就是对构造函数`Vue`进行实例化，执行结果如下：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b68a5e0eeda4dc28bd6ca3f2ad0c167~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看出实例化后的实例中包含了很多属性，用来对当前`app`进行描述，当然复杂的`Vue`项目这个`app`将会是一个树结构，通过`$parent`和`$children`维护父子关系。\r\n\r\n`new Vue`的过程中还会执行`this._init`方法进行初始化处理。\r\n\r\n## 七、`编译`\r\n\r\n虚拟`DOM`的生成必须通过`render`函数实现，`render`函数的产生是在编译阶段完成，核心代码如下：\r\n```\r\nexport const createCompiler = createCompilerCreator(function baseCompile (\r\n  template: string,\r\n  options: CompilerOptions\r\n): CompiledResult {\r\n  const ast = parse(template.trim(), options)\r\n  if (options.optimize !== false) {\r\n    optimize(ast, options)\r\n  }\r\n  const code = generate(ast, options)\r\n  return {\r\n    ast,\r\n    render: code.render,\r\n    staticRenderFns: code.staticRenderFns\r\n  }\r\n})\r\n```\r\n主要完成的功能是：\r\n- 通过`const ast = parse(template.trim(), options)`将`template`转换成`ast`树\r\n- 通过`optimize(ast, options)`对`ast`进行优化\r\n- 通过`const code = generate(ast, options)`将优化后的`ast`转换成包含`render`字符串的`code`对象，最终`render`字符串通过`new Function`转换为可执行的`render`函数\r\n\r\n`模板编译的真实入口`可以参考[vue2从template到render：模板编译入口](https://juejin.cn/post/7134253213871505415)<br>\r\n`parse`可以参考[vue2从template到render：AST](https://juejin.cn/post/7134722260870365198)<br>\r\n`optimize`可以参考[vue2从template到render：optimize](https://juejin.cn/post/7136206751602311175)<br>\r\n`generate`可以参考[vue2从template到render：code](https://juejin.cn/post/7135783392133513252)\r\n\r\n## 八、虚拟`DOM`\r\n**先看浏览器对`HTML`的理解**：\r\n```\r\n<div>  \r\n    <h1>My title</h1>  \r\n    Some text content  \r\n    <!-- TODO: Add tagline -->  \r\n</div>\r\n```\r\n当浏览器读到这些代码时，它会建立一个DOM树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。\r\n上述 HTML 对应的 DOM 节点树如下图所示：\r\n\r\n![544ef95bdd7c96a19d700ce613ab425a_dom-tree.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc218300418a46119b2b26f0d9269343~tplv-k3u1fbpfcp-watermark.image?)\r\n每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。\r\n\r\n**再看`Vue`对`HTML template`的理解**\r\n\r\nVue 通过建立一个**虚拟 DOM** 来追踪自己要如何改变真实 DOM。因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“**VNode**”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\r\n\r\n简言之，浏览器对HTML的理解是DOM树，Vue对`HTML`的理解是虚拟DOM，最后在`patch`阶段通过DOM操作的api将其渲染成真实的DOM节点。\r\n\r\n## 九、模板或者组件渲染\r\n`Vue`中的编译会执行到逻辑`vm._update(vm._render(), hydrating)`，其中的`vm._render`执行会获取到`vNode`，`vm._update`就会对`vNode`进行`patch`的处理，又分为模板渲染和组件渲染。\r\n\r\n- 模板渲染，参考[vue2从数据到视图渲染：模板渲染](https://juejin.cn/post/7129095821261275167)\r\n- 组件渲染，参考[vue2从数据到视图渲染：组件渲染](https://juejin.cn/post/7129095821261275167)\r\n\r\n## 十、数据响应式处理\r\n\r\n`Vue`的数据响应式处理的核心是`Object.defineProperty`，在递归响应式处理对象的过程中，为每一个属性定义了一个发布者`dep`，当进行`_render`函数执行时会访问到当前值，在`get`中通过`dep.depend`进行当前`Watcher`的收集，当数据发生变化时会在`set`中通过`dep.notify`进行`Watcher`的更新。\r\n\r\n数据响应式处理以及发布订阅者模式的关系请参考[vue2从数据变化到视图变化：发布订阅模式](https://juejin.cn/post/7130991439965585444)\r\n\r\n## 十一、`this.$set`\r\n```\r\nconst app = new Vue({\r\n  el: \\\"#app\\\",\r\n  data() {\r\n    return {\r\n      obj: {\r\n        name: \\\"name-1\\\"\r\n      }\r\n    };\r\n  },\r\n  template: `<div @click=\\\"change\\\">{{obj.name}}的年龄是{{obj.age}}</div>`,\r\n  methods: {\r\n    change() {\r\n      this.obj.name = 'name-2';\r\n      this.obj.age = 30;\r\n    }\r\n  }\r\n});\r\n```\r\n以上例子执行的结果是：<br>\r\nname-1的年龄是<br>\r\n当点击后依然是：<br>\r\nname-2的年龄是<br>\r\n可以看出点击后，`obj`的`name`属性变化得到了视图更新，而`age`属性并未进行变化。\r\n\r\n`name`属性响应式的过程中锁定了一个发布者`dep`，在当前视图渲染时在发布者`dep`的`subs`中做了记录，一旦其发生改变，就会触发`set`方法中的`dep.notify`，继而执行视图的重新渲染。然而，`age`属性并未进行响应式的处理，当其改变时就不能进行视图渲染。\r\n\r\n此时就需要通过`this.$set`的方式对其进行手动响应式的处理。具体细节请参考 [手动响应式处理和数组检测变化](https://juejin.cn/post/7131280408385159175)\r\n## 十二、组件注册\r\n组件的使用是先注册后使用，又分为：\r\n- 全局注册：可以直接在页面中使用\r\n- 局部注册：使用时需要通过`import xxx from xxx`的方式引入，并且在当前组件的选项`components`中增加局部组件的名称。\r\n\r\n全局注册和局部注册实现原理可以参考 [vue2从数据到视图渲染：组件注册(全局组件/局部组件)](https://juejin.cn/post/7129338204448260109)\r\n\r\n## 十三、异步组件\r\nVue单页面应用中一个页面只有一个`<div id=\\\"app\\\"></div>`承载所有节点，因此复杂项目可能会出现首屏加载白屏等问题，Vue异步组件就很好的处理了这问题。\r\n\r\n异步组件的分类和实现原理请参考 [vue2从数据到视图渲染：异步组件](https://juejin.cn/post/7129784993663942693)\r\n\r\n## 十四、`this.$nextTick`\r\n因为通过`new`实例化构造函数`Vue`的时候会执行初始化方法`this._init`，其中涉及到的方法大多都是同步执行。`nextTick`在vue中是一个很重要的方法，在`new Vue`实例化的同步过程中将一些需要异步处理的函数推到异步队列中去，可以等`new Vue`所有的同步任务执行完后，再执行异步队列中的函数。\r\n\r\n`nextTick`的实现可以参考 [vue2从数据变化到视图变化：nextTick](https://juejin.cn/post/7129855050259628068)，\r\n\r\n\r\n## 十五、`keep-alive`内置组件\r\n`vue`中支持组件化，并且也有用于缓存的内置组件`keep-alive`可直接使用，使用场景为`路由组件`和`动态组件`。\r\n- `activated`表示进入组件的生命周期，`deactivated`表示离开组件的生命周期\r\n- `include`表示匹配到的才缓存，`exclude`表示匹配到的都不缓存\r\n- `max`表示最多可以缓存多少组件\r\n\r\n`keep-alive`的具体实现请参考 [vue中的keep-alive（源码分析）](https://juejin.cn/post/7155828702356439076/)\r\n\r\n## 十六、生命周期\r\n`vue`中的生命周期有哪些？<br>\r\n答案：`11`个，分别为`beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`activated`、`deactivated`、`beforeDestroy`、`destroyed`和`errorCaptured`。\r\n\r\n具体实现请参考 [vue生命周期](https://juejin.cn/post/7140218856152236068)\r\n\r\n## 十七、`v-show`和`v-if`的区别\r\n先看`v-if`和`v-show`的使用场景：\r\n\r\n（1）`v-if`更多的使用在需要考虑白屏时间或者切换次数很少的场景<br>\r\n（2）`v-show`更多使用在`transition`控制的动画或者需要非常频繁地切换的场景\r\n\r\n再从底层实现思路上分析：\r\n\r\n（1）`v-if`条件为`false`时，会生成空的占位注释节点，那么在考虑首页白屏时间时，选用`v-if`比较合适。条件从`false`变化为`true`的话会从空的注释节点变成真实节点，条件再变为`false`时真实节点又会变成注释节点，如果切换次数比较多，那么开销会比较大，频繁切换场景不建议使用`v-if`。<br>\r\n（2）`v-show`条件为`false`时，会生成真实的节点，只是为当前节点增加了`display:none`来控制其隐藏，相比`v-if`生成空的注释节点其首次渲染开销是比较大的，所以不建议用在考虑首屏白屏时间的场景。如果我们频繁切换`v-show`的值，从`display:none`到`display:block`之间的切换比起空的注释节点和真实节点的开销要小很多，这种场景就建议使用`v-show`。\r\n\r\n可以通过[vue中v-if和v-show的区别（源码分析）](https://juejin.cn/post/7139815983979757575)了解`v-if`和`v-show`详细过程。\r\n\r\n## 十八、`v-for`中`key`的作用\r\n在`v-for`进行循环展示过程中，当数据发生变化进行渲染的过程中，会进行新旧节点列表的比对。首先新旧`vnode`列表首先通过`首首`、`尾尾`、`首尾`和`尾首`的方式进行比对，如果`key`相同则采取原地复用的策略进行节点的移动。\r\n\r\n如果首尾两两比对的方式找不到对应关系，继续通过`key`和`vnode`的对应关系进行寻找。\r\n\r\n如果`key`和`vnode`对应关系中找不到，继续通过`sameVnode`的方式在未比对的节点中进行寻找。\r\n\r\n如果都找不到，则将其按照新`vnode`进行`createElm`的方式进行创建，这种方式是比节点移动的方式计算量更大。\r\n\r\n最后将旧的`vnode`列表中没有进行匹配的`vnode`中的`vnode.elm`在父节点中移除。\r\n\r\n简单总结就是，新的`vnode`列表在旧的`vnode`列表中去寻找具有相同的`key`的节点进行原地复用，如果找不到则通过创建的方式`createElm`去创建一个，如果旧的`vnode`列表中没有进行匹配则在父节点中移除其`vnode.elm`。这就是原地复用逻辑的大体实现。\r\n\r\n具体`key`和`diff`算法的关系可以参考[vue2从数据变化到视图变化：diff算法图解](https://juejin.cn/post/7131760211609518094)\r\n\r\n## 十九、`v-for`和`v-if`能同时使用吗\r\n答案是：用了也能出来预期的效果，但是会有性能浪费。\r\n\r\n同时包含`v-for`和`v-if`的`template`模板在编辑阶段会执行`v-for`比`v-if`优先级更高的编译流程；在生成`vnode`的阶段，会包含属性`isComment`为`true`的空白占位`vnode`；在`patch`阶段，会生成真实的占位节点。虽然一个空的占位节点无妨，但是如果数据量比较大的话，也是一个性能问题。\r\n\r\n当然，可以在获取到数据(一般是在`beforeCreate`或者`created`阶段)时进行过滤处理，也可以通过计算属性对其进行处理。\r\n\r\n可以通过[`v-for`和`v-if`可以一起使用吗？](https://juejin.cn/post/7137326610822201357)了解`v-for`和`v-if`的详细过程。\r\n\r\n## 二十、`vue`中的`data`为什么是函数\r\n答案是：是不是一定是函数，得看场景。并且，也无需担心什么时候该将`data`写为函数还是对象，因为`vue`内部已经做了处理，并在控制台输出错误信息。\r\n\r\n**场景一**：`new Vue({data: ...})`<br>\r\n这种场景主要为项目入口或者多个`html`页面各实例化一个`Vue`时，这里的`data`即可用对象的形式，也可用工厂函数返回对象的形式。因为，这里的`data`只会出现一次，不存在重复引用而引起的数据污染问题。\r\n\r\n**场景二**：组件场景中的选项<br>\r\n在生成组件`vnode`的过程中，组件会在生成构造函数的过程中执行合并策略：\r\n```\r\n// data合并策略\r\nstrats.data = function (\r\n  parentVal,\r\n  childVal,\r\n  vm\r\n) {\r\n  if (!vm) {\r\n    if (childVal && typeof childVal !== 'function') {\r\n      process.env.NODE_ENV !== 'production' && warn(\r\n        'The \\\"data\\\" option should be a function ' +\r\n        'that returns a per-instance value in component ' +\r\n        'definitions.',\r\n        vm\r\n      );\r\n\r\n      return parentVal\r\n    }\r\n    return mergeDataOrFn(parentVal, childVal)\r\n  }\r\n\r\n  return mergeDataOrFn(parentVal, childVal, vm)\r\n};\r\n```\r\n如果合并过程中发现子组件的数据不是函数，即`typeof childVal !== 'function'`成立，进而在开发环境会在控制台输出警告并且直接返回`parentVal`，说明这里压根就没有把`childVal`中的任何`data`信息合并到`options`中去。\r\n\r\n\r\n可以通过[`vue`中的`data`为什么是函数？](https://juejin.cn/post/7139925047145316360)了解详细过程。\r\n\r\n## 二十一、`this.$watch`\r\n使用场景：用来监听数据的变化，当数据发生变化的时候，可以做一些业务逻辑的处理。\r\n\r\n配置参数：\r\n- `deep`：监听数据的深层变化\r\n- `immediate`：立即触发回调函数\r\n\r\n实现思路： `Vue`构造函数定义完成以后，在执行`stateMixin(Vue)`时为`Vue.prototype`上定义`$watch`。该方法通过`const watcher = new Watcher(vm, expOrFn, cb, options)`进行`Watcher`的实例化，将`options`中的`user`属性设置为`true`。并且，`$watch`逻辑结束的会返回函数`function unwatchFn () { watcher.teardown() }`，用来取消侦听的函数。\r\n\r\n可以通过`watch`选项和`$watch`方法的区别[vue中的watch和$watch监听的事件，执行几次？](https://juejin.cn/post/7156172339414040584)来了解详细过程。\r\n\r\n## 二十二、计算属性和侦听属性的区别\r\n**相同点：** 两者都是`Watcher`实例化过程中的产物\r\n\r\n**计算属性：**\r\n- 使用场景：模板内的表达式主要用于简单运算，对于复杂的计算逻辑可以用计算属性\r\n- 计算属性是基于它们的响应式依赖进行缓存的，当依赖的数据未发生变化时，多次调用无需重复执行函数\r\n- 计算属性计算结果依赖于`data`中的值\r\n- 同步操作，不支持异步\r\n\r\n**侦听属性：**\r\n- 使用场景：当需要在数据变化时执行异步或开销较大的操作时，可以用侦听属性\r\n- 可配置参数：可以通过配置`immediate`和`deep`来控制立即执行和深度监听的行为\r\n- 侦听属性侦听的是`data`中定义的\r\n\r\n计算属性请参考[vue2从数据变化到视图变化：计算属性](https://juejin.cn/post/7132100391776452615)<br>\r\n侦听属性请参考[vue2从数据变化到视图变化：侦听器](https://juejin.cn/post/7132312215402577956)\r\n\r\n## 二十三、`v-model`\r\n```\r\n// main.js\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  data() {\r\n    return {\r\n      msg: \\\"\\\"\r\n    };\r\n  },\r\n  template: `<div>\r\n    <input v-model=\\\"msg\\\" placeholder=\\\"edit me\\\">\r\n    <p>msg is: {{ msg }}</p>\r\n  </div>`\r\n});\r\n```\r\n**普通input：**`input`中的`v-model`，最终通过`target.addEventListener`处理成在节点上监听`input`事件`function($event){msg=$event.target.value}}`的形式，当`input`值变化时`msg`也跟着改变。\r\n```\r\n// main.js\r\nconst inputBox = {\r\n  template: `<input @input=\\\"$emit('input', $event.target.value)\\\">`,\r\n};\r\n\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>\r\n    <input-box v-model=\\\"msg\\\"></input-box>\r\n    <p>{{msg}}</p>\r\n  </div>`,\r\n  components: {\r\n    inputBox\r\n  },\r\n  data() {\r\n    return {\r\n      msg: 'hello world!'\r\n    };\r\n  },\r\n});\r\n```\r\n**组件**：`v-model`在组件中则通过给点击事件绑定原生事件，当触发到`$emit`的时候，再进行回调函数`ƒunction input($$v) {msg=$$v}`的执行，进而达到子组件修改父组件中数据`msg`的目的。\r\n\r\n## 二十四、`v-slot`\r\n\r\n`v-slot`产生的主要目的是，在组件的使用过程中可以让父组件有修改子组件内容的能力，就像在子组件里面放了个插槽，让父组件往插槽内塞入父组件中的楔子；并且，父组件在子组件中嵌入的楔子也可以访问子组件中的数据。`v-slot`的产生让组件的应用更加灵活。\r\n\r\n### 1、具名插槽\r\n```\r\nlet baseLayout = {\r\n  template: `<div class=\\\"container\\\">\r\n    <header>\r\n      <slot name=\\\"header\\\"></slot>\r\n    </header>\r\n    <main>\r\n      <slot></slot>\r\n    </main>\r\n    <footer>\r\n      <slot name=\\\"footer\\\"></slot>\r\n    </footer>\r\n  </div>`,\r\n  data() {\r\n    return {\r\n      url: \\\"\\\"\r\n    };\r\n  }\r\n};\r\n\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<base-layout>\r\n    <template v-slot:header>\r\n      <h1>title-txt</h1>\r\n    </template>\r\n    <p>paragraph-1-txt</p>\r\n    <p>paragraph-2-txt</p>\r\n    <template v-slot:footer>\r\n      <p>foot-txt</p>\r\n    </template>\r\n  </base-layout>`,\r\n  components: {\r\n    baseLayout\r\n  }\r\n});\r\n```\r\n引入的组件`baseLayout`中的`template`被添加了属性`v-slot:header`和`v-slot:footer`，子组件中定义了对应的插槽被添加了属性`name=\\\"header\\\"`和`name=\\\"footer\\\"`，未被进行插槽标识的内容被插入到了匿名的`<slot></slot>`中。\r\n\r\n### 2、作用域插槽\r\n```\r\nlet currentUser = {\r\n  template: `<span>\r\n    <slot name=\\\"user\\\" v-bind:userData=\\\"childData\\\">{{childData.firstName}}</slot>\r\n  </span>`,\r\n  data() {\r\n    return {\r\n      childData: {\r\n        firstName: \\\"first\\\",\r\n        lastName: \\\"last\\\"\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<current-user>\r\n    <template v-slot:user=\\\"slotProps\\\">{{slotProps.userData.lastName}}</template>\r\n  </current-user>`,\r\n  components: {\r\n    currentUser\r\n  }\r\n});\r\n```\r\n当前例子中作用域插槽通过`v-bind:userData=\\\"childData\\\"`的方式，将`childData`作为参数，父组件中通过`v-slot:user=\\\"slotProps\\\"`的方式进行接收，为父组件使用子组件中的数据提供了可能。\r\n\r\n`v-slot`的底层实现请参考[vue中的v-slot（源码分析）](https://juejin.cn/post/7144188805254709256)\r\n\r\n## 二十五、`Vue.filters`\r\n`filters`类似于管道流可以将上一个过滤函数的结果作为下一个过滤函数的第一个参数，又可以在其中传递参数让过滤器更灵活。\r\n```\r\n// main.js文件\r\nimport Vue from \\\"vue\\\";\r\n\r\nVue.filter(\\\"filterEmpty\\\", function(val) {\r\n  return val || \\\"\\\";\r\n});\r\n\r\nVue.filter(\\\"filterA\\\", function(val) {\r\n  return val + \\\"平时周末的\\\";\r\n});\r\n\r\nVue.filter(\\\"filterB\\\", function(val, info, fn) {\r\n  return val + info + fn;\r\n});\r\n\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>{{msg | filterEmpty | filterA | filterB('爱好是', transformHobby('chess'))}}</div>`,\r\n  data() {\r\n    return {\r\n      msg: \\\"张三\\\"\r\n    };\r\n  },\r\n  methods: {\r\n    transformHobby(type) {\r\n      const map = {\r\n        bike: \\\"骑行\\\",\r\n        chess: \\\"象棋\\\",\r\n        game: \\\"游戏\\\",\r\n        swimming: \\\"游泳\\\"\r\n      };\r\n      return map[type] || \\\"未知\\\";\r\n    }\r\n  }\r\n});\r\n```\r\n其中我们对`msg`通过`filterEmpty`、`filterA`和`filterB('爱好是', transformHobby('chess'))}`进行三层过滤。\r\n\r\n`Vue.filters`的底层实现请查看[vue中的filters（源码分析）](https://juejin.cn/post/7146889304143298597)\r\n\r\n## 二十六、`Vue.use`\r\n- 作用：`Vue.use`被用来安装Vue.js插件，例如`vue-router`、`vuex`、`element-ui`。\r\n- `install`方法：如果插件是一个对象，必须提供 `install` 方法。如果插件是一个函数，它会被作为`install`方法。`install`方法调用时，会将`Vue`作为参数传入。\r\n- 调用时机：该方法需要在调用 `new Vue()` 之前被调用。\r\n- 特点：当 install 方法被同一个插件多次调用，插件将只会被安装一次。\r\n\r\n## 二十七、`Vue.extend`和选项`extends`\r\n### 1、`Vue.extend`\r\n`Vue.extend`使用基础`Vue`构造器创建一个“子类”，参数是一个包含组件选项的对象，实例化的过程中可以修改其中的选项，为实现功能的继承提供了思路。\r\n```\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div><div id=\\\"person1\\\"></div><div id=\\\"person2\\\"></div></div>`,\r\n  mounted() {\r\n    // 定义子类构造函数\r\n    var Profile = Vue.extend({\r\n      template: '<p @click=\\\"showInfo\\\">{{name}} 喜欢 {{fruit}}</p>',\r\n      data: function () {\r\n        return {\r\n          name: '张三',\r\n          fruit: '苹果'\r\n        }\r\n      },\r\n      methods: {\r\n        showInfo() {\r\n          console.log(`${this.name}喜欢${this.fruit}`)\r\n        }\r\n      }\r\n    })\r\n    // 实例化1，挂载到`#person1`上\r\n    new Profile().$mount('#person1')\r\n    // 实例化2，并修改其`data`选项，挂载到`#person2`上\r\n    new Profile({\r\n      data: function () {\r\n        return {\r\n          name: '李四',\r\n          fruit: '香蕉'\r\n        }\r\n      },\r\n    }).$mount('#person2')\r\n  },\r\n});\r\n```\r\n在当前例子中，通过`Vue.extend`构建了子类构造函数`Profile`，可以通过`new Profile`的方式实例化无数个`vm`实例。我们定义初始的`template`、`data`和`methods`供`vm`进行使用，如果有变化，在实例的过程中传入新的选项参数即可，比如例子中实例化第二个`vm`的时候就对`data`进行了调整。\r\n\r\n### 2、选项`extends`\r\n`extends`允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 `Vue.extend`。这主要是为了便于扩展单文件组件，以实现组件继承的目的。\r\n```\r\nconst common = {\r\n  template: `<div>{{name}}</div>`,\r\n  data() {\r\n    return {\r\n      name: '表单'\r\n    }\r\n  }\r\n}\r\n\r\nconst create = {\r\n  extends: common,\r\n  data() {\r\n    return {\r\n      name: '新增表单'\r\n    }\r\n  }\r\n}\r\n\r\nconst edit = {\r\n  extends: common,\r\n  data() {\r\n    return {\r\n      name: '编辑表单'\r\n    }\r\n  }\r\n}\r\n\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>\r\n    <create></create>\r\n    <edit></edit>\r\n  </div>`,\r\n  components: {\r\n    create,\r\n    edit,\r\n  }\r\n});\r\n```\r\n当前极简demo中定义了公共的表单`common`，然后又在新增表单组件`create`和编辑表单组件`edit`中扩展了`common`。\r\n\r\n## 二十八、`Vue.mixin`和选项`mixins`\r\n全局混入和局部混入视情况而定，主要区别在全局混入是通过`Vue.mixin`的方式将选项混入到了`Vue.options`中，在所有获取子组件构建函数的时候都将其进行了合并，是一种影响全部组件的混入策略。\r\n\r\n而局部混入是将选项通过配置`mixins`选项的方式合并到当前的子组件中，只有配置了`mixins`选项的组件才会受到混入影响，是一种局部的混入策略。\r\n\r\n## 二十九、`Vue.directive`和`directives`\r\n### 1、使用场景\r\n\r\n主要用于对于DOM的操作，比如：文本框聚焦，节点位置控制、防抖节流、权限管理、复制操作等功能\r\n\r\n### 2、钩子函数\r\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\r\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\r\n- `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。\r\n- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\r\n- `unbind`：只调用一次，指令与元素解绑时调用。\r\n\r\n### 3、钩子函数参数\r\n- `el`：指令所绑定的元素，可以用来直接操作 DOM。\r\n- `binding`：一个对象，包含以下 property：\r\n    - `name`：指令名，不包括 `v-` 前缀。\r\n    - `value`：指令的绑定值，例如：`v-my-directive=\\\"1 + 1\\\"` 中，绑定值为 `2`。\r\n    - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\r\n    - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\\\"1 + 1\\\"` 中，表达式为 `\\\"1 + 1\\\"`。\r\n    - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\\\"foo\\\"`。\r\n    - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\r\n- `vnode`：Vue 编译生成的虚拟节点。\r\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\r\n\r\n### 4、动态指令参数\r\n\r\n指令的参数可以是动态的。例如，在 `v-mydirective:[argument]=\\\"value\\\"` 中，`argument` 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。\r\n\r\n## 三十、`vue`中的原生事件\r\n`vue`中可以通过`@`或者`v-on`的方式绑定事件，也可为其添加修饰符。\r\n\r\n```\r\nnew Vue({\r\n  el: '#app',\r\n  template: `<div @click='divClick'><a @clickt='aClick' href=''>点击</a></div>`,\r\n  methods: {\r\n    divClick() {\r\n      console.log('divClick')\r\n    },\r\n    aClick() {\r\n      console.log('aClick')\r\n    },\r\n  }\r\n})\r\n```\r\n以上例子如果点击`a`会触发其默认行为，如果`href`不为空还会进行跳转。除此之外，点击还会继续触发`div`上绑定的点击事件。\r\n\r\n如果通过`@click.stop.prevent='aClick'`的方式为`a`标签的点击事件添加修饰符`stop`和`prevent`，那么就不会触发其`a`的默认行为，即使`href`不为空也不会进行跳转，同时，`div`上的点击事件也不会进行触发。\r\n\r\n模板的渲染一般分为编译生成`render`函数、`render`函数执行生成`vNode`和`patch`进行渲染。下面按照这步骤进行简单分析。\r\n### 1、`render`\r\n通过编译生成的`render`函数：\r\n```\r\nwith(this) {\r\n    return _c('div', {\r\n        on: {\r\n            \\\"click\\\": divClick\r\n        }\r\n    }, [_c('a', {\r\n        attrs: {\r\n            \\\"href\\\": \\\"http://www.baidu.com\\\"\r\n        },\r\n        on: {\r\n            \\\"click\\\": function ($event) {\r\n                $event.stopPropagation();\r\n                $event.preventDefault();\r\n                return aClick($event)\r\n            }\r\n        }\r\n    }, [_v(\\\"点击\\\")])])\r\n}\r\n```\r\n其中`div`的`on`作为`div`事件描述。`a`标签的`attrs`作为属性描述，`on`作为事件描述，在描述中`.stop`被编译成了`$event.stopPropagation()`来阻止事件冒泡，`.prevent`被编译成了`$event.preventDefault()`用来阻止`a`标签的默认行为。\r\n### 2、`vNode`\r\n通过执行`Vue.prototype._render`将`render`函数转换成`vNode`。\r\n### 3、`patch`\r\n`patch`的过程中，当完成`$el`节点的渲染后会执行`invokeCreateHooks(vnode, insertedVnodeQueue)`逻辑，其中，针对`attrs`会将其设置为`$el`的真实属性，当前例子中会为`a`标签设置`herf`属性。针对`on`会通过`target.addEventListener`的方式将其处理过的事件绑定到`$el`上，当前例子中会分别对`div`和`a`中的`click`进行处理，再通过`addEventListener`的方式进行绑定。\r\n\r\n### 小结\r\n`vue`中的事件，从编译生成`render`再通过`Vue.prototype._render`函数执行`render`到生成`vNode`，主要是通过`on`作为描述。在`patch`渲染阶段，将`on`描述的事件进行处理再通过`addEventListener`的方式绑定到`$el`上。\r\n\r\n## 三十一、常用修饰符\r\n\r\n### 1、表单修饰符\r\n\r\n#### （1）`.lazy`\r\n在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 ，可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步:\r\n```\r\n<input v-model.lazy=\\\"msg\\\">\r\n```\r\n\r\n#### （2）`.number`\r\n如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\r\n```\r\n<input v-model.number=\\\"age\\\" type=\\\"number\\\">\r\n```\r\n\r\n#### （3）`.trim`\r\n如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\r\n```\r\n<input v-model.trim=\\\"msg\\\">\r\n```\r\n\r\n### 2、事件修饰符\r\n\r\n#### （1）`.stop`\r\n阻止单击事件继续传播。\r\n```\r\n<!--这里只会触发a-->\r\n<div @click=\\\"divClick\\\"><a v-on:click.stop=\\\"aClick\\\">点击</a></div>\r\n```\r\n#### （2）`.prevent`\r\n阻止标签的默认行为。\r\n```\r\n<a href=\\\"http://www.baidu.com\\\" v-on:click.prevent=\\\"aClick\\\">点击</a>\r\n```\r\n\r\n#### （3）`.capture`\r\n事件先在有`.capture`修饰符的节点上触发，然后在其包裹的内部节点中触发。\r\n```\r\n<!--这里先执行divClick事件，然后再执行aClick事件-->\r\n<div @click=\\\"divClick\\\"><a v-on:click=\\\"aClick\\\">点击</a></div>\r\n```\r\n\r\n#### （4）`.self`\r\n只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的。\r\n```\r\n<!--在a标签上点击时只会触发aClick事件，只有点击phrase的时候才会触发divClick事件-->\r\n<div @click.self=\\\"divClick\\\">phrase<a v-on:click=\\\"aClick\\\">点击</a></div>\r\n```\r\n\r\n#### （5）`.once`\r\n不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的组件事件上，表示当前事件只触发一次。\r\n```\r\n<a v-on:click.once=\\\"aClick\\\">点击</a>\r\n```\r\n\r\n#### （6）`.passive`\r\n`.passive` 修饰符尤其能够提升移动端的性能\r\n```\r\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->  \r\n<!-- 而不会等待 `onScroll` 完成 -->  \r\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->  \r\n<div v-on:scroll.passive=\\\"onScroll\\\">...</div>\r\n```\r\n\r\n### 3、其他修饰符\r\n除了表单和事件的修饰符，`Vue`还提供了很多其他修饰符，在使用的时候可以查阅文档。\r\n\r\n### 小结\r\n> `Vue`中提供了很多好用的功能和`api`，那么修饰符的出现就为功能和`api`提供了更为丰富的扩展属性和更大的灵活度。\r\n\r\n## 三十二、`vue-router`\r\n`vue`路由是单页面中视图切换的方案，有三种`mode`:\r\n- hash，#后的仅仅作为参数，不属于url部分\r\n- history，路径作为请求url请求资源链接，如果找不到会出现404错误\r\n- abstract，服务端渲染场景\r\nhash场景下，会出现`url`链接，再修改其view-router中对应的值。\r\n\r\n了解`vue-router`的底层实现请参考[vue2视图切换：vue-router](https://juejin.cn/post/7141965586099077157)\r\n\r\n## 三十三、`vuex`\r\n`vuex`是状态管理仓库，一般使用的场景为：多个视图依赖于同一状态，来自不同视图的行为需要变更同一状态。其管理的状态是响应式的，修改也只能显式提交`mutation`的方式修改。`vuex`有`state`、`getter`、`mutation`、`action`和`module`五个核心，并且通过`module`实现了`vuex`树的管理。\r\n\r\n了解`vuex`的底层实现请参考[vue2状态管理：vuex](https://juejin.cn/post/7141965586099077157)\r\n\r\n## 三十四、`eventBus`\r\n**使用场景**：兄弟组件传参\r\n```\r\nconst eventBus = new Vue();\r\n\r\nconst A = {\r\n  template: `<div @click=\\\"send\\\">component-a</div>`,\r\n  methods: {\r\n    send() {\r\n      eventBus.$emit('sendData', 'data from A')\r\n    }\r\n  },\r\n}\r\n\r\nconst B = {\r\n  template: `<div>component-b</div>`,\r\n  created() {\r\n    eventBus.$on('sendData', (args) => {\r\n      console.log(args)\r\n    })\r\n  },\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A,\r\n    B,\r\n  },\r\n  template: `<div><A></A><B></B></div>`,\r\n})\r\n```\r\n在当前例子中，`A`组件和`B`组件称为兄弟组件，`A`组件通过事件总线`eventBus`中的`$emit`分发事件，`B`组件则通过`$on`来监听事件。\r\n\r\n**实现原理：**`eventsMixin`\r\n```\r\nexport function eventsMixin (Vue: Class<Component>) {\r\n  const hookRE = /^hook:/\r\n  Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {\r\n    const vm: Component = this\r\n    if (Array.isArray(event)) {\r\n      for (let i = 0, l = event.length; i < l; i++) {\r\n        vm.$on(event[i], fn)\r\n      }\r\n    } else {\r\n      (vm._events[event] || (vm._events[event] = [])).push(fn)\r\n      // optimize hook:event cost by using a boolean flag marked at registration\r\n      // instead of a hash lookup\r\n      if (hookRE.test(event)) {\r\n        vm._hasHookEvent = true\r\n      }\r\n    }\r\n    return vm\r\n  }\r\n\r\n  Vue.prototype.$once = function (event: string, fn: Function): Component {\r\n    const vm: Component = this\r\n    function on () {\r\n      vm.$off(event, on)\r\n      fn.apply(vm, arguments)\r\n    }\r\n    on.fn = fn\r\n    vm.$on(event, on)\r\n    return vm\r\n  }\r\n\r\n  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {\r\n    const vm: Component = this\r\n    // all\r\n    if (!arguments.length) {\r\n      vm._events = Object.create(null)\r\n      return vm\r\n    }\r\n    // array of events\r\n    if (Array.isArray(event)) {\r\n      for (let i = 0, l = event.length; i < l; i++) {\r\n        vm.$off(event[i], fn)\r\n      }\r\n      return vm\r\n    }\r\n    // specific event\r\n    const cbs = vm._events[event]\r\n    if (!cbs) {\r\n      return vm\r\n    }\r\n    if (!fn) {\r\n      vm._events[event] = null\r\n      return vm\r\n    }\r\n    // specific handler\r\n    let cb\r\n    let i = cbs.length\r\n    while (i--) {\r\n      cb = cbs[i]\r\n      if (cb === fn || cb.fn === fn) {\r\n        cbs.splice(i, 1)\r\n        break\r\n      }\r\n    }\r\n    return vm\r\n  }\r\n\r\n  Vue.prototype.$emit = function (event: string): Component {\r\n    const vm: Component = this\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      const lowerCaseEvent = event.toLowerCase()\r\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\r\n        tip(\r\n          `Event \\\"${lowerCaseEvent}\\\" is emitted in component ` +\r\n          `${formatComponentName(vm)} but the handler is registered for \\\"${event}\\\". ` +\r\n          `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n          `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n          `You should probably use \\\"${hyphenate(event)}\\\" instead of \\\"${event}\\\".`\r\n        )\r\n      }\r\n    }\r\n    let cbs = vm._events[event]\r\n    if (cbs) {\r\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs\r\n      const args = toArray(arguments, 1)\r\n      const info = `event handler for \\\"${event}\\\"`\r\n      for (let i = 0, l = cbs.length; i < l; i++) {\r\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info)\r\n      }\r\n    }\r\n    return vm\r\n  }\r\n}\r\n```\r\n在`Vue`构造函数定义完执行的`eventsMixin`函数中，在`Vue.prototype`上分别定义了`$on`、`$emit`、`$off`和`$once`的方法易实现对事件的绑定、分发、取消和只执行一次的方法。`eventBus`就是利用了当`new Vue`实例化后实例上的`$on`、`$emit`、`$off`和`$once`进行数据传递。\r\n\r\n## 三十五、`ref`\r\n**使用场景：** 父组件获取子组件数据或者执行子组件方法\r\n```\r\nconst A = {\r\n  template: `<div>{{childData.age}}</div>`,\r\n  data() {\r\n    return {\r\n      childData: {\r\n        name: 'qb',\r\n        age: 30\r\n      },\r\n    }\r\n  },\r\n  methods: {\r\n    increaseAge() {\r\n      this.childData.age++;\r\n    }\r\n  }\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A,\r\n  },\r\n  template: `<A ref='childRef' @click.native='changeChildData'></A>`,\r\n  methods: {\r\n    changeChildData() {\r\n      // 执行子组件的方法\r\n      this.$refs.childRef.increaseAge()\r\n      // 获取子组件的数据\r\n      console.log(this.$refs.childRef.childData);\r\n    },\r\n  }\r\n})\r\n```\r\n在当前例子中，通过`ref='childRef'`的方式在当前组件中定义一个`ref`，可以通过`this.$refs.childRef`的方式获取到子组件`A`。可以通过`this.$refs.childRef.increaseAge()`的方式执行子组件中`age`增加的方法，也可以通过`this.$refs.childRef.childData`的方式获取到子组件中的数据。\r\n\r\n## 三十六、`props`\r\n**使用场景：** 父子传参\r\n```\r\nconst A = {\r\n  template: `<div @click='emitData'>{{childData}}</div>`,\r\n  props: ['childData'],\r\n  methods: {\r\n    emitData() {\r\n      this.$emit('emitChildData', 'data from child')\r\n    }\r\n  },\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A\r\n  },\r\n  template: `<A :childData='parentData' @emitChildData='getChildData'></A>`,\r\n  data() {\r\n    return {\r\n      parentData: 'data from parent'\r\n    }\r\n  },\r\n  methods: {\r\n    getChildData(v) {\r\n      console.log(v);\r\n    }\r\n  }\r\n})\r\n```\r\n从当前例子中可以看出，数据父传子是通过`:childData='parentData'`的方式，数据子传父是通过`this.$emit('emitChildData', 'data from child')`的方式，然后，父组件通过`@emitChildData='getChildData'`的方式进行获取。\r\n\r\n### 1、父组件`render`函数\r\n`new Vue`中传入的模板`template`经过遍历生成的`render`函数如下：\r\n```\r\nwith(this) {\r\n    return _c('A', {\r\n        attrs: {\r\n            \\\"childData\\\": parentData\r\n        },\r\n        on: {\r\n            \\\"emitChildData\\\": getChildData\r\n        }\r\n    })\r\n}\r\n```\r\n其中`data`部分有`attrs`和`on`来描述属性和方法。\r\n\r\n在通过`createComponent`创建组件`vnode`的过程中，会通过`const propsData = extractPropsFromVNodeData(data, Ctor, tag)`的方式获取`props`，通过`const listeners = data.on`的方式获取`listeners`，最后将其作为参数通过`new VNode(options)`的方式实例化组件`vnode`。\r\n\r\n### 2、子组件渲染\r\n在通过`const child = vnode.componentInstance = createComponentInstanceForVnode(\r\n        vnode,\r\n        activeInstance\r\n      )`创建组件实例的过程中，会执行到组件继承自`Vue`的`._init`方法，通过`initEvents`将事件处理后存储到`vm._events`中，通过`initProps`将`childData`赋值到子组件`A`的`vm`实例上，并进行响应式处理，让其可以通过`vm.childData`的方式访问，并且数据发生变化时视图也可以发生改变。\r\n      \r\n组件模板编译后对应的`render`函数是:\r\n```\r\nwith(this) {\r\n    return _c('div', {\r\n        on: {\r\n            \\\"click\\\": emitData\r\n        }\r\n    }, [_v(_s(childData))])\r\n}\r\n```\r\n在`createElm`完成节点的创建后，在`invokeCreateHooks(vnode, insertedVnodeQueue)`阶段，给`DOM`原生节点节点绑定`emitData`。\r\n\r\n### 3、`this.$emit`\r\n在点击执行`this.$emit`时，会通过`var cbs = vm._events[event]`取出`_events`中的事件进行执行。\r\n\r\n至此，父组件中的传递的数据就在子组件中可以通过`this.xxx`的方式获得，也可以通过`this.$emit`的方式将子组件中的数据传递给父组件。\r\n\r\n`prop`数据发生改变引起视图变化的底层逻辑请参考[vue2从数据变化到视图变化：props引起视图变化详解](https://juejin.cn/post/7132758292681457700)\r\n\r\n## 三十七、`$attrs`和`$listeners`\r\n**使用场景：** 父子组件非`props`属性和非`native`方法传递\r\n```\r\n// main.js文件\r\nimport Vue from \\\"vue\\\";\r\n\r\nconst B = {\r\n  template: `<div @click=\\\"emitData\\\">{{ formParentData }}</div>`,\r\n  data() {\r\n    return {\r\n      formParentData: ''\r\n    }\r\n  },\r\n  inheritAttrs: false,\r\n\r\n  created() {\r\n    this.formParentData = this.$attrs;\r\n    console.log(this.$attrs, '--------------a-component-$attrs')\r\n    console.log(this.$listeners, '--------------b-component-$listeners')\r\n  },\r\n  methods: {\r\n    emitData() {\r\n      this.$emit('onFun', 'form B component')\r\n    }\r\n  },\r\n}\r\n\r\nconst A = {\r\n  template: `<B v-bind='$attrs' v-on='$listeners'></B>`,\r\n  components: {\r\n    B,\r\n  },\r\n  props: ['propData'],\r\n  inheritAttrs: false,\r\n  created() {\r\n    console.log(this.$attrs, '--------------b-component-$attrs')\r\n    console.log(this.$listeners, '--------------b-component-$listeners')\r\n  }\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A,\r\n  },\r\n  template: `<A :attrData='parentData' :propData='parentData' @click.native=\\\"nativeFun\\\" @onFun=\\\"onFun\\\"></A>`,\r\n  data() {\r\n    return {\r\n      parentData: 'msg'\r\n    }\r\n  },\r\n  methods: {\r\n    nativeFun() {\r\n      console.log('方法A');\r\n    },\r\n    onFun(v) {\r\n      console.log('方法B', v);\r\n    },\r\n  }\r\n})\r\n```\r\n当前例子中，`new Vue`的`template`模板中有`attrData`、`propData`、`click.native`和`onFun`在进行传递。实际运行后，在`A`组件中`this.$attrs`为`{attrData: 'msg'}`，`this.$listeners`为`{onFun:f(...)}`。在`A`组件中通过`v-bind='$attrs'`和`v-on='$listeners'`的方式继续进行属性和方法的传递，在`B`组件中就可以获取到`A`组件中传入的`$attrs`和`$listeners`。\r\n\r\n当前例子中完成了非`props`属性和非`native`方法的传递，并且通过`v-bind='$attrs'`和`v-on='$listeners'`的方式实现了属性和方法的跨层级传递。\r\n\r\n同时通过`this.$emit`的方法触发了根节点中`onFun`事件。\r\n\r\n关于例子中的`inheritAttrs: false`，默认情况下父作用域的不被认作`props`的`attribute`绑定将会“回退”且作为普通的`HTML`属性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置`inheritAttrs`到`false`，这些默认行为将会被去掉。\r\n\r\n## 三十八、`$parent`和`$children`\r\n**使用场景：** 利用父子关系进行数据的获取或者方法的调用\r\n```\r\nconst A = {\r\n  template: `<div @click=\\\"changeParentData\\\">{{childRandom}}</div>`,\r\n  data() {\r\n    return {\r\n      childRandom: Math.random()\r\n    }\r\n  },\r\n  mounted() {\r\n    console.log(this.$parent.parentCount, '--child-created--'); // 获取父组件中的parentCount\r\n  },\r\n  methods: {\r\n    changeParentData() {\r\n      console.log(this.$parent); // 打印当前实例的$parent\r\n      this.$parent.changeParentData(); // 调用当前父级中的方法`changeParentData`\r\n    },\r\n    changeChildData() {\r\n      this.childRandom = Math.random();\r\n    }\r\n  }\r\n}\r\nconst B = {\r\n  template: `<div>b-component</div>`,\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A,\r\n    B,\r\n  },\r\n  template: `<div><A></A><B></B><p>{{parentCount}}</p><button  @click=\\\"changeChildrenData\\\">修改子组件数据</button></div>`,\r\n  data() {\r\n    return {\r\n      parentCount: 1\r\n    }\r\n  },\r\n  mounted() {\r\n    console.log(this.$children[0].childRandom, '--parent-created--'); // 获取第一个子组件中的childRandom\r\n  },\r\n  methods: {\r\n    changeParentData() {\r\n      this.parentCount++;\r\n    },\r\n    changeChildrenData() {\r\n      console.log(this.$children); // 此时有两个子组件\r\n      this.$children[0].changeChildData(); // 调起第一个子组件中的'changeChildData'方法\r\n    }\r\n  }\r\n})\r\n```\r\n在当前例子中，父组件可以通过`this.$children`获取所有的子组件，这里有`A`组件和`B`组件，可以通过`this.$children[0].childRandom`的方式获取子组件`A`中的数据，也可以通过`this.$children[0].changeChildData()`的方式调起子组件`A`中的方法。\r\n\r\n子组件可以通过`this.$parent`的方式获取父组件，可以通过`this.$parent.parentCount`获取父组件中的数据，也可以通过`this.$parent.changeParentData()`的方式修改父组件中的数据。\r\n\r\n`Vue`中`$parent`和`$children`父子关系的底层构建请参考[杂谈：$parent/$children的底层逻辑](https://juejin.cn/post/7162097166725414942/)\r\n\r\n## 三十九、`inject`和`provide`\r\n使用场景：嵌套组件多层级传参\r\n```\r\nconst B = {\r\n  template: `<div>{{parentData1}}{{parentData2}}</div>`,\r\n  inject: ['parentData1', 'parentData2'],\r\n}\r\n\r\nconst A = {\r\n  template: `<B></B>`,\r\n  components: {\r\n    B,\r\n  },\r\n}\r\n\r\nnew Vue({\r\n  el: '#app',\r\n  components: {\r\n    A,\r\n  },\r\n  template: `<A></A>`,\r\n  provide: {\r\n    parentData1: {\r\n      name: 'name-2',\r\n      age: 30\r\n    },\r\n    parentData2: {\r\n      name: 'name-2',\r\n      age: 29\r\n    },\r\n  }\r\n})\r\n```\r\n例子中在`new Vue`的时候通过`provide`提供了两个数据来源`parentData1`和`parentData2`，然后跨了一个`A`组件在`B`组件中通过`inject`注入了这两个数据。\r\n\r\n### 1、`initProvide` \r\n在执行组件内部的`this._init`初始化方法时，会执行到`initProvide`逻辑：\r\n```\r\nexport function initProvide (vm: Component) {\r\n  const provide = vm.$options.provide\r\n  if (provide) {\r\n    vm._provided = typeof provide === 'function'\r\n      ? provide.call(vm)\r\n      : provide\r\n  }\r\n}\r\n```\r\n如果在当前`vm.$options`中存在`provide`，会将其执行结果赋值给`vm._provided`。\r\n### 2、`initInjections`\r\n```\r\nfunction initInjections (vm: Component) {\r\n  const result = resolveInject(vm.$options.inject, vm)\r\n  if (result) {\r\n    toggleObserving(false)\r\n    Object.keys(result).forEach(key => {\r\n      /* istanbul ignore else */\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        defineReactive(vm, key, result[key], () => {\r\n          warn(\r\n            `Avoid mutating an injected value directly since the changes will be ` +\r\n            `overwritten whenever the provided component re-renders. ` +\r\n            `injection being mutated: \\\"${key}\\\"`,\r\n            vm\r\n          )\r\n        })\r\n      } else {\r\n        defineReactive(vm, key, result[key])\r\n      }\r\n    })\r\n    toggleObserving(true)\r\n  }\r\n}\r\nfunction resolveInject (inject: any, vm: Component): ?Object {\r\n  if (inject) {\r\n    // inject is :any because flow is not smart enough to figure out cached\r\n    const result = Object.create(null)\r\n    const keys = hasSymbol\r\n      ? Reflect.ownKeys(inject)\r\n      : Object.keys(inject)\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const key = keys[i]\r\n      // #6574 in case the inject object is observed...\r\n      if (key === '__ob__') continue\r\n      const provideKey = inject[key].from\r\n      let source = vm\r\n      while (source) {\r\n        if (source._provided && hasOwn(source._provided, provideKey)) {\r\n          result[key] = source._provided[provideKey]\r\n          break\r\n        }\r\n        source = source.$parent\r\n      }\r\n      if (!source) {\r\n        if ('default' in inject[key]) {\r\n          const provideDefault = inject[key].default\r\n          result[key] = typeof provideDefault === 'function'\r\n            ? provideDefault.call(vm)\r\n            : provideDefault\r\n        } else if (process.env.NODE_ENV !== 'production') {\r\n          warn(`Injection \\\"${key}\\\" not found`, vm)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n如果当前组件中有选项`inject`，会以`while`循环的方式不断在`source = source.$parent`中寻找`_provided`，然后获取到祖先组件中提供的数据源，这是实现祖先组件向所有子孙后代注入依赖的核心。\r\n\r\n## 四十、`Vue`项目能做的性能优化\r\n### 1、`v-if`和`v-show`\r\n- 频繁切换时使用`v-show`，利用其缓存特性\r\n- 首屏渲染时使用`v-if`，如果为`false`则不进行渲染\r\n### 2、`v-for`的`key`\r\n- 列表变化时，循环时使用唯一不变的`key`，借助其本地复用策略\r\n- 列表只进行一次渲染时，`key`可以采用循环的`index`\r\n### 3、侦听器和计算属性\r\n- 侦听器`watch`用于数据变化时引起其他行为\r\n- 多使用`compouter`计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算\r\n### 4、合理使用生命周期\r\n- 在`destroyed`阶段进行绑定事件或者定时器的销毁\r\n- 使用动态组件的时候通过`keep-alive`包裹进行缓存处理，相关的操作可以在`actived`阶段激活\r\n### 5、数据响应式处理\r\n- 不需要响应式处理的数据可以通过`Object.freeze`处理，或者直接通过`this.xxx = xxx`的方式进行定义\r\n- 需要响应式处理的属性可以通过`this.$set`的方式处理，而不是`JSON.parse(JSON.stringify(XXX))`的方式\r\n### 6、路由加载方式\r\n- 页面组件可以采用异步加载的方式\r\n### 7、插件引入\r\n- 第三方插件可以采用按需加载的方式，比如`element-ui`。\r\n### 8、减少代码量\r\n- 采用`mixin`的方式抽离公共方法\r\n- 抽离公共组件\r\n- 定义公共方法至公共`js`中\r\n- 抽离公共`css`\r\n### 9、编译方式\r\n- 如果线上需要`template`的编译，可以采用完成版`vue.esm.js`\r\n- 如果线上无需`template`的编译，可采用运行时版本`vue.runtime.esm.js`，相比完整版体积要小大约`30%`\r\n### 10、渲染方式\r\n- 服务端渲染，如果是需要`SEO`的网站可以采用服务端渲染的方式\r\n- 前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式\r\n### 11、字体图标的使用\r\n- 有些图片图标尽可能使用字体图标\r\n\r\n## 四十一、`Vue`项目白屏问题\r\n- 1、开启`gzip`压缩减小文件体积。\r\n- 2、`webpack`设置`productionSourceMap:false`，不在线上环境打包`.map`文件。\r\n- 3、路由懒加载\r\n- 4、异步组件的使用\r\n- 5、静态资源使用`cdn`链接引入\r\n- 6、采用`ssr`服务端渲染方案\r\n- 7、骨架屏或者`loading`效果填充空白间隙\r\n- 8、首次不渲染的隐藏采用`v-if`\r\n- 9、注重代码规范：抽取公共组件，公共js，公共css样式，减小代码体积。删除无用代码，减少非必要注释。防止写出死循环等等\r\n- 10、删除辅助开发的`console.log`\r\n- 11、非`Vue`角度思考：非重要文件采用异步加载方式、css样式采用媒体查询、采用域名分片技术、http1升级成http2、如果是SSR项目考虑服务端渲染有没有可优化的点、请求头是否带了多余信息等思路\r\n\r\n内容有些多，大体可以归类为从服务端拿到资源的速度、资源的体积和渲染是否阻塞的角度去作答。\r\n\r\n## 四十二、从`0`到`1`构建一个`Vue`项目需要注意什么\r\n- 架子：选用合适的初始化脚手架(`vue-cli2.0`或者`vue-cli3.0`)\r\n- 请求：数据`axios`请求的配置\r\n- 登录：登录注册系统\r\n- 路由：路由管理页面\r\n- 数据：`vuex`全局数据管理\r\n- 权限：权限管理系统\r\n- 埋点：埋点系统\r\n- 插件：第三方插件的选取以及引入方式\r\n- 错误：错误页面\r\n- 入口：前端资源直接当静态资源，或者服务端模板拉取\r\n- `SEO`：如果考虑`SEO`建议采用`SSR`方案\r\n- 组件：基础组件/业务组件\r\n- 样式：样式预处理起，公共样式抽取\r\n- 方法：公共方法抽离\r\n\r\n## 四十三、`SSR`\r\n### 1、什么是服务端渲染（SSR）？\r\nVue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\\\"激活\\\"为客户端上完全可交互的应用程序。\r\n### 2、为什么使用服务端渲染（SSR）？\r\n与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：\r\n- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\r\n- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。\r\n### 3、使用服务器端渲染 (SSR) 时需要考虑的问题？\r\n使用服务器端渲染 (SSR) 时还需要有一些权衡之处\r\n-   开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。\r\n-   涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。\r\n-   更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\r\n\r\n## 四十四、`scoped`\r\n在`Vue`项目开发的项目中如果样式中未使用`scoped`，组件间的样式会出现覆盖的问题。\r\n\r\n**反例：**\r\n```\r\n// app.vue文件\r\n<template>\r\n  <div>\r\n    <h3 class=\\\"title\\\">app-txt</h3>\r\n    <child></child>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport child from \\\"@/components/child\\\";\r\nexport default {\r\n  components: { child },\r\n};\r\n</script>\r\n\r\n<style>\r\n.title {\r\n  color: red;\r\n}\r\n</style>\r\n```\r\n\r\n```\r\n// child.vue文件\r\n<template>\r\n  <h3 class=\\\"title\\\">child-txt</h3>\r\n</template>\r\n\r\n<style>\r\n  .title {\r\n    color: green;\r\n  }\r\n</style>\r\n```\r\n\r\n父组件和子组件的样式颜色都为`green`，子组件中的样式覆盖了父组件的样式。\r\n\r\n**正例：**\r\n\r\n```\r\n<template>\r\n  <h3 class=\\\"title\\\">child-txt</h3>\r\n</template>\r\n\r\n<style scoped>\r\n  .title {\r\n    color: green;\r\n  }\r\n</style>\r\n```\r\n此时，父组件中颜色为`red`，子组件中颜色为`green`。\r\n\r\n**主要原因：**\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b3818e9f4e40a9acc00e957c114b71~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8343809daa3f49a98914c238b13e1ae7~tplv-k3u1fbpfcp-watermark.image?)\r\n例子中的DOM节点和CSS层叠样式中都被添加了`data-v-xxx`来表示唯一，所以`scoped`是给当前组件的节点和样式唯一标识为`data-v-xxx`，避免了样式覆盖。\r\n\r\n## 四十五、`created`、`watch`和`computed`的执行顺序\r\n\r\n请参考 [杂谈：vue中created、watch和computed的执行顺序](https://juejin.cn/post/7169990997223407646)\r\n\r\n## 四十六、`created`中两次数据修改，会触发几次页面更新\r\n\r\n请参考 [杂谈：created中两次数据修改，会触发几次页面更新？](https://juejin.cn/post/7170248485705351175)\r\n\r\n## 写在最后\r\n\r\n在寒冬里，依然要有一颗火热的心，一起加油~"
    },
    {
        "article_id": "7163835739447230501",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ec7e2875754e168186053e9b0a75eb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "前端架构师的一些思考和总结",
        "preview": "加入大淘宝到现在也有六年多了，一路走来很开心可以一直做技术。负责过业务、基础库、工具以及架构，期望自己不断成长。想对之前的工作做一些思考和记录，也想为后续的工作找一个合适的开始。",
        "author": "阿里巴巴大淘宝技术",
        "view_count": 20190,
        "collect_count": 369,
        "comment_count": 37,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/fe6354fc1957bc85218bf6454b8f96e0~300x300.image",
        "category": "前端",
        "content": "> 大淘宝技术前端工程师梧忌推荐语：有幸在大淘宝与洋风同学共事了一段时间。他在终端架构侧有丰富的经验，他所打造的终端调试工具 AppDevTools 、终端请求库 mtop.js 在阿里内部被广泛使用。洋风从自己的经验出发，在这篇文章中讲述了前端架构师的工作范畴和如何做好前端架构，相信对于期望往该方向成长的同学会有所帮助。\r\n\r\n加入大淘宝到现在也有六年多了，一路走来很开心可以一直做技术。负责过业务、基础库、工具以及架构，期望自己不断成长。想对之前的工作做一些思考和记录，也想为后续的工作找一个合适的开始。有蛮多话想说的，这次就先从 “前端架构” 这个话题慢慢说起吧。\r\n\r\n# 聊聊架构\r\n好的代码和差的代码都能运行，但我们会追求好的代码，获得更好的维护性和可读性。同理没有架构的系统也能工作，但如果一个业务团队没有好的架构，整个团队将陷入混乱，最终难以支撑业务快速变化。  \r\n架构是为了解决问题，将复杂、模糊的问题，变得清晰、有逻辑。问题的尺度上，可以大到整个公司的系统设计，也可以小到一个模块如何渲染。问题的时间上，可以是当下的问题，也可以是预期以后会发生的问题。如何做好结构和如何解决好问题有很多相似之处，比如把复杂问题简单化，比如找到多种解决方案并在其中找到最合适有效的方案，比如要考虑成本和实现，控制好风险等等。网上也有很多关于架构设计的原则和思维等，这里就不在赘述了。  \r\n**我所追求的架构，不仅要清晰有逻辑，还要简单灵活好扩展；能切实解决问题，也能支撑业务快速稳定发展，并不断演进。**\r\n\r\n# 聊聊前端架构师\r\n所谓架构师，通俗的说就是架构的设计者或构建者。《架构师到底是做什么的？》很有意思，其中有一段话是这么说的：\r\n> 一个架构师， 好的架构师， 就是反复做四件事：第一，先选一个好的挑战， 第二， 把简单的东西想复杂 ；第三， 把复杂的东西做简单；第四， 最后把复杂的东西讲简单。\r\n> \r\n> 做第一件事是为了创造价值， 第二件事是为了控制好风险和准备好未来， 做第三件事请是为了做好产品且控制好成本， 而做第四件事情是为了做好传承。\r\n\r\n架构师必须依靠团队的支持，不同的专注领域衍生出不同的架构师，这里主要聊聊前端架构师。曾有人说前端架构师就是选选框架，搞搞文件目录就可以了，但伴随基础设施的发展、大前端体系的不断增大以及用户体验的不断升级，前端架构师有了更大的价值和更高的上限。围绕用户体验链路，前端架构师可以将具有不同关注点的团队联系起来，包括产品、设计、前端、服务端、客户端、工程、数据、运维等团队，用户视角也能帮助前端架构师发现更多问题。围绕大前端技术，前端架构师可以主导所有技术体系的设计和实现，甚至会影响组织架构的调整（比如终端工程师的诞生）。\r\n\r\n当然前端架构师的目标也离不开高性能、高可用、易扩展以及解决系统复杂度。举个解决首屏加载速度慢问题的例子，我们做了以下事情：\r\n\r\n1.  了解业务：全面调研当前业务和竞品的现状，充分理解当前渲染链路和节点，确认当前存在的问题\r\n1.  寻找方案：预估未来发展的方向，尽可能多的了解相关解决方案或创新自己的方案，比如：SSR，ER，预渲染，预加载，静态化等\r\n1.  评估方案：和相关同学讨论或开会，评估所有可行的方案及其合适度、复杂度、前瞻性和 ROI。选出至少一个候选方案，比如：SSR\r\n1.  Demo 开发：基于现有开发能力为所有候选方案开发对应 Demo，提前探路并验证风险和可行性，帮助产出更合适的方案设计\r\n1.  方案设计：梳理清楚 SSR 完整链路上相关节点和合作方，多写、多画、多思考、多讨论相关架构和设计，深入细节产出 RFC 文档\r\n1.  RFC 评审：充分评审设计、实现和产物细节，可多次评审直至所有成员达成共识。确定相关开发和团队分工，保证方案完善可执行\r\n1.  落到实处：推进项目开发，多与开发团队沟通，并至少参与一部分编码工作，打通所有相关开发和运维链路，保障产物简单好用\r\n1.  沉淀传承：沉淀文档，通过会议、分享或文章帮助其他人理解 SSR 方案和架构，用好 SSR。做好答疑，并推动方案实施\r\n1.  不断演进：关注 SSR 的发展，演进已有链路，比如，个性化的 SSR，结合 ER 的 SSR 等\r\n\r\n从开发、构建发布到全量用户使用，从数据衡量到问题排查，我们交付了一个完整的 SSR 方案，其中处处有前端架构师的设计和影响。\r\n\r\n前端架构师是否和你想象的有所不同？不仅仅要产出架构图，保证架构的正确执行，深入实现并至少要参与一部分编码工作，落实一个一个解决方案同时，前端架构师也要能阅读代码并经常与各个开发团队交流。可以说整个用户体验链路都有前端架构师的影子，他们了解用户体验；不设限，有审美能力，优雅；能看到其他人看不到的问题，也能解决一些其他人解决不了的问题；能够把复杂的系统想得清楚和透彻，也能够了解各个模块和环节；对未来发展有自己的思考和判断，并不断解决 DX 和 UX 相关问题。\r\n\r\n# 思考和总结\r\n\r\n回顾过去的工作，得益于团队的信任及大前端的不断演进，我可以不断学习思考实践、权衡重构及与人打交道，令我非常愉悦，受益匪浅。严格来说我应该算个前端解决方案架构师，在前端架构的方向，我也还有很多需要发展和改善的地方，下面梳理下个人的思考和总结：我认为一个好的架构师，不仅技术要好，还要懂业务；能从整体设计架构，也能在局部实现功能。首先，技术好是成为架构师的基础条件。在平常的开发中，需要多注意让你的代码容易阅读和扩展，多想想是否有更好的实现方式，多参与代码审查工作。这样通过大量的编码实践，可以逐步地培养出好的架构思维。成为架构师后也要多写代码，如果不写代码，是不能体会出开发的痛点和设计不好带来的问题，无法及时地对架构中的问题做出调整，所设计的架构可能不实用，甚至甚脱离现实。\r\n\r\n架构师不同于高级开发可以只追求技术的深度，还需要有一定的技术广度。因为技术的选型，通常不能局限于一种技术，需要根据业务特点和团队特点灵活地选择，是 “T”字形的成长模型：\r\n\r\n1.  广度：做技术方案时，要有多种选择，最好可以熟悉各个链路的关系\r\n1.  深度：要能解决一些别人搞不定的问题，至少也能指导从某个方向入手排查\r\n\r\n其次，要充分理解业务并时刻关注业务变化，使架构不仅能够很好地支持业务特点，并具有一定的前瞻性。架构师需要站在推进业务发展的角度上合理地改进和优化架构设计，为业务的快速发展做好保障。做“合适”的架构非常重要，避免拿着锤子找钉子。\r\n\r\n再者，要做一个靠谱并有良好的沟通和协调能力的人。架构师往往要面临着跨组、跨团队甚至跨 BU 的一些技术方案，需要在互相信任的前提下沟通和协调各方的诉求和冲突。好的架构师也可以让业务、技术、团队一起变得更好。\r\n\r\n最后，我想说其实做架构设计，并不代表一定要有一个架构师的头衔。每个人都可以参与到架构设计中来，只要心中有大局有架构思维，能理解当前架构设计，不断更好的优化和执行，就能写出好代码做出好架构，提升整体的凝聚力和战斗力。\r\n\r\n要想成为好的架构师，没有什么捷径可以走。持续的学习，不停的思考，多问为什么，多想想还能不能更好。愿大家都可以成为一个优秀靠谱的程序员、架构师。"
    },
    {
        "article_id": "7187206201363398717",
        "snapshot": "",
        "title": "select for update加了行锁还是表锁？",
        "preview": "大家，我是田螺。 最近在开发需求的时候，用到了select......for update。在代码评审的时候，一位同事说 ，唯一索引+一个非索引字段，是否可能会锁全表呢？本文田螺哥将通过9个实验证明",
        "author": "捡田螺的小男孩",
        "view_count": 2988,
        "collect_count": 76,
        "comment_count": 6,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/84f7320d757a1a90652f1c80b639fcd5~300x300.image",
        "category": "后端",
        "content": "## 前言\r\n\r\n大家，我是**田螺**。\r\n\r\n最近在开发需求的时候，**用到了```select......for update```**。在代码评审的时候，一位同事说\r\n，```唯一索引+一个非索引字段```，是否可能会**锁全表**呢？本文田螺哥将通过```9```个实验操作的例子，给大家验证```select......for update```到底加了什么锁，**是表锁还是行锁**。\r\n\r\n以下是**本文的提纲**哈：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1905d9c8b349ca871f335e269d7f72~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n因为加锁是跟**数据库的隔离级别**息息相关的。而常用的数据库隔离级别也就```RC(读已提交)和RR(可重复读)```，所以本文分别根据RC(读已提交) 和 RR(可重复读)隔离级别展开讲述。\r\n\r\n- **公众号**：捡田螺的小男孩\r\n- github地址，感谢每颗star：[github](https://github.com/whx123/JavaHome)\r\n\r\n\r\n## 1. 环境准备\r\n\r\n**设置数据库隔隔离级别**\r\n```\r\nmysql> set global TRANSACTION ISOLATION level read COMMITTED;\r\nQuery OK, 0 rows affected (0.00 sec)\r\n\r\nmysql> select @@transaction_isolation;\r\n+-------------------------+\r\n| @@transaction_isolation |\r\n+-------------------------+\r\n| READ-COMMITTED          |\r\n+-------------------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n**自动提交关闭**\r\n```\r\nmysql> set @@autocommit=0;  //设置自动提交关闭\r\nQuery OK, 0 rows affected (0.00 sec)\r\n\r\nmysql> select @@autocommit;\r\n+--------------+\r\n| @@autocommit |\r\n+--------------+\r\n|            0 |\r\n+--------------+\r\n1 row in set (0.00 sec)\r\n\r\n```\r\n\r\n\r\n\r\n**建表语句**\r\n```\r\nCREATE TABLE `user_info_tab` (\r\n  `id` int NOT NULL AUTO_INCREMENT,\r\n  `author` varchar(255) DEFAULT NULL,\r\n  `age` int DEFAULT NULL,\r\n  `city` varchar(255) DEFAULT NULL,\r\n  `status` varchar(4) NOT NULL DEFAULT '0',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `idx_author` (`author`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=1570072 DEFAULT CHARSET=utf8mb3;\r\n```\r\n\r\n**初始化数据**(接下来的实验证明，都是基于这几条初始数据)\r\n```\r\ninsert into user_info_tab(`author`,`age`,`city`,`status`) values('杰伦',18,'深圳','1');\r\ninsert into user_info_tab(`author`,`age`,`city`,`status`) values('奕迅',26,'湛江','0');\r\ninsert into user_info_tab(`author`,`age`,`city`,`status`) values('俊杰',28,'广州','1');\r\n```\r\n\r\n**MYSQL 版本**\r\n\r\n```\r\nmysql> select @@version;  \r\n+-----------+\r\n| @@version |\r\n+-----------+\r\n| 8.0.31    |\r\n+-----------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n\r\n## 2.RC 隔离级别\r\n\r\n### 2.1 RC隔离级别 + 唯一索引\r\n\r\n先把隔离级别设置为```RC```，因为```author```为唯一索引，我们使用```author```为条件去执行```select......for update```语句，然后开启另外一个事务**去更新数据同一条数据，发现被阻塞了**。如下图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a900f8a56c8b4414b5aa50c249857843~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n事务二的更新语句为什么会**阻塞**呢？ \r\n> 因为事务一的```select......for update```已经加了锁了嘛。那加的是**行锁还是表锁**呢？ 如果加的是表锁的话，我们更新其他行的记录的话，应该是也会阻塞的，如果是行锁的话，更新其他记录是可以顺利执行的。\r\n\r\n大家可以再看下这个图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27b643bfaf984119a39dd15220edbfb4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**通过实验，可以发现**:如果事务中是更新其他行记录的话，是可以顺利执行的。**因此在RC隔离级别下**，如果条件是唯一索引，**那么```select......for update```加的应该是行锁**。\r\n\r\n**有些小伙伴会很好奇，到底加了什么锁呢？** 接下来带大家看看，具体加的是什么锁。\r\n\r\n我用的```MySQL```版本是```8.0+```,用这个语句查看：\r\n```\r\nSELECT * FROM performance_schema.data_locks\\\\G;\r\n```\r\n\r\n如下图，```select * from  user_info_tab  where author ='杰伦' for update```语句一共加了三把锁，分别是 **```IX```意向排他锁（表级别的锁，不影响插入）、两把```X```排他锁（行锁，分别对应唯一索引，主键索引）**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8138ac1d86641d199bac2813fc9dd73~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n有些读者朋友说，这里不是加了```IX```表锁嘛？**为什么不阻塞其他行的更新？** 其实这个是**意向排他锁**。\r\n> 意向排他锁：简称```IX```锁，当事务准备在某条记录上加上```X```锁时，需要在表级别加一个IX锁。如```select ... for update```，要给表设置```IX锁```;\r\n\r\n那既然有**表锁**，为啥事务二在执行其他行的更新语句时，并不会阻塞，这是因为：**意向锁仅仅表明意向的锁，意向锁之间不会互斥，是可以并行的。**，锁的兼容性如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9d8df240f1488d802f7dca98bf400f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n有些小伙伴可能还有疑问，**为啥会有两把的X锁呢？** 不是都锁住的是同一行嘛？其实**RC隔离**级别下，**唯一索引的加锁**是这样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595d32ae60d149d38db75f984a1587f8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n**为什么不是唯一索引上加X锁就可以了呢？为什么主键索引上的记录也要加锁呢？**\r\n\r\n> 如果并发的一个SQL，通过唯一索引条件，来更新**主键索引**：```update user_info_tab set author = '学友' where id = '1570068'```;此时，如果```select...for update```语句没有将主键索引上的记录加锁，那么并发的```update```就会感知不到```select...for update```语句的存在，违背了**同一记录**上的**更新/删除**需要串行执行的约束。\r\n\r\n\r\n大家如果对于锁这块基础知识，还是有疑问的话，可以看下我之前的这篇文章哈：[两万字详解！InnoDB锁专题！](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=554600777&lang=zh_CN#rd)\r\n\r\n\r\n### 2.2 RC 隔离级别 + 主键 \r\n\r\n在```RC 隔离级别```下，如果```select......for update```的查询条件是```主键id```，加的又是什么锁呢？\r\n\r\n我们执行语句：```select * from user_info_tab where id ='1570070' for update;```然后开启另外一个事务**去更新数据同一条数据，发现被阻塞了**。如下图：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2de09ada364283bfc8dcf640a802d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n如果**事务二**更新的是其他行的记录，则是可以顺利执行的，如下图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed3d684e30954eafa67331e861ef42cf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n**通过实验，可以发现**:\r\n> 如果事务中是更新其他行记录的话，是可以顺利执行的。**因此在RC隔离级别下**，如果条件是主键，**那么```select......for update```锁的也是行**。\r\n\r\n根据**2.1小节**的结论，```select......for update```**都会加**个表级别的```IX```意向排他锁。所以，查询条件是```id```的话，```select......for update```会加两把锁，分表是```IX意向排他锁（表锁，不影响插入）```、```一把X排他锁（行锁，对于主键索引）```\r\n\r\n我们执行语句，查询一下到底加的是什么锁。\r\n```\r\nbegin;\r\nselect * from user_info_tab where id ='1570070' for update;\r\nSELECT * FROM performance_schema.data_locks\\\\G;\r\n```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6d23d1e34ff46e7bc8fbb345a5e5ed6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**因此在RC隔离级别下**，如果条件是主键，**那么```select......for update```加的就是两把锁**，一把```IX```意向排他锁（不影响插入），一把对应主键的```X```排他锁（**行锁，会锁住那一行**）。\r\n\r\n\r\n### 2.3 RC 隔离级别 + 普通索引\r\n\r\n\r\n在```RC 隔离级别```下，如果```select......for update```的查询条件是```普通索引```，加的又是什么锁呢？\r\n\r\n我们这里先给原来表加上普通索引：\r\n```\r\nalter table user_info_tab add index idx_city (city);\r\n```\r\n\r\n我们执行语句：```select * from user_info_tab where city ='广州' for update;```然后开启另外一个事务**去更新同一条数据，发现被阻塞了**。如下图：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29ac556dc9534c0ab53d84a499532dfb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n如果**事务二**更新的是其他行的记录，还是可以顺利执行的，如下图：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ee4cb34ea6542c7a3cef2cae2d80374~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们看一下```select * from user_info_tab where city ='广州' for update;```到底加了什么锁，如下图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b128c6355c48b9abdfb9ad5e0d8d7f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n发现一共加了三把锁，分别是：```IX意向排他锁（表锁）```、```两把X排他锁（行锁，分别对应普通索引的X锁，对应主键的X锁）```。\r\n\r\n如果查询条件，**没有命中数据库表的记录**，**又加什么锁呢？**\r\n\r\n我们把查询条件改一下：```select * from user_info_tab where city ='广州' and status='0' for update;```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e2542026ff4ce8974b91d4abec8837~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**发现只加了一把锁**，即```IX意向排他锁（表锁，不影响插入）```。\r\n\r\n### 2.4 RC 隔离级别 + 无索引\r\n\r\n在```RC 隔离级别```下，如果```select......for update```的查询条件是**无索引**呢，加的又是什么锁呢？\r\n\r\n多数读者凭感觉都是**锁表**了，我们来验证一下。\r\n\r\n我们执行语句：```select * from user_info_tab where age ='26' for update;```（age是没有加索引的），然后开启另外一个事务去更新数据。如下图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd4c1bb673674efd93ad3573bcb6f917~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n由上图可以发现，**事务一** 先执行```select......for update```，然后事务二先更新别的行，发现可以顺利执行，如果执行```for update```的同一行，**还是会阻塞等待**。\r\n\r\n可推出结论，```select......for update```的查询条件是**无索引**，主要还是**行锁**。我们看下具体的加锁情况：\r\n```\r\nSELECT * FROM performance_schema.data_locks\\\\G;\r\n```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0bd8f4735d4432b941302588a6dfb75~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n发现一共加了两把锁，分别是：```IX意向排他锁（表锁）```、```一把X排他锁（行锁，对应主键的X锁）```。\r\n\r\n这个为啥呢？**为什么不是一个锁表的X锁呢？** 这是因为:\r\n\r\n> 若```age```列上没有索引，MySQL会走聚簇(主键)索引进行**全表扫描**过滤。**每条记录都会加上X锁**。但是，为了效率考虑，**MySQL在这方面进行了改进，在扫描过程中，若记录不满足过滤条件，会进行解锁操作**。同时优化违背了2PL原则。\r\n\r\n\r\n## 3.RR 隔离级别\r\n\r\n\r\n### 3.1  RR隔离级别 + 唯一索引\r\n\r\n如果是**RR（可重复）的数据库隔离级别**呢，```select......for update```的查询条件是**唯一索引**的话，加的又是什么锁呢？\r\n\r\n我们知道```RR隔离级别```比```RC隔离级别```，主要差异还是有**间隙锁**这个概念。接下来我们还是通过实验去验证，先把数据库隔离级别设置为```RR```：\r\n\r\n> mysql> set global transaction isolation level repeatable read; (**设置完好像要重启一下**)\r\n> \r\n> Query OK, 0 rows affected (0.00 sec)\r\n\r\n\r\n我们执行语句：```select * from  user_info_tab  where author ='杰伦' for update;```（**author是唯一索引的**），然后开启另外一个事务去更新数据。如下图：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0f3adec9614ec6b350669d019d94cc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n由上图可以发现，即使是RR数据库隔离级别，事务一先执行```select......for update```，然后事务一先更新别的行，发现可以顺利执行，如果执行更新```for update```的那一行，**还是会阻塞超时**。\r\n\r\n再去看下具体加了什么锁：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02eba36672f044fdb96d189c4649600f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n大家可以发现，**不管是RC隔离级别还是RR隔离级别**，```select......for update```，查询条件是唯一索引，**命中数据库表记录时**，一共会加三把锁：一把```IX```意向排他锁 **（表锁，不影响插入）**，一把对应主键的```X```排他锁（**行锁**），一把对应唯一索引的X排他锁 **（行锁）**。\r\n\r\n\r\n### 3.2 RR 隔离级别 + 主键\r\n\r\n如果是 **RR**（可重复读）的数据库隔离级别，```select......for update```的查询条件是**主键**的话，加的又是什么锁呢？\r\n\r\n根据前面的实验结果，我们其实可以推测得出来了，应该跟RC隔离级别一样，会加两把锁：一把```IX```意向排他锁（**表锁，不影响插入**），一把对应主键的```X```排他锁（**行锁，影响对应主键那一行的插入**）。\r\n\r\n我们通过语句确认一下，先输入一下语句：\r\n```\r\nbegin;\r\nselect * from user_info_tab where id ='1570070' for update;\r\nSELECT * FROM performance_schema.data_locks\\\\G;\r\n```\r\n大家可以看下，跟我们的推测是一样的：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/076d3d5b1b174caab0eda6efa6c68567~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 3.3 RR 隔离级别 + 普通索引\r\n\r\n在RR隔离级别下，如果```select......for update```的查询条件是普通索引的话，**除了会加X锁，IX锁，还会加Gap 锁**。\r\n\r\n> Gap锁的提出，是为了解决幻读问题引入的，它是一种加在两个索引之间的锁。\r\n\r\n我们来验证一下，先开始事务一，执行一下操作：\r\n\r\n```\r\nbegin;\r\nselect * from user_info_tab where city ='广州' for update;\r\n```\r\n接着开启事务\r\n```\r\nbegin;\r\ninsert into user_info_tab(`author`,`age`,`city`,`status`) values('方燕',27,'汕头','1');\r\n```\r\n\r\n验证流程图如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa32d4fd6039426ba80a93157e67f71c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n大家可以发现，插入新记录，会被阻塞，那是因为**有间隙锁**的缘故，我们再看下到底加了哪些锁：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0c922d66679413dbafebc6270d1006c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n发现相对于**RC隔离级别**，确实多了**间隙**锁，锁住范围了。我画了这种场景的加锁示意图，大家可以看一下：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e77090ddb4a45bcb759b2515251dfb2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n如果要插入汕头城市的记录，会被Gap锁锁住了，因此会阻塞。\r\n\r\n因此，在RR隔离级别下，如果```select......for update```的查询条件是普通索引的话，命中查询记录的话，除了会加**两把X锁（行锁），IX锁（表锁，不影响插入），还会加Gap 锁（间隙锁，会影响插入）**。\r\n\r\n大家如果对**间隙锁**这块不是很熟悉的话，可以看下我以前的这篇文章哈，[两万字详解！InnoDB锁专题！](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=554600777&lang=zh_CN#rd)\r\n\r\n\r\n\r\n### 3.4  RR隔离级别 + 无索引\r\n\r\n在RR隔离级别下，如果```select......for update```的查询条件是无索引的话，**会锁全表嘛**？来一起验证一下\r\n\r\n我们直接按顺序执行以下这些语句：\r\n\r\n```\r\nbegin;\r\nselect * from user_info_tab where age ='26' for update;\r\nselect OBJECT_NAME,INDEX_NAME, LOCK_TYPE,LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\r\n```\r\n\r\n可以发现加了这么多锁：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/214ad492ba584df8846abb565ec982c0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n一共**五**把锁，这个```IX```锁（表级别，意向排他锁），我们可以理解，跟前面几个例子的一样。后面三把行锁，就是把每一行的数据记录，都加了X排他锁（行锁，锁的对象对应于```主键Id```），我们也可以理解。 但是这个第二行，**是一把怎么样的X锁**呢？\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc2c9570a9e4e468269a5e1c342f814~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我谷歌了一下,什么是```supremum pseudo-record```，找到了这个解释:\r\n\r\n> For the last interval, the next-key lock locks the gap above the largest value in the index and the “supremum” pseudo-record having a value higher than any value actually in the index. The supremum is not a real index record, so, in effect, this next-key lock locks only the gap following the largest index value.\r\n\r\n翻译过来，大概意思就是：**相当于比索引中所有值都大，但却不存在索引中，相当于最后一行之后的间隙锁**。我理解就是如果查询条件有索引的话，类似于一个（索引最大值，+无穷）的虚拟间隙锁。\r\n\r\n但是因为我们的查询字段```age```**并没有索引**，锁为```X```锁，```lock_data```值为```supremum pseudo-record```，它表示：**全表行锁**，**要走聚簇索引进行全部扫描**。\r\n\r\n也就是说RR隔离级别下，对于```select......for update```，**查询条件无索引**的话，会加一个```IX锁```（表锁，不影响插入），每一行实际记录行的```X锁```，还有对应于```supremum pseudo-record```的**虚拟全表行锁**。这种场景，通俗点讲，其实就是**锁表了**。\r\n\r\n我们来做个实验，验证虚拟全表行锁的存在，先开启事务一，执行：\r\n```\r\nbegin;\r\nselect * from user_info_tab where age ='26' for update;\r\n```\r\n\r\n然后开启事务二，执行一个插入语句:\r\n```\r\nbegin;\r\ninsert into user_info_tab(id,`author`,`age`,`city`,`status`) values(1,'小明',31,'北京','1');\r\n```\r\n\r\n大家可以看下，阻塞了，:\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9169551c32143d39f49afe77bc51fdb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 加餐\r\n\r\n都写到这里了，大家有没有发现，田螺哥列举RR数据库隔离级别的例子，```select......for update```条件都是命中数据库表记录的。在这里，田螺哥给大家出道题。在```RR```隔离级别下，如果```select......for update```的查询条件，是**没命中当前数据表记录的话**，又加什么锁呢？\r\n\r\n我们来搞点刺激的，```select......for update``` 搞两个条件：一个唯一索引(```author```) + 一个无索引(```status```)，然后没命中当前数据表记录，你觉得会加什么锁呢?\r\n```\r\nCREATE TABLE `user_info_tab` (\r\n  `id` int NOT NULL AUTO_INCREMENT,\r\n  `author` varchar(255) DEFAULT NULL,\r\n  `age` int DEFAULT NULL,\r\n  `city` varchar(255) DEFAULT NULL,\r\n  `status` varchar(4) NOT NULL DEFAULT '0',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `idx_author` (`author`) USING BTREE,\r\n  KEY `idx_city` (`city`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=1570074 DEFAULT CHARSET=utf8mb3\r\n```\r\n\r\n我们按顺序执行者几条语句：\r\n\r\n```\r\nbegin;\r\nselect * from  user_info_tab  where author ='杰伦'  and status ='0'  for update ;\r\nselect OBJECT_NAME,INDEX_NAME, LOCK_TYPE,LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\r\n```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d789c67a4cf4697bc24052c97fa7367~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 最后\r\n\r\n我是捡田螺的小男孩。通过本文，大家学到哪些知识点呢？\r\n\r\n1. ```select......for update```在不同场景，都加了什么锁\r\n2. 如何查看一个SQL 加了什么锁 （执行完原生SQL，再执行```SELECT * FROM performance_schema.data_lock```）\r\n3. 如何手写个死锁 (分别开两个事务，制造锁冲突，文章的例子，好多都是死锁的case)\r\n\r\n本文是我**通过实验对比**的结论，如果大家觉得哪里不对的话，可以在留言区讨论哈。如果本文对你有帮助的话，麻烦给田螺哥一个三连（点赞、在看、转发分享）支持一下，感谢~\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7165771303898021902",
        "snapshot": "",
        "title": "我的摆烂空间(小程序)",
        "preview": "前言 不忙的时候就想做些东西，记得之前遇到过类似日记类的小程序，趁这次空闲做了个小程序《摆烂空间》 位置、天气 头部展示了位置和天气，wx.getLocation获取地理位置，上线前记得申请此api权",
        "author": "追旅",
        "view_count": 3990,
        "collect_count": 38,
        "comment_count": 44,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/bba1e572ee18fa7dadb1c486cb2f0649~300x300.image",
        "category": "前端",
        "content": "## 前言\r\n\r\n不忙的时候就想做些东西，记得之前遇到过类似日记类的小程序，趁这次空闲做了个小程序《摆烂空间》\r\n\r\n\r\n![xcx.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ee6ec865704480b2ae971a9adb227c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![space3.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e417c5a46cb4a08aeae10623a20d0ef~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![space2.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c8f00c303746708619e3124bcb3b15~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![space1.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bf5f271f9a2430b8df13b7fd5ca40ce~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 位置、天气\r\n\r\n头部展示了位置和天气，```wx.getLocation```获取地理位置，上线前记得申请此```api```权限，拿到经纬度后可以调用[和风天气](https://id.qweather.com/#/homepage)接口查询城市、天气情况，如下\r\n\r\n```js\r\nwx.getLocation({\r\n  type: 'wgs84',\r\n  success(res) {\r\n    const { latitude, longitude } = res ?? {}\r\n    // 获取城市\r\n    wx.request({\r\n      url: `https://geoapi.qweather.com/v2/city/lookup?location=${longitude},${latitude}&key=${key}`,\r\n      success: data => console.log(data)\r\n      // {name: \\\"滨江\\\", id: \\\"101210114\\\", lat: \\\"30.20661\\\", lon: \\\"120.21061\\\", adm2: \\\"杭州\\\", …}\r\n    })\r\n    // 获取天气\r\n    wx.request({\r\n      url: `https://devapi.qweather.com/v7/weather/now?location=${longitude},${latitude}&key=${key}`,\r\n      success: data => console.log(data)\r\n      // now: {obsTime: \\\"2022-11-14T14:55+08:00\\\", temp: \\\"12\\\", feelsLike: \\\"9\\\", icon: \\\"104\\\", text: \\\"阴\\\", …}\r\n    })\r\n  },\r\n  fail(error) {\r\n    console.warn('error: ', error)\r\n  }\r\n})\r\n```\r\n\r\n## 下班倒计时、节日\r\n\r\n下班倒计时不多说，写个定时器即可。周末、法定节假日调用找到的免费接口，获取当天信息如下(都是免费接口，最喜欢白嫖了)\r\n\r\n```js\r\nwx.request({\r\n  url: `https://timor.tech/api/holiday/info/${year}-${month}-${day}`,\r\n  success: ({ data }) => console.log(data)\r\n  // type: {type: 0, name: \\\"周一\\\", week: 1} 0 表示工作日，1表示周末，2表示法定节假日\r\n})\r\n```\r\n\r\n该接口返回```type```字段可以区分当天是工作日、周末还是法定节假日\r\n\r\n另外一个接口可以提供一些趣味提示，如距离下个法定节假日的时间等等，该接口有缓存作用，常导致获取的信息不正确，所以加个随机```id```参数获取最新数据\r\n\r\n```js\r\nwx.request({\r\n  url: `https://timor.tech/api/holiday/tts?id=${Math.random()}`,\r\n  success: ({ data }) => console.log(data)\r\n  // {code: 0, tts: \\\"还有5天就是周六了，先好好工作吧！最近的一个节日是元旦。还要47天。早着呢！\\\"}\r\n})\r\n```\r\n\r\n## 摆烂人生\r\n\r\n展示退休时间、距退休时间、收入、发薪日、随机下班吃什么做什么，可以通过设置初始化自己的个人信息\r\n\r\n## 摆烂幸运数\r\n\r\n自己经常买彩票，这里```大乐透```和```双色球```，但是敏感词无法过审，所以换了名字\r\n\r\n## 摆烂姿势\r\n\r\n网上看到过一些有意思的摆烂姿势，在这里加一个摆烂姿势模块\r\n\r\n\r\n## 结语\r\n\r\n云开发也收费了，所以很多数据是本地缓存，以后再也不能白嫖了。其实我觉得可以添加一些房贷车贷等模块，计算出道退休时能否真正摆烂，然后再给一些趣味提示，或者做一些休闲小游戏，摆烂日记等等模块。感兴趣小伙伴可以喊我一起做事情\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7188029263201697851",
        "snapshot": "",
        "title": "多线程代码，性能怎么优化！",
        "preview": "Java 中最烦人的，就是多线程，一不小心，代码写的比单线程还慢，这就让人非常尴尬。 通常情况下，我们会使用 ThreadLocal 实现线程封闭，比如避免 SimpleDateFormat 在并发环",
        "author": "QuanLiu",
        "view_count": 2195,
        "collect_count": 19,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ca18d3794b52ad6b805a61fc4cde26d2~300x300.image",
        "category": "后端",
        "content": "Java 中最烦人的，就是多线程，一不小心，代码写的比单线程还慢，这就让人非常尴尬。\r\n\r\n通常情况下，我们会使用 ThreadLocal 实现线程封闭，比如避免 SimpleDateFormat 在并发环境下所引起的一些不一致情况。其实还有一种解决方式。通过对parse方法进行加锁，也能保证日期处理类的正确运行，代码如图。![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8be5ada966ce4c27915b6e761b54821b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n1\\\\. 锁很坏\r\n-------\r\n\r\n但是，锁这个东西，很坏。就像你的贞操锁，一开一闭热情早已烟消云散。\r\n\r\n所以，锁对性能的影响，是非常大的。对资源加锁以后，资源就被加锁的线程所独占，其他的线程就只能排队等待这个锁。此时，程序由并行执行，变相的变成了顺序执行，执行速度自然就降低了。\r\n\r\n下面是开启了50个线程，使用ThreadLocal和同步锁方式性能的一个对比。\r\n\r\n    Benchmark  Mode  Cnt       Score      Error   UnitsSynchronizedNormalBenchmark.sync         \r\n    thrpt      10  2554.628 ± 5098.059  ops/msSynchronizedNormalBenchmark.threadLocal  thrpt   10  3750.902 ±  103.528  ops/ms\r\n    ========去掉业务影响========  \r\n    Benchmark  Mode  Cnt          Score        Error   UnitsSynchronizedNormalBenchmark.sync         \r\n    thrpt      10    26905.514 ±   1688.600  ops/msSynchronizedNormalBenchmark.threadLocal  thrpt   10  7041876.244 ± 355598.686  ops/ms\r\n\r\n可以看到，使用同步锁的方式，性能是比较低的。如果去掉业务本身逻辑的影响（删掉执行逻辑），这个差异会更大。代码执行的次数越多，锁的累加影响越大，对锁本身的速度优化，是非常重要的。\r\n\r\n我们都知道，Java 中有两种加锁的方式，一种就是常见的synchronized 关键字，另外一种，就是使用 concurrent 包里面的 Lock。针对于这两种锁，JDK 自身做了很多的优化，它们的实现方式也是不同的。\r\n\r\n2\\\\. synchronied原理\r\n-----------------\r\n\r\nsynchronized关键字给代码或者方法上锁时，都有显示的或者隐藏的上锁对象。当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。\r\n\r\n*   给普通方法加锁时，上锁的对象是`this`\r\n    \r\n*   给静态方法加锁时，锁的是class对象。\r\n    \r\n*   给代码块加锁，可以指定一个具体的对象作为锁\r\n    \r\n\r\nmonitor，在操作系统里，其实就叫做管程。\r\n\r\n那么，synchronized 在字节码中，是怎么体现的呢？参照下面的代码，在命令行执行`javac`，然后再执行`javap -v -p`，就可以看到它具体的字节码。可以看到，在字节码的体现上，它只给方法加了一个flag：`ACC_SYNCHRONIZED`。\r\n\r\n    synchronized void syncMethod() {  \r\n    System.out.println(\\\"syncMethod\\\");\r\n    }\r\n    ======字节码=====\r\n    synchronized void syncMethod();    \r\n    descriptor: ()\r\n    V    \r\n    flags: ACC_SYNCHRONIZED   \r\n    Code:      stack=2, locals=1, args_size=1         \r\n    0: getstatic     #4                          \r\n    3: ldc           #5                                  \r\n    5: invokevirtual #6                    \r\n    8: return\r\n\r\n我们再来看下同步代码块的字节码。可以看到，字节码是通过`monitorenter`和`monitorexit`两个指令进行控制的。  \r\n\r\n    void syncBlock(){    \r\n    synchronized (Test.class){    \r\n    }\r\n    }\r\n    ======字节码======\r\n    void syncBlock();    \r\n    descriptor: ()\r\n    V    \r\n    flags:    \r\n    Code:      \r\n    stack=2, locals=3, args_size=1        \r\n    0: ldc           #2          \r\n    2: dup         \r\n    3: astore_1        \r\n    4: monitorenter        \r\n    5: aload_1         \r\n    6: monitorexit         \r\n    7: goto          15        \r\n    10: astore_2        \r\n    11: aload_1        \r\n    12: monitorexit        \r\n    13: aload_2        \r\n    14: athrow        \r\n    15: return      Exception \r\n    table:         from    to  target type             5     7    10   any            10    13    10   any\r\n\r\n这两者虽然显示效果不同，但他们都是通过`monitor`来实现同步的。我们可以通过下面这张图，来看一下monitor的原理。\r\n\r\n注意了，下面是面试题目高发地。\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca240b718cce40ec88a34129810545af~tplv-k3u1fbpfcp-watermark.image?)如图所示，我们可以把运行时的对象锁抽象的分成三部分。其中，EntrySet 和WaitSet 是两个队列，中间虚线部分是当前持有锁的线程。我们可以想象一下线程的执行过程。  \r\n\r\n当第一个线程到来时，发现并没有线程持有对象锁，它会直接成为活动线程，进入 RUNNING 状态。\r\n\r\n接着又来了三个线程，要争抢对象锁。此时，这三个线程发现锁已经被占用了，就先进入 EntrySet 缓存起来，进入 BLOCKED 状态。此时，从`jstack`命令，可以看到他们展示的信息都是`waiting for monitor entry`。\r\n\r\n    \\\"http-nio-8084-exec-120\\\" #143 daemon prio=5 os_prio=31 cpu=122.86ms elapsed=317.88s tid=0x00007fedd8381000 nid=0x1af03 waiting for monitor entry  [0x00007000150e1000]   \r\n    java.lang.Thread.State: BLOCKED (on object monitor)    \r\n    at java.io.BufferedInputStream.read(java.base@13.0.1/BufferedInputStream.java:263)    \r\n    - waiting to lock <0x0000000782e1b590> (a java.io.BufferedInputStream)    \r\n    at org.apache.commons.httpclient.HttpParser.readRawLine(HttpParser.java:78)    \r\n    at org.apache.commons.httpclient.HttpParser.readLine(HttpParser.java:106)    \r\n    at org.apache.commons.httpclient.HttpConnection.readLine(HttpConnection.java:1116)    \r\n    at org.apache.commons.httpclient.HttpMethodBase.readStatusLine(HttpMethodBase.java:1973)    \r\n    at org.apache.commons.httpclient.HttpMethodBase.readResponse(HttpMethodBase.java:1735)\r\n\r\n处于活动状态的线程，执行完毕退出了；或者由于某种原因执行了wait 方法，释放了对象锁，就会进入 WaitSet 队列。这就是在调用`wait`之前，需要先获得对象锁的原因。就像下面的代码：  \r\n\r\n    synchronized (lock){   \r\n     try {         \r\n    lock.wait();    \r\n    } \r\n    catch (InterruptedException e) {        \r\n    e.printStackTrace();    \r\n    }\r\n    }\r\n\r\n此时，`jstack`显示的线程状态是 WAITING 状态，而原因是`in Object.wait()`。  \r\n\r\n    \\\"wait-demo\\\" #12 prio=5 os_prio=31 cpu=0.14ms elapsed=12.58s tid=0x00007fb66609e000 nid=0x6103 in Object.wait()  [0x000070000f2bd000]   \r\n    java.lang.Thread.State: WAITING (on object monitor)    \r\n    at java.lang.Object.wait(java.base@13.0.1/Native Method)    \r\n    - waiting on <0x0000000787b48300> (a java.lang.Object)   \r\n    at java.lang.Object.wait(java.base@13.0.1/Object.java:326)    \r\n    at WaitDemo.lambda$main$0(WaitDemo.java:7)    \r\n    - locked <0x0000000787b48300> (a java.lang.Object)    \r\n    at WaitDemo$$Lambda$14/0x0000000800b44840.run(Unknown Source)    \r\n    at java.lang.Thread.run(java.base@13.0.1/Thread.java:830)\r\n\r\n发生了这两种情况，都会造成对象锁的释放。进而导致 EntrySet里的线程重新争抢对象锁，成功抢到锁的线程成为活动线程，这是一个循环的过程。\r\n\r\n那 WaitSet 中的线程是如何再次被激活的呢？接下来，在某个地方，执行了锁的 notify 或者 notifyAll 命令，会造成WaitSet中 的线程，转移到 EntrySet 中，重新进行锁的争夺。\r\n\r\n如此周而复始，线程就可按顺序排队执行。\r\n\r\n3\\\\. 分级锁\r\n-------\r\n\r\nJDK1.8中，synchronized 的速度已经有了显著的提升。那它都做了哪些优化呢？答案就是分级锁。JVM会根据使用情况，对synchronized 的锁，进行升级，它大体可以按照下面的路径：偏向锁->轻量级锁->重量级锁。\r\n\r\n锁只能升级，不能降级，所以一旦升级为重量级锁，就只能依靠操作系统进行调度。\r\n\r\n和锁升级关系最大的就是对象头里的 MarkWord，它包含`Thread ID`、`Age`、`Biased`、`Tag`四个部分。其中，Biased 有1bit大小，Tag 有2bit，锁升级就是靠判断Thread Id、Biased、Tag等三个变量值来进行的。\r\n\r\n#### 偏向锁\r\n\r\n在只有一个线程使用了锁的情况下，偏向锁能够保证更高的效率。\r\n\r\n具体过程是这样的。当`第一个`线程`第一次`访问同步块时，会先检测对象头`Mark Word`中的标志位`Tag`是否为01，以此判断此时对象锁是否处于无锁状态或者偏向锁状态（匿名偏向锁）。\r\n\r\n`01`也是锁默认的状态，线程一旦获取了这把锁，就会把自己的线程ID写到`MarkWord`中。在其他线程来获取这把锁之前，锁都处于偏向锁状态。\r\n\r\n#### 轻量级锁\r\n\r\n当下一个线程参与到偏向锁竞争时，会先判断 MarkWord 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。\r\n\r\n轻量级锁的获取是怎么进行的呢？它们使用的是自旋方式。\r\n\r\n参与竞争的每个线程，会在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS （自旋）的方式，将锁对象头中的 MarkWord 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着哪个线程获得锁。\r\n\r\n当锁处于轻量级锁的状态时，就不能够再通过简单的对比Tag的值进行判断，每次对锁的获取，都需要通过自旋。\r\n\r\n当然，自旋也是面向不存在锁竞争的场景，比如一个线程运行完了，另外一个线程去获取这把锁。但如果自旋失败达到一定的次数，锁就会膨胀为重量级锁。\r\n\r\n#### 重量级锁\r\n\r\n重量级锁即为我们对synchronized的直观认识，这种情况下，线程会挂起，进入到操作系统内核态，等待操作系统的调度，然后再映射回用户态。系统调用是昂贵的，重量级锁的名称由此而来。\r\n\r\n如果系统的共享变量竞争非常激烈，锁会迅速膨胀到重量级锁，这些优化就名存实亡。如果并发非常严重，可以通过参数`-XX:-UseBiasedLocking`禁用偏向锁，理论上会有一些性能提升，但实际上并不确定。\r\n\r\n4\\\\. Lock\r\n--------\r\n\r\n在 concurrent 包里，我们能够发现`ReentrantLock`和`ReentrantReadWriteLock`两个类。`Reentrant`就是可重入的意思，它们和synchronized关键字一样，都是可重入锁。\r\n\r\n这里有必要解释一下`可重入`这个概念，因为在面试的时候经常被问到。它的意思是，一个线程运行时，可以多次获取同一个对象锁。这是因为Java的锁是基于线程的，而不是基于调用的。比如下面这段代码，由于方法a、b、c锁的都是当前的`this`，线程在调用a方法的时候，就不需要多次获取对象锁。\r\n\r\n    public synchronized void a(){    \r\n    b();\r\n    }\r\n    public synchronized void \r\n    b()\r\n    {    \r\n    c();\r\n    }public synchronized void \r\n    c(){\r\n    }\r\n\r\n### 主要方法\r\n\r\nLOCK是基于AQS（AbstractQueuedSynchronizer）实现的，而AQS 是基于 volitale 和 CAS 实现的。关于CAS，我们将在下一课时讲解。\r\n\r\nLock与synchronized的使用方法不同，它需要手动加锁，然后在finally中解锁。Lock接口比synchronized灵活性要高，我们来看一下几个关键方法。\r\n\r\n*   **lock：** lock方法和synchronized没什么区别，如果获取不到锁，都会被阻塞\r\n    \r\n*   **tryLock：** 此方法会尝试获取锁，不管能不能获取到锁，都会立即返回，不会阻塞。它是有返回值的，获取到锁就会返回true\r\n    \r\n*   **tryLock(long time, TimeUnit unit)：** 与tryLock类似，但它在拿不到锁的情况下，会等待一段时间，直到超时\r\n    \r\n*   **lockInterruptibly：** 与lock类似，但是可以锁等待可以被中断，中断后返回InterruptedException\r\n    \r\n\r\n一般情况下，使用lock方法就可以。但如果业务请求要求响应及时，那使用带超时时间的tryLock是更好的选择：我们的业务可以直接返回失败，而不用进行阻塞等待。tryLock这种优化手段，采用降低请求成功率的方式，来保证服务的可用性，高并发场景下经常被使用。\r\n\r\n### 读写锁\r\n\r\n但对于有些业务来说，使用Lock这种粗粒度的锁还是太慢了。比如，对于一个HashMap来说，某个业务是读多写少的场景，这个时候，如果给读操作也加上和写操作一样的锁的话，效率就会很慢。\r\n\r\nReentrantReadWriteLock是一种读写分离的锁，它允许多个读线程同时进行，但读和写、写和写是互斥的。使用方法如下所示，分别获取读写锁，对写操作加写锁，对读操作加读锁，并在finally里释放锁即可。\r\n\r\n    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    \r\n    Lock readLock = lock.readLock();    \r\n    Lock writeLock = lock.writeLock();    \r\n    public void put(K k, V v) {        \r\n    writeLock.lock();        \r\n    try {            \r\n    map.put(k, v);        \r\n    } finally {            \r\n    writeLock.unlock();        \r\n    }    \r\n    }...\r\n\r\n### 公平锁与非公平锁\r\n\r\n我们平常用到的锁，都是非公平锁。可以回过头来看一下monitor的原理。当持有锁的线程释放锁的时候，EntrySet里的线程就会争抢这把锁。这个争抢的过程，是随机的，也就是说你并不知道哪个线程会获取对象锁，谁抢到了就算谁的。\r\n\r\n这就有一定的概率，某个线程总是抢不到锁，比如，线程通过setPriority 设置的比较低的优先级。这个抢不到锁的线程，就一直处于`饥饿`状态，这就是`线程饥饿`的概念。\r\n\r\n公平锁通过把随机变成有序，可以解决这个问题。synchronized没有这个功能，在Lock中可以通过构造参数设置成公平锁，代码如下。\r\n\r\n    public ReentrantReadWriteLock(boolean fair) {        \r\n    sync = fair ? new FairSync() : new NonfairSync();        \r\n    readerLock = new ReadLock(this);        \r\n    writerLock = new WriteLock(this);\r\n    }\r\n\r\n由于所有的线程都需要排队，需要在多核的场景下维护一个同步队列，在多个线程争抢锁的时候，吞吐量就很低。下面是20个并发之下锁的JMH测试结果，可以看到，非公平锁比公平锁性能高出两个数量级。\r\n\r\n    Benchmark                      Mode  Cnt      Score      Error   UnitsFairVSNoFairBenchmark.fair    \r\n    thrpt   10    186.144 ±   27.462  ops/msFairVSNoFairBenchmark.nofair  \r\n    thrpt   10  35195.649 ± 6503.375  ops/ms\r\n\r\n5\\\\. 锁的优化技巧\r\n----------\r\n\r\n### 死锁\r\n\r\n我们可以先看一下锁冲突最严重的一种情况：死锁。下面这段示例代码，两个线程分别持有了对方所需要的锁，进入了相互等待的状态，就进入了死锁。面试中手写这段代码的频率，还是挺高的。\r\n\r\n    public class DeadLockDemo {    \r\n    public static void main(String[] args) {        \r\n    Object object1 = new Object();        \r\n    Object object2 = new Object();        \r\n    Thread t1 = new Thread(() -> {            \r\n    synchronized (object1) {                \r\n    try {                    \r\n    Thread.sleep(200);                \r\n    } catch (InterruptedException e) {                    \r\n    e.printStackTrace();                \r\n    }                \r\n    synchronized (object2) {                \r\n    }            \r\n    }        \r\n    }, \\\"deadlock-demo-1\\\");        \r\n    t1.start();        \r\n    Thread t2 = new Thread(() -> {            \r\n    synchronized (object2) {                \r\n    synchronized (object1) {               \r\n     }            \r\n    }        \r\n    }, \\\"deadlock-demo-2\\\");       \r\n     t2.start();    \r\n    }\r\n    }\r\n\r\n使用我们上面提到的，带超时时间的tryLock方法，有一方让步，可以一定程度上避免死锁。\r\n\r\n### 优化技巧\r\n\r\n锁的优化理论其实很简单，那就是减少锁的冲突。无论是锁的读写分离，还是分段锁，本质上都是为了避免多个线程同时获取同一把锁。我们可以总结一下优化的一般思路：减少锁的粒度、减少锁持有的时间、锁分级、锁分离 、锁消除、乐观锁、无锁等。\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e59eb52958400a84396eb402dc3f83~tplv-k3u1fbpfcp-watermark.image?)**减少锁粒度**  \r\n\r\n通过减小锁的粒度，可以将冲突分散，减少冲突的可能，从而提高并发量。简单来说，就是把资源进行抽象，针对每类资源使用单独的锁进行保护。比如下面的代码，由于list1和list2属于两类资源，就没必要使用同一个对象锁进行处理。\r\n\r\n    public class LockLessDemo {    \r\n    List<String> list1 = new ArrayList<>();    \r\n    List<String> list2 = new ArrayList<>();    \r\n    public synchronized void addList1(String v){        \r\n    this.list1.add(v);    \r\n    }    \r\n    public synchronized void addList2(String v){        \r\n    this.list2.add(v);   \r\n    }\r\n    }\r\n\r\n可以创建两个不同的锁，改善情况如下：  \r\n\r\n    public class LockLessDemo {    \r\n    List<String> list1 = new ArrayList<>();    \r\n    List<String> list2 = new ArrayList<>();    \r\n    final Object lock1 = new Object();    \r\n    final Object lock2 = new Object();    \r\n    public void addList1(String v) {        \r\n    synchronized (lock1) {            \r\n    this.list1.add(v);        \r\n    }    \r\n    }    \r\n    public void addList2(String v) {       \r\n     synchronized (lock2) {            \r\n    this.list2.add(v);        \r\n    }    \r\n    }\r\n    }\r\n\r\n**减少锁持有时间**通过让锁资源尽快的释放，减少锁持有的时间，其他线程可更迅速的获取锁资源，进行其他业务的处理。考虑到下面的代码，由于slowMethod不在锁的范围内，占用的时间又比较长，可以把它移动到synchronized代码快外面，加速锁的释放。\r\n\r\n    public class LockTimeDemo {    \r\n    List<String> list = new ArrayList<>();    \r\n    final Object lock = new Object();    \r\n    public void addList(String v) {        \r\n    synchronized (lock) {            \r\n    slowMethod();            \r\n    this.list.add(v);        \r\n    }    \r\n    }    \r\n    public void slowMethod(){    \r\n    }}\r\n\r\n**锁分级**锁分级指的是我们文章开始讲解的synchronied锁的锁升级，属于JVM的内部优化。它从偏向锁开始，逐渐会升级为轻量级锁、重量级锁，这个过程是不可逆的。\r\n\r\n**锁分离**我们在上面提到的读写锁，就是锁分离技术。这是因为，读操作一般是不会对资源产生影响的，可以并发执行。写操作和其他操作是互斥的，只能排队执行。所以读写锁适合读多写少的场景。\r\n\r\n**锁消除**通过JIT编译器，JVM可以消除某些对象的加锁操作。举个例子，大家都知道StringBuffer和StringBuilder都是做字符串拼接的，而且前者是线程安全的。\r\n\r\n但其实，如果这两个字符串拼接对象用在函数内，JVM通过逃逸分析分析这个对象的作用范围就是在本函数中，就会把锁的影响给消除掉。比如下面这段代码，它和StringBuilder的效果是一样的。\r\n\r\n    String m1(){    \r\n    StringBuffer sb = new StringBuffer();    \r\n    sb.append(\\\"\\\");    \r\n    return sb.toString();\r\n    }\r\n    \r\n\r\nEnd\r\n---\r\n\r\nJava中有两种加锁方式，一种是使用synchronized关键字，另外一种是concurrent包下面的Lock。本课时，我们详细的了解了它们的一些特性，包括实现原理。下面对比如下：\r\n\r\n类别\r\n\r\nSynchronized\r\n\r\nLock\r\n\r\n实现方式\r\n\r\nmonitor\r\n\r\nAQS\r\n\r\n底层细节\r\n\r\nJVM优化\r\n\r\nJava API\r\n\r\n分级锁\r\n\r\n是\r\n\r\n否\r\n\r\n功能特性\r\n\r\n单一\r\n\r\n丰富\r\n\r\n锁分离\r\n\r\n无\r\n\r\n读写锁\r\n\r\n锁超时\r\n\r\n无\r\n\r\n带超时时间的tryLock\r\n\r\n可中断\r\n\r\n否\r\n\r\nlockInterruptibly\r\n\r\nLock的功能是比synchronized多的，能够对线程行为进行更细粒度的控制。但如果只是用最简单的锁互斥功能，建议直接使用synchronized。有两个原因：\r\n\r\n*   synchronized的编程模型更加简单，更易于使用\r\n    \r\n*   synchronized引入了偏向锁，轻量级锁等功能，能够从JVM层进行优化，同时，JIT编译器也会对它执行一些锁消除动作\r\n    \r\n\r\n多线程代码好写，但bug难找，希望你的代码即干净又强壮，兼高性能与高可靠于一身。"
    },
    {
        "article_id": "7187287554796814393",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61b69001d934c7b8d471d62f411c749~tplv-k3u1fbpfcp-watermark.image?",
        "title": "因为数据库与项目经理引发的一点小争执，保存留念",
        "preview": "作为刚步入社会的小同学来说，对代码有热情是很好，但是也极其嫌麻烦，明明都做完了还要被要求一遍又一遍的更改，相信大多数人都是嫌麻烦，然后就是两人之间的打情骂俏。",
        "author": "LoveAndProgram",
        "view_count": 2400,
        "collect_count": 3,
        "comment_count": 11,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f10a2daa35dace8bbfb6fb337d895420~300x300.image",
        "category": "后端",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n\r\n\r\n\r\n# 前言\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为刚步入社会的小同学来说，对代码有热情是很好，但是也极其嫌麻烦，明明都做完了还要被要求一遍又一遍的更改，相信大多数人都是嫌麻烦，然后就是两人之间的打情骂俏。\r\n\r\n>项目经理：你改一改嘛🤤<p>\r\n我：哎呀，好麻烦啊，不给你写了一个么😭<p>\r\n项目经理：你那个我数据库不能维护啊，快改改，乖o(*^＠^*)o<p>\r\n我：😣我不我不，为啥不能维护，我不理解<p>\r\n项目经理：你去试试😣球球了，你去试试😭<p>\r\n~~（当然没我写的这么肉麻嘞🤣，如有雷同，纯属巧合）~~ \r\n\r\n---\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，数据库维护，他从前端页面进入后向页面输入肯定要调用sql，问题来了，以下这种形式sql可以是实现随意添加么（没有主键）\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96cf1ffbb9084b6488e32cf12df6075a~tplv-k3u1fbpfcp-zoom-1.image)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我写python的第一反应：这有啥问题么，数据库我会个简单的增删改查，但是我感觉应该有函数可以直接往后加吧(很chun的想法，两种不同的语言怎么可能会一样)，于是乎我开始了，漫漫搜索之路（因为回家连不上内网mysql，以下用Oracle代替）\r\n\r\n# 使用insert函数\r\n\r\n - 数据库基本增加操作：`insert into table_name (column1, column2, ...) VALUES (value1, value2, ...)`，这里直接跳过全字段添加，选取单字段添加，本以为他会如下图：\r\n \r\n\r\n```sql\r\nINSERT into wang.gjc_data (a1) values ('a');\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc4b541657c04929a794bc2004293613~tplv-k3u1fbpfcp-zoom-1.image)\r\n - 实际上如下图（哪怕是选取单字段也是默认增加一行）：\r\n ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f69c90ec500e49d7b6c2d31192c5eab6~tplv-k3u1fbpfcp-zoom-1.image)\r\n >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我确实懵了，以前从来没有想过这件事，因为从数据库读取下来很多时候数据第一步就是先转置，感觉有点麻烦吧，因为转置完会出现很多意料之外的情况，但是人家数据库就是这么存的，现在轮到自己建数据库才发现数据库规则可太多了，而且自己上传数据也都是一次上传一行，没遇见过也就没有真正想过数据库在没有主键的情况下可以单单只改一个数据么，但是吧，我头铁啊，python能做到为啥数据库不行，我还是不信，我继续搜\r\n\r\n\r\n \r\n\r\n - 多条一次性插入:`INSERT ALL INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...)  \r\ninto table_name（column_name1,column_name2） values (value1,value2)...select * from dual;`\r\n\r\n```sql\r\nINSERT ALL \r\nINTO table_name  (A1,A2) values ('a','b')  \r\nINTO table_name  (B2,C1) VALUES ('c','d')\r\nselect * from dual;\r\n```\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果显而易见，肯定不是我所期望的那个场面，如下图：\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9356f1f7b68f4f09b07c66f6add621f0~tplv-k3u1fbpfcp-zoom-1.image)\r\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话我是真搜不着啥信息，找不到想要的答案就全试一遍，撞到南墙就回头了！所以我决定接下来从update语句下手。\r\n\r\n---\r\n\r\n# 使用update函数\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想想，update好像无法新增一列，好像还没开始就结束了，但是实际页面肯定需要`改`这个条件，那试试能不能达到自己想要的画面\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为没有主键，所以我选择直接用`update`，最后结果与预料的一样，一列全部改变，图下图：\r\n\r\n```sql\r\nupdate  GJC_DATA set GJC_DATA.c2= 'c2'\r\n\r\n```\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7261509351c44a4d9106b45cff6a6b19~tplv-k3u1fbpfcp-zoom-1.image)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我就想到了**第二范式**的概念：**第二范式要求在满足第一范式的基础上，非码属性必须完全依赖于候选字，也就是要消除部分依赖。**\r\n    没有主键形成依赖，不满足第二范式。但是好像就算我加上一列自增主键，也无法用`insert`插入一个指定位置而不是一次插入一行，但是`update`是可以实现的，如下图（重新创建一个数据库表）：\r\n\r\n```sql\r\nCREATE TABLE WANG.gjc_data(\r\nid int NOT NULL,\r\na1 varchar(128),\r\na2 varchar(128),\r\na3 varchar(128),\r\na4 varchar(128),\r\na5 varchar(128),\r\nb1 varchar(128),\r\nb2 varchar(128),\r\nc1 varchar(128),\r\nc2 varchar(128),\r\nc3 varchar(128),\r\nc4 varchar(128),\r\nc5 varchar(128),\r\nc6 varchar(128),\r\nc7 varchar(128),\r\nPRIMARY KEY(id)\r\n);\r\ncreate sequence id_zeng_1\r\nstart with 1          --以1开始\r\nincrement by 1;  \r\ninsert into wang.gjc_data  (id,A1,b1) values(id_zeng_1.nextval,'a','d');\r\ninsert into wang.gjc_data  (id,A1,b1) values(id_zeng_1.nextval,'b','e');\r\ninsert into wang.gjc_data  (id,A1,b1) values(id_zeng_1.nextval,'c','f');\r\n```\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c3eca24f78427d8d00f9496fc7e5e4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n```sql\r\nupdate wang.gjc_data set A1='B'  WHERE id=1;\r\n```\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb6a34715b4c44808c908c20b2ef2e08~tplv-k3u1fbpfcp-zoom-1.image)\r\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，认清现实了，不过insert一次插入一行，下面直接插一行我python使用的时候早就可以用pandas清空空值，他也无法接受，可能他觉得客户看起来不好看吧，得，那凑活给他改改\r\n\r\n - `Oracle`数据库\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a6458fcff1e47609add5dba55defef9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n - `Jupyter`读取`Oracle`\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f6e82602f24ceea7273c6c996a3f45~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n# 总结\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这算是结束了，总结一下，我原以为是我数据库学的不精通，做不到指定位置添加，经过这么一番探索后才发现真的没有这种操作，果然，实践才是检验真理的唯一标准，不遇上这事我还真一直有这个误区，算了，这次被自家人嘲笑就嘲笑了，那也比到时候出差去外面丢人强。\r\n>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;谨以此文提醒自己，不再犯相同错误，数据库并不可以向excel那样用语句向指定位置插入指定值，更新也是需要设置主键或是一列唯一值去做一个指引；理论知识还是比较薄弱，需要持续加强。"
    },
    {
        "article_id": "7170767923005358094",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc9311d551443ada7786342e63d28d8~tplv-k3u1fbpfcp-watermark.image?",
        "title": "疫情当下，远程工作兴起！前端音视频通话？学！🔥",
        "preview": "制作 https 自签名证书，使用 nginx 反向代理 https，使用 socket.io 来实现客户端与信令服务器的通信，实现一个 WebRTC + 信令服务器自动建立连接的音视频实时通话。",
        "author": "荣顶",
        "view_count": 8030,
        "collect_count": 187,
        "comment_count": 24,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/26f254d4ee2f1e58081b5f503fd01dda~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: smartblue\r\nhighlight: atom-one-dark\r\n---\r\n\r\n>作者：[荣顶](https://github.com/wangrongding) 、[github](https://github.com/wangrongding)  \r\n声明：文章为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n\r\n## 前言\r\n\r\n- [WebRTC 从实战到未来！迎接风口，前端必学的技术 🔥](https://juejin.cn/post/7151932832041058340)\r\n- [WebRTC 从实战到未来！前端如何实现一个最简单的音视频通话？🔥](https://juejin.cn/post/7165539003465531399)\r\n\r\n看到前两篇文章都非常受欢迎，非常的开心！🤖 继续加油！冲！  \r\n我们也在前两篇文章中大概讲解了 音视频媒体流的获取，处理，以及在上一篇文章中为了更直观的演示 WebRTC 建立点对点通信的过程，通过手动交换 sdp 来建 p2p 连接，实现了一个最简单的音视频通话，但在实际的应用场景中，我们几乎不可能会通过手动来交换 sdp ，因为这样会增加很多的工作量，也不方便，所以我们借助一个信令服务器来帮助我们实现自动建立连接的这个过程。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2daf17b2c8e4b8fa4824467c7603ae4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 从这篇文章中你将学到\r\n\r\n- 学会如何制作 https 的自签名证书\r\n- 学会如何使用 nginx 反向代理 https\r\n- 学会使用 socket.io 来实现客户端与信令服务器的通信\r\n- 了解并实现一个 WebRTC + 信令服务器自动建立连接的音视频实时通话\r\n\r\n## 体验地址\r\n\r\n[👉🏻 1.本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p)  \r\n[👉🏻 2.本文客户端源代码地址](https://github.com/wangrongding/frontend-park)  \r\n[👉🏻 3.本文服务端源代码地址](https://github.com/wangrongding/node-park/blob/main/src/signaling/signaling-http-server.js)\r\n\r\n你可以开两个浏览器 tab 或者用不同的设备，根据说明即可体验。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49c4ff3a08364415b368422e86f033a6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 了解信令前，需要了解的几个概念\r\n\r\n结合上一篇讲到的 `SDP` , `NAT` , `ICE`，我们还需要了解：`STUN`，`TURN`服务，以及`ICE候选者的种类`。\r\n\r\n### 候选者的种类\r\n\r\nWebRTC 众多的链接候选者中，可以分为三类：\r\n\r\n- `host`：本机候选者（设备的 ipv4 或 ipv6 地址，即内网地址，一般会有两个，分别对应 udp 和 tcp，ip 相同，端口不同），ICE 尝试与对方建立 P2P 连接时的首选，一般这个地址为内网地址，如果双方位于同一个内网，那么直接建立成功。\r\n- `srflx`：P2P 链接候选者（STUN 服务返回的你这个主机的外网地址），在第一次尝试连接失败时，说明双方不在同一个内网，ICE 将使用 STUN 服务获取主机的公网地址以及映射端口，然后开始尝试通过用这个公网 IP 和对方建立连接。\r\n- `relay`：中继服务器候选者，如果第二次仍然失败了（当 `STUN` 不适用时(某些 NAT 会为每个连接分配不同的端口，导致获取的端口和视频连接端口并不一致），那么意味着双方无法直接建立 P2P 连接，这时候就只能通过一个中继服务器，即 `TURN` 服务器来和双方建立连接，然后中转他们之间传输的内容，这种对服务器开销最大，而且也会增加时延，所以只有在没得选择的情况下采用。\r\n\r\n所以可以总结为三类候选者中，`host` 候选者的优先级是最高的，当 `host` 类型的候选者无法建立链接的时候，WebRTC 会从 `srflx` 候选者中进行连通性测试，也就是尝试通过 `P2P` 的方式连接双方，如果失败才会尝试使用 `relay` 的方式进行链接。\r\n\r\n### STUN (Session Traversal Utilities for NAT)\r\n\r\n我们需要知道的是：主机要想访问公网资源，必须有自己的公网地址，只有这样，我们才能在访问资源主机的时候，让它通过我们主机的公网地址找到我们的主机，并把你想要访问的资源发送给你。\r\n\r\n> 一般情况下，在一个网段内的主机只有内网 IP 和端口号，那内网的主机是如何访问公网资源的呢？实际上，内网的网关都有 NAT 的功能，NAT 的功能是将内网 IP 映射转换成公网地址。当我们的内网主机想要访问公网资源的时候，内网网关会将请求的内网地址映射成公网地址，然后将请求发送到要访问的公网服务器上，服务器处理好请求之后，将响应数据传递给请求中携带的公网地址上，该公网接收到响应数据之后，它的网关就会通过之前的地址映射最终中转给内网的主机。通过这种方式实现内网主机访问公网资源的需求。  \r\n> 基于以上的这种方式，我们可以知道内网主机虽然不知道自己在公网的地址，但是内网主机访问的服务器是知道内网主机对应的公网 IP 的，于是我们在公网中架设一台服务器，通过这台服务器可以询问到自己的公网地址。实际上这一询问流程已经被定义成了一套规范，就是 STUN 协议。  \r\n> NAT 遍历操作由 Session Traversal Utilities for NAT (STUN) 服务器执行。 STUN 方法是一种用于终端检查其“公共 IP 地址和端口”的过程的协议。当客户端向 STUN 服务器发送请求时，它会发送通信所需的信息以及客户端用来与其他设备通信的公共 IP 地址。但是，即使在这种情况下，如果无法进行通信，也会将其传输到 TURN 服务器。\r\n\r\n简单概括就是，我们要知道自己的`外网 IP 地址`，依靠的就是 `STUN` 服务。客户端通过给公网的 STUN 服务器发送请求获得自己的公网地址信息，以及是否能够被（穿过路由器）访问。\r\n\r\n[协议地址](https://www.rfc-editor.org/rfc/rfc5389)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b12e0c9d88044a788ac56627a515140~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### TURN (Session Traversal Utilities for NAT)\r\n\r\nWebRTC 通信双方通过 P2P 的方式无法建立链接的情况下，会使用 relay 服务进行中转服务。 relay 是所有候选者中优先级最低的链接方式，但是 relay 也是连通率最高的方式。WebRTC 通信双方通过向 TURN 服务器发送 Allocation 指令获得在 relay 服务器上的端口，用于中转 UDP 数据。\r\n\r\n> 总结上面的内容，WebRTC 的通信双方在进行链接之前会按照优先级收集链接的候选者，按照优先级的高低，分别是：在本级收集所有的 host 类型的候选者进行内网链接，通过 STUN 协议收集 srflx 候选者进行 P2P 链接，通过 TURN 协议收集 relay 候选者通过中转服务器链接并传输 UDP 数据。\r\n\r\n很显然这种方式是开销很大的，所以只有在没得选择的情况下采用。\r\n\r\n[协议地址](https://www.rfc-editor.org/rfc/rfc7065)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b03272406d49ada507ecd8217771c4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n一般我们都会通过 [coturn](https://github.com/coturn/coturn)会[restund](https://creytiv.com/restund.html)来搭建 `STUN` 和 `TURN` 服务。非常的方便，我使用的是开源社区提供的 `coturn`，它是一个比较成熟的项目。我会在第 4,5 篇文章讲到如何搭建它，这篇我们直接用现成的 `STUN` 服务就行。至于 `TURN`服务...🥲 目前我还没有一个比较好的服务器，能顶得住这种，我后面看看搞一台合适的过来搭建一个，供大家在线体验一下。\r\n\r\n所以这篇文章我们做的 demo 可以在内网，以及网络环境不是特别复杂的外网下进行音视频通话。（一方位于 NAT 网络内部，或者双方都在 `非对称NAT`网络内的情况）\r\n\r\n## 什么叫信令？\r\n\r\n我们知道 `WebRTC` 想要直接通过 `P2P` 连接进行通信，需要一个中继的过程(在两个终端之间传递控制信息的过程)，这个中继的过程就称之为`信令`。  \r\n所以简单来说，信令就是在两个设备之间发送控制信息以确定通信协议、信道、媒体编解码器和格式以及数据传输方法以及任何所需的路由信息的过程，而执行此操作的服务器称为`信令服务器`。\r\n\r\n信令服务器按照与聊天室相同的方式对连接的节点进行逻辑分组，并帮助各端相互交换 `SDP` 等信息。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1001dc7f6b7417ea2809773a02f00de~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 关于 WebRTC 的信令流程最重要的一点是： **「信令在规范中并没有定义」** 所以开发者需要自己决定如何实现这个过程。开发者可以为应用程序引擎选择任意的信息协议（如 SIP 或 XMPP），任意双向通信信道（如 WebSocket 或 XMLHttpRequest) 与持久连接服务器的 API（如 Google Channel API）一起工作。\r\n\r\n根据上面的说明我们就可以知道信令服务器的实现方式有很多种，可以根据要开发的服务的性质使用现有的信令协议，也可以通过轮询/长轮询或 websocket 等适当的双向通信通道来实现。\r\n\r\n由于信令的核心是交换异步发送的对等信息（SDP，Candidate）。因此，将其实现为支持全双工通信的 websocket 最为合适。下面我面会通过 socket.io 来实现一个简单的信令服务器。\r\n\r\n有点像村里相亲的，一开始不认识对方，没法直接联系，需要通过媒介，中间人来传递消息后，你们可能知道对方的位置啊，联系方式啊等等才能很好的直接建立联系。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d4d8c69ef034c4baae5a49b5d1ebe3e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af419763ad5460d981009a2bffbf34f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这张图很清楚的描述了这个过程。\r\n\r\n各端通过信令服务器交换 `SDP` 信息，然后各端通过 `P2P` 连接进行通信。\r\n\r\n关于信令更多的详细内容可以参考：[MDN 信令的介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Session_lifetime#%E4%BF%A1%E4%BB%A4)，[MDN 信令与视频通话](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling)\r\n\r\n## 信令服务器的具体实现\r\n\r\n下面我们主要使用 `socket.io` 来实现一个简单的信令服务器。\r\n\r\n为什么使用它呢？\r\n\r\n就像 Axios 是对 XMLHttpRequest 的封装， 而 Socket.io 就是对 WebSocket 的封装，并且实现了 WebSocket 的服务端代码。Socket.IO 将 WebSocket 和轮询（Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。也就是说，WebSocket 仅仅是 Socket.IO 实现实时通信的一个子集。Socket.IO 简化了 WebSocket API，统一了返回传输的 API。\r\n\r\n总结一下就是：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51d89c1ee854331851482042081c44b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n用它来写非常的简单方便，下面我们就用 express 配合 socket.io 来实现一个简单的信令服务器。\r\n\r\n### 信令服务的搭建\r\n\r\n我们用 nodejs 来写服务端，首先我们要安装一下 `socket.io`\r\n\r\n```bash\r\n# 服务端\r\nnpm i express socket.io\r\n```\r\n\r\n然后我们创建一个 `server.js` 文件，用来启动一个没有业务逻辑的信令服务。\r\n\r\n```js\r\nimport http from 'http'\r\nimport { Server } from 'socket.io'\r\nimport express from 'express'\r\n\r\nconst port = 3000\r\nconst app = express()\r\nconst httpServer = http.createServer(app)\r\n// 创建信令服务器\r\nconst io = new Server(httpServer, {\r\n  cors: {\r\n    origin: '*', // 允许跨域\r\n    methods: ['GET', 'POST'], // 允许的请求方式\r\n    allowedHeaders: '*', // 允许的请求头\r\n    credentials: true, // 允许携带cookie\r\n  },\r\n  allowEIO3: true, // 是否启用与Socket.IO v2客户端的兼容性\r\n  transport: ['websocket'], // 仅允许websocket,[\\\"polling\\\", \\\"websocket\\\"]\r\n})\r\n\r\n// 在指定端口启动服务器\r\nhttpServer.listen(port, () => {\r\n  console.log('\\\r\n Http server up and running at => http://%s:%s', httpServer.address().address, httpServer.address().port)\r\n})\r\n\r\n// 监听用户连接\r\nio.on('connection', (socket) => {\r\n  console.log('connection~')\r\n\r\n  // 监听连接断开\r\n  socket.on('disconnect', () => {\r\n    console.log('disconnect~')\r\n  })\r\n})\r\n```\r\n\r\n这里我们使用了 `express` 来创建一个简单的服务，然后使用 `socket.io` 来创建一个 websocket 服务。\r\n\r\n这样一个 简单 websocket 服务架子就搭好了。我们先启动这个服务.\r\n\r\n```bash\r\nnode server.js\r\n```\r\n\r\n是不是很简单~~\r\n\r\n### 客户端需要做的事情\r\n\r\n然后我们在客户端也要安装配套的 `socket.io-client`\r\n\r\n```bash\r\n# 客户端\r\nnpm i socket.io-client\r\n```\r\n\r\n然后我们在客户端代码中引入 `socket.io-client`，并且连接到我们刚启动的信令服务。\r\n\r\n```js\r\nimport io from 'socket.io-client'\r\n\r\n// 连接到信令服务\r\nconst socket = io('http://localhost:3000')\r\n```\r\n\r\n由于 WebRTC 是需要在 `https` 协议下才能使用的，所以我们需要在本地生成一个 自签名的`https` 证书。（当然，你客户端直接在 localhost 下测试就不需要通过 https 了）。\r\n\r\n要不然，你在 https 协议的页面，请求 http 资源时，浏览器会报错，因为 https 页面中的资源必须是 https 的，否则浏览器会阻止加载。\r\n\r\nhttps，对应的我们信令服务的地址也需要是 https，不然就会报错\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44664b5bb8ee46b4827eb812e2249d90~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以下面我们需要自签一张证书。\r\n\r\n## 自签证书\r\n\r\n我们可以通过 openssl 生成自签证书，并将其保存在本地。我一直觉得用 OpenSSL 弄好麻烦，这里我使用 mkcert，它作为本地 https 的快速解决方案，用起来非常方便。\r\n\r\n> [mkcert](https://github.com/FiloSottile/mkcert) 是一个用 Go 语言编写的工具，它可以轻松地为本地开发生成有效的 TLS 证书。它使用了一个名为 local CA 的根证书，这个根证书是由 mkcert 生成的，它会被安装到系统的受信任的根证书列表中。\r\n\r\n下面一起来通过 mkcert 生成自签证书，并将其保存在本地。\r\n\r\n### 安装 mkcert 并生成证书\r\n\r\n我这边使用的是 macos ，安装起来很方便，其他系统的安装方式可以参考 [mkcert 文档](https://github.com/FiloSottile/mkcert),[本地 https 快速解决方案——mkcert](https://blog.dteam.top/posts/2019-04/%E6%9C%AC%E5%9C%B0https%E5%BF%AB%E9%80%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88mkcert.html)，基本都差不多\r\n\r\n```sh\r\n# 安装 mkcert\r\nbrew install mkcert\r\n# 安装完成后，执行↓\r\nmkcert -install\r\n```\r\n\r\n安装完成后，我们就可以使用 mkcert 生成自签证书了，这里我生成了一个名为 localhost 的证书，证书保存在当前目录下。\r\n\r\n生成证书也很简单，就一行命令\r\n\r\n```sh\r\n# mkcert domain1 [domain2 [...]]\r\n\r\n# 本地的直接这样就ok\r\nmkcert localhost 127.0.0.1 ::1\r\n```\r\n\r\n生成的证书包含两个文件，一个是证书文件，一个是私钥文件，这两个文件都是必须的，因为证书文件是公开的，而私钥文件是私有的，它们是一对。\r\n\r\n```sh\r\nlocalhost.pem\r\nlocalhost-key.pem\r\n```\r\n\r\n生成完毕后，不管你是在 nginx 中使用还是在 node 中使用，只需要将在 nginx 或者 node 中指定证书文件和私钥文件的路径即可。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ae475542dc0467fa697d9c609305e0f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### node 中使用\r\n\r\n```js\r\nimport { Server } from 'socket.io'\r\nimport express from 'express'\r\nimport https from 'https'\r\nimport path from 'path'\r\nimport { fileURLToPath } from 'url'\r\nimport fs from 'fs'\r\n\r\nconst __filename = fileURLToPath(import.meta.url)\r\nconst __dirname = path.dirname(__filename)\r\n\r\n//https证书\r\nconst options = {\r\n  cert: fs.readFileSync(path.join(__dirname, '../assets/localhost.pem')),\r\n  key: fs.readFileSync(path.join(__dirname, '../assets/localhost-key.pem')),\r\n}\r\nconst app = express()\r\nconst httpsServer = https.createServer(options, app)\r\n\r\nhttpsServer.listen(3333, '0.0.0.0', () => {\r\n  console.log('Https server up and running...')\r\n})\r\n```\r\n\r\n### nginx 中使用\r\n\r\n在本地测试的话怎么样都行，到线上环境的时候，可以去各大云服务商申请证书，上传到服务器和自签的证书一样使用就行了，这块就不多说了。\r\n\r\n(需要注意的是，ip 证书非常的贵，一般都是直接用一个域名证书，然后通过 nginx 做转发)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74baba5bd88d4796b944e081848fda44~tplv-k3u1fbpfcp-zoom-1.image)  \r\n或者你只是想在线上测试的话，也一样通过 mkcert 工具来生成本地的自签 HTTPS 证书就行了，只不过这个证书浏览器会提示不安全，但是用来测试还是可以的。\r\n\r\n```sh\r\nserver {\r\n    #SSL 默认访问端口号为 443\r\n    listen 12345 ssl;\r\n    #请填写证书文件的相对路径或绝对路径\r\n    ssl_certificate /path/to/localhost.pem;\r\n    #请填写私钥文件的相对路径或绝对路径\r\n    ssl_certificate_key /path/to/localhost-key.pem;\r\n    #请填写绑定证书的域名\r\n    server_name localhost;\r\n\r\n    location / {\r\n      proxy_pass http://localhost:3000;\r\n\r\n      # 为了让代理服务器了解客户端将协议切换到 WebSocket 的意图，下面三个标头必须加上\r\n      proxy_http_version 1.1;\r\n      proxy_set_header Upgrade $http_upgrade;\r\n      proxy_set_header Connection 'upgrade';\r\n\r\n      # http://nginx.org/en/docs/http/websocket.html\r\n      # https://echizen.github.io/tech/2018/10-21-nginx-websocket\r\n    }\r\n}\r\n```\r\n\r\n### 客户端使用\r\n\r\n比如我这边用 vite 创建的项目，我在 vite.config.ts 中要配置 https，直接按照下面的代码配置就行了。其他脚手架生成的项目也是类似的。\r\n\r\n```typescript\r\n// https://vitejs.dev/config/\r\nimport * as fs from 'fs'\r\n\r\nexport default defineConfig((config) => ({\r\n  // 配置主机、端口、https…\r\n  server: {\r\n    https: {\r\n      key: fs.readFileSync(`${__dirname}/localhost-key.pem`),\r\n      cert: fs.readFileSync(`${__dirname}/localhost.pem`),\r\n    },\r\n  },\r\n}))\r\n```\r\n\r\nok, 到这里，铺垫工作就完成了，下面我们就可以正式开始写前后端的相关逻辑了。\r\n\r\n## 信令服务的逻辑实现\r\n\r\n还记的我们上一篇文章中是如何实现 p2p 通信的吗？\r\n\r\n我们通过手动传输本地和远程的 `SDP`等信息来实现 P2P 通信，所以这次我们只需要把这个过程交给 socket 服务来处理就行了。\r\n\r\n首先我们需要安装并引入 `socket.io-client`，然后连接到我们上一小节启动的信令服务。\r\n\r\n```typescript\r\nimport io from 'socket.io-client'\r\nconst socket = io('https://localhost:3000')\r\n```\r\n\r\n然后我们需要监听一些服务端的事件，这个我们根据具体需求来定义。\r\n\r\nsocket.io 最主要的就是 `on` 和 `emit` 两个方法，在客户端 `on` 用来监听服务端的事件，`emit` 用来触发服务端的事件。在服务端 `on` 用来监听客户端的事件，`emit` 用来触发客户端的事件。还有一些其他的 api 我们直接对着文档来就行，所以说它使用起来非常的简单。\r\n\r\n### 定义客户端需要监听的事件\r\n\r\nok，我们先来看一下我们需要监听的事件。\r\n\r\n```typescript\r\n// 连接成功时触发\r\nsocket.on('connect', () => {\r\n  handleConnect()\r\n})\r\n\r\n// 断开连接时触发\r\nsocket.on('disconnect', (reason) => {\r\n  if (reason === 'io server disconnect') {\r\n    // 断线是由服务器发起的，重新连接。\r\n    socket.connect()\r\n  }\r\n  ElMessage.warning('您已断开连接')\r\n})\r\n// 服务端发送报错信息\r\nsocket.on('error', (data) => {\r\n  ElMessage.error(data)\r\n})\r\n// 当有用户加入房间时触发\r\nsocket.on('welcome', (data) => {\r\n  ElMessage.success(data.userId === userId ? '🦄成功加入房间' : `🦄${data.userId}加入房间`)\r\n})\r\n// 当有用户离开房间时触发\r\nsocket.on('leave', (data) => {\r\n  ElMessage.warning(data.userId === userId ? '🦄成功离开房间' : `🦄${data.userId}离开房间`)\r\n})\r\n// 当有用户发送消息时触发\r\nsocket.on('message', (data) => {})\r\n// 创建offer,发送给远端\r\nsocket.on('createOffer', (data) => {\r\n  // 如果已经创建过，直接发送\r\n  if (offerSdp) {\r\n    socket.emit('offer', {\r\n      userId,\r\n      roomId: roomId.value,\r\n      sdp: offerSdp,\r\n    })\r\n    return\r\n  }\r\n  createOffer() // 创建 offer\r\n})\r\n// 收到offer,创建answer\r\nsocket.on('offer', (data) => {\r\n  createAnswer(data.sdp)\r\n})\r\n// 收到answer,设置远端sdp\r\nsocket.on('answer', (data) => {\r\n  addAnswer(data.sdp)\r\n})\r\n```\r\n\r\n当然你也可以根据自己的习惯直接把所有事件都包在 `socket.on('message',(data)=>{})` 里，data 里加好 type 就行，这样只需要保留几个关键事件，其余的都走 message 事件的逻辑。\r\n\r\n### 定义信令服务端需要监听的事件\r\n\r\n```javascript\r\n// 用户连接\r\nio.on('connection', (socket) => {\r\n  console.log('connection~')\r\n  // 用户加入房间\r\n  socket.on('join', (data) => {\r\n    console.log('join~', data)\r\n    handleUserJoin(socket, data)\r\n  })\r\n  // 用户离开房间\r\n  socket.on('leave', (data) => {\r\n    console.log('leave', data)\r\n    handleUserDisconnect(socket)\r\n  })\r\n  // 监听连接断开\r\n  socket.on('disconnect', () => {\r\n    console.log('disconnect~')\r\n    handleUserDisconnect(socket)\r\n  })\r\n  //=============================\r\n  // 用户发送 offer\r\n  socket.on('offer', (data) => {\r\n    socket.to(data.roomId).emit('offer', data)\r\n  })\r\n  // 用户发送 answer\r\n  socket.on('answer', (data) => {\r\n    socket.to(data.roomId).emit('answer', data)\r\n  })\r\n  // 用户发送消息\r\n  socket.on('message', (data) => {\r\n    console.log('message', data)\r\n  })\r\n})\r\n```\r\n\r\n### 客户端加入房间\r\n\r\n接下来我们需要实现客户端加入房间的逻辑，这个逻辑其实就是告诉服务端，我要加入某个房间，然后服务端会把我这个房间的其他客户端的信息告诉我。\r\n\r\n```typescript\r\n// 随机一个用户名，后面你可以自己改成输入框让用户输入\r\nconst userId = Math.random().toString(36).substring(2)\r\n// 房间号，这里随便写一个，后面你可以自己改成输入框让用户输入\r\nconst roomId = 123\r\n\r\n// 加入房间\r\nfunction joinRoom() {\r\n  socket.emit('join', { userId, roomId })\r\n}\r\n```\r\n\r\n### 服务端接手客户端加入房间的逻辑\r\n\r\n服务端接手客户端加入房间的逻辑，其实就是把客户端的信息保存到服务端的内存中，然后把这个房间的其他客户端的信息告诉客户端。\r\n\r\n```js\r\n// 服务端，当用户加入房间\r\nsocket.on('join', (data) => {\r\n  handleUserJoin(socket, data)\r\n})\r\n\r\n// 房间信息\r\nconst ROOM_LIST = []\r\n// 每个房间最多容纳的人数\r\nconst MAX_USER_COUNT = 2\r\n// 用户加入房间\r\nfunction handleUserJoin(socket, data) {\r\n  const filterRoom = ROOM_LIST.filter((item) => item.roomId === data.roomId)[0]\r\n  let room = { roomId: data.roomId, userList: [] }\r\n\r\n  // 判断房间是否存在\r\n  if (filterRoom) {\r\n    room = filterRoom\r\n  } else {\r\n    ROOM_LIST.push(room)\r\n  }\r\n\r\n  // 每个房间人数不超过预设的人数\r\n  if (room.userList.length >= MAX_USER_COUNT) {\r\n    socket.emit('error', '房间人数已满，请稍后再试')\r\n    return\r\n  }\r\n\r\n  // 当房间里的人数为0且管理员还没有设置，设置管理员\r\n  if (room.userList.length === 0) {\r\n    room.admin = data.userId\r\n  }\r\n\r\n  // 判断用户是否已经在房间里\r\n  if (room.userList.some((item) => item.userId === data.userId)) {\r\n    socket.emit('error', '用户已在房间里')\r\n    return\r\n  }\r\n  // 把用户信息保存到房间里\r\n  room.userList.push(data)\r\n  console.log(data.userId, '加入房间')\r\n\r\n  socket.userId = data.userId\r\n  socket.roomId = data.roomId\r\n\r\n  // 将用户加入房间\r\n  socket.join(data.roomId)\r\n  // 通知房间内的其他用户\r\n  socket.to(data.roomId).emit('welcome', data)\r\n  // 通知自己加入房间成功，\r\n  socket.emit('joined', data)\r\n}\r\n```\r\n\r\n### 客户端创建提案\r\n\r\n这里，我们主要对上一篇创建提案的代码中添加 socket 发送的逻辑，我们需要在当有 ICE 候选改变时，将这些 本地的 SDP 描述发送到服务端，服务端再将这些信息转发给远程的客户端。这里我们先写发送逻辑，后面再去服务端写好接收逻辑就行。\r\n\r\n```typescript\r\n// 成功加入房间\r\nsocket.on('joined', (room, id) => {\r\n  ElMessage.success('🦄🦄🦄成功加入房间')\r\n  createOffer()\r\n})\r\n\r\n// 创建 offer\r\nasync function createOffer() {\r\n  // 当一个新的offer ICE候选人被创建时触发事件\r\n  peerConnection.onicecandidate = async (event) => {\r\n    if (event.candidate) {\r\n      offerSdp = JSON.stringify(peerConnection.localDescription)\r\n      // 发送 offer\r\n      if (offerSdp) {\r\n        socket.emit('offer', {\r\n          userId,\r\n          roomId: roomId.value,\r\n          sdp: offerSdp,\r\n        })\r\n      }\r\n    }\r\n  }\r\n  const offer = await peerConnection.createOffer()\r\n  await peerConnection.setLocalDescription(offer)\r\n}\r\n```\r\n\r\n其中的 `onicecandidate` 事件，是用来监听 ICE 服务器返回的候选地址，当 ICE 服务器返回一个新的候选地址时，就会触发该事件，这里我们通过 `socket.emit` 将这个候选地址发送给信令服务。\r\n\r\n当你在后期连接成功的时候，其实可以把 候选人信息(candidate) 打印出来可以看看，当两个设备在同一个内网中连接的时候， candidate 的地址为一个 ipv6 长格式的内网地址和一个 ipv4 的内网地址。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c348e5cf89d4c99accc6ad48f17c5bd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当两个设备不在同一个内网中连接的时候，可以看到 candidate 的地址最后为一个 ipv4 的外网地址,说明它尝试了两次连接，第一次是内网连接，第二次是外网连接。证明了前面说的三种类型的先后连接方式。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/665360ce135545cba442b6d99bac944a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 信令服务端接收提案\r\n\r\n接下来我们需要在服务端接收到客户端发送的提案后，将这个提案转发给远端的客户端。\r\n\r\n```typescript\r\n// 接收 offer\r\nsocket.on('offer', (data) => {\r\n  // console.log('offer', data)\r\n  socket.to(data.roomId).emit('offer', data)\r\n})\r\n```\r\n\r\n### 客户端接收远程的提案\r\n\r\n接下来我们需要在客户端接收到远程的提案后，将这个提案设置成 RemoteDescription。然后创建应答，将应答设置成本地描述，在候选人信息改变时，将应答发送给服务端。\r\n\r\n```typescript\r\n// 创建 answer\r\nasync function createAnswer(val: string) {\r\n  const offer = JSON.parse(val)\r\n  peerConnection.onicecandidate = async (event) => {\r\n    // 当一个新的 answer ICE candidate 被创建时\r\n    if (event.candidate) {\r\n      socket.emit('answer', {\r\n        userId,\r\n        roomId: roomId.value,\r\n        sdp: JSON.stringify(peerConnection.localDescription),\r\n      })\r\n    }\r\n  }\r\n  await peerConnection.setRemoteDescription(offer)\r\n  const answer = await peerConnection.createAnswer()\r\n  await peerConnection.setLocalDescription(answer)\r\n}\r\n```\r\n\r\n### 客户端创建 answer 的逻辑\r\n\r\n作为接收方，在拿到 offer 后，我们就可以创建 answer 并设置到本地描述中，然后通过信令服务器发送 answer 给对端。\r\n\r\n```typescript\r\nconst createAnswer = async () => {\r\n  // 解析字符串\r\n  const offer = JSON.parse(offerSdp)\r\n  pc.onicecandidate = async (event) => {\r\n    // Event that fires off when a new answer ICE candidate is created\r\n    if (event.candidate) {\r\n      answerSdp = JSON.stringify(pc.localDescription)\r\n    }\r\n  }\r\n  await pc.setRemoteDescription(offer)\r\n  const answer = await pc.createAnswer()\r\n  await pc.setLocalDescription(answer)\r\n}\r\n```\r\n\r\n### 客户端最后再添加 answer 的逻辑\r\n\r\n作为发起方，接下来我们需要在客户端接收到 接收方的应答后，将这个应答设置成 RemoteDescription。这样，一个最简单的 WebRTC 通信流程就完成了。\r\n\r\n```typescript\r\n// 添加 answer(应答)\r\nconst addAnswer = async () => {\r\n  const answer = JSON.parse(answerSdp)\r\n  if (!pc.currentRemoteDescription) {\r\n    pc.setRemoteDescription(answer)\r\n  }\r\n}\r\n```\r\n\r\n### 离开房间\r\n\r\n```typescript\r\n// 离开房间\r\nfunction handleLeave() {\r\n  // 关闭对等连接\r\n  peerConnection.close()\r\n  // 发送离开的消息\r\n  socket.emit('leave', { userId, roomId: roomId.value })\r\n  // 关闭socket连接\r\n  socket.disconnect()\r\n}\r\n```\r\n\r\n这样我们大体的 WebRTC 通信流程就完成了，下面我们就把它部署到服务器上。\r\n\r\n## 部署信令服务\r\n\r\n我们可以用 `Docker` 配合 `Nginx` 来部署你的服务，这里不做重点讲，我们主要通过 `pm2` 来帮忙部署这个服务，让我们可以快捷的测试看看， `pm2` 是一个带有负载均衡功能的 Node 应用的进程管理器，可以让你的 `Node` 应用始终保持在线，同时提供了一些其他的功能，比如日志记录、进程监控、进程守护等。\r\n\r\n### 安装 pm2\r\n\r\n```sh\r\n# 安装 pm2\r\nnpm install pm2 -g\r\n```\r\n\r\n### 启动服务\r\n\r\n```bash\r\n# 启动\r\npm2 start index.js\r\n# 查看\r\npm2 list\r\n# 停止\r\npm2 stop index.js\r\n# 重启\r\npm2 restart index.js\r\n# 删除\r\npm2 delete index.js\r\n```\r\n\r\n### 开机自启动\r\n\r\n```bash\r\n# 生成开机启动脚本\r\npm2 startup\r\n# 保存当前进程列表\r\npm2 save\r\n```\r\n\r\n## 最后\r\n\r\n[👉🏻 1.本文示例在线体验地址](https://frontend-park.vercel.app/audio-and-video/webRTC/signaling-p2p)  \r\n[👉🏻 2.本文客户端源代码地址](https://github.com/wangrongding/frontend-park)  \r\n[👉🏻 3.本文服务端源代码地址](https://github.com/wangrongding/node-park/blob/main/src/signaling/signaling-http-server.js)\r\n\r\n你可以开两个浏览器 tab 或者用不同的设备，输入房间号进去体验下。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60f0dfd24e8d4d2aa06ddb4497966d22~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n本篇文章主要是通过信令服务队上一篇文章的进阶处理，实现了自动连接的音视频通话。大家如果有什么问题，可以在评论区留言，我会及时回复。\r\n\r\n所有的文章都在 [👉🏻 这个专栏中](https://juejin.cn/column/7139951010042085407) ，如果您喜欢这个专栏的文章，或者对您有一些帮助，可以点赞鼓励，我会继续产出更好的文章给大家 ~ 谢谢🥰\r\n"
    },
    {
        "article_id": "7188883453113270329",
        "snapshot": "",
        "title": "「我的阴阳两界」微扰酱的2022年度总结",
        "preview": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 微扰酱的2022年度总结「我的阴阳两界」",
        "author": "微扰理论",
        "view_count": 710,
        "collect_count": 0,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/b037af20754a7ad5a42ae495d0d46135~300x300.image",
        "category": "代码人生",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n本文转载自我的公众号 「**微扰理论**」；[原文链接](https://mp.weixin.qq.com/s?__biz=Mzg3Mzg3MTA0OA==&mid=2247484029&idx=1&sn=1556bf5b9f4630b3f77e73f87543f855)。\r\n\r\n今年不过是我开始写年终总结的第二年，就比[去年](http://mp.weixin.qq.com/s?__biz=Mzg3Mzg3MTA0OA==&mid=2247483876&idx=1&sn=066b95b307a4df5016213752cddec897&chksm=ced82243f9afab5545628b26dc3148e801b3ba7d696a382eaae7ade4c8aaa7e78faff00180b9&scene=21#wechat_redirect)迟到了两周；未来怎样真是不好去想。好在终究是在农历新年前动起了笔，思忖再三，将题目定为了《**我的阴阳两界**》。\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca74f2d59db044618d58706254e63263~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n一方面，这是因为我非常喜爱王小波，而他的众多小说里，我最喜欢读的正是这篇《我的阴阳两界》。另一方面，今年的我和许多人一样，正好经历了从阴到阳的变化，所以拿来作为标题自然再贴切不过。\r\n\r\n当然，由于我很快又转阴了，并且以后说不准还有第二遭，这让我看起来似乎比“王二”的生命层次更丰富些；但只看我的2022好像又很难相信这样的结论。\r\n\r\n首先，还是谈一谈工作以外的事情。（为了统一叙述，下述篇幅中的今年指代2022年）\r\n\r\n# 关于疫情\r\n\r\n今年已经是新冠大流行跨越的第三个年头，这毫无疑问地改变了每一个人的生活轨迹。比较幸运的是，我身边的家人朋友尚未有人因为疫情遭受巨大的病痛甚至不幸离世；但这依旧为大家的生活带了各种各样的不便和痛苦，其中有几件事情让我感触颇深。\r\n\r\n首先是年初上海的 lockdown。由于我的家人朋友大部分居住在上海，我虽然生活在北京但还是第一时间感受到了事态的魔幻；我的妈妈后来也很无奈的跟我吐槽，一开始以为只是封闭几天，没想到一封就是3个月。也经历了抢菜的艰难，稍有松懈，饮食和起居方面就会大打折扣；当然更多的事情也不便在这里多展开了。总之，我们家已经算是颇为幸运的了，年末网易发布了一个 not exists 的年度总结，则更充分地描述了这件事。然而由于其实世界上原本就没有这样的总结视频，所以人们其实也没受过什么苦，有的只是小径分叉的花园。\r\n\r\n相比于这些，年末时新冠中招的经历则更让我觉的真实，也更加感慨这轮新冠传播力度之强。中招的时候还尚未完全放开，而我和kira酱彼时已经居家隔离一周有余，在哪都没去只有外卖和大白上门的情况下还是无可避免的阳了。依次发了两天烧，所幸时间刚好稍稍错开，让我们有了更多照顾彼此的能量；身上有诸多症状，不过都不算严重，感兴趣可以看看我的[另一篇文章](http://mp.weixin.qq.com/s?__biz=Mzg3Mzg3MTA0OA==&mid=2247484000&idx=1&sn=e1bfff7d74e8b12649a371e785c86153&chksm=ced821c7f9afa8d1736e5f2b3d69c5c2c4f781366573d5feb14673ad7c24f5e806d2490eed4d&scene=21#wechat_redirect)，不过看来大家都是阳了一轮了，所以其实也没什么额外的信息量给诸位读者了。刚检测出阳的时候，其实我最担心的还是在身体最不舒适的时候被强制拉到方舱。不过可能是因为已经临近政策全面开放，隔离区床位也不是很充沛了，工作人员还是贴心地征询了我们的意见，让我们居家就行，相比于早期我所听闻的情况要显得人性化的多。而真正感触更深的则是放开之后，疫情传播速度之快，几乎没多久，我认识的人就全阳了一遍，而家里的老人没事，还是很令人开心的；人们对新冠的态度也明显有了一些变化，可能是所谓“绝知此事要躬行”的道理。不过这些变化似乎还是没有新冠病毒本身变化的快，旦夕之间，致病力大打折扣。专家们用他们的学识解释给我们听，我比较驽钝，学得慢；而一些天资聪颖的人甚至已经发现了“益生菌”，有绘画天赋的艺术家们则又得以开始创作风趣的漫画了。\r\n\r\n由于我家的幸运和我真正关心的人其实都已经阳过且康复了的事实，可以说这次大流行尚未对我造成难以接受的直接冲击；但是他确确实实也对我造成了经济上的影响，比那种通过大环境和漫长经济链条触达的方式要清晰直接得多。\r\n\r\n相信熟悉我的朋友一定知道，悖论13，也就是去年年终总结里提到的剧本杀店在今年国庆之后就彻底关店了。店里东西被某位合伙人清空的太快，连着我高中时留下的“风声”桌游也在这片狼籍中不见了踪影，这还是很令人痛心疾首的。事实上，**每次看到这个桌游，我都能想到和那几个好朋友在夏天的高铁上穿梭于川渝大地。**  而以后，我或许只能再买一个新的风声桌游去纪念那段时间；或许我又不该这么做，那么也许我会迟早忘记这件事；不过我现在将这件事写了出来，多少又安心了一些。\r\n\r\n说回店铺的经营，我想失败的主要的原因应该还是自己和合伙人们不善于经营，毕竟政策每导致闭店一个月不过亏损3个月利润，而去年加起来闭店不会超过2个半月，那么我们应该还有4个月的利润；最后却没有赚到钱。当然，关于这样的结局，我原本也早有心理准备了，要是最后能平静的散伙，我也不会如此郁结；但至今仍然和某位合伙人有些经济问题悬而未决，就令人很难受了。不过心里面，我又不是那么怪他，但是却会更加心疼那些全部身家悬于线下经营或者经济压力巨大且必须依赖线下经营才能养家糊口的人们。我想他们中的大部分还是创造了更多更直接的价值，没有他们的话，人们的生活会变得更糟一些；我敬佩他们，也希望他们能过的更好。最近我读了大卫格雷柏的 \\\"bullshit jobs: a theory\\\" ，更有这样的感触。好了，说到底，关店不是多么光彩的事情，就不多提了；我也写了[另一篇关于这个故事的文章](http://mp.weixin.qq.com/s?__biz=Mzg3Mzg3MTA0OA==&mid=2247483924&idx=1&sn=cb10c992761db035e87a5343a9d9d6c9&chksm=ced821b3f9afa8a5dbae0ce153e399cdca4dce0047d115643c7d92fc8b5fc24252e84626176a&scene=21#wechat_redirect)，感兴趣可以去看看。\r\n\r\n这些就是疫情期间对我触动颇大的几件事情，他们贯穿了我的整个2022。我有时候在想，这次大流行对人们的影响也许才刚刚开始，又会在何时以何种方式结束呢？谁也不知道。\r\n\r\n# 关于旅行\r\n\r\n受限于疫情的影响，今年去的地方要少得多；我和kira酱一起去往的城市只有4个，分别是上海，渭南（途径西安），长沙，昆明。不过很开心的是，我们已经一起去过彼此的家乡，见过彼此的家人；**在许多次旅途的路上，我都在想，也许很快我也会进入人生的下一段旅程了，是令人期待的**。\r\n\r\n在旅途中还有一个比较大的变化在于，接近年末的时候，我重拾了对摄影的兴趣；尤其是开始考虑拍视频的运镜技巧，这让我收获了很多乐趣。一方面这让我多了一些维度去欣赏日常看的电影和视频；另一方面，相比于捕捉某一个瞬间，和时间扯上关系之后确实让普通人有更多的发挥空间，算是一个门槛不高又能充分感受创造力的活动。我自己是很期待明年可以分享一些能看得过去的作品给大家的（若是以现在的水准贸然发出来的话，可能只会以被kira酱打一顿告终）。\r\n\r\n# 关于工作\r\n\r\n相比于以往，我现在会把更多的时间划分到工作的范畴内。只要我认为自己通过劳动行为对一部分人产生了价值的事情，不管有无真正的收入，我都把他们定义成工作。只是其中有一些事情更快乐一些，有一些事情没那么快乐；而我现在倾向于不去做那些不快乐的事情。至于剩下一部分事情，比如你拿到了在办公室待满足够时间就能得到的收入，但在此期间却没有产生什么价值，我觉得这不是工作，只是 bullshit，而这个社会像这样的岗位可太多了。所以当我见到有些时候，企业们纷纷发现不再需要继续雇这么多人撑场面就赶紧把他们输送到社会上其他更能发光发热的地方去时，我一点也不意外。我能有这样奇怪的想法，多少是受了 David Graeber 这个疯言疯语的人的影响，如果你不同意可以不用理睬我。我想我在“王二”那个年代，可能也会被人叫做“小神经”，而正常人是不会想要理睬“小神经”的。\r\n\r\n那么下面我来谈谈“小神经”在工作方面的变化。\r\n\r\n先谈谈全职工作方面的变化。由于年初的时候和前司某位founder有一些不愉快，虽然我对他很respect，**因为他很酷，热爱开源和摇滚乐，在他的世界里似乎可以做自己想做的大部分事情**，我还是决定离开这家公司了。毕竟，他的世界里对他来说是好的，但我跟他交流之后，我就不太想成为其中的一部分了，我想有我自己的世界。当然更重要的原因还是，后来做的事情开始无聊了，这样的工作不是小神经能做的；于是我去了现在的公司，真正开始接触比较传统的数据库开发，认识了我现在的leader。我觉得他是一个蛮纯粹的人，挺喜欢数学的，所以去PKU也读的是数学，有时候说虽然已经错过了最佳年龄，以后有机会还是可以去搞个数学系PhD读读，做点研究；肯定也还是很喜欢写代码的，年纪比我大不少，思维非常敏捷，记忆力更是出奇的好。对 postgres 代码真的非常熟悉，基本可以做到指哪打哪，有什么问题只要不算太复杂，都可以很快地定位到相关的代码，这可是有200万行代码的大家伙。事实上，我在加入这家公司之前，确实还是低看了数据库的复杂度；而现在我终于知道程序员之间的参差，见过了 tom lane 每天在社区里的活跃度，我有什么理由不相信自己也会写代码写到60岁呢？\r\n\r\n下面说点实际的吧。虽然我的基础不好，今年还是对 postgres 源码有了比较体系化的学习；最近两个月主要都在独立做一个关于在 greenplum 中支持 pg 并行化的重构，而加起来其实也只是一个 700 多行的 patch，这两天刚刚进入尾声，前后收获了近百条 comments；这在以往的工作中确实是没遇到过的情况，那时候，一天也许都可以写700行代码。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7747977bcf2344d6bf7636524d24c2f5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我确实在开发这个 patch 的过程中学到了很多，尤其是对执行器部分源码的理解得到了飞跃式的提升，算是对大部分数据库算子的实现逻辑都有了初步的认知；在刚入职时许多不理解的代码，现在看来则充满了设计之美，Clang这么古老的语言在宏和函数指针的加持下充满了OOP的智慧。当然，要是能更有函数式编程的影子就更好了。\r\n\r\n从今年夏秋之交开始，我也陆续写了一些关于 postgres 或者其他数据库相关的文章；并试图给 pg 社区提过一个 patch，可惜的是似乎没有人理睬我；希望明年可以再接再厉。除了我司产品预期的开源之外，也可以再多参与一些其他社区的贡献，毕竟今年在开源项目上的投入相比于去年来说降的很低了，github上大部分贡献还都是个人的以学习为目的或者干脆就是笔记之类的项目。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e3c2cefb4349ffb381b4d3b0e803f2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n除了本职工作之外，今年还是有一些其他有意思的事情发生的。比如我建立的两个学习小组运转良好，规则要求每个成员都需要隔天写笔记打卡阅读或者CSAPP，运作一年之后仍然在继续活跃，有一些群友通过这个小组真正意义上完成了CSAPP的阅读则是令我最欣慰的事情。对我个人来说，这也真正让我的阅读习惯得以养成，去年明显读了更多的书，而大部分都是在下半年完成的；未来一年，也许我会考虑将这件事变得更自动化，让更多的人得以参与。感兴趣可以参考我的[另一篇文章](http://mp.weixin.qq.com/s?__biz=Mzg3Mzg3MTA0OA==&mid=2247483980&idx=2&sn=ebae32053c879cab9e612550e3c3789a&chksm=ced821ebf9afa8fd6386adcf0e18cd5f4c438db4127acad79decccda1da9d0f09ee1c4c08d4a&scene=21#wechat_redirect)。\r\n\r\n不过在自媒体方面，由于我的惰性，去年坚持的日更力扣每日一题题解的活动终究是断了。相关社群的活跃度滑落得一日千丈，**最近几乎没人在群里讨论算法问题了，这令我很难受**。也许明年再开始多花一些时间更新算法方面的内容？不知道能不能坚持，毕竟这算真正的为爱发电行为。不过，自己的公众号和知乎维护的更好一些了，有了一些粉丝，感谢大家的关注。\r\n\r\n而关于极客时间的专栏，其实我写完之后还是有不少不满意的地方；大概是因为去年每周被催更的日子太不好受，我报复性的后来很长一段时间都歇笔了（其实力扣停更和换工作也都是在那一段时间里发生的）。明年要多搞搞，尤其是争取修订一些其中明显的错误并争取把纸质版出版；录制相关视频和补充专栏中各个算法的实现也是一个重要的计划。\r\n\r\n个人项目方面则是失败的一塌糊涂。**科研方面最近进展为零，完全不知道怎么跟老板交差**，想着春节期间要好好整理一下之后的方向；其他的几个side project idea则永远停留在idea之上，这些可能都需要通过更科学的任务管理手段和更强的内在驱动力去推进。我的同事 rose 在这方面给了我很好的例子，rosedb 作为个人项目，已经算颇受欢迎，虽然离生产还很遥远；我想着这已经是绝大部分普通开发者能做到的天花板了，如果能做到我前司 emqx 那样的程度，则多少也需要很好的时运，让作者可以真的无所顾忌的投入其中才行；并且在此之前，也许也要有更多的积累。明年我该在这些方面想想办法了。\r\n\r\n总之，今年工作方面除了在本职工作方面更加意识到自己和一流程序员的差距和真正进入了数据库内核开发者的行列之外，可以说没什么进展；只好在明年再接再厉了。\r\n\r\n# 关于我的阴阳两界\r\n\r\n不过我想去年最大的变化应该还是发生在心理上；**在我的28岁，我认为，如果我的一生也有阴阳两界，那应该分界线就在我的这一时期**，而且是一段时期，也许会持续两三年。虽然，以后我可能又不这么想了。\r\n\r\n其实我跟我女朋友之前一直有一些争论，关于我是不是喜欢社交这件事。不过现在我们知道了，结论是我喜欢社交，因为她在很多事情都更有道理；随着时间推移，只要给我时间思考，我越来越可以懂得她的道理了。这是一件好事。\r\n\r\n比如关于我喜欢社交这件事，有很多证据。比如我跟我的朋友相处时非常愉快；虽然我在北京，但我总想着我上海的朋友们；我还开剧本杀店，这么多人，不喜欢社交的人不会开这样的店。并且我又好像比较热衷于组织或者参与一些活动，尤其是我总想着做一些社区的产品（比如本科的时候我就做过这样的尝试）；这事实上与我对技术本身的投入共同争抢着我的时间。而每每我表达了我对前者的一些兴趣，kira酱自然就会更觉得我是喜欢社交的人。\r\n\r\n其实我本身对这种事是无所谓的，不过由于kira酱不是个热衷于社交的人，我要是喜欢社交，在某些程度上来说我和她就不是“自己人”，这就让我不太开心。****\r\n\r\n不过最近我找到一些证据证明我们其实还是“自己人”，即使我喜欢社交而她不喜欢。在更早的时候，我是非常不喜欢线上交友的，因为我不喜欢打字交流这样低效率的方式，而且整个线上社交的大环境也显得更加浑浊；但是最近我却发现这已经是我最喜欢社交的方式之一了。比如，每周五，我会参加一个好朋友组织的英语角，里面全部都是程序员。大家彼此不认识，但是能听到彼此交流对一些问题的真实且深刻的看法；许多时候，我和很多好朋友之间也没法聊这些。更令人开心的环节则是**很多时候大家会交流到一些天才般极富创造力的想法**，比如，有人想做一个帮助人们学习语言的视频播放器，可以只展示一部分你不熟悉的词汇的字幕；配合上 beyond player (这同样是一款非常酷的软件) 的回放功能，正是我想要的播放器。你们可以一起交换信息，甚至一起创造新的事物（这不正是程序员存在的意义吗），因为参与者都和你有相似的背景和想法；相比于在人群中偶然的遇见，这样的邂逅虽然少了浪漫，效率却大大提高了，我以为在爱情以外的范畴是最适合的。\r\n\r\n还有，通过写文章，我也认识了许多有趣的人，他们用自己的影响力改变着世界的某个方面；我可以和他们一起讨论一些有趣的 side project 的想法；也能从他们身上学习到很多优秀的品质，他们中的大部分都有很强的自驱力，这是我需要持续努力的地方。在这些社交活动中，我获得了许多益处，也让我即使在北京远离了我的朋友家人们，还能在kira酱以外的空间里感受到和这个世界强烈的联系。\r\n\r\n所以，我现在终于发现了，我喜欢社交的本质只是因为我喜欢和“自己人”们交流想法，而那也许只是出于我所念着的思维和创造的乐趣吧。\r\n\r\n**现在，我也喜欢和kira酱交流想法，因此，我和她也还是“自己人”** ，即使她不喜欢社交而我喜欢。\r\n\r\n# 结语\r\n\r\n那么如果对我来说也存在着阴阳两界，那又是以什么为界的呢？我其实心里已经有答案了，不过说出来就有些傻了，我不明说了。\r\n\r\n不过我们可以一起来看看“王二”是怎么划分的，明着来说自然是以某种不可言说的生理性障碍为界，不过字里行间也许能得到另一种答案。\r\n\r\n> 硬的时候我们急着去要自己分内的那点东西，丝毫不想它是不是自己想要的。等到有了一点自己想要的东西，不管是它是署了自己名字的小说，还是西夏文，就已经活到了另一界了。\r\n\r\n祝愿大家也都可以像王小波一样有趣地生活，也许还能找到自己的“西夏文”和“李银河”；当然关于什么是西夏文，就强烈推荐你看一下小波的书了。\r\n\r\n最后，也欢迎大家多多关注「微扰理论」。如果觉得本文对你有所帮助，可以分享给你的好朋友们，也欢迎在看、留言、点赞三连；**每个你留下的痕迹都是对微扰酱最好的支持**。"
    },
    {
        "article_id": "7186539152630874149",
        "snapshot": "",
        "title": "聊聊Spring中的@Autowired注解",
        "preview": "大家好，我是Spring作者Juergen Hoeller中的Hoeller。 今天来跟大家聊聊简单聊聊@Autowired，Autowired翻译过来为自动装配，也就是自动给Bean对象的属性赋值。",
        "author": "Hoeller",
        "view_count": 4100,
        "collect_count": 6,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0e466d365612d64690d726441f984d32~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: smartblue\r\n---\r\n大家好，我是Spring作者Juergen Hoeller中的Hoeller。\r\n\r\n今天来跟大家聊聊简单聊聊@Autowired，Autowired翻译过来为自动装配，也就是**自动给Bean对象的属性赋值**。\r\n\r\n```\r\n@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, \r\n         ElementType.PARAMETER, ElementType.FIELD, \r\n         ElementType.ANNOTATION_TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\npublic @interface Autowired {\r\n\r\n\\t/**\r\n\\t * Declares whether the annotated dependency is required.\r\n\\t * <p>Defaults to {@code true}.\r\n\\t */\r\n\\tboolean required() default true;\r\n\r\n}\r\n```\r\n\r\n以上是@Autowired的定义，重点看 **@Target**，我们发现@Autowired可以写在：\r\n\r\n1.  ElementType.CONSTRUCTOR：表示可以写在构造方法上\r\n2.  ElementType.METHOD：表示可以写在普通方法上\r\n3.  ElementType.PARAMETER：表示可以写在方法参数前\r\n4.  ElementType.FIELD：表示可以写在属性上\r\n5.  ElementType.ANNOTATION_TYPE：表示可以写在其他注解上\r\n\r\n  \r\n\r\n\r\n### 写在构造方法上\r\n\r\n对于@Autowired写在构造方法上的情况，跟Spring选择构造方法的逻辑有关，一个类中是不是有多个构造方法，是不是加了@Autowired注解，是不是有默认构造方法，跟构造方法参数类型和个数都有关系，后面单独来介绍。\r\n\r\n### 写在普通方法上\r\n\r\n对于@Autowired写在普通方法上的情况，我们通常写的setter方法其实就是一个普通的setter方法，那非setter方法上加@Autowired会有作用吗？\r\n\r\n比如：\r\n\r\n```\r\n@Component\r\npublic class UserService {\r\n\r\n\\t@Autowired\r\n\\tpublic void test(OrderService orderService) {\r\n\\t\\tSystem.out.println(orderService);\r\n\\t}\r\n\r\n}\r\n```\r\n\r\n  \r\n\r\n\r\n这个test方法会被Spring自动调用到，并且能打印出OrderService对应的Bean对象。\r\n\r\n### 写在方法参数前\r\n\r\n把@Autowired写在参数前没有多大意义，只在spring-test中有去处理这种情况，源码注释原文：\r\n\r\nAlthough @Autowired can technically be declared on individual method or constructor parameters since Spring Framework 5.0, most parts of the framework ignore such declarations. The only part of the core Spring Framework that actively supports autowired parameters is the JUnit Jupiter support in the spring-test module\r\n\r\n### 写在属性上\r\n\r\n这种情况不用多说了，值得注意的是，默认情况下，因为@Autowired中的required属性为true，表示强制依赖，如果更加某个属性找不到所依赖的Bean是不会赋null值的，而是会报错，如果把required属性设置为false，则会赋null值。\r\n\r\n### 写在其他注解上\r\n\r\n比如我们可以自定义要给注解：\r\n\r\n```\r\n@Autowired\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface HoellerAutowired {\r\n}\r\n```\r\n\r\n@HoellerAutowired和@Autowired是等价的，能用@Autowired的地方都可以用@HoellerAutowired代替。\r\n\r\n以上，随便写写，谢谢大家的观看。\r\n"
    },
    {
        "article_id": "7169546701500317709",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506e4a6fa3004fba9b0356c9e3afd428~tplv-k3u1fbpfcp-watermark.image?",
        "title": "公共Hooks封装之文件下载useDownloadFile",
        "preview": "开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第1天，点击查看活动详情 对于经常需要开发企业管理后台的前端开发来说，必不可少的需要使用表格对于数据进行操作，在对于现有项目进行代码",
        "author": "JasonSubmara",
        "view_count": 2422,
        "collect_count": 94,
        "comment_count": 15,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/a81904948b5f7b7e1d01a83df93583b3~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第1天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702)\r\n\r\n> 写在前面 <br>\r\n对于经常需要开发企业管理后台的前端开发来说，必不可少的需要使用表格对于数据进行操作，在对于现有项目进行代码优化时，封装一些公共的Hooks.<br>\r\n本篇文章为`useDownloadFile.js`\r\n\r\n> 基于个人项目环境进行封装的Hooks，仅以本文介绍封装Hooks思想心得，故相关代码可能不适用他人\r\n\r\n### 项目环境\r\nVue3.x + Ant Design Vue3.x + Vite3.x\r\n\r\n对于企业管理后台中常见的各类资源文件（图片、文档、音视频等），下载保存本地则是再正常不过的需求了，为保证统一性和避免每个单页面文件内重复书写冗余代码，封装此方法\r\n\r\n### 封装前提：各方法对比\r\n\r\n| 方法 | 操作原理 | 优点 | 缺点 |\r\n| --- | --- | --- | --- |\r\n| form 表单 | 动态生成一个表单，利用表单提交的功能来实现文件的下载 | 兼容性好，不会出现URL长度限制问题 | 无法知道下载的进度，用户体验交互差<br>无法直接下载浏览器可直接预览的文件类型 |\r\n| window.open / location.href | 打开新标签页访问下载资源 | 简单粗暴 | 会出现URL长度限制问题<br>无法知道下载的进度，用户体验交互差<br>无法直接下载浏览器可直接预览的文件类型<br>需要注意url编码问题<br>不能添加header，也就不能进行鉴权 |\r\n| `<a />` download 属性 | 利用a标签原生访问属性，附加新增的download属性，使用浏览器进行下载 | 简单粗暴且可下载正常预览文件 | 不能下载跨域地址文件<br>IE/Edge内兼容问题<br>无法鉴权 |\r\n| Blob 对象 | 发请求获取二进制数据，转化为Blob对象，利用URL.createObjectUrl生成url地址，赋值在a标签的href属性上，结合download进行下载 | 能解决不能直接下载浏览器可浏览的文件<br>可以鉴权| IE10以下不可用<br>Safari使用情况可能有问题 |\r\n\r\n综上并结合实际项目，最后使用Blob对象进行封装下载文件方法\r\n\r\n### 封装分解：下载核心代码\r\n``` javascript :no-line-numbers\r\nxhr.onloadend = function (e) {\r\n  if (e.target.status === 200 || e.target.status === 304) {\r\n    const aElement = document.createElement('a');\r\n    const blob = e.target.response;\r\n    const url = window.URL.createObjectURL(blob);\r\n    aElement.style.display = 'none';\r\n    aElement.href = url;\r\n    aElement.download = `${options.fileName}.${fileType}`;\r\n    document.body.appendChild(aElement);\r\n    aElement.click();\r\n    if (window.URL) {\r\n      window.URL.revokeObjectURL(url);\r\n    } else {\r\n      window.webkitURL.revokeObjectURL(url);\r\n    }\r\n    document.body.removeChild(aElement);\r\n  }\r\n};\r\nxhr.send();\r\n```\r\n\r\n### 封装分解：用户体验设计\r\n- 下载过程中，配合项目使用的Ant Design Vue框架，可以加强用户感知文件下载进度，\r\n- 为防止用户暴力点击，重复触发下载的问题，使用Loading Flag标识，\r\n- 下载失败后，提示用户，重新下载\r\n\r\n``` javascript :no-line-numbers\r\ncreateVNode('div', {}, ['文件下载过程中请勿关闭当前页面']),\r\ncreateVNode('div', { className: 'mt-2' }, [`当前下载进度 ${progress.value}%`]),\r\n\r\ncatch (e) {\r\n  console.error(e);\r\n  downloading = false;\r\n  infoModal && infoModal.destroy();\r\n  Modal.error({\r\n    title: '提示',\r\n    content: '下载发生异常，请重试',\r\n  });\r\n}\r\n```\r\n\r\n### useDownloadFile.js完整代码\r\n``` javascript :no-line-numbers\r\nimport { createVNode, ref, onBeforeUnmount } from 'vue';\r\nimport { Modal } from 'ant-design-vue';\r\n\r\nexport function useDownloadFile() {\r\n  let xhr = null;\r\n  let downloading = false; // 限制同一文件同时触发多次下载\r\n  let infoModal;\r\n\r\n  onBeforeUnmount(() => {\r\n    xhr && xhr.abort();\r\n  });\r\n\r\n  const downloadFile = options => {\r\n    try {\r\n      if (downloading || !options.url || !options.fileName) return;\r\n      downloading = true;\r\n      options.url = options.url.replace('http://', 'https://');\r\n      const progress = ref(0);\r\n      const fileType = options.url.split('.').pop();\r\n      xhr = new XMLHttpRequest();\r\n      xhr.responseType = 'blob';\r\n      xhr.open('get', options.url, true);\r\n      infoModal = Modal.info({\r\n        title: '文件下载',\r\n        okText: '取消下载',\r\n        content: () => {\r\n          return createVNode('div', {}, [\r\n            createVNode('div', {}, ['文件下载过程中请勿关闭当前页面']),\r\n            createVNode('div', { className: 'mt-2' }, [`当前下载进度 ${progress.value}%`]),\r\n          ]);\r\n        },\r\n        onOk() {\r\n          xhr.abort();\r\n          return Promise.resolve();\r\n        },\r\n      });\r\n      xhr.onprogress = function (e) {\r\n        progress.value = Math.floor((e.loaded / e.total) * 100);\r\n        if (progress.value === 100) {\r\n          downloading = false;\r\n          infoModal.destroy();\r\n        }\r\n      };\r\n      xhr.onloadend = function (e) {\r\n        if (e.target.status === 200 || e.target.status === 304) {\r\n          const aElement = document.createElement('a');\r\n          const blob = e.target.response;\r\n          const url = window.URL.createObjectURL(blob);\r\n          aElement.style.display = 'none';\r\n          aElement.href = url;\r\n          aElement.download = `${options.fileName}.${fileType}`;\r\n          document.body.appendChild(aElement);\r\n          aElement.click();\r\n          if (window.URL) {\r\n           window.URL.revokeObjectURL(url);\r\n          } else {\r\n            window.webkitURL.revokeObjectURL(url);\r\n          }\r\n          document.body.removeChild(aElement);\r\n        }\r\n      };\r\n      xhr.send();\r\n    } catch (e) {\r\n      console.error(e);\r\n      downloading = false;\r\n      infoModal && infoModal.destroy();\r\n      Modal.error({\r\n        title: '提示',\r\n        content: '下载发生异常，请重试',\r\n      });\r\n    }\r\n  };\r\n\r\n  return {\r\n    downloadFile,\r\n  };\r\n}\r\n```\r\n\r\n### 系列文章\r\n- [公共Hooks封装之文件下载useDownloadFile](https://juejin.cn/post/7169546701500317709)\r\n- [公共Hooks封装之报表导出useExportExcel](https://juejin.cn/post/7170948983219552270)\r\n- [公共Hooks封装之表格数据useTableData](https://juejin.cn/post/7171784482804989959)\r\n- [公共Hooks封装之请求参数useQueryParams](https://juejin.cn/editor/drafts/7174272140529631263)\r\n\r\n### 写在最后\r\n\r\n- 文章内容为**个人基于实际项目并脱敏处理的原创内容**，如需要转载请备注原文链接～\r\n- 如果看完文章对于你有帮助，就来一键三连吧～更欢迎您在评论区进行指点"
    },
    {
        "article_id": "7175689778090901561",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45b69b135424ee492fef7769b7c9744~tplv-k3u1fbpfcp-watermark.image?",
        "title": "JavaScript 最佳实践：如何写出更可靠、更高性能的代码",
        "preview": "自2000年以来，Web开发一直在以惊人的速度发展。从最初毫无章法可循的 “野蛮生长”，到如今已发展出完整的规范体系，各种研究成果和最佳实践层出不穷。Web开发领域的最新技术和开发工具已经令人目不暇接",
        "author": "CoderBin",
        "view_count": 3363,
        "collect_count": 116,
        "comment_count": 20,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/880868841b36eb13d36e1a0ab7a52cac~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: vuepress\r\nhighlight: atom-one-dark\r\n---\r\n\r\n# 前言\r\n自2000年以来，Web 开发一直在以惊人的速度发展。从最初毫无章法可循的 “野蛮生长”，到如今已发展出完整的规范体系，各种研究成果和最佳实 践层出不穷。Web 开发领域的最新技术和开发工具已经令人目不暇接。其中，前端三件套中的核心 JavaScript 尤其成为了研究和关注的焦点。 JavaScript 的最佳实践可以分成几类，适用于开发流程的不同阶段。\r\n>提示：阅读本文大约需要50分钟\r\n## 1. 可维护性\r\n在早期网站中，JavaScript 主要用于实现一些小型动效或表单验证。今天的 Web 应用程序则动辄成千上万行 JavaScript 代码，用于完成各种各样的复杂处理。这些变化要求开发者把可维护能力放到重要位置上。正如更传统意义上的软件工程师一样，JavaScript 开发者受雇是要为公司创造价值的。他们不仅要保证产品如期上线，而且要随着时间推移为公司不断积累 知识资产。 \r\n\r\n**编写可维护的代码十分重要，因为大多数开发者会花大量时间去维护别人写的代码**。实际开发中，从第一行代码开始写起的情况非常少，通常是要在别人的代码之上构建自己的工作。让自己的代码容易维护，可以保证其他开发者更好地完成自己的工作。\r\n\r\n**注意**：可维护代码的概念并不只适用于 JavaScript，其中很多概念适用于所有编程语言，尽管部分概念特定于 JavaScript。\r\n\r\n### 1.1 什么是可维护的代码\r\n通常，说代码“可维护”就意味着它具备如下特点。\r\n\r\n* **容易理解** ：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它是怎么实现的。 \r\n* **符合常识** ：代码中的一切都显得顺理成章，无论操作有多么复杂。 \r\n* **容易适配** ：即使数据发生变化也不用完全重写。\r\n* **容易扩展** ：代码架构经过认真设计，支持未来扩展核心功能。 \r\n* **容易调试** ：出问题时，代码可以给出明确的信息，通过它能直接定位 问题。\r\n\r\n**能够写出可维护的 JavaScript 代码是一项重要的专业技能。这就是业余爱好者和专业开发人员之间的区别，前者用一个周末就拼凑出一个网站，而后者真正了解自己的技术。**\r\n\r\n### 1.2 编码规范\r\n**编写可维护代码的第一步是认真考虑编码规范**。大多数编程语言会涉及编码规范，简单上网一搜，就可以找到成千上万的相关文章。专业组织有为开发者建立的编码规范，旨在让人写出更容易维护的代码。优秀开源项目有严格的编码规范，可以让社区的所有人容易地理解代码是如何组织的。 \r\n\r\n编码规范对 JavaScript 而言非常重要，因为这门语言实在太灵活了。与大多数面向对象语言不同， JavaScript 并不强迫开发者把任何东西都定义为对象。它支持任何编程风格，包括传统的面向对象编程、声明式编程，以及函数式编程。简单看几个开源的 JavaScript库，就会发现有很多方式可以创建对象、定义方法和管理环境。\r\n\r\n接下来的几节会讨论制定编码规范的一些基础知识。这些话题很重要，当然每个人的需求不同，实现方式也可以不同。\r\n\r\n#### 1.2.1 可读性\r\n要想让代码容易维护，首先必须使其可读。可读性必须考虑代码是一种文本文件。**为此，代码缩进是保证可读性的重要基础**。如果所有人都使用相同的缩进，整个项目的代码就会更容易让人看懂。缩进通常要使用空格数而不是Tab（制表符）来定义，因为后者在不同文本编辑器中的显示不同。一般来说，缩进是4个空格，当然具体多少个可以自己定。 \r\n\r\n**可读性的另一方面是代码注释**。在大多数编程语言中，广泛接受的做法是为每个方法都编写注释。因为 JavaScript 可以在代码中的任何地 方创建函数，所以这一点经常被忽视。正因为如此，可能给 JavaScript 中的每个函数都写注释才更重要。一般来说，以下这些地方应该写注释。\r\n\r\n* **函数和方法** 。每个函数和方法都应该有注释来描述其用途，以及完成任务所用的算法。同时，也写清使用这个函数或方法的前提 （假设）、每个参数的含义，以及函数是否返回值（因为通过函 数定义看不出来）。\r\n\r\n* **大型代码块** 。多行代码但用于完成单一任务的，应该在前面给出注释，把要完成的任务写清楚。 \r\n* **复杂的算法** 。如果使用了独特的方法解决问题，要通过注释解释明白。这样不仅可以帮助别人查看代码，也可以帮助自己今后查 看代码。 \r\n* **使用黑科技** 。由于浏览器之间的差异，JavaScript 代码中通常包含一些黑科技。不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用途写出来。这样可以避免别人误以为黑科技没有用而把它“修复”掉，结果你已解决的问 题又会出现。\r\n\r\n**缩进和注释可以让代码更容易理解，将来也更容易维护。**\r\n\r\n#### 1.2.2 变量和函数命名\r\n代码中变量和函数的适当命名对于其可读性和可维护性至关重要。因为很多 JavaScript 开发者是业余爱好者出身，所以很容易用foo 、 bar 命名变量，用 doSomething 来命名函数。专业 JavaScript 开发者必须改掉这些习惯，这样才能写出可维护的代码。以下是关于命名的通用规则。\r\n\r\n* **变量名应该是名词**，例如 car 或 person 。\r\n\r\n*  **函数名应该以动词开始**，例如 `getName()` 。返回布尔值的函数 通常以 is 开头，比如 `isEnabled()` 。\r\n*  对变量和函数都使用符合逻辑的名称，不用担心长度。长名字的问题可以通过后处理和压缩解决（后面会讨论）。 \r\n*  **变量、函数和方法应该以小写字母开头，使用驼峰大小写 （camelCase）形式**，如 `getName()` 和 `isPerson` 。类名应该首 字母大写，如Person 、RequestFactory 。常量值应该全部 大写并以下划线相接，比如 `REQUEST_TIMEOUT` 。 \r\n*  **名称要尽量用描述性和直观的词汇**，但不要过于冗长。 `getName()` 一看就知道会返回名称，而 `PersonFactory` 一看就知道会产生某个 Person 对象或实体。\r\n\r\n#### 1.2.3 变量类型透明化\r\n因为 JavaScript 是松散类型的语言，所以很容易忘记变量包含的数据类型。**适当命名可以在某种程度上解决这个问题**，但还不够。有三种方式可以标明变量的数据类型。\r\n\r\n**第一种标明变量类型的方式是通过初始化**。定义变量时，应该立即将其初始化为一个将来要使用的类型值。例如，要保存布尔值的变量，可以将其初始化为 true 或 false ；而要保存数值的变量，可以将其初始化为一个数值。再看几个例子：\r\n```js\r\n// 通过初始化标明变量类型\r\nlet found = false; // 布尔值\r\nlet count = -1;    // 数值\r\nlet name = \\\"\\\";     // 字符串\r\nlet person = null; // 对象\r\n```\r\n初始化为特定数据类型的值可以明确表示变量的类型。ES6之前，初始化方式不适合函数声明中函数的参数；ES6之后，可以在函数声明中为参数指定默认值来标明参数类型。\r\n\r\n**第二种标明变量类型的方式是使用匈牙利表示法**。匈牙利表示法指的是在变量名前面前缀一个或多个字符表示数据类型。这种表示法曾在脚本语言中非常流行，很长时间以来也是 JavaScript 首选的格式。对于基本数据类型，JavaScript传统的匈牙利表示法用 o 表示对象，s 表示字符串，i 表示整数，f 表示浮点数，b 表示布尔值。示例如下：\r\n```js\r\n// 使用匈牙利表示法标明数据类型\r\nlet bFound;  // 布尔值\r\nlet iCount;  // 整数\r\nlet sName;   // 字符串\r\nlet oPerson; // 对象\r\n```\r\n匈牙利表示法也可以很好地应用于函数参数。它的缺点是使代码可读性下降、不够直观，并破坏了类似句子的自然阅读流畅性。因此，匈牙利表示法在开发者中失宠了。\r\n\r\n**最后一种标明变量类型的方式是使用类型注释**。类型注释放在变量名后面、初始化表达式的前面。基本思路是在变量旁边使用注释说明类型，比如：\r\n```js\r\n// 使用类型注释表明数据类型\r\nlet found /*:Boolean*/ = false\r\nlet count /*:int*/ = 10\r\nlet name /*:String*/ = 'Nicholas'\r\nlet person /*:Object*/ = null\r\n```\r\n类型注释在保持代码整体可读性的同时向其注释了类型信息。类型注释的缺点是不能再使用多行注释把大型代码块注释掉了。因为类型注释也是多行注释，所以会造成干扰，如下例所示：\r\n```js\r\n// 这样多行注释不会生效\r\n/*\r\nlet found /*:Boolean*/ = false;\r\nlet count /*:int*/ = 10;\r\nlet name /*:String*/ = \\\"Nicholas\\\";\r\nlet person /*:Object*/ = null;\r\n*/\r\n```\r\n这里本来是想使用多行注释把所有变量声明都注释掉。但类型注释产生了干扰，因为第一个/* （第2行）的实例会与第一个*/ （第3行） 的实例匹配，所以会导致语法错误。如果想注释掉使用类型注释的代码，则只能使用单行注释一行一行地注释掉每一行（很多编辑器可以自动完成）。\r\n\r\n**以上是最常用的三种标明变量数据类型方式。每种方式都有其优点和缺点，可以根据实际情况选用。关键要看哪一种最适合自己的项目， 并保证一致性。**\r\n\r\n### 1.3 松散耦合\r\n**只要应用程序的某个部分对另一个部分依赖得过于紧密，代码就会变成紧密耦合，因而难以维护**。典型的问题是在一个对象中直接引用另一个对象，这样，修改其中一个，可能必须还得修改另一个。紧密耦合的软件难于维护，肯定需要频繁地重写。\r\n\r\n考虑到相关的技术，Web 应用程序在某些情况下可能变得过于紧密耦合。关键在于有这个意识，随时注意不要让代码产生紧密耦合。\r\n\r\n#### 1.3.1 解耦HTML/JavaScript\r\n**Web 开发中最常见的耦合是 HTML/JavaScript 耦合**。在网页中，HTML和 JavaScript 分别代表不同层面的解决方案。HTML 是数据，JavaScript 是行为。这是因为它们之间要交互操作，需要通过不同的方式将这两种技术联系起来。可惜的是，其中一些方式会导致 HTML 与 JavaScript 紧密耦合。\r\n\r\n把 JavaScript 直接嵌入在 HTML 中，要么使用包含嵌入代码的 `<script>` 元素，要么使用 HTML 属性添加事件处理程序，这些都会造成紧密耦合。比如下面的例子：\r\n```html\r\n<!-- 使用<script>造成HTML/JavaScript紧密耦合 -->\r\n<script>\r\n  document.write('Hello world!')\r\n</script>\r\n<!-- 使用事件处理程序属性造成HTML/JavaScript紧密耦合 -->\r\n<input type=\\\"button\\\" value=\\\"Click Me\\\" onclick=\\\"handleClick()\\\" />\r\n```\r\n虽然技术上这样做没有问题，但实践中，这样会将表示数据的 HTML 与定义行为的 JavaScript 紧密耦合在一起。**理想情况下，HTML 和 JavaScript 应该完全分开，通过外部文件引入 JavaScript，然后使用 DOM 添加行为**。\r\n\r\nHTML 与 JavaScript 紧密耦合的情况下，每次分析 JavaScript 的报错都要先确定错误来自 HTML 还是 JavaScript。这样也会引发代码可用性的新错误。在这个例子中，用户可能会在 `handleClick()` 函数可用之 前点击按钮，从而导致 JavaScript 报错。因为每次修改按钮的行为都需要既改 HTML 又改  JavaScript，而实际上只有后者才是有必要修改的，所以就会降低代码的可维护性。\r\n\r\n在相反的情况下，HTML 和 JavaScript 也会变得紧密耦合：把 HTML 包含在 JavaScript 中。这种情况通常发生在把一段 HTML 通过 innerHTML 插入到页面中时，示例如下：\r\n```js\r\n// HTML紧密耦合到了JavaScript\r\nfunction insertMessage(msg) {\r\n  let container = document.getElementById('container')\r\n  container.innerHTML = `\r\n    <div class=\\\"msg\\\">\r\n      <p> class=\\\"post\\\">${msg}</p>\r\n      <p><em>Latest message above.</em></p>\r\n    </div>\r\n  `\r\n}\r\n```\r\n**一般来说，应该避免在 JavaScript 中创建大量 HTML**。同样，这主要是为了做到数据层和行为层各司其职，在出错时更容易定位问题所在。使用上面的示例代码时，如果动态插入的 HTML 格式不对，就会造成页面布局出错。不过在这种情况下定位错误就更困难了，因为这时候通常首先会去找页面中出错的 HTML 源代码，但又找不到，因为它是动态生成的。修改数据或页面的同时还需要修改J avaScript，这说明两层是紧密耦合的。\r\n\r\n**HTML 渲染应该尽可能与 JavaScript 分开**。在使用 JavaScript 插入数据时，应该尽可能不要插入标记。相应的标记可以包含并隐藏在页面中，在需要的时候 JavaScript 可以直接用它来显示，而不需要动态生成。另一个办法是通过 Ajax 请求获取要显示的 HTML，这样也可以保证同一个渲染层（PHP、JSP、Ruby等）负责输出标记，而不是把标记嵌 在 JavaScript 中。 \r\n\r\n**解耦HTML和JavaScript可以节省排错时间，因为更容易定位错误来源**。同样解耦也有助于保证可维护性。修改行为只涉及JavaScript， 修改标记只涉及要渲染的文件。\r\n\r\n#### 1.3.2 解耦CSS/JavaScript\r\nWeb 应用程序的另一层是 CSS，主要负责页面显示。JavaScript 和 CSS 紧密相关，它们都建构在 HTML 之上，因此也经常一起使用。与 HTML和 JavaScript 的情况类似，CSS 也可能与 JavaScript 产生紧密耦合。最常见的例子就是使用 JavaScript 修改个别样式，比如：\r\n```js\r\n// CSS紧耦合到了JavaScript\r\nelement.style.color = 'red'\r\nelement.style.backgroundColor = 'blue'\r\n```\r\n**因为CSS负责页面显示，所以任何样式的问题都应该通过CSS文件解决**。可是，如果JavaScript直接修改个别样式（比如颜色），就会增 加一个排错时要考虑甚至要修改的因素。结果是JavaScript某种程度 上承担了页面显示的任务，与CSS成了紧密耦合。如果将来有一天要修 改样式，那么CSS和JavaScript可能都需要修改。这对负责维护的开发者来说是一个噩梦。层与层的清晰解耦是必需的。 \r\n\r\n现代Web应用程序经常使用JavaScript改变样式，因此虽然不太可能完全解耦CSS和JavaScript，但可以让这种耦合变成更松散。**这主要可以通过动态修改类名而不是样式来实现**，比如：\r\n```js\r\n// CSS与JavaScript松散耦合\r\nelement.className = \\\"edit\\\";\r\n```\r\n**通过修改元素的CSS类名，可以把大部分样式限制在CSS文件里**。 JavaScript只负责修改应用样式的类名，而不直接影响元素的样式。 只要应用的类名没错，那么显示的问题就只跟CSS有关，而跟 JavaScript无关。 \r\n\r\n同样，保证层与层之间的适当分离至关重要。显示出问题就应该只到 CSS中解决，行为出问题就应该只找JavaScript的问题。**这些层之间的松散耦合可以提升整个应用程序的可维护性**。\r\n\r\n#### 1.3.3 解耦应用程序逻辑/事件处理程序\r\n**每个Web应用程序中都会有大量事件处理程序在监听各种事件**。可是，其中很少能真正做到应用程序逻辑与事件处理程序分离。来看下面的例子：\r\n```js\r\nfunction handleKeyPress(event) {\r\n  if (event.keyCode == 13) {\r\n    let target = event.target\r\n    let value = 5 * parseInt(target.value)\r\n    if (value > 10) {\r\n      document.getElementById('error-msg').style.display = 'block'\r\n    }\r\n  }\r\n}\r\n```\r\n这个事件处理程序除了处理事件，还包含了应用程序逻辑。这样做的问题是双重的。\r\n* **首先**，除了事件没有办法触发应用程序逻辑，结果造成调试困难。如果没有产生预期的结果怎么办？是因为没有调用事件处理程序，还是因为应用程序逻辑有错误？\r\n\r\n* **其次**，如果后续事件也会对应相同的应用程序逻辑，则会导致代码重复，或者把它提取到单独的函数中。无论情况如何，都会导致原本不必要的多余工作。\r\n\r\n**更好的做法是将应用程序逻辑与事件处理程序分开，各自负责处理各自的事情**。事件处理程序应该专注于event 对象的相关信息，然后把这些信息传给处理应用程序逻辑的某些方法。例如，前面的例子可以重写为如下代码：\r\n```js\r\nfunction validateValue(value) {\r\n  value = 5 * parseInt(value)\r\n  if (value > 10) {\r\n    document.getElementById('error-msg').style.display = 'block'\r\n  }\r\n}\r\n\r\nfunction handleKeyPress(event) {\r\n  if (event.keyCode == 13) {\r\n    let target = event.target\r\n    validateValue(target.value)\r\n  }\r\n}\r\n```\r\n这样修改之后，**应用程序逻辑跟事件处理程序就分开了**。 `handleKeyPress()` 函数只负责检查用户是不是按下了回车键 （`event.keyCode` 等于13 ），如果是则取得事件目标，并把目标值传给 `validateValue()` 函数，该函数包含应用程序逻辑。注意，`validateValue()` 函数中不包含任何依赖事件处理程序的代码。这个函数只负责接收一个值，并根据该值执行其他所有操作。 \r\n\r\n把应用程序逻辑从事件处理程序中分离出来有很多好处。\r\n* **首先**，这可以让我们以最少的工作量轻松地修改触发某些流程的事件。如果原来是通过鼠标单击触发流程，而现在又想增加键盘操作来触发，那么修改起来也很简单。\r\n\r\n* **其次**，可以在不用添加事件的情况下测试代码，这样创建单元测试或自动化应用程序流都会更简单。\r\n\r\n**以下是在解耦应用程序逻辑和业务逻辑时应该注意的几点。**\r\n* 不要把 event 对象传给其他方法，而是只传递 event 对象中必要的数据。 \r\n\r\n* 应用程序中每个可能的操作都应该无需事件处理程序就可以执行。 \r\n* 事件处理程序应该处理事件，而把后续处理交给应用程序逻辑。\r\n\r\n**做到上述几点能够给任何代码的可维护性带来巨大的提升，同时也能为将来的测试和开发提供很多可能性。**\r\n\r\n### 1.4 编码惯例\r\n编写可维护的JavaScript不仅仅涉及代码格式和规范，也涉及代码做什么。企业开发Web应用程序通常需要很多人协同工作。**这时候就需要保证每个人的浏览器环境都有恒定不变的规则**。为此，开发者应该遵守某些编码惯例。\r\n\r\n#### 1.4.1 尊重对象所有权\r\n**JavaScript的动态特性意味着几乎可以在任何时候修改任何东西**。过去有人说，JavaScript中没有什么是神圣不可侵犯的，因为不能把任何东西标记为最终结果或者恒定不变。但ECMAScript 5引入防篡改对象之后，情况不同了。当然，对象默认还是可以修改的。在其他语言中，在没有源代码的情况下，对象和类不可修改。JavaScript则允许在任何时候修改任何对象，因此就可能导致意外地覆盖默认行为。因为这门语言没有什么限制，所以就需要开发者自己限制自己。\r\n\r\n**在企业开发中，非常重要的编码惯例就是尊重对象所有权，这意味着不要修改不属于你的对象**。简单来讲，如果你不负责创建和维护某个对象及其构造函数或方法，就不应该对其进行任何修改。更具体一点说，就是如下惯例。\r\n\r\n* 不要给实例或原型添加属性。\r\n* 不要给实例或原型添加方法。\r\n* 不要重定义已有的方法。\r\n\r\n**问题在于，开发者会假设浏览器环境以某种方式运行。修改了多个人使用的对象也就意味着会有错误发生**。假设有人希望某个函数叫作 `stopEvent()` ，用于取消某个事件的默认行为。然后，你把它给改了，除了取消事件的默认行为，又添加了其他事件处理程序。可想而知，问题肯定会接踵而至。别人还认为这个函数只做最开始的那点事，但由于对它后来添加的副作用并不知情，因此很可能就会用错或者造成损失。\r\n\r\n**以上规则不仅适用于自定义类型和对象，而且适用于原生类型和对象**，比如Object 、String 、document 、window ，等等。考虑到浏览器厂商也有可能会在不公开的情况下以非预期方式修改这些对象，潜在的风险就更大了。\r\n\r\n有个流行的Prototype库就发生过类似的事件。该库在document 对象上实现了 `getElementsByClassName()` 方法，返回一个Array 的实例，而这个实例上还增加了 `each()` 方法。jQuery的作者 John Resig 后来在自己的博客上分析了这个问题造成的影响。他在博客中指出这个问题是由于浏览器也原生实现了相同的 `getElementsByClassName()` 方法造成的，但 Prototype 的同名方法返回的是Array 而非NodeList ，NodeList 没有 `each()` 方法。使用这个库的开发者之前会写这样的代码：\r\n```js\r\ndocument.getElementsByClassName(\\\"selected\\\").each(Element.hide);\r\n```\r\n虽然这样写在没有原生实现getElementsByClassName() 方法的浏览器里没有问题，但在实现它的浏览器里就会出问题。这是因为两个同名方法返回的结果不一样。我们不能预见浏览器厂商将来会怎么修改原生对象，因此不管怎么修改它们都可能在将来某个时刻出现冲 突时导致问题。\r\n\r\n**为此，最好的方法是永远不要修改不属于你的对象**。只有你自己创建的才是你的对象，包括自定义类型和对象字面量。Array 、 document 等对象都不是你的，因为在你的代码执行之前它们已经存在了。可以按如下这样为对象添加新功能。\r\n\r\n* 创建包含想要功能的新对象，通过它与别人的对象交互。 \r\n* 创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。 \r\n\r\n很多JavaScript库目前支持这种开发理念，这样无论浏览器怎样改变 都可以发展和适应。\r\n\r\n#### 1.4.2 不声明全局变量\r\n**与尊重对象所有权密切相关的是尽可能不声明全局变量和函数**。同样，这也关系到创建一致和可维护的脚本运行环境。最多可以创建一 个全局变量，作为其他对象和函数的命名空间。来看下面的例子：\r\n```js\r\n// 两个全局变量：不要！\r\nvar name = 'Nicholas'\r\nfunction sayName() {\r\n  console.log(name)\r\n}\r\n```\r\n以上代码声明了两个全局变量：`name` 和 `sayName()` 。可以像下面这样把它们包含在一个对象中：\r\n```js\r\n// 一个全局变量：推荐\r\nvar MyApplication = {\r\n  name: 'Nicholas',\r\n  sayName: function() {\r\n    console.log(this.name)\r\n  }\r\n}\r\n```\r\n这个重写后的版本只声明了一个全局对象 MyApplication 。该对象包含了 `name` 和 `sayName()` 。这样可以避免之前版本的几个问题。\r\n* 首先，变量 `name` 会覆盖 `window.name` 属性，而这可能会影响其他功能。\r\n* 其次，有助于分清功能都集中在哪里。调用 `MyApplication.sayName()` 从逻辑上会暗示，出现任何问题都可以在MyApplication 的代码中找原因。\r\n\r\n**这样一个全局对象可以扩展为命名空间的概念**。命名空间涉及创建一个对象，然后通过这个对象来暴露能力。比如，Google Closure 库就利用了这样的命名空间来组织其代码。下面是几个例子。\r\n\r\n* `goog.string` ：用于操作字符串的方法。 \r\n* `goog.html.utils` ：与HTML相关的方法。 \r\n* `goog.i18n` ：与国际化（i18n）相关的方法。\r\n\r\n对象goog 就相当于一个容器，其他对象包含在这里面。**只要使用对象以这种方式来组织功能，就可以称该对象为命名空间**。整个Google Closure库都构建在这个概念之上，能够在同一个页面上与其他 JavaScript库共存。 \r\n\r\n**关于命名空间，最重要的确定一个所有人都同意的全局对象名称**。这个名称要足够独特，不可能与其他人的冲突。大多数情况下，可以使用开发者所在的公司名，例如goog 或Wrox 。下面的例子演示了使用 Wrox 作为命名空间来组织功能：\r\n```js\r\n// 创建全局对象\r\nvar Wrox = {};\r\n// 创建命名空间\r\nWrox.ProJS = {};\r\n// 添加其他对象\r\nWrox.ProJS.EventUtil = { ... };\r\nWrox.ProJS.CookieUtil = { ... };\r\n```\r\n在这个例子中，Wrox 是全局变量，然后在它的下面又创建了命名空间。如果一本书所有代码都保存在Wrox.ProJS 命名空间中，那么其他作者的代码就可以使用自己的对象来保存。只要每个人都遵循这个模式，就不必担心有人会覆盖这里的EventUtil 或CookieUtil ，因为即使重名它们也只会出现在不同的命名空间中。比如下面的例子：\r\n\r\n```js\r\n// 为另一本书创建命名空间\r\nWrox.ProAjax = {};\r\n// 添加其他对象\r\nWrox.ProAjax.EventUtil = { ... };\r\nWrox.ProAjax.CookieUtil = { ... };\r\n// 可以照常使用ProJS下面的对象\r\nWrox.ProJS.EventUtil.addHandler( ... );\r\n// 以及ProAjax下面的对象\r\nWrox.ProAjax.EventUtil.addHandler( ... );\r\n```\r\n**虽然命名空间需要多写一点代码，但从可维护性角度看，这个代价还是非常值得的。命名空间可以确保代码与页面上的其他代码互不干扰。**\r\n\r\n#### 1.4.3 不要比较null\r\n**JavaScript不会自动做任何类型检查，因此就需要开发者担起这个责任**。结果，很多JavaScript代码不会做类型检查。**最常见的类型检查是看值是不是null**。然而，与null 进行比较的代码太多了，其中很多因为类型检查不够而频繁引发错误。比如下面的例子：\r\n```js\r\nfunction sortArray(values) {\r\n  if (values != null) {\r\n    // 不要这样比较！\r\n    values.sort(comparator)\r\n  }\r\n}\r\n```\r\n这个函数的目的是使用给定的比较函数对数组进行排序。为保证函数正常执行，values 参数必须是数组。但是，if 语句在这里只简单地检查了这个值不是null 。实际上，字符串、数值还有其他很多值可以通过这里的检查，结果就会导致错误。 \r\n\r\n**现实当中，单纯比较null 通常是不够的。检查值的类型就要真的检查类型，而不是检查它不能是什么**。例如，在前面的代码中，values 参数应该是数组。为此，应该检查它到底是不是数组，而不是检查它不是null 。可以像下面这样重写那个函数：\r\n```js\r\nfunction sortArray(values) {\r\n  if (values instanceof Array) {\r\n    // 推荐\r\n    values.sort(comparator)\r\n  }\r\n}\r\n```\r\n此函数的这个版本可以过滤所有无效的值，根本不需要使用null 。 \r\n\r\n如果看到比较null 的代码，可以使用下列某种技术替换它。 \r\n* **如果值应该是引用类型**，则使用 `instanceof` 操作符检查其构造函数。\r\n\r\n* **如果值应该是原始类型**，则使用 `typeof` 检查其类型。\r\n* **如果希望值是有特定方法名的对象**，则使用 `typeof` 操作符确保 对象上存在给定名字的方法。代码中比较null 的地方越少，就越容易明确类型检查的目的，从而消除不必要的错误。\r\n\r\n#### 1.4.4 使用常量\r\n**依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误**。显示在用户界面上的字符串就应该以这种方式提取出来，可以方便实现国际化。URL也应该这样提取出来，因为随着应用程序越来越复杂，URL极有可能变化。基本上，像这种地方将来因为某种原因而需要修改时，可能就要找到某个函数并修改其中的代码。每次像这样修改应用程序逻辑，都可能引入新错误。**为此，可以把这些可能会修改的数据提取出来，放在单独定义的常量中，以实现数据与逻辑分离。**\r\n\r\n关键在于把数据从使用它们的逻辑中分离出来。可以使用以下标准检查哪些数据需要提取。\r\n\r\n* **重复出现的值** ：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另一个值没改造成的错误。这里也包括 CSS的类名。 \r\n\r\n* **用户界面字符串** ：任何会显示给用户的字符串都应该提取出来，以方便实现国际化。 \r\n* **URL** ：Web应用程序中资源的地址经常会发生变化，因此建议把所有URL集中放在一个地方管理。\r\n* **任何可能变化的值** ：任何时候，只要在代码中使用字面值，就问问自己这个值将来是否可能会变。如果答案是“是”，那么就应该把它提取到常量中。\r\n\r\n使用常量是企业级JavaScript开发的重要技术，因为它可以让代码更容易维护，同时可以让代码免受数据变化的影响。\r\n\r\n## 2. 性能\r\n相比JavaScript刚问世时，目前每个网页中JavaScript代码的数量已有极大的增长。代码量的增长也带来了运行时执行JavaScript的性能问题。 **JavaScript一开始就是一门解释型语言，因此执行速度比编译型语言要慢一些**。Chrome是第一个引入优化引擎将JavaScript编译为原生代码的浏览器。随后，其他主流浏览器也紧随其后，实现了JavaScript编译。\r\n\r\n即使到了编译JavaScript时代，仍可能写出运行慢的代码。**不过，如果遵循一些基本模式，就能保证写出执行速度很快的代码。**\r\n\r\n### 2.1 作用域意识\r\n随着作用域链中作用域数量的增加，访问当前作用域外部变量所需的时间也会增加。访问全局变量始终比访问局部变量慢，因为必须遍历作用域链。**任何可以缩短遍历作用域链时间的举措都能提升代码性能。**\r\n\r\n#### 2.1.1 避免全局查找\r\n**改进代码性能非常重要的一件事，可能就是要提防全局查询**。全局变量和函数相比于局部值始终是最费时间的，因为需要经历作用域链查找。来看下面的函数：\r\n```js\r\nfunction updateUI() {\r\n  let imgs = document.getElementsByTagName('img')\r\n  for (let i = 0, len = imgs.length; i < len; i++) {\r\n    imgs[i].title = `${document.title} image ${i}`\r\n  }\r\n  let msg = document.getElementById('msg')\r\n  msg.innerHTML = 'Update complete.'\r\n}\r\n```\r\n这个函数看起来好像没什么问题，**但其中三个地方引用了全局 document 对象**。如果页面的图片非常多，那么 for 循环中就需要引用 document 几十甚至上百次，**每次都要遍历一次作用域链**。\r\n* 通过在局部作用域中保存 document 对象的引用，能够明显提升这个函数的性能，因为只需要作用域链查找 。\r\n* 通过创建一个指向 document 对象的局部变量，可以通过将全局查找的数量限制为一个来提高这个函数的性能：\r\n\r\n```js\r\nfunction updateUI() {\r\n  let doc = document\r\n  let imgs = doc.getElementsByTagName('img')\r\n  for (let i = 0, len = imgs.length; i < len; i++) {\r\n    imgs[i].title = `${doc.title} image ${i}`\r\n  }\r\n  let msg = doc.getElementById('msg')\r\n  msg.innerHTML = 'Update complete.'\r\n}\r\n```\r\n这里先把 document 对象保存在局部变量 doc 中。然后用 doc 替代 了代码中所有的 document。这样调用这个函数只会查找一次作用域链，相对上一个版本，肯定会快很多。 \r\n\r\n**因此，一个经验规则就是，只要函数中有引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。**\r\n\r\n#### 2.1.2 不使用with语句\r\n**在性能很重要的代码中，应避免使用 with 语句**。与函数类似，with 语句会创建自己的作用域，因此也会加长其中代码的作用域链。**在 with 语句中执行的代码一定比在它外部执行的代码慢，因为作用域链查找时多一步**。 \r\n\r\n**实际编码时很少有需要使用with 语句的情况，因为它的主要用途是节省一点代码**。大多数情况下，使用局部变量可以实现同样的效果，无须增加新作用域。下面看一个例子：\r\n```js\r\nfunction updateBody() {\r\n  with (document.body) {\r\n    console.log(tagName)\r\n    innerHTML = 'Hello world!'\r\n  }\r\n}\r\n```\r\n这段代码中的 with 语句让使用 `document.body` 更简单了。使用局部变量也可以实现同样的效果，如下：\r\n```js\r\nfunction updateBody() {\r\n  let body = document.body\r\n  console.log(body.tagName)\r\n  body.innerHTML = 'Hello world!'\r\n}\r\n```\r\n虽然这段代码多了几个字符，但比使用 with 语句还更容易理解了， 因为 tagName 和 innerHTML 属于谁很明确。这段代码还通过把 `document.body` 保存在局部变量中来省去全局查找。\r\n\r\n### 2.2 选择正确的方法\r\n**与其他语言一样，影响性能的因素通常涉及算法或解决问题的方法**。经验丰富的开发者知道用什么方法性能更佳。通常很多能在其他编程语言中提升性能的技术和方法同样也适用于JavaScript。\r\n\r\n#### 2.2.1 避免不必要的属性查找\r\n在计算机科学中，算法复杂度使用大表示法来表示。最简单同时也最快的算法可以表示为常量值或。然后，稍微复杂一些的算法同时执行时间也更长一些。下表列出了JavaScript中常见算法的类型。\r\n\r\n\r\n| 表示法 | 名称 | 说明 |\r\n| :---: | :---: | :---: |\r\n| O(1) | 常量 | 无论多少值，执行时间都不变。表示简单值和保存在变量中的值 |\r\n| O(log n) | 对数 | 执行时间随着值的增加而增加，但算法完成不需要读取每个值。 例子：二分查找 |\r\n| O(n) | 线性 | 执行时间与值的数量直接相关。例子：迭代数组的所有元素 |\r\n| O(n^2) | 二次方 | 执行时间随着值的增加而增加，而且每个值至少要读取 次。例 子：插入排序 |\r\n\r\n**常量值或O(1) ，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化**。读取常量值是效率极高的操作，因此非常快。来看下面的例子：\r\n```js\r\nlet value = 5\r\nlet sum = 10 + value\r\nconsole.log(sum)\r\n```\r\n以上代码查询了4次常量值：数值5、变量value 、数值10和变量sum 。整体代码的复杂度可以认为是O(1)。\r\n\r\n**在JavaScript中访问数组元素也是O(1)操作，与简单的变量查找一样**。因此，下面的代码与前面的例子效率一样：\r\n```js\r\nlet values = [5, 10]\r\nlet sum = values[0] + values[1]\r\nconsole.log(sum)\r\n```\r\n**使用变量和数组相比访问对象属性效率更高，访问对象属性的算法复杂度是O(n)**。访问对象的每个属性都比访问变量或数组花费的时间长，**因为查找属性名要搜索原型链**。简单来说，**查找的属性越多，执行时间就越长**。来看下面的例子：\r\n```js\r\nlet values = { first: 5, second: 10 }\r\nlet sum = values.first + values.second\r\nconsole.log(sum)\r\n```\r\n这个例子使用两次属性查找来计算sum 的值。一两次属性查找可能不会有明显的性能问题，但几百上千次则绝对会拖慢执行速度。\r\n\r\n特别要注意避免通过多次查找获取一个值。例如，看下面的例子：\r\n```js\r\nlet query = window.location.href.substring(window.location.href.indexOf('?'))\r\n```\r\n这里有6次属性查找：\r\n* 3次是为查找 `window.location.href.substring()`\r\n* 3次是为查找 `window.location.href.indexOf()`\r\n\r\n通过数代码中出现的点号数量，就可以知道有几次属性查找。以上代码效率特别低，这是因为使用了两次 `window.location.href` ，即同样的查找执行了两遍。\r\n\r\n**只要使用某个object 属性超过一次，就应该将其保存在局部变量中**。第一次仍然要用O(n)的复杂度去访问这个属性，但后续每次访问就都是O(1)，这样就是质的提升了。例如，前面的代码可以重写为如下：\r\n\r\n```js\r\nlet url = window.location.href\r\nlet query = url.substring(url.indexOf('?'))\r\n```\r\n这个版本的代码只有4次属性查找，比之前节省了约33%。在大型脚本中如果能这样优化，可能就会明显改进性能。 \r\n\r\n**通常，只要能够降低算法复杂度，就应该尽量通过在局部变量中保存值来替代属性查找**。另外，如果实现某个需求既可以使用数组的数值索引，又可以使用命名属性（比如NodeList 对象），那就都应该使用数值索引。\r\n\r\n#### 2.2.2 优化循环\r\n**循环是编程中常用的语法构造，因此在JavaScript中也十分常见**。优化这些循环是性能优化的重要内容，因为循环会重复多次运行相同的代码，所以运行时间会自动增加。其他语言有很多关于优化循环的研究，这些技术同样适用于JavaScript。优化循环的基本步骤如下。\r\n\r\n1. **简化终止条件** 。因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要避免属性查找或其他操作。 \r\n\r\n2. **简化循环体** 。循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外部的密集计算。\r\n\r\n3. **使用后测试循环** 。最常见的循环就是 for 和 while 循环，这两种循环都属于先测试循环。do-while 就是后测试循环，避免了对终止条件初始评估 ，因此应该会更快。\r\n\r\n>注意：在旧版浏览器中，从循环迭代器的最大值开始递减至0的效率更高。之所以这样更快，是因为JavaScript引擎用于检查循环分支条件的指令数更少。在现代浏览器中，正序还是倒序不会有可感知的性能差异。因此可以选择最适合代码逻辑的迭代方式。\r\n\r\n以上优化的效果可以通过下面的例子展示出来。这是一个简单的for 循环：\r\n```js\r\nfor (let i = 0; i < values.length; i++) {\r\n  process(values[i])\r\n}\r\n```\r\n这个循环会将变量 i 从 0 递增至数组values 的长度。假设处理这些值的顺序不重要，**那么可以将循环变量改为递减的形式**，如下所示：\r\n```js\r\nfor (let i = values.length - 1; i >= 0; i--) {\r\n  process(values[i])\r\n}\r\n```\r\n这一次，变量 i 每次循环都会递减。在这个过程中，终止条件的计算复杂度也从查找 `values.length` 的变成了访问 0 的。循环体只有一条语句，已不能再优化了。不过，整个循环可修改为后测试循环：\r\n```js\r\nlet i = values.length - 1\r\nif (i > -1) {\r\n  do {\r\n    process(values[i])\r\n  } while (--i >= 0)\r\n}\r\n```\r\n**这里主要的优化是将终止条件和递减操作符合并成了一条语句**。然后，如果再想优化就只能去优化 `process()` 的代码，因为循环已没有可以优化的点了。\r\n\r\n**使用后测试循环时要注意，一定是至少有一个值需要处理一次**。如果 这里的数组是空的，那么会浪费一次循环，而先测试循环就可以避免这种情况。\r\n\r\n#### 2.2.3 展开循环\r\n**如果循环的次数是有限的，那么通常抛弃循环而直接多次调用函数会更快**。仍以前面的循环为例，如果数组长度始终一样，则可能对每个元素都调用一次 `process()` 效率更高：\r\n```js\r\n// 抛弃循环\r\nprocess(values[0])\r\nprocess(values[1])\r\nprocess(values[2])\r\n```\r\n这个例子假设 values 数组始终只有3个值，然后分别针对每个元素调用一次`process()` 。像这样展开循环可以节省创建循环、计算终止条件的消耗，从而让代码运行更快。\r\n\r\n**如果不能提前预知循环的次数，那么或许可以使用一种叫作达夫设备 （Duff's Device）的技术**。该技术是以其发明者Tom Duff命名的，他最早建议在C语言中使用该技术。在JavaScript实现达夫设备的人是 Jeff Greenberg。达夫设备的基本思路是以 8 的倍数作为迭代次数从而将循环展开为一系列语句。来看下面的例子：\r\n```js\r\n// 来源：Jeff Greenberg在 JavaScript 中实现的达夫设备\r\n// 假设 values.length > 0\r\nlet iterations = Math.ceil(values.length / 8)\r\nlet startAt = values.length % 8\r\nlet i = 0\r\ndo {\r\n  switch (startAt) {\r\n    case 0:\r\n      process(values[i++])\r\n    case 7:\r\n      process(values[i++])\r\n    case 6:\r\n      process(values[i++])\r\n    case 5:\r\n      process(values[i++])\r\n    case 4:\r\n      process(values[i++])\r\n    case 3:\r\n      process(values[i++])\r\n    case 2:\r\n      process(values[i++])\r\n    case 1:\r\n      process(values[i++])\r\n  }\r\n  startAt = 0\r\n} while (--iterations > 0)\r\n```\r\n这个达夫设备的实现首先通过用 `values` 数组的长度除以 8 计算需要多少次循环。`Math.ceil()` 用于保证这个值是整数。`startAt` 变量保存着仅按照除以 8 来循环不会处理的元素个数。第一次循环执行时，会检查 `startAt` 变量，以确定要调用 `process()` 多少次。例如，假设数组有 10 个元素，则 `startAt` 变量等于 2，因此第一次循环只会调用 `process()` 两次。第一次循环末尾，`startAt` 被重置为 0。于是后续每次循环都会调用 8 次 `process()` 。这样展开之后，能够加快大数据集的处理速度。\r\n\r\nAndrew B. King 在 Speed Up Your Site 一书中提出了更快的达夫设备实现，他将 do-while 循环分成了两个单独的循环，如下所示：\r\n```js\r\n// 来源：Speed Up Your Site（New Riders，2003）\r\nlet iterations = Math.floor(values.length / 8)\r\nlet leftover = values.length % 8\r\nlet i = 0\r\nif (leftover > 0) {\r\n  do {\r\n    process(values[i++])\r\n  } while (--leftover > 0)\r\n}\r\ndo {\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n  process(values[i++])\r\n} while (--iterations > 0)\r\n```\r\n在这个实现中，变量 `leftover` 保存着只按照除以 8 来循环不会处理， 因而会在第一个循环中处理的次数。处理完这些额外的值之后进入主循环，每次循环调用 8 次 `process()` 。这个实现比原始的实现快约  40%。\r\n\r\n展开循环对于大型数据集可以节省很多时间，但对于小型数据集来说，则可能不值得。因为实现同样的任务需要多写很多代码，所以如果处理的数据量不大，那么显然没有必要。\r\n\r\n#### 2.2.4 避免重复解释\r\n**重复解释的问题存在于 JavaScript 代码尝试解释 JavaScript 代码的情形**。在使用 `eval()` 函数或 `Function` 构造函数，或者给 `setTimeout()` 传入字符串参数时会出现这种情况。下面是几个例子：\r\n```js\r\n// 对代码求值：不要\r\neval(\\\"console.log('Hello world!')\\\")\r\n// 创建新函数：不要\r\nlet sayHi = new Function(\\\"console.log('Hello world!')\\\")\r\n// 设置超时函数：不要\r\nsetTimeout(\\\"console.log('Hello world!')\\\", 500)\r\n```\r\n在上面所列的每种情况下，都需要重复解释包含JavaScript代码的字符串。**这些字符串在初始解析阶段不会被解释，因为代码包含在字符串里**。这意味着在JavaScript运行时，必须启动新解析器实例来解析这些字符串中的代码。**实例化新解析器比较费时间，因此这样会比直接包含原生代码慢。**\r\n\r\n这些情况都有对应的解决方案。很少有情况绝对需要使用 `eval()` ， 因此应该尽可能不使用它。此时，只要把代码直接写出来就好了。对于 `Function` 构造函数，重写为常规函数也很容易。而调用 `setTimeout()` 时则可以直接把函数作为第一个参数。比如：\r\n```js\r\n// 直接写出来\r\nconsole.log('Hello world!')\r\n// 创建新函数：直接写出来\r\nlet sayHi = function() {\r\n  console.log('Hello world!')\r\n}\r\n// 设置超时函数：直接写出来\r\nsetTimeout(function() {\r\n  console.log('Hello world!')\r\n}, 500)\r\n```\r\n**为了提升代码性能，应该尽量避免使用要当作JavaScript代码解释的字符串。**\r\n\r\n#### 2.2.5 其他性能优化注意事项\r\n在评估代码性能时还有一些地方需要注意。下面列出的虽然不是主要问题，但在使用比较频繁的时候也可能有所不同。\r\n* **原生方法很快** 。应该尽可能使用原生方法，而不是使用 JavaScript 写的方法。原生方法是使用C或C++等编译型语言写的，因此比JavaScript写的方法要快得多。JavaScript 中经常被忽视的是 `Math` 对象上那些执行复杂数学运算的方法。这些方法总是比执行相同任务的JavaScript函数快得多，比如求正弦、余 弦等。 \r\n\r\n* **switch 语句很快** 。如果代码中有复杂的 if-else 语句，将其转换成switch 语句可以变得更快。然后，通过重新组织分支，把最可能的放前面，不太可能的放后面，可以进一步提升性能。 \r\n\r\n* **位操作很快** 。在执行数学运算操作时，位操作一定比任何布尔值或数值计算更快。选择性地将某些数学操作替换成位操作，可以极大提升复杂计算的效率。像求模、逻辑AND与和逻辑OR或都很适合替代成位操作。\r\n\r\n### 2.3 语句最少化\r\n**JavaScript代码中语句的数量影响操作执行的速度**。一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快。那么优化的目标就是寻找可以合并的语句，以减少整个脚本的执行时间。为此，可以参考如下几种模式。\r\n#### 2.3.1 多个变量声明\r\n```js\r\n// 有四条语句：浪费\r\nlet count = 5\r\nlet color = 'blue'\r\nlet values = [1, 2, 3]\r\nlet now = new Date()\r\n```\r\n在强类型语言中，不同数据类型的变量必须在不同的语句中声明。**但在JavaScript中，所有变量都可以使用一个 let 语句声明**。前面的代码可以改写为如下：\r\n```js\r\n// 一条语句更好\r\nlet count = 5,\r\n  color = 'blue',\r\n  values = [1, 2, 3],\r\n  now = new Date()\r\n```\r\n这里使用一个 let 声明了所有变量，变量之间以逗号分隔。这种优化很容易做到，且比使用多条语句执行速度更快。\r\n\r\n#### 2.3.2 插入迭代性值\r\n任何时候只要使用迭代性值（即会递增或递减的值），都要尽可能使用组合语句。来看下面的代码片段：\r\n```js\r\nlet name = values[i]\r\ni++\r\n```\r\n前面代码中的两条语句都只有一个作用：\r\n* 第一条从 values 中取得一个值并保存到 name 中\r\n* 第二条递增变量 i\r\n\r\n把迭代性的值插入第一条语句就可以将它们合并为一条语句：\r\n```js\r\nlet name = values[i++]\r\n```\r\n这一条语句完成了前面两条语句完成的事情。**因为递增操作符是后缀形式的，所以 i 在语句其他部分执行完成之前是不会递增的**。只要遇到类似的情况，就要尽量把迭代性值插入到上一条使用它的语句中。\r\n\r\n#### 2.3.3 使用数组和对象字面量\r\n**两种使用数组和对象的方式：构造函数和字面量**。使用构造函数始终会产生比单纯插入元素或定义属性更多的语句，而字面量只需一条语句即可完成全部操作。来看下面的例子：\r\n```js\r\n// 创建和初始化数组用了四条语句：浪费\r\nlet values = new Array()\r\nvalues[0] = 123\r\nvalues[1] = 456\r\nvalues[2] = 789\r\n// 创建和初始化对象用了四条语句：浪费\r\nlet person = new Object()\r\nperson.name = 'Nicholas'\r\nperson.age = 29\r\nperson.sayName = function() {\r\n  console.log(this.name)\r\n}\r\n```\r\n在这个例子中，分别创建和初始化了一个数组和一个对象。两件事都 用了四条语句：一条调用构造函数，三条添加数据。这些语句很容易转换成字面量形式:\r\n```js\r\n// 一条语句创建并初始化数组\r\nlet values = [123, 456, 789]\r\n// 一条语句创建并初始化对象\r\nlet person = {\r\n  name: 'Nicholas',\r\n  age: 29,\r\n  sayName() {\r\n    console.log(this.name)\r\n  }\r\n}\r\n```\r\n重写后的代码只有两条语句：一条创建并初始化数组，另一条创建并初始化对象。相对于前面使用了8条语句，这里使用两条语句，减少了 75% 的语句量。对于数千行的JavaScript代码，这样的优化效果可能更明显。\r\n\r\n**应尽可能使用数组或对象字面量，以消除不必要的语句。**\r\n\r\n>注意：减少代码中的语句量是很不错的目标，但不是绝对的法则。一味追求语句最少化，可能导致一条语句容纳过多逻辑，最终难以理解。\r\n\r\n### 2.4 优化DOM交互\r\n**在所有JavaScript代码中，涉及DOM的部分无疑是非常慢的**。DOM操作和交互需要占用大量时间，因为经常需要重新渲染整个或部分页面。此外，看起来简单的操作也可能花费很长时间，因为DOM中携带着大量信息。理解如何优化DOM交互可以极大地提升脚本的执行速度。\r\n\r\n#### 2.4.1 实时更新最小化\r\n**访问DOM时，只要访问的部分是显示页面的一部分，就是在执行实时更新操作**。之所以称其为实时更新，是因为涉及立即（实时）更新页面 的显示，让用户看到。每次这样的更新，无论是插入一个字符还是删除页面上的一节内容，都会导致性能损失。这是因为浏览器需要为此重新计算数千项指标，之后才能执行更新。实时更新的次数越多，执行代码所需的时间也越长。反之，实时更新的次数越少，代码执行就越快。来看下面的例子：\r\n```js\r\nlet list = document.getElementById('myList'),\r\n  item\r\nfor (let i = 0; i < 10; i++) {\r\n  item = document.createElement('li')\r\n  list.appendChild(item)\r\n  item.appendChild(document.createTextNode('Item ${i}'))\r\n}\r\n```\r\n以上代码向列表中添加了10项。每添加1项，就会有两次实时更新：一次添加`<li>`元素，一次为它添加文本节点。因为要添加10项，所以整个操作总共要执行20次实时更新。 \r\n\r\n为解决这里的性能问题，需要减少实时更新的次数。有两个办法可以实现这一点。\r\n* 第一个办法是从页面中移除列表，执行更新，然后再把 列表插回页面中相同的位置。这个办法并不可取，因为每次更新时页面都会闪烁。\r\n\r\n* **第二个办法是使用文档片段构建 DOM 结构，然后一次性将 它添加到 list 元素**。这个办法可以减少实时更新，也可以避免页面闪烁。比如：\r\n```js\r\nlet list = document.getElementById('myList'),\r\n  fragment = document.createDocumentFragment(),\r\n  item\r\nfor (let i = 0; i < 10; i++) {\r\n  item = document.createElement('li')\r\n  fragment.appendChild(item)\r\n  item.appendChild(document.createTextNode('Item ' + i))\r\n}\r\nlist.appendChild(fragment)\r\n```\r\n这样修改之后，完成同样的操作只会触发一次实时更新。这是因为更新是在添加完所有列表项之后一次性完成的。文档片段在这里作为新创建项目的临时占位符。最后，使用 `appendChild()` 将所有项目都添加到列表中。别忘了，在把文档片段传给 `appendChild()` 时，会把片段的所有子元素添加到父元素，片段本身不会被添加。 \r\n\r\n**只要是必须更新DOM，就尽量考虑使用文档片段来预先构建DOM结构，然后再把构建好的DOM结构实时更新到文档中。**\r\n#### 2.4.2 使用innerHTML\r\n在页面中创建新DOM节点的方式有两种：使用DOM方法如 `createElement()` 和 `appendChild()`，以及使用 `innerHTML`。 对于少量DOM更新，这两种技术区别不大，**但对于大量DOM更新，使用 innerHTML 要比使用标准DOM方法创建同样的结构快很多**。 \r\n\r\n在给 innerHTML 赋值时，后台会创建 HTML 解析器，然后会使用原生 DOM 调用而不是 JavaScript 的 DOM 方法来创建 DOM 结构。**原生DOM方法速度更快，因为该方法是执行编译代码而非解释代码**。前面的例子如果使用 innerHTML 重写就是这样的：\r\n```js\r\nlet list = document.getElementById('myList'),\r\n  html = ''\r\nfor (let i = 0; i < 10; i++) {\r\n  html += '<li>Item ${i}</li>'\r\n}\r\nlist.innerHTML = html\r\n```\r\n以上代码构造了一个HTML字符串，然后将它赋值给 `list.innerHTML` ，结果也会创建适当的DOM结构。虽然拼接字符串也会有一些性能损耗，但这个技术仍然比执行多次DOM操作速度更快。\r\n\r\n**与其他DOM操作一样，使用 innerHTML 的关键在于最小化调用次数**。 例如，下面的代码使用innerHTML 的次数就太多了：\r\n```js\r\nlet list = document.getElementById('myList')\r\nfor (let i = 0; i < 10; i++) {\r\n  list.innerHTML += '<li>Item ${i}</li>' // 不要\r\n}\r\n```\r\n这里的问题是每次循环都会调用 innerHTML ，因此效率极低。事实上，调用 innerHTML 也应该看成是一次实时更新。构建好字符串然后调用一次 innerHTML 比多次调用 innerHTML 快得多。\r\n>注意：使用 innerHTML 可以提升性能，但也会暴露巨大的 XSS 攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。此时必须要当心。\r\n\r\n#### 2.4.3 使用事件委托\r\n大多数 Web 应用程序会大量使用事件处理程序实现用户交互。一个页面中事件处理程序的数量与页面响应用户交互的速度有直接关系。**为了减少对页面响应的影响，应该尽可能使用事件委托。**\r\n\r\n**事件委托利用了事件的冒泡**。任何冒泡的事件都可以不在事件目标上，而在目标的任何祖先元素上处理。基于这个认知，可以把事件处理程序添加到负责处理多个目标的高层元素上。只要可能，就应该在文档级添加事件处理程序，因为在文档级可以处理整个页面的事件。\r\n\r\n#### 2.4.4 注意HTMLCollection\r\n由于Web应用程序存在很大的性能问题，`HTMLCollection` 对象是有缺点。任何时候，只要访问HTMLCollection ，无论是它的属性还是方法，就会触发查询文档，而这个查询相当耗时。减少访问HTMLCollection 的次数可以极大地提升脚本的性能。 \r\n\r\n**可能优化 HTMLCollection 访问最关键地方就是循环了**。之前，我们讨论过要把计算 HTMLCollection 长度的代码转移到 for 循环初始化的部分。来看下面的例子：\r\n```js\r\nlet images = document.getElementsByTagName('img')\r\nfor (let i = 0, len = images.length; i < len; i++) {\r\n  // 处理\r\n}\r\n```\r\n这里的关键是把 length 保存到了 len 变量中，而不是每次都读一次 HTMLCollection 的 length 属性。在循环中使用 HTMLCollection 时，应该首先取得对要使用的元素的引用，如下面所示。这样才能避免在循环体内多次调用 HTMLCollection ：\r\n```js\r\nlet images = document.getElementsByTagName('img'),\r\n  image\r\nfor (let i = 0, len = images.length; i < len; i++) {\r\n  image = images[i]\r\n  // 处理\r\n}\r\n```\r\n这段代码增加了image 变量，用于保存当前的图片。有了这个局部变 量，就不需要在循环中再访问images HTMLCollection 了。 \r\n\r\n编写JavaScript代码时，关键是要记住，只要返回HTMLCollection 对象，就应该尽量不访问它。以下情形会返回HTMLCollection ：\r\n* 调用 getElementsByTagName() ； \r\n* 读取元素的 childNodes 属性；\r\n* 读取元素的 attributes 属性；\r\n* 访问特殊集合，如 document.form 、document.images 等。\r\n\r\n理解什么时候会碰到 HTMLCollection 对象并适当地使用它，有助于明显地提升代码执行速度。\r\n\r\n## 3. 部署\r\n**任何JavaScript解决方案最重要的部分可能就是把网站或Web应用程序部署到线上环境了**。在此之前我们已完成了很多工作，包括架构方面和优化方面的。现在到了把代码移出开发环境，发布到网上，让用户去使用它的时候了。不过，在发布之前还需要解决一些问题。\r\n\r\n### 3.1 构建流程\r\n**准备发布JavaScript代码时最重要一环是准备构建流程**。开发软件的典型模式是编码、编译和测试。换句话说，首先要写代码，然后编译，之后运行并确保它能够正常工作。\r\n\r\n但因为JavaScript不是编译型语言，所以这个流程经常会变成编码、测试。你写的代码跟在浏览器中测试的代码一样。这种方式的问题在于代码并不是最优的。你写的代码不应该不做任何处理就直接交给浏览器，原因如下。\r\n* **知识产权问题** ：如果把满是注释的代码放到网上，其他人就很容易了解你在做什么，重用它，并可能发现安全漏洞。 \r\n* **文件大小** ：你写的代码可读性很好，容易维护，但性能不好。浏览器不会因为代码中多余的空格、缩进、冗余的函数和变量名而受益。 \r\n* **代码组织** ：为保证可维护性而组织的代码不一定适合直接交付给浏览器。\r\n\r\n为此，需要为JavaScript文件建立构建流程。\r\n\r\n#### 3.1.1 文件结构\r\n**构建流程首先定义在源代码控制中存储文件的逻辑结构**。最好不要在一个文件中包含所有JavaScript代码。**相反，要遵循面向对象编程语言的典型模式，把对象和自定义类型保存到自己独立的文件中**。这样可以让每个文件只包含最小量的代码，让后期修改更方便，也不易引 入错误。\r\n\r\n此外，在使用并发源代码控制系统（如Git、CVS或 Subversion）的环境中，这样可以**减少合并时发生冲突的风险。**\r\n\r\n**注意，把代码分散到多个文件是从可维护性而不是部署角度出发的**。对于部署，应该把所有源文件合并为一个或多个汇总文件。Web应用程序使用的JavaScript文件越少越好，因为HTTP请求对某些Web应用程序而言是主要的性能瓶颈。**而且，使用 `<script>` 标签包含 JavaScript 是阻塞性操作**，这导致代码下载和执行期间停止所有其他下载任务。 因此，要尽量以符合逻辑的方式把JavaScript代码组织到部署文件中。\r\n\r\n#### 3.1.2 任务运行器\r\n**如果要把大量文件组合成一个应用程序，很可能需要任务运行器自动完成一些任务**。任务运行器可以完成代码检查、打包、转译、启动本地服务器、部署，以及其他可以脚本化的任务。 \r\n\r\n很多时候，任务运行器要通过命令行界面来执行操作。因此你的任务运行器可能仅仅是一个辅助组织和排序复杂命令行调用的工具。从这个意义上说，任务运行器在很多方面非常像 `.bashrc` 文件。其他情况下，要在自动化任务中使用的工具可能是一个兼容的插件。 \r\n\r\n**如果你使用 Node.js 和 npm 打印 JavaScript 资源，Grunt 和 Gulp 是两个主流的任务运行器**。它们非常稳健，其任务和指令都是通过配置文件，以纯 JavaScript 形式指定的。使用 Grunt 和 Gulp 的好处是它们分别有各自的插件生态，因此可以直接使用npm包。\r\n\r\n#### 3.1.3 摇树优化\r\n**摇树优化（tree shaking）是非常常见且极为有效的减少冗余代码的策略**。使用静态模块声明风格意味着构建工具可以确定代码各部分之间的依赖关系。更重要的是，摇树优化还能确定代码中的哪些内容是完全不需要的。 \r\n\r\n实现了摇树优化策略的构建工具能够分析出选择性导入的代码，其余模块文件中的代码可以在最终打包得到的文件中完全省略。假设下面是个示例应用程序：\r\n```js\r\nimport { foo } from './utils.js'\r\nconsole.log(foo)\r\nexport const foo = 'foo'\r\nexport const bar = 'bar' // unused\r\n```\r\n这里导出的 bar 就没有被用上，而构建工具可以很容易发现这种情况。在执行摇树优化时，构建工具会将bar 导出完全排除在打包文件之外。静态分析也意味着构建工具可以确定未使用的依赖，同样也会排除掉。通过摇树优化，最终打包得到的文件可以瘦身很多。\r\n\r\n#### 3.1.4 模块打包器\r\n**以模块形式编写代码，并不意味着必须以模块形式交付代码**。通常，由大量模块组成的JavaScript代码在构建时需要打包到一起，然后只交付一个或少数几个JavaScript文件。 \r\n\r\n模块打包器的工作是识别应用程序中涉及的JavaScript依赖关系，将它们组合成一个大文件，完成对模块的串行组织和拼接，然后生成最终提供给浏览器的输出文件。\r\n\r\n能够实现模块打包的工具非常多。Webpack、Rollupt 和 Browserify 只是其中的几个，可以将基于模块的代码转换为普遍兼容的网页脚本。\r\n\r\n### 3.2 验证\r\n即使已出现了能够理解和支持JavaScript的IDE，大多数开发者仍通过在浏览器中运行代码来验证自己的语法。这种方式有很多问题。\r\n* 首先，如此验证不容易自动化，也不方便从一个系统移植到另一个系统。\r\n\r\n* 其次，除了语法错误，只有运行的代码才可能报错，没有运行到的代码则无法验证。有 一些工具可以帮我们发现JavaScript代码中潜在的问题，最流行的是 Douglas Crockford的JSLint和ESLint。 \r\n\r\n这些代码检查工具可以发现JavaScript代码中的语法错误和常见的编码错误。下面是它们会报告的一些问题：\r\n\r\n* 使用 eval() ； \r\n* 使用未声明的变量； \r\n* 遗漏了分号； \r\n* 不适当地换行； \r\n* 不正确地使用逗号； \r\n* 遗漏了包含语句的括号； \r\n* 遗漏了switch 分支中的 break ； \r\n* 重复声明变量； \r\n* 使用了 with ； \r\n* 错误地使用等号（应该是两个或三个等号）； \r\n* 执行不到的代码。\r\n\r\n在开发过程中添加代码检查工具有助于避免出错。推荐开发者在构建流程中也加入代码检查环节，以便在潜在问题成为错误之前识别它们。\r\n\r\n### 3.3 压缩\r\n谈到JavaScript文件压缩，实际上主要是两件事：**代码大小** （code size）和 **传输负载** （wire weight）。\r\n* 代码大小指的是浏览器需要解析的字节数\r\n\r\n* 而传输负载是服务器实际发送给浏览器的字节数。\r\n\r\n在Web开发的早期阶段，这两个数值几乎相等，服务器发送给浏览器的是未经修改的源文件。而今天，这两个数值不可能相等，实际上也不应该相等。\r\n\r\n#### 3.3.1 代码压缩\r\n**JavaScript不是编译成字节码，而是作为源代码传输的**，所以源代码文件通常包含对浏览器的JavaScript解释器没有用的额外信息和格式。JavaScript压缩工具可以把源代码文件中的这些信息删除，并在保证程序逻辑不变的前提下缩小文件大小。\r\n\r\n**注释、额外的空格、长变量或函数名都能提升开发者的可读性，但对浏览器而言这些都是多余的字节**。压缩工具可以通过如下操作减少代码大小：\r\n* 删除空格（包括换行）； \r\n* 删除注释； \r\n* 缩短变量名、函数名和其他标识符。\r\n\r\n**所有JavaScript文件都应该在部署到线上环境前进行压缩。在构建流程中加入这个环节压缩JavaScript文件是很容易的。**\r\n\r\n#### 3.3.2 JavaScript编译\r\n**类似于最小化，JavaScript代码编译通常指的是把源代码转换为一种逻辑相同但字节更少的形式**。与最小化的不同之处在于，编译后代码的结构可能不同，但仍然具备与原始代码相同的行为。编译器通过输入全部 JavaScript 代码可以对程序流执行稳健的分析。 \r\n\r\n编译可能会执行如下操作： \r\n* 删除未使用的代码； \r\n* 将某些代码转换为更简洁的语法； \r\n* 全局函数调用、常量和变量行内化\r\n\r\n#### 3.3.3 JavaScript 转译\r\n我们提交到项目仓库中的代码与浏览器中运行的代码不一样。ES6、 ES7和ES8都为ECMAScript规范扩充增加了更好用的特性，但不同浏览器支持这些规范的步调并不一致。 \r\n\r\n**通过JavaScript转译，可以在开发时使用最新的语法特性而不用担心浏览器的兼容性问题**。转译可以将现代的代码转换成更早的 ECMAScript版本，通常是ES3或ES5，具体取决于你的需求。这样可以 确保代码能够跨浏览器兼容。\r\n\r\n>注意：“转译”（transpilation）和“编译”（compilation） 经常被人当成同一个术语混用。编译是将源代码从一种语言转换为另一种语言。转译在本质上跟编译是一样的，只是目标语言与源语言是一种语言的不同级别的抽象。因此，把ES6/ES7/ES8代码 转换为ES3/ES5代码从技术角度看既是编译也是转译，只是转译更为确切一些。\r\n\r\n#### 3.3.4 HTTP压缩\r\n**传输负载是从服务器发送给浏览器的实际字节数**。这个字节数不一定与代码大小相同，因为服务器和浏览器都具有压缩能力。所有当前主流的浏览器（IE/Edge、Firefox、Safari、Chrome和Opera）都支持客户端解压缩收到的资源。服务器则可以根据浏览器通过请求头部 （Accept-Encoding）标明自己支持的格式，选择一种用来压缩 JavaScript文件。\r\n\r\n在传输压缩后的文件时，服务器响应的头部会有字段（Content-Encoding）标明使用了哪种压缩格式。浏览器看到这个头部字段后，就会根据这个压缩格式进行解压缩。**结果是通过网络传输的字节数明显小于原始代码大小。**\r\n\r\n例如，使用Apache服务器上的两个模块（mod_gzip 和 mod_deflate ）可以减少原始JavaScript文件的约70%。这很大程度上是因为JavaScript的代码是纯文件，所以压缩率非常高。减少通过网络传输的数据量意味着浏览器能更快收到数据。\r\n\r\n注意，服务器压缩和浏览器解压缩都需要时间。不过相比于通过传入更少的字节数而节省的时间，整体时间应该是减少的。\r\n\r\n>注意：大多数Web服务器（包括开源的和商业的）具备HTTP压缩 能力。关于如何正确地配置压缩，请参考相关服务器的文档。\r\n\r\n## 4. 小结\r\n随着JavaScript开发日益成熟，最佳实践不断涌现。曾经的业余爱好如今 也成为了正式的职业。因此，前端开发也需要像其他编程语言一样，注重 可维护性、性能优化和部署。\r\n\r\n**1. 为保证JavaScript代码的可维护性，可以参考如下编码惯例。**\r\n* 其他语言的编码惯例可以作为添加注释和确定缩进的参考，但 JavaScript作为一门适合松散类型的语言也有自己的一些特殊要求。 \r\n\r\n* 由于JavaScript必须与HTML和CSS共存，因此各司其职尤为重要：JavaScript负责定义行为，HTML负责定义内容，而CSS负责定义外观。 \r\n* 如果三者职责混淆，则可能导致难以调试的错误和可维护性问题。\r\n\r\n**2. 随着Web应用程序中JavaScript代码量的激增，性能也越来越重要。因此应该牢记如下这些事项。**\r\n* 执行JavaScript所需的时间直接影响网页性能，其重要性不容忽视。\r\n\r\n* 很多适合C语言的性能优化策略同样也适合JavaScript，包括循环展开和使用switch 语句而不是if 语句。 \r\n* 另一个需要重视的方面是DOM交互很费时间，因此应该尽可能限制DOM 操作的数量。\r\n\r\n**3. 开发Web应用程序的最后一步是上线部署。以下是本文讨论的相关要点。**\r\n* 为辅助部署，应该建立构建流程，将JavaScript文件合并为较少的（最好是只有一个）文件。\r\n\r\n* 构建流程可以实现很多源代码处理任务的自动化。例如，可以运行 JavaScript验证程序，确保没有语法错误和潜在的问题。\r\n* 压缩可以让文件在部署之前变得尽量小。\r\n* 启用HTTP压缩可以让网络传输的JavaScript文件尽可能小，从而提升 页面的整体性能。\r\n\r\n> 每文一句：积累知识，胜过积蓄金银。\r\n\r\n本次的分享就到这里，如果本章内容对你有所帮助的话可以**点赞+收藏**。文章有不对的地方欢迎指出，有任何疑问都可以在评论区留言。希望大家都能够有所收获，大家一起探讨、进步！\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783)***"
    },
    {
        "article_id": "7170248485705351175",
        "snapshot": "",
        "title": "杂谈：created中两次数据修改，会触发几次页面更新？",
        "preview": "从生命周期created和页面渲染的先后顺序，Object.defineProperty触发get和set函数的机理，以及eventLoop事件循环机制入手分析就会清晰很多。",
        "author": "qb",
        "view_count": 1722,
        "collect_count": 19,
        "comment_count": 10,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e40655a4d62c0313136fc23d36050e80~300x300.image",
        "category": "前端",
        "content": "面试题：`created`生命周期中两次修改数据，会触发几次页面更新？\r\n\r\n## 一、同步的\r\n\r\n先举个简单的`同步的`例子：\r\n```\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>\r\n    <div>{{count}}</div>\r\n  </div>`,\r\n  data() {\r\n    return {\r\n      count: 1,\r\n    }\r\n  },\r\n  created() {\r\n    this.count = 2;\r\n    this.count = 3;\r\n  },\r\n});\r\n\r\n```\r\n在`created`生命周期中，通过`this.count = 2`和`this.count = 3`的方式将`this.count`重新赋值。\r\n\r\n这里直接抛出答案：渲染一次。\r\n\r\n---\r\n`为什么？ `\r\n\r\n这个与数据的响应式处理有关，先看响应式处理的逻辑：\r\n```\r\nexport function defineReactive (\r\n  obj: Object,\r\n  key: string,\r\n  val: any,\r\n  customSetter?: ?Function,\r\n  shallow?: boolean\r\n) {\r\n  // 重点：创建一个发布者实例\r\n  const dep = new Dep()\r\n\r\n  const property = Object.getOwnPropertyDescriptor(obj, key)\r\n  if (property && property.configurable === false) {\r\n    return\r\n  }\r\n\r\n  // cater for pre-defined getter/setters\r\n  const getter = property && property.get\r\n  const setter = property && property.set\r\n  if ((!getter || setter) && arguments.length === 2) {\r\n    val = obj[key]\r\n  }\r\n\r\n  let childOb = !shallow && observe(val)\r\n  Object.defineProperty(obj, key, {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: function reactiveGetter () {\r\n      const value = getter ? getter.call(obj) : val\r\n      if (Dep.target) {\r\n        // 重点：进行当前正在计算的渲染Watcher的收集\r\n        dep.depend()\r\n        if (childOb) {\r\n          childOb.dep.depend()\r\n          if (Array.isArray(value)) {\r\n            dependArray(value)\r\n          }\r\n        }\r\n      }\r\n      return value\r\n    },\r\n    set: function reactiveSetter (newVal) {\r\n      const value = getter ? getter.call(obj) : val\r\n      /* eslint-disable no-self-compare */\r\n      if (newVal === value || (newVal !== newVal && value !== value)) {\r\n        return\r\n      }\r\n      /* eslint-enable no-self-compare */\r\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\r\n        customSetter()\r\n      }\r\n      // #7981: for accessor properties without setter\r\n      if (getter && !setter) return\r\n      if (setter) {\r\n        setter.call(obj, newVal)\r\n      } else {\r\n        val = newVal\r\n      }\r\n      childOb = !shallow && observe(newVal)\r\n      // 重点：当数据发生变化时，发布者实例dep会通知收集到的watcher进行更新\r\n      dep.notify()\r\n    }\r\n  })\r\n}\r\n\r\n```\r\n\r\n在数据响应式处理阶段，会实例化一个发布者`dep`，并且通过`Object.defineProperty`的方式为当前数据定义`get`和`set`函数。在生成虚拟`vNode`的阶段，会触发`get`函数中会进行当前正在计算的渲染`Watcher`的收集，此时，发布者`dep`的`subs`中会多一个渲染`Watcher`实例。在数据发生变化的时候，会触发`set`函数，通知发布者`dep`中`subs`中的`watcher`进行更新。\r\n\r\n至于数据修改会触发几次更新，就与当前发布者`dep`的`subs`中收集了几次渲染`watcher`有关了，再看`watcher`收集和`created`执行之间的顺序：\r\n\r\n```\r\nVue.prototype._init = function (options) {\r\n    // ...\r\n    initState(vm);\r\n    // ...\r\n    callHook(vm, 'created');\r\n    // ...\r\n    if (vm.$options.el) {\r\n      vm.$mount(vm.$options.el);\r\n    }\r\n}\r\n```\r\n我们知道在`initState(vm)`阶段对数据进行响应式处理，但是此时发布者`dep`的`subs`还是空数组。当执行`callHook(vm, 'created')`的时候，会执行`this.count = 2`和`this.count = 3`的逻辑，也的确会触发`set`函数中的`dep.notify`通知收集到的`watcher`进行更新。但是，此时`dep`的`subs`是空数组，相当于啥也没做。\r\n\r\n只有在`vm.$mount(vm.$options.el)`执行过程中，生成虚拟`vNode`的时候才会进行渲染`Watcher`收集，此时，`dep`的`subs`才不为空。最终，通过`vm.$mount(vm.$options.el)`进行了页面的一次渲染，并未因为`this.count=2`或者`this.count=3`而触发多余的页面更新。\r\n\r\n简言之，就是`created`钩子函数内的逻辑的执行是在渲染`watcher`收集之前执行的，所以未引起因为数据变化而导致的页面更新。\r\n\r\n## 二、异步的\r\n\r\n同步的场景说完了，我们再举个`异步的`例子：\r\n\r\n```\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>\r\n    <div>{{count}}</div>\r\n  </div>`,\r\n  data() {\r\n    return {\r\n      count: 1,\r\n    }\r\n  },\r\n  created() {\r\n    setTimeout(() => {\r\n      this.count = 2;\r\n    }, 0)\r\n    setTimeout(() => {\r\n      this.count = 3;\r\n    }, 0)\r\n  },\r\n});\r\n```\r\n\r\n在`created`生命周期中，通过异步的方式执行`this.count = 2`和`this.count = 3`的方式将`this.count`重新赋值。\r\n\r\n这里直接抛出答案：首次渲染一次，因为数据变化导致的页面更新两次。\r\n\r\n---\r\n\r\n`为什么？`\r\n\r\n这个就与`eventLoop`事件循环机制有关了，我们知道`javascript`是一个单线程执行的语言，当我们通过`new Vue`实例化的过程中，会执行初始化方法`this._init`方法，开始了`Vue`底层的处理逻辑。当遇到`setTimeout`异步操作时，会将其推入到`异步队列`中去，等待当前同步任务执行完以后再去异步队列中取出队首元素进行执行。\r\n\r\n当前例子中，在`initState(vm)`阶段对数据进行响应式处理。当执行`callHook(vm, 'created')`的时候，会将`this.count = 2`和`this.count = 3`的逻辑推入到异步队列等待执行。继续执行`vm.$mount(vm.$options.el)`的过程中会去生成虚拟`vNode`，进而触发`get`函数的渲染`Watcher`收集，此时，`dep`的`subs`中就有了一个渲染`watcher`。\r\n\r\n等首次页面渲染完成以后，会去执行`this.count=2`的逻辑，数据的修改会触发`set`函数中的`dep.notify`，此时发布者`dep`的`subs`不为空，会引起页面的更新。同理，`this.count=3`会再次引起页面数据的更新。也就是说，首次渲染一次，因为`this.count=2`和`this.count=3`还会导致页面更新两次。\r\n\r\n## 三、附加\r\n\r\n如果我改变的值和`data`中定义的值一致呢？\r\n\r\n```\r\nnew Vue({\r\n  el: \\\"#app\\\",\r\n  template: `<div>\r\n    <div>{{count}}</div>\r\n  </div>`,\r\n  data() {\r\n    return {\r\n      count: 1,\r\n    }\r\n  },\r\n  created() {\r\n    setTimeout(() => {\r\n      this.count = 1;\r\n    }, 0)\r\n  },\r\n});\r\n```\r\n\r\n这个时候，在触发`set`的逻辑中，会当执行到`if (newVal === value || (newVal !== newVal && value !== value)) { return }`的逻辑，不会再执行到`dep.notify`，这种场景下数据的数据也不会引起页面的再次更新。\r\n\r\n\r\n## 总结\r\n> 从生命周期`created`和页面渲染的先后顺序，`Object.defineProperty`触发`get`和`set`函数的机理，以及`eventLoop`事件循环机制入手，去分析`created`中两次数据修改会触发几次页面更新的问题就会清晰很多。"
    },
    {
        "article_id": "7157971234696167461",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/773a8c65ab3a490c8a6b138d8aa6aaec~tplv-k3u1fbpfcp-watermark.image?",
        "title": "12个你可能不知道的CSS小技巧",
        "preview": "走过路过不要错过，本文整理出12个开发中你有可能没有用到过的CSS小技巧，快点进来看一看，你知道其中的几个呢",
        "author": "阳呀呀",
        "view_count": 7413,
        "collect_count": 313,
        "comment_count": 36,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/16903e8bdac3c3f7~tplv-t2oaga2asx-image.image",
        "category": "前端",
        "content": "---\r\ntheme: nico\r\n---\r\n本文整理出`12`个开发中你有可能没有用到过的`CSS`小技巧，一起来看看吧~\r\n\r\n### 1. 自定义光标（cursor）\r\n首先来看一下`CSS`的内置光标样式。平时开发中用到的基本上就是`default`、`pointer`、`not-allowed`、`move`这几个。其实内置的光标样式还有很多，大家可以把鼠标放到下面的颜色块上体验一下。\r\n\r\n自定义光标也很简单，只需要通过`cursor: url(xxx)`引入一张图片即可。有时候我们下载的`chrome`主题会改变光标的样式，用的就是这个方法。\r\n\r\n#### 实践\r\n\r\n[代码片段](https://code.juejin.cn/pen/7120827353747423262)\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f643fca8c742d9955ab3beb8cc9aa2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 2. 自定义插入光标颜色（caret-color）\r\n\r\n一般的交互情况下，如果用户输入错误，输入框的颜色会变成红色的。这时我们可以通过`caret-color`这个属性把插入光标也变成红色的。如果不想要展示这个插入光标，可以将`caret-color`设置为`transparent`。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121247897407979527)\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b3ecb5a64e464ea70992ea6cd12f38~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 3. 自定义placeholder样式（::placeholder）\r\n还拿输入框校验失败的例子来说，如果一个输入框是必填的，如果没有输入具体值，在失焦的情况下一般都会标红提示。这时候也可以把`placeholder`变成红色的达到更加醒目的效果。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121250286173650951)\r\n\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee293efb9f994a89a473464a801d1488~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 4. 自定义选中样式（::selection）\r\n有时候我们看到网页的文字选中会有特殊的样式，就是通过`::selection`这个伪元素来实现的。\r\n\r\n`::selection`伪元素用来应用于文档中被用户高亮的部分。在使用这个伪元素时，有一点需要注意，只有以下这些`CSS`属性可以用于`::selection` 选择器：\r\n\r\n-   [`color`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/color)\r\n-   [`background-color`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color)\r\n-   [`cursor`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor)\r\n-   [`caret-color`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/caret-color)\r\n-   [`outline`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline)\r\n-   [`text-decoration`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration)\r\n-   [`text-emphasis-color` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis-color \\\"Currently only available in English (US)\\\")\r\n-   [`text-shadow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow)\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121690723539222559)\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093a954e84684226a26344f06cba5241~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 5. 禁止用户选择 & 可以整段选择（user-select）\r\n\r\n有些网站会禁止用户选中内容进行复制，在CSS层面可以通过`user-select: none`来实现。\r\n\r\n`user-select`属性用来控制用户能否选中文本。它可以接收的参数还有`auto`、`text`、`contain`、`all`等。\r\n\r\n当为`all`时，当点击子元素或者上下文时，包含该子元素的最顶层元素也会被选中。有了这个属性，我们在复制整篇内容时，不用先选中然后通过拖动滚动条来实现复制大段的内容了，可以通过先找到想要复制的元素的根元素，然后给它加上`user-select: all`的属性，就可以轻松的点击一下就全部选中了。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121689707674599461)\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1d493b81cc4eaebd136a099ba369eb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n### 6. 禁止鼠标事件（pointer-events）\r\n\r\n在有些需求中，需要禁止用户点击某个区域，看起来鼠标在这个区域完全不起作用，不会响应相应的事件。这时候可以通过`pointer-events`属性来限制。\r\n\r\n`pointer-events`属性用来指定在什么情况下某个特定的图形元素可以成为鼠标事件的`target`。把它设置成`none`即可到达效果。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7153196694715236386)\r\n\r\n\r\n#### 浏览器支持情况\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73687163911a4a8e8804a6e6d0639e5d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 7. 让网站变灰（filter:grayscale）\r\n\r\n在一些公祭日的时候，我们浏览网站通常都会发现网站整体风格都会变成灰色的。这种效果就是用`filter`这个属性实现的。\r\n\r\n`filter`属性可以将模糊或颜色偏移等图形效果应用于元素，可以接收的函数包括：\r\n- [`blur()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur)、 \r\n- [`brightness()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness)\r\n- [`contrast()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast)\r\n- [`grayscale()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale)\r\n- [`hue-rotate()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate)\r\n- [`invert()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert)\r\n- [`opacity()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity)\r\n- [`saturate()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate)\r\n- [`sepia()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia)\r\n- [`drop-shadow()`](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow)\r\n\r\n其中`grayscale(）`函数的作用就是将图片转换成灰度，可以接收数字或者百分比参数。0代表不做处理，1代表完全变成灰度。两者之间的数值通过线性插值来生成具体的灰度值。不传参默认为1。所以我们用`filter:grayscale()`一行代码就可以实现让网站变灰的效果。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121689041854005255)\r\n\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa4eeae77deb4b35ba132582deea53d4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 8. 透明图片阴影效果（filter:drop-shadow）\r\n\r\n在上面的`filter`属性可接收的函数中有一个`drop-shadow`函数，可以形成阴影的效果。它与[`box-shadow`](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow)类似，不同点在于`box-shadow`属性在元素的整个框后面创建一个矩形阴影，而`drop-shadow()`则是创建一个符合图像本身形状 (`alpha`通道) 的阴影。因此`drop-shadow`函数在透明图片上的优势就体现出来了。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121989722829750303)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1894d13033664d89bd5681abee3d4c4c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 9. 首字母大写（::first-letter）\r\n\r\n在排版中我们经常能看到首字母大写的效果。这种效果可以使用`::first-letter`这个伪元素来实现。\r\n\r\n`::first-letter`会选中某块级元素第一行的第一个字母。要注意必须为块级元素，也就是说只有在`display`属性值为`block`、`inline-block`、`table-cell`、`list-item`或`table-caption`的元素上才起作用。其他情况下将没有效果。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121231000356519944)\r\n\r\n#### 浏览器支持情况\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efc36145269b4599be055e68ba10362c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 10. 多行文本截断展示省略号(-webkit-line-clamp)\r\n在工作中经常会遇到容器宽度不够的情况下要截断文本的情况。单行文本截断展示省略号的方法估计大家已经应用的很是得心应手了。\r\n```\r\nwhite-space: nowrap; \r\noverflow: hidden; \r\ntext-overflow: ellipsis;\r\n```\r\n 下面来看看多行文本截断展示的情况。`-webkit-line-clamp`该派上用场了。\r\n \r\n `-webkit-line-clamp`属性可以把块容器中的内容限制为指定的行数。它只有在`display`属性设置成`-webkit-box`或者`-webkit-inline-box`并且`-webkit-box-orient`属性设置成`vertical`时才有效果。再配合上`overflow: hidden`和`text-overflow: ellipsis`就可以实现多行文本截断展示省略号的效果了。\r\n \r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7153199771153334311)\r\n\r\n#### 浏览器支持情况\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9cb927308de48b195f4c1143f4aa37d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 11. 中文简体繁体相互转换（font-variant-east-asian）\r\n`font-variant-east-asian`这个属性可以实现中文简体繁体的相互转换。但使用它达到效果是有条件的，需要字体本身就包含繁体变体。苹果设备的默认中文字体中一般都包含繁体字体。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121687316552712229)\r\n\r\n#### 浏览器支持情况\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21fa046ba28a48668a52e7a976ef95d9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 12. 实现镜像、倒影等效果（-webkit-box-reflect）\r\n`-webkit-box-reflect`这个属性可以在不同方向反射元素的内容。有了这个属性，我们就可以实现一些神奇的效果，比如镜像、倒影等。\r\n\r\n#### 实践\r\n[代码片段](https://code.juejin.cn/pen/7121684901572640799)\r\n\r\n\r\n#### 浏览器支持情况\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a310430b0456465385d0b79bf7a17ee3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 总结\r\n以上就是本期介绍的12个`CSS`小技巧。你学会了没？看完是不是觉得`CSS`的世界还是挺有意思的~\r\n\r\n\r\n### 参考文章\r\n1. [8 cool CSS tips & tricks to impress](https://livecodestream.dev/post/8-cool-css-tips-tricks-to-impress/)\r\n2. [11 CSS secrets you need to know in 2020](https://www.creativebloq.com/features/css-secrets)\r\n3. [10 CSS Tricks That Greatly Improve User Experience](https://betterprogramming.pub/10-css-tricks-that-greatly-improve-user-experience-5ee52886ca4b)\r\n\r\n\r\n"
    },
    {
        "article_id": "7188876269281345594",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8ebdfbaa53c4d5d860f51097480fbcd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "从 One-Hot 到 ChatGPT",
        "preview": "2022到2023年最火AI应用，毋庸置疑当属 OpenAI 的 ChatGPT 。 那么我们不禁要想 ChatGPT 为什么能够做到这些能力，它又是怎么演化而来的。回顾 NLP 发展来探究背后的原因",
        "author": "FelixCoder",
        "view_count": 630,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/dd4f2175446f95e53488ef018115ea0b~300x300.image",
        "category": "人工智能",
        "content": "## 一、介绍\r\n\r\n2022到2023年最火AI应用，毋庸置疑当属 OpenAI 的 [ChatGPT](https://chat.openai.com/chat) 。 那么我们不禁要想 [ChatGPT](https://chat.openai.com/chat)  为什么能够做到这些能力，它又是怎么演化而来的。高楼大厦不是瞬间就能建成的，肯定存在一个发展过程。 而且技术是不断的更新迭代的。我们想搞清楚 [NLP](https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/365730) 领域是怎么一步一步的探索和创新，最终诞生了 [ChatGPT](https://chat.openai.com/chat) 这个具有跨时代意义的模型。 这里技术链条很长，如果从头讲起，我们得从最开始 One-hot 编码开始讲起。NLP 领域是我最近比较关注的领域，也算是对我最新的学习做一个总结和回顾。\r\n\r\n> 阅读注意： 本文涉及很多专业名词，博主尽量用通俗的语言说。但非 AI 领域人士，可能会看不懂。大量学术名词不可避免，如有任何疑问请留言，我会尽量解答。\r\n> \r\n\r\n## 二、从一张图开始\r\n\r\n整理了一下关于整个 NLP 的发展的链路，是怎么发展到 ChatGPT这一步的，见下图\r\n\r\n![Untitled.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/908a38aabd014c1382d4c19b2f2988ca~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n上图每一块其实都是 NLP 领域的一次跃迁。 那么我们最初的 One-hot 编码开始，一步一步去了解每一步都做了哪些改进和优化。\r\n\r\n> 每一块会逐一讲解，但不会深入到算法和实现方式，这样文章长度就不可控了，看起来也会很枯燥，所以我这篇文章只讲用途和缺点，以及后面如何改进。 如果想了解细节，大家可以留言，我再单开文章讲解。\r\n> \r\n\r\n## 三、One-hot 独热编码\r\n\r\n### 3.1、介绍\r\n\r\n在机器学习领域，一切数据都需要向量化，比如在 NLP领域一个中文词或英文单词，如何让机器能够理解他们。 一句话概括：One-hot 编码是将类别变量转换为机器学习算法易于利用的一种形式的过程。\r\n\r\n![Untitled 1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7a72d0715149619379cbb7a90e7d48~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n如上图所示，每个单词对应一份单独的编码，这个编码是不重复的，只代表这个单词。为什么采用这种形式呢，而不是直接用数字顺序编码呢（比如,1,2,3,4等这种），神经网络存在大量的加劝平均运算。那么1 + 3 = 4，4 / 2 = 2，这意味着， 变成了另一种单词。毫无疑问，这是一个糟糕的方案。该模型的预测会有大量误差。所以才诞生了 One-hot 编码解决这样的问题。\r\n\r\n### 3.2、问题\r\n\r\n当然使用 One-hot 编码也会存在新的问题。即单词与单词是存在相似度的，比如 a , an 等 ， 但One-hot 编码并不知道这些，如果采用[余弦相似度](https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/17509249)计算向量间的相似度计算他们两个向量的相似度，可明显得到为0，即任意二者都不相关，也就是说独热表示无法解决词之间的相似性问题。 那怎么解决这个问题呢 ？ 这个时候 Word Embedding 出现了。 \r\n\r\n## 四、Word Embedding\r\n\r\n### 4.1、介绍\r\n\r\n由于 One-hot 编码无法解决词与词之间相似性问题，那么聪明的小伙伴可能想到了，采用深度神经网络学习一个词向量出来。让他可以满足词之间相似性的问题。原理见下图\r\n\r\n![Untitled 2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1247b5f4ca14999a3b20fe4c16b0bf2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但还有一些独特优势：\r\n\r\n1. 他可以将文本通过一个低维向量来表达，不像 one-hot 那么长。\r\n2. 语意相似的词在向量空间上也会比较相近。\r\n3. 通用性很强，可以用在不同的下游任务中。\r\n\r\n### 4.2、问题\r\n\r\n能做到一定的相似性，但效果不理想，性能也不是最优的。所以下面出现了 Word2Vec 来改进这一点。\r\n\r\n## 五、Word2Vec 模型\r\n\r\n### 5.1、介绍\r\n\r\nWord2Vec 的网络结构其实和神经网络语言模型（NNLM）是基本类似的。但是他们训练方法不太一样。\r\n\r\n\r\n![Untitled 3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eeed83a24864760907579f627b310e5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nWord2Vec 有两种训练方法：\r\n\r\n1. 第一种叫 CBOW，核心思想是从一个句子里面把一个词抠掉，用这个词的上文和下文去预测被抠掉的这个词。\r\n2. 第二种叫做 Skip-gram，和 CBOW 正好反过来，输入某个单词，要求网络预测它的上下文单词。\r\n\r\n而你回头看看，NNLM 是怎么训练的？是输入一个单词的上文，去预测这个单词。这是有显著差异的。\r\n\r\n**Word2Vec 有以下一些优势：**\r\n\r\n1. 由于 Word2vec 会考虑上下文，跟之前的 Word Embedding 方法相比，效果要更好\r\n2. 比之前的 Word Embedding 方法维度更少，所以速度更快\r\n3. 通用性很强，可以用在各种 NLP 任务中\r\n\r\n### 5.2、问题\r\n\r\nWord2Vec 还是为了解决词之间的相似度的问题。 但是聪明的小伙伴发现了，由于词和向量是一对一的关系，所以多义词的问题无法解决。 比如 bank 这个单词，在不通语言上下文中，是不同的意思。即代表 河岸，也表示银行。 \r\n\r\n怎么办？ 这时候诞生了 ELMo 模型。 但后面先不讲 ELMo 模型， 我们先讲一下，Word2Vec 学好的词向量如何应用到下游任务中？ 这里就顺便提一下 RNN 和 LSTM 模型\r\n\r\n## 六、RNN 和 LSTM\r\n\r\n### 6.1、前言\r\n\r\n为什么这里插一个 RNN 和  LSTM ， 在进行下游任务中（比如续写， 翻译等），我们可以将 Word2Vec 输出的词向量作为 RNN 和  LSTM 的输入。  ELMo 模型 也只是在 LSTM 上的改进，它使用了双向长短期记忆网络（LSTM）。OK， 那么我们先来看看 RNN 是什么。\r\n\r\n### 6.2、介绍 RNN\r\n\r\nRNN 是一个非常经典的面向序列的模型，可以对自然语言句子或是其他时序信号进行建模。进一步讲，它只有一个物理RNN单元，但是这个RNN单元可以按照时间步骤进行展开，在每个时间步骤接收当前时间步的输入和上一个时间步的输出，然后进行计算得出本时间步的输出。\r\n\r\n传统神经网络的结构比较简单：输入层 – 隐藏层 – 输出层。\r\n\r\nRNN 跟传统神经网络最大的区别在于每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练。\r\n\r\n![image.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a8a5aeb23514955938b208bcac385eb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n所以RNN 是一种连续的时序模型，它会持续存储上次的模型内容，带入到下次隐藏层，但是这个关系只维持一层，向后传递会前面的信息会越来越弱。聪明的小伙伴可能已经发现问题了。\r\n\r\n### 6.3、RNN 问题\r\n\r\n1. RNN 只有短期的记忆问题，无法处理很长的输入序列（长序列容易遗忘前面信息）\r\n2. RNN 梯度消失和梯度爆炸问题\r\n\r\n> 所以后面要提到 LSTM 来改进这个问题\r\n> \r\n\r\n### 6.4、什么是 LSTM\r\n\r\n长短期记忆网络——通常被称为 LSTM，是一种特殊的 RNN，能够学习长期依赖性。由 Hochreiter 和 Schmidhuber（1997）提出的，并且在接下来的工作中被许多人改进和推广。LSTM 在各种各样的问题上表现非常出色，现在被广泛使用。\r\n\r\nLSTM 被明确设计用来避免长期依赖性问题。长时间记住信息实际上是 LSTM 的默认行为，而不是需要努力学习的东西！LSTM 还有一个好处是，只记重要的内容，比如一段文章很长，但正在有价值往往就那么几句关键。 \r\n\r\n那它是怎么做到的呢？见下图\r\n\r\n![Untitled 4.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0feafbaee645eeb58e7548ff32a8b2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nLSTM 通过各种门来解决问题\r\n\r\n- **状态向量ct**：它控制着整个LSTM单元的状态或者记忆，它会根据每个时刻的输入进行更新，从而实时保持LSTM单元的记忆。\r\n- **隐状态向量ht**：它是当前LSTM单元对外的输出状态，它是实际的工作状态向量，即一般会利用ht来做一些具体的任务。\r\n- **输入门**it：控制当前时刻的输入信息需要向状态向量𝑐𝑡ct中注入哪些信息。举个例子，当输入信息是一些没有实际意义的词，比如”的”，可能模型不会让这些信息流入到状态向量中，从而保持模型的语义表达。\r\n- **遗忘门**ft：控制前一时刻的状态向量 ct−1需要被屏蔽/遗忘哪些信息。举个例子：昨天我去爬了长城，哦不对是前天， 当模型看到”不对，是前天”的时候，可能就会忘记前边的”昨天”。\r\n- **输出门**ot：控制当前时刻的状态向量ct需要对外输出哪些信息，最终输出的信息即为ht。\r\n\r\n> 公示和具体的算法就不写了，我这里只是抛一个砖，大家自行学习，或留言交流。\r\n> \r\n\r\n### 6.4、LSTM 问题\r\n\r\nLSTM 虽然能够解决 RNN 的问题， 但自身也有一些问题，比如复杂度较高，LSTM 有三个不同的门，参数较多，训练起来比较困难。\r\n\r\n后面在 2014 年 由Cho, et al在文章《Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation》中提出的 GRU 是对 LSTM 的一个改进版本， GRU只含有两个门控结构，且在超参数全部调优的情况下，二者性能相当，但是GRU结构更为简单，训练样本较少，易实现。 \r\n\r\n> GRU 是在 LSTM 基础上的一个优化， 我这里就不单独讲了。\r\n> \r\n\r\n## 七 、ELMO 预训练\r\n\r\n### 7.1、介绍\r\n\r\n在讲解 Word2vec 时，细心地读者一定已经发现，这些词表示方法本质上是静态的，每一个词都有一个唯一确定的词向量，不能根据句子的不同而改变，无法处理自然语言处理任务中的多义词问题。 所以上面也有提到，ELMO 主要是为了解决单词的多义性的问题。那它是怎么解决的呢 \r\n\r\n![Untitled 5.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8d58624d4a6451c83f20b7c56f8c4f3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nELMo 的本质思想是：我事先用 Word2vec 模型学好一个单词的词向量，此时多义词无法区分，不过这没关系。在我实际使用 词向量 的时候，单词已经具备了特定的上下文了，这个时候我可以根据上下文单词的语义再去调整单词的词向量表示，这样经过调整后的 词向量 更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。所以 ELMo 本身是个根据当前上下文对词向量动态调整的思路。\r\n\r\nELMo 采用了典型的两阶段过程：\r\n\r\n1. 第一个阶段是利用语言模型进行预训练；\r\n2. 第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的词向量作为新特征补充到下游任务中。\r\n\r\n### 7.2、总结\r\n\r\n本质上 ELMo 也是一个预训练模型，输出是特征，ELMo 模型本质是为了提取特征。 只是它输出的向量内容包含单词的多义信息和单词的语义特征，句法特征。（至于为什么会有这个3个特征，我也不清楚，深度学习有时候也挺玄学） 有了这些特征后，就可以更好的喂给下游任务，做目标任务的输出。\r\n\r\n### 7.3、问题\r\n\r\n1. 训练时间长，性能较差，无法并行化。\r\n2. 提取的特征能力不如 Transformer \r\n\r\n> 后面会讲到 Transformer 模型，采用完全不同思路解决之前的问题，ELMo 方法已被淘汰，一直到目前主流还是采用 Transformer 。\r\n> \r\n\r\n## 八、Attention 和 Transformer\r\n\r\n### 8.1、介绍Attention\r\n\r\nAttention 是 Transformer 的一部分，也是非常重要的一部分。 那什么是  Attention ？ Attention 顾名思义注意力机制，Attention 也借鉴了人类的视觉注意力。比如人类视觉通过快速扫描全局图像，获得需要重点关注的目标区域，也就是一般所说的注意力焦点，而后对这一区域投入更多注意力资源，以获取更多所需要关注目标的细节信息，而抑制其他无用信息。类似下图。\r\n\r\n![Untitled 6.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6efbfeeefe5345ab8d17e3fa6162831d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nAttention 也分很多种， 比如 Self Attention （自注意力）  Masked Self-Attention （掩码注意力），如果他们有什么区别，那就要讲到  encoder 和 decoder 。 细节较多。有兴趣可以看[这篇文章](https://paddlepedia.readthedocs.io/en/latest/tutorials/pretrain_model/transformer.html#input-embedding)。\r\n\r\nAttention 本质就是通过输入x与随机矩阵相乘得到 Q K V 三个向量， 在实际的应用场景，为了提高计算速度，我们采用的是矩阵的方式，直接计算出Q K V的矩阵，然后把embedding的值与三个矩阵直接相乘，把得到的新矩阵Q与K相乘，乘以一个常数，做softmax操作，最后乘上V矩阵，最终通过 Q 和 K 的相似性程度来确定 V 的权重分布。Attention 通俗来讲它的目的还是为了提取句法特征和语义特征，它的效果要优于 ELMo 模型。\r\n\r\n### 8.2、介绍Transformer\r\n\r\nTransformer 简单来讲，就是对 Attention 的应用。 Transformer 简单点看其实就是 self-attention 模型的叠加\r\n，首先我们来看看 Transformer 的整体框架。\r\n\r\n![Untitled 7.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e34017fec4b479b956a2d5733498784~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n上图所示的整体框架乍一眼一看非常复杂，本质来讲它是两块内容构造， 左边是 Encoder（编码器） ，右边是 Decoder（解码器）。每一个encoder和decoder的内部简版结构如下图。\r\n\r\n![Untitled 8.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/692e9afce0cc4fdaa48c72bfe778b8a9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n对于encoder，包含两层，一个self-attention层和一个前馈神经网络，self-attention能帮助当前节点不仅仅只关注当前的词，从而能获取到上下文的语义。\r\n\r\ndecoder也包含encoder提到的两层网络，但是在这两层中间还有一层attention层，帮助当前节点获取到当前需要关注的重点内容。\r\n\r\n> 从我的一张图可以看出，到 Transformer 这里分出了两个模型 GPT 和 Bert ，他们都来自Transformer 。GPT 用了 Decoder , Bert 用了 Encoder。虽然都来自 Transformer 却走了两条不同的路线。一个选择走生成式语言大模型路线( OpenAI 野心很大，想走无监督通用人工智能路线 )，拥有很强预测和生成能力。 Bert 则是选择了强化对语义的理解，对特征的提取能力。本质上两者都是预训练模型都可以做 fine-tuning（微调），只是选择走不同的发展方向。Bert 适合做 文本分类，句子关系判断，命名实体识别，问答等。GPT 适合做 文本生成、文本续写、文本修饰、文本摘要等。\r\n> \r\n\r\n### 8.3、GPT 和 Bert\r\n\r\n简单提一下原理，为什么选择 Decoder 和 Encoder 会有方向不同区别？  回顾我上面提到的，GPT 使用 Transformer 的 Decoder 结构，他是带有掩码的 Mask Multi-Head Attention 。在预测时，GPT 是不知道下文内容是什么的，GPT 模型是利用上文预测下一个单词的，因为 Decoder 使用了 Masked Multi Self-Attention 屏蔽了单词的后面内容，所以 Decoder 是现成的生成式语言模型。所以 GPT 非常适合做生成式任务。\r\n\r\n而 Bert 是采用的 Encoder 结构， 训练和预测都是知道整个上下文信息的。所以它能做很强的语义理解类的任务。当然我这里只是浅层的表述，其实有大量的技术细节，我就不详说了。感兴趣可留言。\r\n\r\n言归正传，既然我们要讲的是 ChatGPT ，那么我们继续从 GPT 接着讲吧。 [Bert](https://zhuanlan.zhihu.com/p/514830786) 大家可以自行了解。\r\n\r\n## 九、GPT1 和 GPT2 和 GPT3\r\n\r\n### 9.1、介绍\r\n\r\nGPT 全称为 Generative Pre-trained Transformer （生成式预训练模型）。OpenAI在2018年发布的第一个预训练语言模型 GPT1，它使用了Transformer架构，并在大量文本数据上进行了预训练。\r\n\r\n在GPT1之前的模型，比如 ELMo，它们往往使用大量的数据对有监督的模型进行任务相关的模型训练，但是这种有监督学习的任务存在两个缺点：\r\n\r\n1. 需要大量的标注数据，高质量的标注数据往往很难获得，因为在很多任务中，图像的标签并不是唯一的或者实例标签并不存在明确的边界；\r\n2. 根据一个任务训练的模型很难泛化到其它任务中，这个模型只能叫做“领域专家”而不是真正的理解了NLP。\r\n\r\n这里介绍的 GPT1 的思想是先通过在无标签的数据上进行无监督学习，学习一个生成式的语言模型，然后再根据特定热任务进行有监督的 Fine-Tuning(微调)。这些任务包含自然语言推理，问答和常识推理，语义相似度，文本分类。 \r\n\r\nGPT2 的目标旨在训练一个泛化能力更强的词向量模型，GPT2 并没有对 GPT1 的网络进行过多的结构的创新与设计，只是使用了更多的网络参数和更大的数据集，让整个模型变的更大了。\r\n\r\nGPT3 则真的大力出奇迹的产物， 海量的训练数据，仅仅需要 zero-shot 或者 few-shot，GPT-3就可以在下游任务表现的非常好。除了几个常见的NLP任务，GPT-3还在很多非常困难的任务上也有惊艳的表现，例如撰写人类难以判别的文章，甚至编写SQL查询语句，React或者JavaScript代码等。而这些强大能力的能力得意于模型的规模变大（ 是GPT1 的10倍规模 ）， 1750 亿的模型参数量， 45TB的训练数据。Github的  [Copilot](https://github.com/features/copilot) 就是基于 GPT3 模型的应用。\r\n\r\n**这里顺便提一下，GPT 是如何处理多任务的**，传统语言模型，每个任务对应一个模型。GPT 提出的MQAN模型可以将机器翻译，自然语言推理，语义分析，关系提取等10类任务统一建模为一个分类任务，而无需再为每一个子任务单独设计一个模型。基于上面的思想，作者认为，当一个语言模型的容量足够大时，它就足以覆盖所有的有监督任务，也就是说所有的有监督学习都是无监督语言模型的一个子集 。例如当模型训练完“麦克乔丹是历史上最好的篮球运动员”语料的语言模型之后，便也学会了(question：“谁是最好的篮球运动员 ?”，answer:“麦克乔丹”)的Q&A任务。所以这也是 GPT 的一个特点。\r\n\r\n### 9.3、问题\r\n\r\n但 GPT 本身也存在一些不完善的地方，比如下面这些缺点也是 GPT 需要改进的地方。\r\n\r\n1. 对于一些命题没有意义的问题，GPT 不会判断命题有效与否，而是拟合一个没有意义的答案出来；\r\n2. 由于海量数据的存在，很难保证 GPT3 生成数据的安全性，数据会存在一些非常敏感的内容，比如 Copilot 就把用户真实身份证号码生成出来。数据缺失一定的清洗，甚至包含种族歧视，性别歧视，宗教偏见等。\r\n3. 受限于 Transformer 的建模能力，GPT3 并不能保证生成的一篇长文章或者一本书籍的连贯性，存在下文不停重复上文的问题。\r\n\r\n> 那面对这些问题如何改进，这个时候 InstructGPT，特点则是引人了强化学习 PPO。 下面再讲。\r\n> \r\n\r\n## 十、InstructGPT\r\n\r\n### 10.1、介绍\r\n\r\n2022 年初，OpenAI 发布了 InstructGPT，在这项研究中，相比 GPT3 而言，OpenAI 采用对齐研究（alignment research），训练出更真实、更无害，而且更好地遵循用户意图的语言模型 InstructGPT，InstructGPT 是一个经过微调的新版本 GPT3 ，可以将有害的、不安全的数据、不真实的和敏感数据的输出最小化。 那它又是怎么做到这一点的呢？\r\n\r\n根据我上面有提到，InstructGPT 引入了监督学习再加上从人类反馈中获得的强化学习。来提高 GPT3 的输出质量。在这种学习中，人类对模型的潜在输出进行排序，强化学习算法则对产生类似于高级输出材料的模型进行奖励。\r\n\r\n![Untitled 9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eef08599d56464d80f745383bb164ae~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n本质上来说，InstructGPT 是安排人来给 GPT3 生成的内容打分和排序。包括后面会提到的 ChatGPT 也是一样，它同样也是采用 RLHF（从人类反馈中强化学习）训练的，不同之处在于数据是如何设置用于训练（以及收集）的。\r\n\r\n**为什么要使用排序方法，而不是直接打分数呢？**这是因为不同的研究人员对同一个句子可能有不一样的评分，这样会导致大量的噪声出现，如果改成排序，则会大大降低噪声。\r\n\r\n得到排序结果后，就可以用来训练奖励模型。奖励模型可以利用预训练模型进行初始化，或者也可以进行随机初始化。然后把人工标注的排序结果输入到奖励模型中。这里可以使用类似推荐系统中的“pair-wise”，把两个句子输入进行，奖励模型判别哪个句子较好。\r\n\r\n有了这些基础。所以我们 GPT 得回答会越来越符合人的逻辑和思维，就看起来没有那么傻了，这个也是ChatGPT 爆火的原因。\r\n\r\n## 十一、ChatGPT\r\n\r\n ChatGPT 的论文还没有发表， 根据 OpenAI 的习惯，可能也是在数月以后。 但我们知道它用方法跟InstructGPT 类似。 但有一些细微的区别，大同小异吧。 这种大模型，也许就算公开方法给你们，一般公司也很难复刻。 GPT3 模型训练一次的花费就是 1200万美金 。可能出一次错都没钱再训练第二次。 还有就是数据，ChatGPT 没有公布他们的训练数据来源， 我猜测肯定也是会涉及到侵权问题的，所以才未公布。 OpenAI 属于创业公司，也有多位金主爸爸撑腰，干也就干了，也没人说啥。毕竟还是有竞争压力的。\r\n\r\nChatGPT 还不是很完美， 有些问题答不上来，可能会强行回答，造成人们的误解。 特别是在专业领域上，创建新的名词，追问过深，就会用套路了，废话文学就来了。 我就不举例，大家可以自行尝试。\r\n\r\n据 GPT 创始人说 GPT4 会在今年发布，它能够通过图灵测试，并且能够先进到和人类没有区别。让我敬请期待。\r\n\r\n## 十二、总结\r\n\r\n人工智能这个领域还是非常内卷和前端领域有得一拼，好现象，就怕停滞不前。 AI 领域从 Transformer 诞生后，就开始军备竞赛了。Transformer 可以说是统一了语言模型和视觉模型，模型大统一后，基于此发展了各种各样优秀应用，比如今年的AI 绘画领域 Diffusion 模型， 基于视觉和文本的结合的模型CLIP，都是有突飞猛进的进步，未来人工智能将会是一片大好前景，甚至 AI 的崛起，有可能带来第四次工业革命。所以未来押注 AI 这条赛道是没有错，我也是基于兴趣去学这个领域，欢迎小伙伴们一起学习。"
    },
    {
        "article_id": "7188374018217476157",
        "snapshot": "",
        "title": "手写JavaScript事件总线",
        "preview": "需求分析 一提起事件总线我们首先想到的就是要有事件监听、触发事件等功能。大概包括如下几点 on 事件监听 emit 事件触发 off 事件取消 once 单次监听 编写代码 编写结构 首先创建一个名为",
        "author": "five_coder",
        "view_count": 1106,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/75332e79deefa75627f4279bca2b4fb8~300x300.image",
        "category": "前端",
        "content": "---\r\nhighlight: a11y-dark\r\n---\r\n# 需求分析\r\n一提起事件总线我们首先想到的就是要有事件监听、触发事件等功能。大概包括如下几点\r\n\r\n1. on 事件监听\r\n2. emit 事件触发\r\n3. off 事件取消\r\n4. once 单次监听\r\n\r\n# 编写代码\r\n\r\n## 编写结构\r\n\r\n首先创建一个名为 AriesEventBus 的类，在类里面定义事件监听、事件触发等方法，把功能结构先给写好\r\n```javascript\r\nclass AriesEventBus {\r\n  constructor() {\r\n\r\n  }\r\n\r\n  // 事件监听\r\n  on(eventName, eventCallback) {\r\n\r\n  }\r\n\r\n  // 事件触发\r\n  emit(eventName, ...args) {\r\n\r\n  }\r\n\r\n  // 移除事件监听\r\n  off(eventName, eventCallback) {\r\n\r\n  }\r\n\r\n  // 单次监听\r\n  once(eventName, eventCallback) {\r\n    \r\n  }\r\n}\r\n```\r\n## 实现 事件监听(on) 功能\r\n\r\n如果有使用过事件总线的库的小伙伴应该知道一般情况下我们监听事件的格式会如下：\r\n\r\n-   第一次参数为要监听的事件名\r\n-   第二个参数为要执行的回调函数\r\n```javascript\r\neventBus.on(\\\"事件名\\\", (...arg) => {\r\n\r\n})\r\n\r\n```\r\n因此我们可以在代码中这样实现：\r\n```javascript\r\nclass AriesEventBus {\r\n  constructor() {\r\n      // 在类初始化的时候就往this中绑定一个eventBus，用于存储事件名和事件函数\r\n    this.eventBus = {}\r\n  }\r\n\r\n  // 事件监听\r\n  on(eventName, eventCallback, thisArg) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n      \r\n      // 从 eventBus 中获取对应的事件数据\r\n    let handlers = this.eventBus[eventName]\r\n    // 如果 handlers 不存在那就代表从未在 eventBus 上挂载过该事件的 handlers\r\n    if (!handlers) {\r\n        // 给 handlers 赋值为数组类型，再将 eventName 挂载到 eventBus 上\r\n      handlers = []\r\n      this.eventBus[eventName] = handlers\r\n    }\r\n\r\n      // 在上一步的if语句中已经将引用数据类型的 handlers 赋值给了this.eventBus[eventName]\r\n      // 这样我们在这一步进行 push 操作的时候也会修改 this.eventBus[eventName] 的数据\r\n      // 因为 array 是引用类型，handlers 和 this.eventBus[eventName] 存放的都是一样内存地址\r\n    handlers.push({\r\n      eventCallback,\r\n      thisArg\r\n    })\r\n  }\r\n}\r\n```\r\n## 实现事件触发(emit)功能\r\n\r\n一般情况下，我们要触发事件的话代码会如下格式：\r\n\r\n-   第一个参数为需要触发的事件名称\r\n-   之后的参数为args，也就是一个或多个传进事件监听函数的数据\r\n```javascript\r\neventBus.emit(\\\"事件名\\\", args)\r\n```\r\n代码实现如下：\r\n```javascript\r\nclass AriesEventBus {\r\n  constructor() {\r\n    this.eventBus = {}\r\n  }\r\n    \r\n  // 事件监听\r\n  on(eventName, eventCallback, thisArg) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n      \r\n      // 从 eventBus 中获取对应的事件数据\r\n    let handlers = this.eventBus[eventName]\r\n    // 如果 handlers 不存在那就代表从未在 eventBus 上挂载过该事件的 handlers\r\n    if (!handlers) {\r\n        // 给 handlers 赋值为数组类型，再将 eventName 挂载到 eventBus 上\r\n      handlers = []\r\n      this.eventBus[eventName] = handlers\r\n    }\r\n\r\n      // 在上一步的if语句中已经将引用数据类型的 handlers 赋值给了this.eventBus[eventName]\r\n      // 这样我们在这一步进行 push 操作的时候也会修改 this.eventBus[eventName] 的数据\r\n      // 因为 array 是引用类型，handlers 和 this.eventBus[eventName] 存放的都是一样内存地址\r\n    handlers.push({\r\n      eventCallback,\r\n      thisArg\r\n    })\r\n  }\r\n\r\n  // 事件触发\r\n  emit(eventName, ...args) {\r\n    // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n\r\n    // 从 eventBus 中获取对应的事件数据\r\n    const handlers = this.eventBus[eventName]\r\n    // 判断 handlers 是否存在，不过不存在那就证明 该触发的事件名并未挂载到 eventBus 上\r\n    if (!handlers) {\r\n      throw new Error(\\\"该触发的事件名并未挂载到 eventBus 上\\\")\r\n    }\r\n    // 遍历 handlers 调用 handlers 中的 eventCallback\r\n    handlers.forEach((handler) => {\r\n      handler.eventCallback.apply(handler.thisArg, args)\r\n    })\r\n  }\r\n}\r\n```\r\n## 实现移除事件监听(off)\r\n\r\n调用移出事件监听的写法跟添加事件监听一致，off(移出的事件名，移除的事件函数 )，有一点需要注意，我们一般移出一个事件并不是将所有跟这个事件绑定的 eventCallback 都给移除掉，二是移除对应的的事件函数，也就是 off(移出的事件名，移除的事件函数 ) 的第二个参数\r\n\r\n代码如下：\r\n```javascript\r\nclass AriesEventBus {\r\n  constructor() {\r\n    this.eventBus = {}\r\n  }\r\n    \r\n  // 事件监听\r\n  on(eventName, eventCallback, thisArg) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n      \r\n      // 从 eventBus 中获取对应的事件数据\r\n    let handlers = this.eventBus[eventName]\r\n    // 如果 handlers 不存在那就代表从未在 eventBus 上挂载过该事件的 handlers\r\n    if (!handlers) {\r\n        // 给 handlers 赋值为数组类型，再将 eventName 挂载到 eventBus 上\r\n      handlers = []\r\n      this.eventBus[eventName] = handlers\r\n    }\r\n\r\n      // 在上一步的if语句中已经将引用数据类型的 handlers 赋值给了this.eventBus[eventName]\r\n      // 这样我们在这一步进行 push 操作的时候也会修改 this.eventBus[eventName] 的数据\r\n      // 因为 array 是引用类型，handlers 和 this.eventBus[eventName] 存放的都是一样内存地址\r\n    handlers.push({\r\n      eventCallback,\r\n      thisArg\r\n    })\r\n  }\r\n\r\n  // 事件触发\r\n  emit(eventName, ...args) {\r\n    // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n\r\n    // 从 eventBus 中获取对应的事件数据\r\n    const handlers = this.eventBus[eventName]\r\n    // 判断 handlers 是否存在，不过不存在那就证明 该触发的事件名并未挂载到 eventBus 上\r\n    if (!handlers) {\r\n      throw new Error(\\\"该触发的事件名并未挂载到 eventBus 上\\\")\r\n    }\r\n    // 遍历 handlers 调用 handlers 中的 eventCallback\r\n    handlers.forEach((handler) => {\r\n      handler.eventCallback.apply(handler.thisArg, args)\r\n    })\r\n  }\r\n    \r\n  // 移除事件监听\r\n  off(eventName, eventCallback) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n    const handlers = this.eventBus[eventName] || []\r\n    // 如果 eventName 在 eventBus 中存在则进行操作\r\n    if (handlers.length) {\r\n      const newHandlers = [...handlers]\r\n      for (let i = 0; i < newHandlers.length; i++) {\r\n        const handler = newHandlers[i]\r\n        if (handler.eventCallback === eventCallback) {\r\n          const index = handlers.indexOf(handler)\r\n          handlers.splice(index, 1)\r\n        }\r\n      }\r\n    }\r\n      \r\n    // 判断 handlers 的 length 是否为 0，若为 0 那则代表 eventBus中已经没有挂载该事件，可直接删除\r\n    if (handlers.length === 0) {\r\n      delete this.eventBus[eventName]\r\n    }\r\n    \r\n  }\r\n}\r\n```\r\n## 实现单次监听(once)\r\n\r\n顾名思义，也就是对事件只监听一次，写法格式：\r\n```javascript\r\neventBus.once(事件名，事件函数)\r\n```\r\n代码如下：\r\n```javascript\r\nclass AriesEventBus {\r\n  constructor() {\r\n    this.eventBus = {}\r\n  }\r\n    \r\n  // 事件监听\r\n  on(eventName, eventCallback, thisArg) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n      \r\n      // 从 eventBus 中获取对应的事件数据\r\n    let handlers = this.eventBus[eventName]\r\n    // 如果 handlers 不存在那就代表从未在 eventBus 上挂载过该事件的 handlers\r\n    if (!handlers) {\r\n        // 给 handlers 赋值为数组类型，再将 eventName 挂载到 eventBus 上\r\n      handlers = []\r\n      this.eventBus[eventName] = handlers\r\n    }\r\n\r\n      // 在上一步的if语句中已经将引用数据类型的 handlers 赋值给了this.eventBus[eventName]\r\n      // 这样我们在这一步进行 push 操作的时候也会修改 this.eventBus[eventName] 的数据\r\n      // 因为 array 是引用类型，handlers 和 this.eventBus[eventName] 存放的都是一样内存地址\r\n    handlers.push({\r\n      eventCallback,\r\n      thisArg\r\n    })\r\n  }\r\n\r\n  // 事件触发\r\n  emit(eventName, ...args) {\r\n    // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n\r\n    // 从 eventBus 中获取对应的事件数据\r\n    const handlers = this.eventBus[eventName]\r\n    // 判断 handlers 是否存在，不过不存在那就证明 该触发的事件名并未挂载到 eventBus 上\r\n    if (!handlers) {\r\n      throw new Error(\\\"该触发的事件名并未挂载到 eventBus 上\\\")\r\n    }\r\n    // 遍历 handlers 调用 handlers 中的 eventCallback\r\n    handlers.forEach((handler) => {\r\n      handler.eventCallback.apply(handler.thisArg, args)\r\n    })\r\n  }\r\n    \r\n  // 移除事件监听\r\n  off(eventName, eventCallback) {\r\n      // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n      // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n\\t\r\n    const handlers = this.eventBus[eventName] || []\r\n    // 如果 eventName 在 eventBus 中存在则进行操作\r\n    if (handlers.length) {\r\n      const newHandlers = [...handlers]\r\n      for (let i = 0; i < newHandlers.length; i++) {\r\n        const handler = newHandlers[i]\r\n        if (handler.eventCallback === eventCallback) {\r\n          const index = handlers.indexOf(handler)\r\n          handlers.splice(index, 1)\r\n        }\r\n      }\r\n    }\r\n      \r\n    // 判断 handlers 的 length 是否为 0，若为 0 那则代表 eventBus中已经没有挂载该事件，可直接删除\r\n    if (handlers.length === 0) {\r\n      delete this.eventBus[eventName]\r\n    }\r\n    \r\n  }\r\n    \r\n   // 单次监听\r\n  once(eventName, eventCallback, thisArg) {\r\n    // 判断事件名是否是 string 类型\r\n    if (typeof eventName !== \\\"string\\\") {\r\n      throw TypeError(\\\"传入的事件名数据类型需为string类型\\\")\r\n    }\r\n    // 判断事件函数是否是 function 类型\r\n    if (typeof eventCallback !== \\\"function\\\") {\r\n      throw TypeError(\\\"传入的回调函数数据类型需为function类型\\\")\r\n    }\r\n    \r\n      // 在内部创建一个函数，将这个函数绑定到属性名为eventName的eventBus上\r\n    const tempCallback = (...args) => {\r\n      // 当第一次触发事件后在执行这一步的时候就通过 off 来移除这个事件函数， 这样这个函数只会执行一次\r\n      this.off(eventName, tempCallback)\r\n      eventCallback.apply(thisArg, args)\r\n    }\r\n\r\n    this.on(eventName, tempCallback)\r\n  }\r\n}\r\n```\r\n## 测试\r\n\r\n至此我们所需要实现的功能都已经写好了，接下来我们来测试一下\r\n```javascript\r\nconst eventBus = new AriesEventBus()\r\n\r\nfunction nameCallback(...args) {\r\n  console.log(\\\"name发生改变了, 值为：\\\" + args);\r\n} \r\nfunction name2Callback(...args) {\r\n  console.log(\\\"name2发生改变了, 值为：\\\" + args);\r\n} \r\nfunction name3Callback(...args) {\r\n  console.log(\\\"name3发生了改变：\\\" + args);\r\n}\r\neventBus.on(\\\"name\\\", nameCallback)\r\neventBus.on(\\\"name\\\", nameCallback)\r\neventBus.on(\\\"name\\\", name2Callback)\r\neventBus.once(\\\"name\\\", name3Callback)\r\n\r\nsetTimeout(() => {\r\n  console.log(\\\"触发事件\\\");\r\n  eventBus.emit(\\\"name\\\", \\\"why\\\", \\\"zjl\\\")\r\n}, 1000);\r\nsetTimeout(() => {\r\n  console.log(\\\"移除事件\\\");\r\n  eventBus.off(\\\"name\\\", nameCallback)\r\n}, 2000);\r\nsetTimeout(() => {\r\n  console.log(\\\"再次触发事件\\\");\r\n  eventBus.emit(\\\"name\\\", \\\"why\\\", \\\"哈哈哈哈\\\")\r\n}, 3000);\r\n```\r\n控制台输出结果：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd9db398ad7f4305bfd13ae96c82fced~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 总结\r\n其实完成功能所需的代码并不复杂，称得上很简单，难的在于是否敢去尝试，这个世界上绝大多数事情还没到拼智商的程度，共勉之！！！\r\n"
    },
    {
        "article_id": "7181293876471136317",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a8d9648df2c406288340b893a0fad46~tplv-k3u1fbpfcp-watermark.image?",
        "title": "💰 金石计划二期活动 开奖啦！",
        "preview": "🎉金石计划02期——瓜分 6 万元现金大奖活动正式落幕啦！感谢每位掘友的付出，希望大家在这次活动中都已经有所收获。",
        "author": "掘金酱",
        "view_count": 2768,
        "collect_count": 3,
        "comment_count": 17,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/168e0858b6ccfd57fe5~tplv-t2oaga2asx-image.image",
        "category": "阅读",
        "content": "🎉金石计划02期——瓜分 6 万元现金大奖活动正式落幕啦！活动详情可查看[ 等级用户专属活动上线啦丨写好文，瓜分6万元现金大奖](https://juejin.cn/post/7162096952883019783)\r\n\r\n截止12月16日23:59分共有 **401** 位用户参与发文挑战，累计贡献了 **2000** 篇技术文章；截止12月29日23:00 共有 **1289** 篇文章满足数据要求进入优质挑战池，感谢每位掘友的付出，希望大家在这次活动中都已经有所收获。\r\n\r\n由于瓜分奖池用户较多，详细的名单公示如下：[金石计划02期.奖金瓜分名单](https://bytedance.feishu.cn/sheets/shtcnCkiavELP6O3I4DwAQMPxdc)\r\n\r\n> 如何快速找到自己：进入飞书表格后，使用 Ctr+F 搜索自己的用户名或 用户id，选择“所有工作表”（ 用户 id 即掘金主页 [juejin.cn/XXXXXX](https://juejin.cn/XXXXXX \\\"https://juejin.cn/XXXXXX\\\") 最后的一串数字）。之前打开过本表同学请刷新表单，奖项或有增补，以最新的表格为准。\r\n\r\n\r\n\r\n![截屏2022-12-26 11.21.44.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ace5c701502548d9b023a1472e563357~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 领奖方式\r\n\r\n-   符合奖金瓜分条件的掘友近期请注意 **[系统消息]** （预计12月26日23:00前下发），请于 **12 月 28 日 23 点** 之前在相关问卷中填写信息，过期将视为放弃奖金。\r\n-   奖金将于问卷截止日期后的 15 个工作日内完成发放。\r\n\r\n**若对获奖名单有疑问，请先在文档中确认未获奖原因，并自查相关文章无问题后，可[点击链接](https://zjsms.com/hF2NL2u)  联系「小斗金」进行自证~**\r\n\r\n  \r\n## 注意\r\n\r\n发放的奖金需按照《中华人民共和国税收征收管理法》有关规定扣缴个人所得税。\r\n\r\n**本活动法律声明详见**  **[金石活动法律声明](https://bytedance.feishu.cn/docx/doxcnhVXY9NDHSE16nmNsGfKcte \\\"https://bytedance.feishu.cn/docx/doxcnhVXY9NDHSE16nmNsGfKcte\\\")**\r\n"
    },
    {
        "article_id": "7180739989821456443",
        "snapshot": "",
        "title": "iOS直播开播端概述",
        "preview": "简单介绍开播在技术实现上的流程，以及在各个阶段能够使用到的技术点。帮助读者对直播的实现有个大致的了解。",
        "author": "懒得起用户名啊",
        "view_count": 11035,
        "collect_count": 11,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/faf0454549018aad64e7c9cd98f12793~300x300.image",
        "category": "iOS",
        "content": "## 前言\r\n1. 好长时间没写文章，可能排版不是很美观。  \r\n2. 此系列文章是我对自己最近所学技术的总结和沉淀，设计到的一些技术点和实现方案并不一定是最好，如有不同意见可以在评论区留言共同探讨以及学习。\r\n3. 此系列文章内容大都是根据我的理解进行描述，可能大白话比较多。\r\n4. 下面直接进入正题。\r\n\r\n## 我所理解的开播\r\n在我的理解中，开播的整个过程在技术实现上可以理解为2条（音频 & 视频）流水线。  \r\n这2条流水线可以划分为相同的5个阶段，即：`采集、业务处理、渲染、编码、推流`，其中 `业务处理` 阶段即是我们实现App开播业务逻辑的阶段，这个阶段的复杂度跟业务的复杂度相关。  \r\n下面对视频和音频的这5个阶段分别进行讲解。\r\n\r\n### 视频\r\n#### 基础知识概念\r\n视频流水线上面流动到各个阶段的“物品”是什么？  \r\n```\r\n并不是一段视频，而是一帧一帧的图像。至于图像也只是一个抽象概念，在各阶段可能会有各种不同的表现形式，如：\r\n* 图片：UIImage，CIImage，CGImage 等。\r\n* 像素数据：CVBuffer/CVImageBuffer/CVPixelBuffer，查看系统源码可以发现这3种其实是同一种类型，只是通过`typedef`重命名了而已，所以遇到了不要慌。\r\n* 纹理：GLTexture(OpenGLES)，MTLTexture(Metal)。\r\n\r\n以上3种图像表现形式之间都可以相互转化，具体的转化方法可以[百度](https://www.baidu.com)。\r\n```\r\nOpenGLES / Metal 是什么？\r\n```\r\nOpenGLES 和 Metal都是用来驱动GPU做图像处理的框架。\r\nOpenGLES是Apple对OpenGL进行封装，使其能够在iOS系统使用。\r\nMetal是Apple针对现代化GPU设备设计的新版图像处理框架，并且采用面向对象的思想进行封装。建议使用Metal。\r\n当然，这两者在使用上非常相似，你只要会其中一个，那么另一个对你来说也就不难了。\r\n但你至少得会一个😂\r\n如果都不会，我建议直接学Metal，具体怎么学？[传送门](https://github.com/bytedance/AlphaPlayer) 研究研究，研究明白就学会了。\r\n```\r\n\r\n#### 采集\r\n**此阶段要做的就是每隔一段时间输出一个图像(一般是CVPixelBuffer)交给下一阶段处理。**  \r\n一般来说，常用的视频采集类型有以下几种：\r\n* 摄像头：开启摄像头采集视频帧，可以使用系统库AVFoundation的AVCaptureSession实现此功能。\r\n* 静态图片：由App设置一张图片(UIImage等)，在此采集类中将UIImage转化成CVPixelBuffer并以自定义的频率输出。\r\n* 视频：由App设置一个视频文件(mp4等)，可以使用系统库AVFoundation解码并读取视频的每一帧CVPixelBuffer输出即可。\r\n\r\n#### 业务处理\r\n**此阶段和其他阶段不同，它不是像采集这样具体的功能，而是多个`子阶段`的组合，而这些`子阶段`则是根据具体的App业务实现的。**  \r\n以我们这个直播软件的业务来说，`子阶段`主要包括：\r\n* 美颜：接收当前主播的图像纹理，输出添加美颜效果后的图像纹理。\r\n* PK合流：接收当前主播的图像纹理 和 对方主播的图像纹理，通过OpenGLES/Metal将两个纹理合并成一个纹理并输出。\r\n* 趣味连麦：接收当前主播的图像纹理 和 指定趣味资源图片的图像纹理，通过OpenGLES/Metal将两个纹理合并成一个纹理并输出。\r\n\r\n当主播处于非PK态的业务场景时，这一阶段就只需要 美颜 处理即可；  \r\n当主播处于PK态的业务场景时，这一阶段就需要 美颜+PK合流 组合起来；  \r\n当主播处于趣味连麦PK态的业务场景时，这一阶段就需要 美颜+趣味连麦+PK合流 组合到一起。\r\n\r\n*******\r\n*注解：*\r\n1. 美颜阶段细分的话又可以分为其他几个子阶段，比如人脸识别、磨皮、妆容、挂件等几个阶段，但因为我们这个直播软件美颜是接入的第三方SDK，这里就不再具体分析美颜的子阶段了。后面另起文章专门讲解美颜的实现吧。\r\n2. PK合流和趣味连麦的实现基本一致，不同的只是片选着色器的代码中定义的纹理合并规则不同。（PK合流是将画面分别绘制在输出纹理的左右两边，趣味连麦合流是将画面绘制在上下两层）\r\n3. PK合流中 对方主播的图像纹理，我们是通过接入的第三方视频通话SDK中的回调 获取到的。\r\n\r\n#### 渲染\r\n**此阶段要做的就是接收一个图像纹理，通过OpenGLES/Metal将纹理绘制到CAEAGLLayer/MTKView上。**  \r\n很简单，就几十行代码，找个demo抄一下或者自己写都行。\r\n\r\n#### 编码\r\n**编码说直白点就是将视频帧压缩，至于H.264和H.265等等就是一种压缩算法。**  \r\n\r\n1. 为什么一定要编码？\r\n```\r\n稍微计算一下\r\n假设采集阶段采集的视频帧大小是`720 * 1280`，CVPixelBuffer的像素格式是BGRA，帧率是30。\r\n则每秒钟需要发送的数据量至少是`720 * 1280 * 4 * 30`字节，约等于105M，用户的手机网速必须达到105M/s才能正常直播，显然这是非常不合理的。\r\n```\r\n2. 如何实现视频编码？\r\n```\r\n可以使用iOS系统库VideoToolBox编码，设置好帧间隔，码率，视频大小，压缩算法等参数，然后传视频帧进去就好了。\r\n(机械，嘎嘎，机械，我只是一个没有感情的API调用机器)\r\n```\r\n这里只介绍了编码是什么，以及使用什么工具去实现它，至于具体的压缩原理以后再另起一篇文章细说吧，如果读者好奇，可以自行去查找相关资料，网上一大堆。\r\n\r\n#### 推流\r\n**这个阶段就是流水线的终点了。在主播开播的时候就要和服务端建立长链接通道，当收到编码压缩后的视频帧时，将视频帧的二进制数据通过长连接通道发送给服务端。**  \r\n\r\n```\r\n长连接有多种协议类型，我们目前采用的是RTMP协议推流，当然还有其他种类，具体使用什么协议由你们和自己的服务端商定。\r\n如何实现？\r\n一般这种通用的长连接协议，都是有人封装好了代码库的。要不，，，从github上找找？\r\n```\r\n\r\n### 音频\r\n音频流水线和视频流水线在阶段上差不多，没有视频处理起来那么麻烦，但是需要了解一些音频数据结构相关的[知识](https://mp.weixin.qq.com/s/jvAXUky0k1ZQhZcsRNNliw)。\r\n\r\n#### 采集\r\n**此阶段通过麦克风录制声音并将声音存储为二进制数据输出交给下一阶段处理。**  \r\n如何实现？\r\n```\r\n使用系统库AVFoundation 或 AudioUnit。\r\n```\r\n\r\n#### 业务处理\r\n**此阶段可以根据不同的业务对音频数据做一些处理**  \r\n1. 音效：萝莉音、大叔音、机械音等。可以通过一些算法对二进制数据修改，进而就可以达到改变音色的效果。（也有一些第三方的代码库）\r\n\r\n2. 混音：将多路音频数据混合成一路音频数据并输出，PK业务中会使用。\r\n```\r\n这里有两种混音方案： \r\n* 系统库：系统提供了音频混合的API，学习怎么调用即可。\r\n* 算法：[音频混合算法](https://blog.csdn.net/unique_no1/article/details/123520817)\r\n```\r\n\r\n#### 渲染\r\n**音频的渲染实际上就是音频的播放**  \r\n实现方案：还是调用系统API，没什么可说的。\r\n\r\n#### 编码\r\n**和视频一样，编码实质上就是用了压缩数据量的，虽然音频数据量没视频那么大，但是能少一点是一点**\r\n实现方案：还是调用系统API，没什么可说的。\r\n\r\n#### 推流\r\n**和视频的推流一样，将编码后的二进制数据通过长连接发送给服务端**\r\n\r\n* 音视频推流的时候最好做一下时间戳对齐，以防止画面和声音对不上的情况出现。\r\n* 网络环境不好的时候。可以降低编码的码率，使画面变模糊，网络环境好时再恢复；也可以选择性的丢弃掉一些帧。  \r\n\r\n## 总结\r\n本篇文章简要的介绍了开播端技术实现上的阶段和概念，并针对每个阶段提供了一些实现的方案。  \r\n\r\n整理一下，我们可以发现，开播最难的地方其实是`业务处理`阶段。因为其他的阶段，功能实现完后面基本上不会有什么变更了，而且这些阶段的实现方案大部分都是基于系统库api就可以实现，不用去找第三方的代码库。  \r\n说`业务处理`阶段难，但其实它也不是很难，根据不同的业务场景去拼接`子阶段`就好了。\r\n\r\n\r\n\r\n### 最后\r\n码字不易，本文地址：`https://juejin.cn/post/7180739989821456443`\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7186840087257153595",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958437e4164143fdbbd7bc2e55042ce0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Git操作不规范，战友提刀来相见！",
        "preview": "年终奖都没了，还要扣我绩效，门都没有，哈哈。 这波骚Git操作我也是第一次用，担心闪了腰，所以不仅做了备份，也做了笔记，分享给大家。 文末留言抽奖，聊聊你的年终奖。",
        "author": "王中阳Go",
        "view_count": 3808,
        "collect_count": 34,
        "comment_count": 14,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8e4ec5490a74736bfdd6fb0ed66b7499~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: Chinese-red\r\nhighlight: a11y-dark\r\n---\r\n\r\n> 年终奖都没了，还要扣我绩效，门都没有，哈哈。\r\n\r\n这波骚Git操作我也是第一次用，担心闪了腰，所以不仅做了备份，也做了笔记，分享给大家。\r\n文末留言抽奖，聊聊你的年终奖。\r\n\r\n# 问题描述\r\n\r\n小A和我在同时开发一个功能模块，他在优化之前的代码逻辑，我在开发新功能。\r\n\r\n小A在我之前把代码提交到了测试分支，我想提交我的新功能代码到测试分支时发现**巨多冲突**，脑袋瞬间就炸了，Boom一声惊雷响啊。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bc3fa5cfe7944e89b28f4460619a214~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**PS：因为小A的需求不急，但是改动巨大；我的需求很急，马上要提测，否则就延期扣绩效了，说真的，我着急了，哈哈哈。**\r\n\r\n# 分析一下\r\n\r\n1. 首先解决冲突浪费时间，我的新功能代码每次提测到测试分支都需要解决冲突。\r\n\r\n2. 我在测试分支解决冲突，只能按照小A优化后的代码逻辑的去解决，和我自己的分支逻辑并不一致。\r\n\r\n3. 交付给测试同学的测试分支代码，和我自己分支的代码不一致，这种测试是没有意义的。\r\n\r\n# 反思出问题的原因\r\n\r\n1. 工厂模式使用的不合理\r\n\r\n2. 任务分配的不合理\r\n\r\n## 代码层面\r\n\r\n*TIPS:以下代码示例语言为Go*\r\n\r\n因为是工厂设计模式，我负责的实现类A和他的实现类B虽然没有直接关系。但是因为他修改了工厂类中的方法定义。\r\n\r\n比如之前工厂类中的接口是这么定义的\r\n\r\n```go\r\npackage factory\r\n\r\ntype xxx interface {\r\n   GetXxxx(ctx context.Context, req aaa.aa) (res bbb.bb, err error)  \r\n}\r\n```\r\n\r\n但是小A优化(修改)了工厂类中的接口定义：\r\n\r\n```go\r\npackage factory\r\n\r\ntype xxx interface {\r\n   GetXxxx(ctx context.Context, req ccc.cc) (res ddd.dd, err error)  \r\n}\r\n```\r\n\r\n这样就导致了一个问题：\r\n\r\n我想合并我的代码到测试分支也必须将我的实现类像小A一样，修改传参类型和返回类型。\r\n\r\n但是我们都在不同的分支上开发，我是没有他定义的类型`ccc.cc`,`ddd.dd`的。\r\n\r\n我又不能直接把他定义的`ccc.cc`,`ddd.dd`要过来，在我自己的分支上开发，一是因为需求不一致，小A的上线周期会比我长；二是这种操作本身就不规范。\r\n\r\n# 解决问题\r\n\r\n## 1.代码层面：\r\n\r\n我们想到的方案是合理使用interface\r\n\r\n工厂类中方法的入参和出参设置为`interface{}`类型\r\n\r\n```go\r\npackage factory\r\n\r\ntype xxx interface {\r\n   GetXxxx(ctx context.Context, req interface{}) (res interface{}, err error)  \r\n}\r\n```\r\n\r\n这样就比较容易进行扩展了。\r\n\r\n## 2.Git层面：\r\n\r\n方法1的入参和出参设置为`interface{}`类型的方案，并没有从根本上解决我们的问题。\r\n\r\n原因是这样的：\r\n\r\n小A的需求是整体优化工厂类和各个实现类的入参、出参，优化内部逻辑，抽取方法。\r\n\r\n小A的迭代优化修改变动很大，导致和我实现的新需求有比较大的冲突。\r\n\r\n但是他的Git分支又在我之前提交到了测试环境，导致我无法正常提交我的代码。\r\n\r\n如果我要提交就要解决各种冲突，解决冲突就要按照小A的优化逻辑去改，提测分支和我自己分支的不一致，难顶啊。\r\n\r\n考虑到小A的修改暂时不需要提测，上线周期也比较长。\r\n\r\n## 最终方案：\r\n\r\n最终的解决方案是这样的：\r\n\r\n1. 从远程的测试分支拉取了一个备份分支，删除小A提交的远程测试分支\r\n2. 把我本地需要测试的分支提交到测试分支，交付测试（因为我的需求很急，而小A的需求并不急）\r\n\r\n# 相关命令\r\n\r\n这波骚操作我也是第一次用，担心闪了腰，所以不仅做了备份，也做了笔记，分享给大家：\r\n\r\n## Git 重命名远程分支\r\n\r\n1.先重命名本地分支\r\n```shell\r\ngit branch -m 旧分支名称  新分支名称\r\n```\r\n\r\n2.删除远程分支\r\n```shell\r\ngit push --delete origin 旧分支名称\r\n```\r\n\r\n3.上传新修改名称的本地分支\r\n```shell\r\ngit push origin 新分支名称\r\n```\r\n\r\n4.修改后的本地分支关联远程分支\r\n```shell\r\ngit branch --set-upstream-to origin/新分支名称\r\n```\r\n\r\n# 推荐阅读\r\n\r\n[【Git必知必会】多人协同开发，紧急修复线上bug的操作指南。](https://mp.weixin.qq.com/s?__biz=MzIyNjM0MzQyNg==&mid=2247484571&idx=1&sn=171f65de5635a8c5a10b375225e39fbb&chksm=e870abf6df0722e088d39b683389f244da0718c37c54ab1f48e6429e90ad9caa33bd13952199&token=181779644&lang=zh_CN#rd)\r\n\r\n# 总结\r\n\r\n开发起来一时爽，维护起来火葬场。\r\n\r\nGit操作不规范，战友提刀来相见！\r\n\r\n**呼应一下开篇，这是临时解决办法的一个经验分享。肯定还有最优解，但是对我来说不重要，再不使用骚操作就该扣绩效了。**\r\n\r\n> 年终奖都没了，还要扣我绩效，门都没有，哈哈。\r\n\r\n你的年终奖还好吗，欢迎在评论区讨论。\r\n\r\n# 一起进步\r\n\r\n欢迎和我一起学习进步：[可以在掘金私信我](https://juejin.cn/notification/im?participantId=2189882892232029 \\\"https://juejin.cn/notification/im?participantId=2189882892232029\\\")\r\n\r\n也可以加我微信号：[wangzhongyang1993](https://juejin.cn/pin/7173841577008168967 \\\"https://juejin.cn/pin/7173841577008168967\\\") \r\n公众号：[程序员升职加薪之旅](https://juejin.cn/pin/7173841577008168967 \\\"https://juejin.cn/pin/7173841577008168967\\\") \r\nB站视频：[王中阳Go](https://link.juejin.cn/?target=https%3A%2F%2Fspace.bilibili.com%2F19626338 \\\"https://link.juejin.cn/?target=https%3A%2F%2Fspace.bilibili.com%2F19626338\\\")\r\n"
    },
    {
        "article_id": "7186448714779590711",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2374ed7d3b4477aa958a8eb2e94e55b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "分库分表，真的有必要吗？",
        "preview": "分库分表，真的有必要吗？ 哈喽，大家好，我是janker。 关于数据库分库分表的面试题已经是烂大街了，面经小册各路神仙的经验分享也是不绝于耳。当然现有的技术解决方案已经是很成熟了。",
        "author": "爪哇干货分享",
        "view_count": 3623,
        "collect_count": 27,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b32b1f34a5852358a9ba336b1d1684ea~300x300.image",
        "category": "后端",
        "content": "# 分库分表，真的有必要吗？\r\n\r\n哈喽，大家好，我是janker。\r\n\r\n关于数据库分库分表的面试题已经是烂大街了，面经小册各路神仙的经验分享也是不绝于耳。当然现有的技术解决方案已经是很成熟了。\r\n\r\n但是想要使用的得心应手，首先应该搞清楚三个问题？\r\n\r\n-   为什么使用分库分表？\r\n-   何时使用分库分表？\r\n-   如何分库分表？\r\n\r\n## 为什么使用分库分表？\r\n\r\n答案很简单：当数据库出现性能瓶颈。顾名思义就是数据库扛不住了。\r\n\r\n数据库出现瓶颈，对外表现有以下几个方面？\r\n\r\n0.  高并发场景下，大量请求阻塞，大量请求都需要操作数据库，导致连接数不够了，请求处于阻塞状态。\r\n0.  `SQL`操作变慢（慢`SQL`增多）如果数据库中存在一张上亿数据量的表，一条 SQL 没有命中索引会全表扫描，这个查询耗时会非常久。\r\n0.  随着业务流量变大存储出现问题，单库数据量越来越大，给存储造成巨大压力。\r\n\r\n从机器角度，性能瓶颈不外乎就是`CPU`、磁盘、内存、网络这些，要解决性能瓶颈最简单粗暴的方式就是提升机器性能，但是通过这种方式投入产出比往往不高，也不划算，所以重点还是要从软件层面去解决问题。\r\n\r\n数据库相关优化方案\r\n\r\n数据库优化方案很多，主要分为两大类：软件层面、硬件层面。\r\n\r\n软件层面包括：SQL 调优、表结构优化、读写分离、数据库集群、分库分表等；\r\n\r\n硬件层面主要是增加机器性能。\r\n\r\n分库分表其实不是数据库优化方案的最终解决办法，一般来说说能用优化SQL、表结构优化、读写分离等手段解决问题，就不要分库分表，因为分库分表会带来更多需要解决的问题，比如说分布式事务，查询难度增大等。\r\n\r\n## 何时使用分库分表？\r\n\r\n什么时候我们才会选择分库分表？前面已经说了，除了分库分表以外那些软件手段搞不定的时候，我们才会选择分库分表。\r\n\r\n我们心中可能会有这些疑问？\r\n\r\n0.  使用分库分表，我们的评判依据是什么？\r\n0.  一张表存储了多少数据的时候，才需要考虑分库分表？\r\n0.  数据增长速度很快，每天产生多少数据，才需要考虑做分库分表？\r\n\r\n阿里巴巴开发手册有推荐的思路：单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。\r\n\r\n注意：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\r\n\r\n## 如何分库分表？\r\n\r\n当前针对分库分表有很多解决方案。这里分两个方面来展开说说：分库 和 分表。\r\n\r\n### 分库\r\n\r\n很多项目前期为了快速迭代，多个应用公用一套数据库，随着业务量增加，系统访问压力增大，系统拆分就势在必行。\r\n\r\n为了保证业务平滑，系统架构重构也是分了几个阶段进行。\r\n\r\n#### 多应用单数据库\r\n\r\n第一个阶段将商城系统单体架构按照功能模块拆分为子服务，比如：Portal 服务、用户服务、订单服务、库存服务等。\r\n\r\n![image-20230107232802486](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/522efb1e86cb4cd2957c2f0152b1b0d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n多应用单数据库如上图，多个服务共享一个数据库，这样做的目的是底层数据库访问逻辑可以不用动，将影响降到最低。\r\n\r\n#### 多应用多数据库\r\n\r\n随着业务推广力度加大，数据库终于成为了瓶颈，这个时候多个服务共享一个数据库基本不可行了。我们需要将每个服务相关的表拆出来单独建立一个数据库，这其实就是“分库”了。\r\n\r\n单数据库的能够支撑的并发量是有限的，拆成多个库可以使服务间不用竞争，提升服务的性能。\r\n\r\n![image-20230107233441875](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61c36810ec5d4196a13acbb79406590b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n从一个大的数据中分出多个小的数据库，每个服务都对应一个数据库，这就是系统发展到一定阶段必要要做的“分库”操作。\r\n\r\n### 分表\r\n\r\n说完了分库，那什么时候才会分表呢？\r\n\r\n如果系统处于高速发展阶段，拿商城系统来说，一天下单量可能几十万，那数据库中的订单表增长就特别快，增长到一定阶段数据库查询效率就会出现明显下降。\r\n\r\n因此当表数据增长过快，根据阿里巴巴开发规范中超过500w的数据就要考虑分表了，当然这只是一个经验值，具体要不要分表还要看业务考虑未来三年的一个业务增量。\r\n\r\n如何分表？\r\n\r\n分表有几个维度，一是水平切分和垂直切分，二是单库内分表和多库内分表。\r\n\r\n#### 水平拆分和垂直拆分\r\n\r\n拿商品表来说，表中分为几类属性：一类是基础属性，例如：商品名称、通用名，商品编码等信息。二类是规格属性：尺寸、型号等信息。三类是拓展属性：描述商品特征的一些属性。我们可以将其拆分为基础信息表、拓展属性表、属性信息表等。这几张表结构不同并且相互独立。但是从这个角度没有解决因为数据量过大而带来的性能问题，因此我们还需要继续做水平拆分。\r\n\r\n![image-20230108161956743](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/992b5067c2394c0cb023514e447cd20c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n水平拆分表的方法很多种，比如说1w条数据，我们拆分为两个表，id 为基数的放在`user1`，id为偶数的放在`user2`中，这样的拆分方式就是水平拆分。\r\n\r\n其他水平拆分的方式也很多，除了上面按照 `id` 来拆分，还可以按照时间维度拆分，比如订单表，可以按照每日、每月等进行拆分。\r\n\r\n-   每日表：只存储当天你的数据。\r\n-   每月表：可以起一个定时任务将前一天的数据全部迁移到当月表。\r\n-   历史表：同样可以用定时任务把时间超过 30 天的数据迁移到 history表。\r\n\r\n总结一下水平拆分和垂直拆分的特点：\r\n\r\n-   垂直切分：基于表或者字段划分，表结构不同。\r\n-   水平拆分：基于数据划分，表结构相同，数据不同。根据表中字段的某一列特性，分而治之。\r\n\r\n水平拆分也分两种拆分方式。单库内拆分和多库内拆分\r\n\r\n#### 单库内拆分和多库内拆分\r\n\r\n拿针对用户表的拆分来举例，之前的单个用户表按照某种规则拆分为多个子表，多个子表存在于同一数据库中。比如下面用户表拆分为用户1表、用户2表。\r\n\r\n![image-20230108203705147](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db27b243240640148531a39b07f396af~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n单库内拆分是在一个数据库中，将一张表拆分为多个子表，一定程度上可以解决单表查询的性能问题，但是也会遇到另外一个问题：但数据库的数据瓶颈。\r\n\r\n所以在行业内更多的将子表拆分到多个数据库中，如下图，用户表拆分为4个子表，4个子表分两批存在两个不同的数据库中，根据一定的规则进行路由。\r\n\r\n![image-20230108204316330](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c13b1961f0b742faac0b4d77e00c3dde~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n多库拆分用一句话概括：主要是为了减少单张表数据量大小，解决单表数据量过大带来的性能问题。\r\n\r\n但是分库分表也带来许多问题。\r\n\r\n### 分库分表带来的问题\r\n\r\n既然分库分表方案那么好，那我们是不是在项目初期就应该采用这种方案呢？莫慌，虽然分库分表解决了很多性能问题，但是同时也给系统带来了很多复杂性。下面我展开说说\r\n\r\n#### 1. 跨库关联查询\r\n\r\n之前单体项目，我们想查询一些数据，无脑`join`就好了，只要数据模型设计没啥问题，关联查询起来其实还是很简单的。现在不一样了，分库分表后的数据可能不在一个数据库，那我们如何关联查询呢？\r\n\r\n下面推荐几种方式去解决这个问题：\r\n\r\n1.  字段冗余：把需要关联的字段放到主表中，避免`join`操作，但是关联字段更新，也会引发冗余字段的更新；\r\n1.  数据抽象：通过`ETL` 等将数据汇总聚合，生成新的表；\r\n1.  全局表：一般是一些基础表可以在每个数据库都放一份；\r\n1.  应用层组装：将基础数据查出来，通过应用程序计算组装；\r\n1.  同特征的数据在一张表：举个例子：同一个用户的数据在同一个库中，比如说我们对订单按照用户`id`进行分表，订单主表、订单拓展信息表、跟订单有关联查询的表都按照用户id 进行分表，那么同一个用户的订单数据肯定在同一个数据库中，订单维度的关联查询就不存在跨库的问题了。\r\n\r\n#### 2. 分布式事务\r\n\r\n单数据库我们可以用本地事务搞定，使用多数据库就只能通过分布式事务解决了。\r\n\r\n常用的解决方案有：基于可靠消息（`MQ`）的最终一致性方案、二段式提交（`XA`）、柔性事务。\r\n\r\n当然分布式事务相关开源项目推荐两个：[Seata](https://github.com/seata/seata) 、[TX-LCN](https://github.com/codingapi/tx-lcn)\r\n\r\n比较推荐 `Seata`，阿里出品、大厂加持、如果需要企业级版本支持也是有的。\r\n\r\n#### 3. 排序、分表、函数计算问题\r\n\r\n使用`SQL` 时，`order by` 、`limit` 等关键字需要特殊处理，一般都是采用数据分片的思路：现在每个分片路由上执行函数、然后将每个分片路由的结果汇总再计算，然后得出最终结果。\r\n\r\n开源的解决方案当然也有不少，比较推荐[shardingsphere](https://shardingsphere.apache.org/document/5.1.0/cn/reference/sharding/)，无论是基于client 或者 基于数据库proxy的都有支持。\r\n\r\n#### 4. 分布式ID\r\n\r\n既然分库分表了，主键id已经不能唯一确定我们的业务数据了，随之而来的就是分布式id，顾名思义就是在多个数据库多张表中唯一确定的ID。\r\n\r\n常见的分布式Id 解决方案有：\r\n\r\n1.  `UUID`\r\n1.  基于全局数据库自增的ID表\r\n1.  基于`Redis`缓存生成全局ID\r\n1.  雪花算法（`Snowflake`）\r\n1.  百度`uid-generator`（雪花算法的变种）\r\n1.  美团`Leaf`（雪花算法的变种）\r\n1.  滴滴`Tinyid`\r\n\r\n这些解决方案后面有专门的文章去介绍，这里不过多展开。\r\n\r\n#### 5. 多数据源\r\n\r\n分库分表之后可能面临从多个数据库中获取数据，一般的解决方案有，基于 client 适配 和 基于 proxy 适配。\r\n\r\n比较成熟并且常用的中间件有：\r\n\r\n-   shardingsphere（apache顶级项目相当成熟，文档完善）\r\n-   MyCat （社区不太活跃、不推荐）\r\n\r\n## 总结\r\n\r\n如果遇到数据库问题，建议不要着急分库分表。原则是：能不分库分表就不要做。先看下能否通过常规优化手段解决问题。\r\n\r\n如上所述，引入分库分表虽然可以解决数据库瓶颈问题，但是也给系统带来巨大的复杂性，不是非必须不要使用。设计系统我们一向要本着高可拓展去设计，但是不要过度设计和超前设计。适合当前系统的设计才是最好的。"
    },
    {
        "article_id": "7165528398679244808",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79bb27cecb024488b96c966fd80cea53~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何替换项目中的if-else和switch",
        "preview": "1、if-else和switch优化为对象； 2、||和??的用法和区别； 3、?.用于对象和函数；",
        "author": "JoyZ",
        "view_count": 8208,
        "collect_count": 184,
        "comment_count": 15,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/2724e3e38eb914b71c4b7fff5f3d896c~300x300.image",
        "category": "前端",
        "content": "在项目中，往往会看到很多的`if-else`或者`switch`，项目会变得很臃肿，而且不易阅读，那么今天我们就来讲讲优化方案\r\n\r\n例如，假设我们有一个函数，它接受一个数字参数并返回其实际含义。使用 if/else 语句，它看起来像这样：\r\n\r\n```\r\nfunction getTranslation(type) {\r\n  if (type === 4) {\r\n    return \\\"forbidden_area\\\";\r\n  } else if (type === 6) {\r\n    return \\\"elevator_area\\\";\r\n  } else if (type === 7) {\r\n    return \\\"dangerous_area\\\";\r\n  } else if (type === 10) {\r\n    return \\\"restricted_area\\\";\r\n  }\r\n​\r\n  return \\\"other_area\\\";\r\n}\r\n```\r\n\r\n这不是很好。它可读性差。\r\n\r\n我们可以通过使用 switch 语句优化，如下所示：\r\n\r\n```\r\nfunction getTranslation(type) {\r\n  switch (type) {\r\n    case 4:\r\n      return \\\"forbidden_area\\\";\r\n    case 6:\r\n      return \\\"elevator_area\\\";\r\n    case 7:\r\n      return \\\"dangerous_area\\\";\r\n    case 10:\r\n      return \\\"restricted_area\\\";\r\n    default:\r\n      return \\\"other_area\\\";\r\n  }\r\n}\r\n```\r\n\r\n但这仍然没有什么可读性。switch 语句也容易出错。\r\n\r\n在这种情况下，我们只是返回一个值，但是当你具有更复杂的功能时，很容易错过 break 语句并引入错误。\r\n\r\n#### **替代方案**\r\n\r\n你可以使用对象以更简洁的方式实现与上述相同的功能。让我们看一个例子：\r\n\r\n```\r\nfunction getTranslation(type) {\r\n  const types = {\r\n    4: 'forbidden_area',\r\n    6: 'elevator_area',\r\n    7: 'dangerous_area',\r\n    10: 'restricted_area'\r\n  }\r\n  return types[type] ?? 'other_area'\r\n}\r\n```\r\n\r\n我们有一个对象，其中键是条件，值是响应。然后我们可以使用方括号符号从传入的参数中选择对象的正确值。\r\n\r\n函数中`return types[type] ?? 'other_area'`使用无效合并来分配默认响应。这意味着如果 `types[type]`为 null 或undefined（但不是 false 或 0 ），则返回默认字符串“other_area”。\r\n\r\n#### **|| vs ??**\r\n\r\n`||`和`??`都是指定默认值\r\n\r\n读取对象属性的时候，如果某个属性的值是`null`或`undefined`，有时候需要为它们指定默认值。常见做法是通过`||`运算符指定默认值\r\n\r\n```\r\nconst headerText = response.settings.headerText || 'Hello, world!';\r\nconst animationDuration = response.settings.animationDuration || 300;\r\nconst showSplashScreen = response.settings.showSplashScreen || true;\r\n```\r\n\r\n上面的三行代码都通过`||`运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为`null`或`undefined`，默认值就会生效，但是属性的值如果为空字符串或`false`或`0`，默认值也会生效。\r\n\r\n为了避免这种情况，[ES2020](https://github.com/tc39/proposal-nullish-coalescing) 引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。而`||`是运算符左侧的值为`null`、`undefined`、`0`、`''`或`NaN`\r\n时，都会返回右侧的值！\r\n\r\n#### **更复杂的逻辑**\r\n\r\n有时你可能需要在你的条件中执行一些更复杂的逻辑。为此，你可以将函数作为值传递给对象键并执行响应：\r\n\r\n```\r\nfunction calculate(action, num1, num2) {\r\n  const actions = {\r\n    add: (a, b) => a + b,\r\n    subtract: (a, b) => a - b,\r\n    multiply: (a, b) => a * b,\r\n    divide: (a, b) => a / b,\r\n  };\r\n​\r\n  return actions[action]?.(num1, num2) ?? \\\"Calculation is not recognised\\\";\r\n}\r\n```\r\n\r\n`?.`有不懂的话，可以先看下面，我们正在选择我们想要做的计算并执行响应，传递两个数字。你可以使用可选链接（最后一行代码中的 ?.）来仅执行已定义的响应。否则，将使用默认的返回字符串。\r\n\r\n如果函数里的逻辑足够复杂也可以把函数提取出来\r\n\r\n```\r\nfunction add(num1, num2) {\r\n  return num1 + num2\r\n}\r\nfunction subtract(num1, num2) {\r\n  return num1 - num2\r\n}\r\nfunction multiply(num1, num2) {\r\n  return num1 * num2\r\n}\r\nfunction divide(num1, num2) {\r\n  return num1 / num2\r\n}\r\nfunction calculate(action, num1, num2) {\r\n  const actions = {\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide\r\n  }\r\n​\r\n  return actions[action]?.(num1, num2) ?? 'Calculation is not recognised'\r\n}\r\n```\r\n\r\n#### ?.的说明\r\n\r\n编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取`message.body.user.firstName`这个属性，安全的写法是写成下面这样。\r\n\r\n```\r\n// 错误的写法\r\nconst  firstName = message.body.user.firstName || 'default';\r\n​\r\n// 正确的写法\r\nconst firstName = (message\r\n  && message.body\r\n  && message.body.user\r\n  && message.body.user.firstName) || 'default';\r\n```\r\n\r\n上面例子中，`firstName`属性在对象的第四层，所以需要判断四次，每一层是否有值。\r\n\r\n这样的层层判断非常麻烦，因此 [ES2020](https://github.com/tc39/proposal-optional-chaining) 引入了“链判断运算符”（optional chaining operator）`?.`，简化上面的写法。\r\n\r\n```\r\nconst firstName = message?.body?.user?.firstName || 'default';\r\n```\r\n\r\n上面代码使用了`?.`运算符，直接在链式调用的时候判断，左侧的对象是否为`null`或`undefined`。如果是的，就不再往下运算，而是返回`undefined`。\r\n\r\n下面是判断对象方法是否存在，如果存在就立即执行的例子。\r\n\r\n```\r\niterator.return?.()\r\n```\r\n\r\n上面代码中，`iterator.return`如果有定义，就会调用该方法，否则`iterator.return`直接返回`undefined`，不再执行`?.`后面的部分。\r\n\r\n下面是`?.`运算符常见形式，以及不使用该运算符时的等价形式。\r\n\r\n```\r\na?.b\r\n// 等同于\r\na == null ? undefined : a.b\r\n​\r\na?.[x]\r\n// 等同于\r\na == null ? undefined : a[x]\r\n​\r\na?.b()\r\n// 等同于\r\na == null ? undefined : a.b()\r\n​\r\na?.()\r\n// 等同于\r\na == null ? undefined : a()\r\n```\r\n\r\n上面代码中，特别注意后两种形式，如果`a?.b()`和`a?.()`。如果`a?.b()`里面的`a.b`有值，但不是函数，不可调用，那么`a?.b()`是会报错的。`a?.()`也是如此，如果`a`不是`null`或`undefined`，但也不是函数，那么`a?.()`会报错。\r\n\r\n参考资料:\r\n[es6](https://es6.ruanyifeng.com/#docs/operator#Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6)，公众号: web前端开发"
    },
    {
        "article_id": "7155354834877546532",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9570e5b115684a44bc4abc82104515a6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "webpack热更新原理-隔壁屋阿珍都看懂了",
        "preview": "前端进阶的必看的模块热更新原理。了解hmr的运行机制，有助于对我们项目运行原理的理解，对项目优化有新的认知~",
        "author": "世杰是真狗",
        "view_count": 2518,
        "collect_count": 52,
        "comment_count": 6,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b6daa5245d28d1baa2bec8cbbceb8e77~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\n---\r\n\r\n## 前言\r\n\r\n>在旧开发的时代，前端项目在开发的过程中修改代码，很有可能是手动切到浏览器刷新页面来看到改动效果。操作不方便且页面之前的编辑记录也都丢失，体验可以说为0。想象一下一个表达你努力填满了所有输入项，结果因为调了一下样式就丢失了所有输入内容，你的心情如何？\r\n\r\n随后变出现live reload自动刷新，解决了手动切的尴尬操作但页面的状态问题仍未解决。\r\n\r\n随着前端工程化的推进，HMR（Hot Module Replace）热模块替换的技术的出现急不可耐，我们可以很简单的配置便能感受这优雅的开发体验。>\r\n\r\n下面就让我们一起分析HMR是如何工作的吧！\r\n\r\n## 什么是浏览器的热更新？\r\n\r\n什么是浏览器的热更新？有些同学可能认为是保存自动编译、或者是自动刷新浏览器就叫热更新；又或者代码能够热替换就是热更新。\r\n\r\n这些说的都对，但不全面。浏览器热更新技术严格的讲，指的是我们开发时能够在浏览器页面中实时看到我们代码的变化产生效果的流程。热更新技术包含了监听本地文件、增量编译构建、代码热替换、socket通信等技术点。\r\n\r\n## HMR最简单的理解\r\n\r\n相信你已经或多或少看到过一些监听开发代码改动，浏览器与静态服务器socket通信的一些HMR相关点。\r\n\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d936539374a34f92be30850f78eef626~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这个图描绘了大致的工作原理。能够帮助你站在更高的角度去俯视这个过程中的流转、以及关键角色。\r\n接下来就是对其中的流程一步一步进行剖析。\r\n\r\n## HMR流程原理\r\n\r\n### 先了解webpack热更新的重要插件\r\n\r\n- webpack-dev-server\r\n- webpack-dev-middleware\r\n- webpack-hot-middleware\r\n\r\n这里可能有很多同学会混淆这几个插件的作用。\r\n\r\n首先来看`webpack-dev-middleware`插件,他最主要是能够将webpack编译产物提交给服务器，并且他将产物放置在内存中【这也是为啥我们在开发过程中在文件夹中找不到我们的打包代码】;\r\n\r\n而`webpack-hot-middleware`插件则提供热更新的能力【通过使用webpack提供的热更新API实现，所以背后干活的还是webpack】；*这个插件在新版本中似乎已经不再需要了*\r\n\r\n 这两个插件一般都是配套使用的，以提供完整的热更新能力。\r\n \r\n而`webpack-dev-server`是【node-express[启动服务] + webpack-dev-middleware + webpack-hot-middleware】的集成封装，有了他，你就可以方便的启动一个具有热更新功能的本地服务器。不用你自己手写什么`let app = new express();app.listen(8080);`这样的启动服务代码了。\r\n\r\n再补充一些知识点：\r\n\r\n- webSocket：长连接双向通信【让服务器与浏览器连接起来，方便通信】\r\n- webpack的构建可以选择watch模式，他自身已经具备了监听文件变化，持续构建的能力。但还未有将自动刷新客户端的能力，并且对新构建的文件未有进行热替换的能力。\r\n- 而webpack-dev-server则是提供自动刷新客户端的能力，他启动一个静态资源托管服务器，客户端访问该服务器，并且通过socket与客户端长连接以便在新构建后通知到客户端进行更新\r\n- 而webpack内置插件HotModuleReplacement.plugin插件则是提供热替换的能力：在客户端拿到新代码后，将新代码与旧代码替换\r\n\r\n*tips: webpack热更新的过程中涉及到比较多的角色，一定要区分好各个角色在过程中发乎着不同的作用。*\r\n\r\n\r\n**让我们运行`npm run serve`，开始分析这个过程吧！**\r\n\r\npackage.json\r\n\r\n```js\r\n...\r\n  \\\"scripts\\\": {\r\n    \\\"build\\\": \\\"webpack\\\",\r\n    \\\"serve\\\": \\\"webpack-dev-server\\\"\r\n  },\r\n...\r\n```\r\n\r\n### 第一阶段：初始化环境\r\n\r\n\r\n兜兜转转便来到了`webpack-dev-server/lib/Server.js`\r\n\r\n`webpack-dev-server`做了非常关键的3个动作：\r\n- 启动静态服务器\r\n- 开通长连接\r\n- 为打包产物注入HMR代码【使得客户端具备热更新能力】\r\n\r\n启动静态服务器、开通长连接这两个动作很好理解，也可以对应上图去理解。\r\n那么【 为打包产物注入HMR代码【使得客户端具备热更新能力】是啥意思呢？\r\n\r\n想象一下，当你的代码在浏览器运行的时候，怎么跟服务器进行长连接呢？这部分代码你肯定是没有写过。这是由webpack-dev-server插件注入到我们产物代码中的。此外除了长连接代码，还有热更新的代码替换等代码都是要被注入的。\r\n\r\n**我们来看看插件是如何在我们的产物中注入代码的？**\r\n\r\n过程比想象的要简单，通过在我们的webpack入口entry中新增文件，在webpack进行构建的时候从entry开始顺藤摸瓜组织代码便一同打包进来。\r\n\r\n我们可以看到注入了两个文件：\r\n- webpack-dev-server/client 【socket管理】\r\n- webpack/hot/dev-server 【热更新能力】\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d607b761a1546f1931884decfbeb64a~tplv-k3u1fbpfcp-watermark.image?)\r\n假如你想写个代码弄崩你们项目，是不是可以考虑写个无限递归的代码用这种代码注入的方式去执行呢。这样一来排查就相对困难啦，到时候再化身救火秃神！想想都觉得厉害。\r\n\r\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a0fe483a5742e5aea021bf54de11c5~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"30%\\\" />\r\n\r\n紧接着构建过程以compiler.watch()的方式运行，这种模式下打包完不会结束掉打包进程，而是持续运行，监听文件变化后进行增量构建【前面有提到这是webpack的能力之一】。一般`npm run build`的方式就是执行compiler.run()打包一次就结束了。\r\n\r\ncompiler.watch()构建后的产物通过webpack-dev-middleware插件提交到服务器。\r\n\r\n而webpack提供的持续监控文件变化的能力是基于node的fs.watch()实现的。他的原理是通过轮询文件的修改时间比对去判断该文件是否发生变化。\r\n\r\n至此我们的项目处于一种运行的状态，能够对代码改动触发增量构建并更新到服务器。\r\n\r\n以上的过程可以理解为 环境初始化阶段。\r\n\r\n### 第二阶段：客户端热更新\r\n\r\n接着我们打开一个浏览器访问：localhost:XXX时，就能够访问到我们的页面。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f80edfdc85949149c3e6c70729a5ad5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们可以看到浏览器已经跟服务器进行了长连接。\r\n\r\n先来看看我们的项目代码：\r\n\r\n入口文件index.js  // 导入writeA.js并处理writeA.js的热更新逻辑\r\n\r\n```js\r\nimport './writeA'\r\nif(module.hot) {\r\n    module.hot.accept('./writeA.js', () => {\r\n        console.log('index.js 捕获到writeA.js的变化...');\r\n        let writeAEl = document.getElementById('ttt');\r\n        if(writeAEl) {\r\n            writeAEl.parentNode.removeChild(writeAEl)\r\n        }\r\n    })\r\n}\r\n```\r\nwriteA.js  // 给body插入元素\r\n\r\n```js\r\nlet myElement = document.createElement('div')\r\nmyElement.innerText = 'writeA.js 123456'\r\nmyElement.id = 'ttt'\r\ndocument.body.appendChild(myElement);\r\nconsole.log('writeA.js run...');\r\n```\r\n代码很简单，module.hot.accept的意思就是捕获writeA.js的改动，如果他改动了就触发逻辑。module.hot.accept的触发时机会在后面提到。\r\n\r\n然后修改writeA.js文件并保存，可以看到浏览器请求了两个文件：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bc9699fb1a748ec82d65037a58e03c4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在修改文件后，触发webpack增量构建【只构建了writeA.js模块，所以速度极快】，当构建结束后会提交到服务器，服务器通过socket通知给浏览器，浏览器收到通知后下载更新文件，下载后对文件进行热替换。大概就是这么一个过程。\r\n\r\n这里补充一个知识点：如何知道构建结束并调用socket通知浏览器的？\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b42f59bb2c4d18b1566619e4523c75~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n代码层面也很好理解，`webpack-dev-server`插件监听`hooks.done`【这里需要你对webpack的`tapable`机制有一定了解，类似于发布订阅模式，当编译完成就会触发钩子`hooks.done`,插件可以监听钩子做自己的逻辑】，触发则调用socket发送消息给客户端，此时会把本次构建生成的hash一起传给客户端。\r\n\r\n这里重点关注浏览器收到这个构建hash后的动作，也是热更新过程的重中之重。\r\n\r\n客户端socket收到hash消息后，先将hash值保存起来。再收到ok消息后调用`reloadApp()`\r\n\r\n伪代码：\r\n\r\n```js\r\n// 路径 webpackd-dev-server/client/reloadApp.js\r\nreloadApp() {\r\n  if(hot) {\r\n      hotEmitter.emit(\\\"webpackHotUpdate\\\", hash); // 走这里\r\n  }esle {\r\n      window.location.reload()\r\n  }\r\n}\r\n```\r\n\r\n发出一个通知事件`hotEmitter.emit(\\\"\\\"webpackHotUpdate)`,这时候`webpack/hot/dev-server.js`【这个文件是上面提到被注入到客户端的代码】监听到该事件：\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1722969ec846f79045e95fe4365f14~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n他最主要要是执行了`module.hot.check()`函数，那个这个函数又是哪里来的？\r\n这是`webpack/lib/hmr/HotModuleReplacement.runtime.js`在构建的过程中给module对象添加hot属性，对应上面webpack-dev-server插件的能力：为打包产物注入HMR代码。\r\n\r\n`module.hot.check`函数调用`hmrDownloadManifest`利用fetch下载我们常见到的XXX.hot-update.json更新清单\r\n\r\n```js\r\n// XXX.hot-update.json\r\n  {\r\n    \\\"c\\\":[\\\"index\\\"], // 更新chunk\r\n    \\\"r\\\":[],\r\n    \\\"m\\\":[]\r\n    // 有些是有\\\"h\\\":hash,版本不同略微不一样\r\n  }\r\n```\r\n然后回调`hmrDownloadUpdateHandlers`通过插入<sctipt>标签的方式下载并执行**XXX.hot-update.js文件\r\n    \r\n// XXX.hot-update.js\r\n    \r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/347113757d5e4bd2a401f167b7583c08~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nxxx.hot-update.js文件执行了一个函数`window.webpackHotUpdatewebpack_study_1`，该函数也是webpack注入代码执行的过程中给window添加的函数，他的作用大致就是将更新的chunk、modules信息保存下来先，以便后续处理这些信息。\r\n    \r\n` module.hot.check()函数代码: `\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c6065b08c7c4e1ea2f018c054ab1571~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n    \r\n在下载完更新XXX.hot-update.js完成后，最后就是应用上这些新代码：\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b53bf7eb1ab641ea943fb2f6c9f463ad~tplv-k3u1fbpfcp-watermark.image?)\r\n应用新代码的核心方法：\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f56bdad7764e4eae82a4dfd589b2dc88~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n这个函数大致就是替换并运行模块代码，执行热替换函数【`module.hot.accept`】!\r\n\r\n替换的过程涉及到webpack的关于module、chunk、chunkGraph、moduleGraph这样的知识，没有再去深入讲解module如何被替换。建议看之前写过的一篇文章全面的了解webpack的构建原理[# webpack原理解析【长文万字】](https://juejin.cn/post/7125696644435148831)。\r\n\r\n\r\n可以看到，修改后的writeA.js重新运行一次，然后index.js对writeA.js的`hot.accept()`被触发。  \r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320aaf2e27414bffab55fe5de7c5f3fe~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n至此整个热更新的过程结束！！！\r\n    \r\n下面我们再梳理一遍客户端从收到socket消息ok之后的调用流程：\r\n    \r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552a1d4d899d434aab759728ef8416bb~tplv-k3u1fbpfcp-watermark.image?)\r\n    \r\n这么看好像整个热更新过程也好像没那么容易理解不是吗？\r\n\r\n## 上帝视角看流程\r\n \r\n       \r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a659988dc6c43b1a9754befba6411cb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n写多少字都不如一个好图易理解、易记忆。\r\n\r\n    \r\n    \r\n    \r\n## 最后\r\n知道的越多，不知道的也越多。在阅读源码的过程中，也发现了很多坑点，例如看到了很多`$XXXX$`这样的命名，不理解为什么要这么做。也看到很多“console.log(url)”这样字符串包裹的代码\r\n    \r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7c51fd3844e4f8e8ac8892480ee3353~tplv-k3u1fbpfcp-watermark.image?)\r\n \r\n阅读难度巨增，不知道为啥会设计成这样，也没有思考会不会有更好的解决办法。一些函数名都是动态生成计算等等，都给我在阅读源码时增加了很多难度。还有就是webpack构建进程与静态服务器之间的交互过程目前理解也相对有限。在阅读文章的时候，一定要对各个角色有所区分，不要把那些功能混淆了。\r\n    \r\n## 另外：\r\n热更新的moduel.hot.accept()函数来实现视图更新、页面状态保存等热更新效果的逻辑实际开发中是非常复杂的，不像上图中那样简单。但所幸，webpack中的很多loader都帮我们实现了该函数的效果。如style-loader、vue-loader等等，有了这些，我们才能够更加专注于开发业务代码。此时，不由得深深佩服这些造轮子的大佬，自愧不如。\r\n    \r\n~ 如果本篇文章能够让你了解到HMR的运行机制的话，请麻烦东东你的小手点个赞再走！❤👍 ~\r\n\r\n\r\n"
    },
    {
        "article_id": "7158009281735262239",
        "snapshot": "",
        "title": "为什么说 bind 的实现非常考验对原型链的理解？",
        "preview": "bind 的实现其实非常考验对原型链的理解。bind 和 apply，call 是 JS 修改 this 指向的三把利器 🔱。但看似简单的内容，实则包含了 JS 的两大核心内容：原型链和构造函数。",
        "author": "圆圆01",
        "view_count": 11126,
        "collect_count": 305,
        "comment_count": 28,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/320f144367404cb3aabb8790dbc007cb~300x300.image",
        "category": "前端",
        "content": "# 前言\r\n**bind 的实现其实非常考验对原型链的理解。**\r\n\r\nbind 和 apply，call 是 JS 修改 this 指向的三把利器 🔱。\r\n\r\n对于 apply，call 来说，bind 的区别在于会返回一个修改了 this 指向的新函数，并不会立即执行。\r\n\r\n但看似简单的内容，实则包含了 JS 的两大核心内容：原型链和构造函数 (new) 。\r\n\r\n这篇文章分为两部分：\r\n- 一部分讲如何实现一个基础版本的 bind 方法，带大家做好热身运动；\r\n- 另一部分进入主题，详细讲解如何通过原型链来实现一个让人眼前一亮的 bind 方法 ✨。\r\n\r\n# 一、实现 bind 方法\r\n\r\n## 1. 改变 this 指向\r\n\r\n简单说，bind 方法会返回一个改变了 this 指向的新方法。\r\n\r\n举个 🌰：\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\nfunction person() {\r\n    console.log(this.name);\r\n}\r\nperson(); // Jack\r\nvar bindYve = person.bind(Yve);\r\nbindYve(); // Yvette\r\n```\r\n根据这个特点，我们来实现第一版的 bind 方法：\r\n\r\n```js\r\n\r\n// v1.0：返回一个改变了 this 指向的方法\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    // 首先要获取调用bind的函数，也就是绑定函数，用this可以获取\r\n    var self = this; // 用self绑定this，因为下面函数中的this指向已经改变（存放当前函数的this）\r\n    return function () {\r\n        // 用apply来改变this指向（apply的实现并不复杂，文末放有链接可以查看）\r\n        self.apply(context);\r\n    }\r\n}\r\n```\r\n\r\n## 2. 函数柯里化\r\nbind 方法的另一个特点是支持柯里化：函数的参数可以分多次传入，即可以在 bind 中传入一部分参数，在执行返回的函数的时候，再传入另一部分参数。\r\n\r\n举个 🌰：\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\nfunction person(age, job, gender) {\r\n    console.log(this.name, age, job, gender);\r\n}\r\nperson(22, 'engineer', 'female');\r\n// Jack 22 engineer female\r\nvar bindYve = person.bind(Yve, 22, 'engineer');\r\nbindYve('female');\r\n// Yvette 22 engineer female\r\n```\r\n\r\n根据这个特点，我们来实现第二版的 bind 方法：\r\n```js\r\n\r\n// v2.0：支持函数柯里化，分段接收参数\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    // 首先要获取调用bind的函数，也就是绑定函数，用this可以获取\r\n    var self = this; // 用self绑定this，因为下面函数中的this指向已经改变（存放当前函数的this）\r\n    var args = [...arguments].slice(1); // 用slice方法取第二个到最后一个参数（获取除了this指向对象以外的参数）\r\n    return function () {\r\n        // 这里的arguments是指bind返回的函数传入的参数\r\n        var restArgs = [...arguments];\r\n        // 用apply来改变this指向，拼接bind方法传入的参数和bind方法返回的函数传入的参数，统一在最后通过apply执行。\r\n        self.apply(context, args.concat(restArgs));\r\n    }\r\n}\r\n```\r\n## 3. 返回值\r\n\r\n别忘啦，函数是可以有返回值的，举个 🌰：\r\n\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\nfunction person(age, job, gender) {\r\n    return {\r\n        name: this.name,\r\n        age,\r\n        job,\r\n        gender\r\n    }\r\n}\r\nvar jack = person(22, 'engineer', 'female');\r\nconsole.log(jack);\r\n// {name: 'Jack', age: 22, job: 'engineer', gender: 'female'}\r\nvar bindYve = person.bind(Yve, 22, 'engineer');\r\nvar Yvette = bindYve('female');\r\nconsole.log(Yvette);\r\n// {name: 'Yvette', age: 22, job: 'engineer', gender: 'female'}\r\n\r\nvar bindYve2 = person.bind2(Yve, 22, 'engineer');\r\nvar Yvette2 = bindYve2('female');\r\nconsole.log(Yvette2);\r\n// undefined\r\n```\r\n\r\n而我们实现的 bind 方法在返回的函数中并没有把结果返回，所以得到的结果是 undefined，而不是返回值。\r\n\r\n这个比较简单，补充一下：\r\n\r\n```js\r\n\r\n// v2.1：拿到返回值\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    var self = this;\r\n    var args = [...arguments].slice(1);\r\n    return function () {\r\n        var restArgs = [...arguments];\r\n        // 返回执行结果\r\n        return self.apply(context, args.concat(restArgs));\r\n    }\r\n}\r\n```\r\n\r\n做完前面这些热身运动，下面我们进入今天的主题 🎃\r\n\r\n# 二、使用原型链完整构建 bind 方法\r\n\r\n## 1. 作为构造函数调用\r\n\r\nbind 方法还有一个重要的的特点，绑定函数也可以使用 new 运算符构造，也就是说还可以将 bind 返回的函数作为构造函数。提供的 this 值会被忽略，但传入的参数仍然生效。\r\n\r\n举个 🌰：\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\nfunction person(age, job, gender) {\r\n    console.log(this.name, age, job, gender);\r\n}\r\nvar bindYve = person.bind(Yve, 22, 'engineer');\r\nvar obj = new bindYve('female');\r\n// undefined 22 'engineer' 'female'\r\n```\r\n\r\n我们在全局和 Yve 中都声明了 name 值，但最后 `this.name` 的结果依然是 undefind，说明 bind 方法绑定的 this 失效了，原因在于返回函数 bindYve 被作为构造函数调用了，了解 new 关键字原理的童鞋就会知道，此时的 this 已经指向了实例 obj。\r\n\r\n> 这一块和 new 的模拟实现结合在一起理解，更容易掌握两者的原理，做到融会贯通。关于 new 的原理可以参考：[JavaScript 深入系列之 new 操作符的模拟实现](https://github.com/yuanyuanbyte/Blog/issues/110)。\r\n\r\n我们知道了作为构造函数调用时，this 指向实例，原先通过 bind 绑定的 this 失效。很显然前面实现的 bind 始终会通过 `self.apply(context)` 将 this 指向 context，不符合这一特点。\r\n\r\n所以，在返回函数作为构造函数调用时，就不用修改 this 指向了，直接 `self.apply(this)`即可。*因为作为构造函数调用时，this 就是指向实例，所以这里不需要做其他操作。*\r\n\r\n结论有了，那如何知道返回函数是被作为构造函数调用的呢？\r\n\r\n**我们可以用 instanceof 来判断返回函数的原型是否在实例的原型链上。**\r\n\r\n举个 🌰 大家就明白啦：\r\n\r\n```js\r\nvar func = function (){\r\n    console.log(this instanceof func);\r\n} \r\n\r\n// 作为普通函数调用\r\nfunc(); \r\n// false\r\n\r\n// 作为构造函数调用\r\nnew func(); \r\n// true\r\n```\r\n\r\n不同的调用方法，函数的 this 指向不同，利用这个特点即可得知返回函数是否作为构造函数调用：\r\n- 作为普通函数调用时，this 指向 window，结果为 false；\r\n- 作为构造函数调用时，this 指向实例，实例的 `__proto__` 属性指向构造函数的 prototype，结果为 true。\r\n\r\n了解这个原理后，实现就简单了：\r\n\r\n```js\r\n\r\n// v3.0：实现作为构造函数调用时this指向失效的效果\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    var self = this;\r\n    var args = [...arguments].slice(1);\r\n\r\n    var fBound = function () {\r\n        var restArgs = [...arguments];\r\n        // 作为普通函数调用时，this 指向 window，结果为 false；\r\n        // 作为构造函数调用时，this 指向实例，实例的 `__proto__` 属性指向构造函数的 prototype，结果为 true\r\n        return self.apply(this instanceof fBound ? this : context, args.concat(restArgs));\r\n    }\r\n    return fBound;\r\n}\r\n```\r\n\r\n> 这里其实考察了原型链的知识，关于原型链的内容可以参考：[JavaScript 深入系列之从原型到原型链](https://github.com/yuanyuanbyte/Blog/issues/89)。\r\n\r\n\r\n## 2. 继承函数的原型\r\n作为构造函数调用时，实例还会继承函数的原型。\r\n\r\n举个 🌰：\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\nfunction person(age, job, gender) {\r\n    this.work = '福报'; // 实例属性\r\n    console.log(this.name, age, job, gender);\r\n}\r\nperson.prototype.clockIn = function () {\r\n    console.log(996);\r\n}\r\nvar bindYve = person.bind(Yve, 22, 'engineer');\r\nvar obj = new bindYve('female');\r\nobj.work; // 福报\r\nobj.clockIn(); // 996\r\n```\r\n\r\n但上一版的实现中并没有做到原型的继承：\r\n\r\n```js\r\n...\r\nvar bindYve2 = person.bind2(Yve, 22, 'engineer');\r\nvar obj2 = new bindYve2('female');\r\nobj2.work; // 福报\r\nobj2.clockIn() // obj2.clockIn is not a function\r\n```\r\n\r\n这个问题怎么解决呢？\r\n\r\n**我们可以修改返回函数的原型，使返回函数的原型指向绑定函数的原型（这样实例就可以继承函数的原型），然后在返回函数中用 instanceof 来判断绑定函数的原型是否在实例的原型链上。** 因为实例的构造函数是返回函数，而返回函数的原型又指向了绑定函数的原型，所以绑定函数的原型肯定在实例的原型链上 **（我画了一个图，来帮大家理解这段内容 🙋‍♀️）**。\r\n\r\n先看如何用代码来实现：\r\n\r\n```js\r\n\r\n// v4.0：继承函数的原型\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    var self = this;\r\n    var args = [...arguments].slice(1);\r\n\r\n    var fBound = function () {\r\n        var restArgs = [...arguments];\r\n        /**\r\n         * 用 instanceof 来判断绑定函数 self 的原型是否在实例的原型链上：\r\n         * 1. 使用 new 运算符作为构造函数调用时，this 指向实例\r\n         *    因为我们在下面通过`fBound.prototype = this.prototype;`修改了 fBound 的原型为绑定函数的原型，所以此时结果为 true，this 指向实例。\r\n         * 2. 正常作为普通函数调用时，this 指向 window，此时结果为 false，this 指向绑定的 context；\r\n         */\r\n        return self.apply(this instanceof self ? this : context, args.concat(restArgs));\r\n    }\r\n    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值\r\n    fBound.prototype = this.prototype;\r\n    return fBound;\r\n}\r\n```\r\n\r\n结合前面的例子画了一张图来帮大家梳理一下：\r\n\r\n![img1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d6378a06c14a4da2860acdbbbd47a2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从上图可以得知使用 new 运算符作为构造函数调用时，绑定函数 person 的原型在实例 obj 的原型链上。使用 `this instanceof self` 来检测绑定函数 self(例子中的 person 方法)的原型是否在实例 obj 的原型链上，就可以知道返回函数是否被作为构造函数调用了 👌。\r\n\r\n## 3. 维护原型关系\r\n\r\n到这里，我们已经实现了返回函数作为构造函数调用时的效果，大家也明白了这些方法的原理，很棒！但还不够完美 🙅‍♀️\r\n\r\n为什么？\r\n\r\n因为这样的实现存在一个问题，我们修改返回函数的原型为绑定函数的原型，再配合 instanceof 来判断返回函数是否作为构造函数调用，思路是合理的，但直接让返回函数的原型指向绑定函数的原型就太粗暴了 🥺\r\n\r\n```js\r\nfBound.prototype = this.prototype;\r\n```\r\n\r\n了解堆栈的童鞋就会知道，这样的写法其实只是做了一个**简单的对象引用**，即把返回函数的原型指向了绑定函数原型对象的引用，**我画了一个存储结构的示意图，帮大家理解一下 😉**：\r\n\r\n![截屏2022-10-27 00.41.10.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98da849702974a3e91e984c64d8a8553~tplv-k3u1fbpfcp-watermark.image?)\r\n**两个原型指向同一个对象，任何的操作都会相互影响。**\r\n\r\n比如实例在原型上新增方法或者修改属性，绑定函数的原型也会跟着改变，举个 🌰：\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\n\r\nfunction person(age, job, gender) {\r\n    console.log(this.name, age, job, gender);\r\n}\r\nvar bindYve = person.bind2(Yve, 22, 'enginner');\r\nvar obj = new bindYve('female');\r\n\r\n// 实例在原型上新增一个方法\r\nobj.__proto__.clickLike = function(){\r\n    console.log('一键三连');\r\n}\r\nobj.clickLike(); // 一键三连\r\n\r\n// 绑定函数的原型也有了这个方法\r\nperson.prototype.clickLike(); // 一键三连\r\n```\r\n\r\n或者直接操作返回函数的原型，也是同样效果：\r\n\r\n```js\r\n...\r\nvar bindYve = person.bind2(Yve, 22, 'enginner');\r\n\r\n// 返回函数的原型新增一个方法\r\nbindYve.prototype.clickLike = function(){\r\n    console.log('下次一定');\r\n}\r\nbindYve.prototype.clickLike(); // 下次一定\r\n\r\n// 绑定函数的原型也有了这个方法\r\nperson.prototype.clickLike(); // 下次一定\r\n```\r\n**解决这个问题我们可以用一个空函数作为中间变量，通过这个中间变量来维护原型关系，从而让 `fBound.prototype` 与 `person.prototype` 不再指向同一个原型对象。**\r\n\r\n来看代码实现（最终版本）：\r\n\r\n```js\r\n\r\n// v5.0：最终版本\r\n\r\nFunction.prototype.bind2 = function (context) {\r\n    var self = this;\r\n    var args = [...arguments].slice(1);\r\n\r\n    var fBound = function () {\r\n        var restArgs = [...arguments];\r\n        return self.apply(this instanceof self ? this : context, args.concat(restArgs));\r\n    }\r\n    // 用一个空函数 fn 作为中间变量\r\n    var fn = function() {};\r\n    // 使中间变量 fn 的 prototype 指向绑定函数的 prototype\r\n    fn.prototype = this.prototype;\r\n    // 再使返回函数的 prototype 指向 fn 的实例，通过中间变量 fn 来维护原型关系\r\n    fBound.prototype = new fn();\r\n    return fBound;\r\n}\r\n```\r\n画了一张图帮大家梳理这段代码：\r\n\r\n![截屏2022-10-21 22.01.06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c5b6a9c7fb4accbdef28c4e209bc7a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从上图可以发现，中间变量 fn 的实例 维护了返回函数 fBound 和 绑定函数 person 的原型关系，使我们可以继续使用 instanceof 来判断返回函数是否作为构造函数调用；同时，也“隔离”了返回函数原型和绑定函数原型，返回函数的原型指向了 fn 的实例，所以再怎么操作返回函数的 prototype 或者返回函数实例的 `__proto__` 属性都碰不着绑定函数的 prototype，解决了 `fBound.prototype` 与 `person.prototype` 指向同一个原型对象的问题。\r\n\r\n到这里，我们已经知道了如何实现一个漂亮的 bind 方法，非常棒！\r\n\r\n![干杯.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f88bcc801e04bfab00a48ddca53cfd2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n实现 bind 方法的内容已经讲完，但关于原型链的内容还有一些没有讲，我们把这些补上 🙆‍♀️\r\n\r\n前文讲到 fn 的实例“隔离”了返回函数原型和绑定函数原型，但其实这只是“半隔离”，我们还是可以通过 `fBound.prototype.__proto__` 或者 `obj.__proto__.__proto__` 来修改绑定函数的原型，这个情况大家需要了解。\r\n\r\n比如：\r\n\r\n\r\n```js\r\nvar name = 'Jack';\r\nvar Yve = {\r\n    name: 'Yvette'\r\n};\r\n\r\nfunction person(age, job, gender) {\r\n    console.log(this.name, age, job, gender);\r\n}\r\nvar bindYve = person.bind2(Yve, 22, 'enginner');\r\nvar obj = new bindYve('female');\r\n\r\n// 实例原型新增一个方法\r\nobj.__proto__.clickLike = function(){\r\n    console.log('下次一定');\r\n}\r\nobj.clickLike(); \r\n// 下次一定\r\n\r\n// 绑定函数的原型不再被影响\r\nperson.prototype.clickLike(); \r\n// person.prototype.clickLike is not a function\r\n\r\n// 但通过原型链依然可以修改绑定函数的原型\r\nbindYve.prototype.__proto__.a = function(){console.log(11111)};\r\nperson.prototype.a(); \r\n// 11111\r\nobj.__proto__.__proto__.b = function(){console.log(22222)};\r\nperson.prototype.b(); \r\n// 22222\r\n```\r\n\r\n这也是 JavaScript 作为一种基于原型的语言的特点。\r\n\r\n另外，从前面的图中可以很清楚的发现 fn 的原型也在返回函数 fBound 的原型链上，所以也可以用 `this instanceof fn` 来判断返回函数是否作为构造函数调用。但相较而言，还是 `this instanceof self` 更加直观。\r\n\r\n到此，关于原型链的一些内容也讲完啦，希望对大家有所帮助 😊\r\n\r\n![比心.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fde559e5d4e0474bb9b78015d3aa8818~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 三、结尾\r\n如果这篇文章对你的学习有所帮助，欢迎点赞 👍 收藏 ⭐ 留言 📝 ，**你的支持是我创作分享的动力！**\r\n\r\n更多内容，可以查看 [圆圆的 blog](https://github.com/yuanyuanbyte/Blog) 💦\r\n"
    },
    {
        "article_id": "7147274707060916232",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c73dd8e449a241e688121cd8aec609c6~tplv-k3u1fbpfcp-watermark.image?",
        "title": "vitepress 中文文档 🎉",
        "preview": "全新的vitepress中文文档已发布🎉🎉🎉，前阵子把自己的技术网站从vuepress升级到了vitepress，顺手翻译了vitepress的英文文档",
        "author": "Process",
        "view_count": 5797,
        "collect_count": 75,
        "comment_count": 28,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/726c51c04cd9d74424e4525e03fc7cfd~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: devui-blue\r\n---\r\n\r\n我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第一篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")\r\n\r\n## ✨ 前言\r\n\r\n前阵子把自己的[技术网站](https://process1024.github.io/article/)从`vuepress`升级到了`vitepress`，在看文档时发现 vitepress\r\n没有中文文档，于是乎就做了一个中文文档的版本，方便自己翻阅文档，也为后续研究vitepress源码做准备。目前全新的vitepress中文文档已发布，快点击加收藏查看吧：\r\n\r\n[vitepress 中文文档]( https://process1024.github.io/vitepress) 🎉🎉🎉。\r\n\r\n[文档仓库](https://github.com/process1024/vitepress)\r\n\r\n\r\n## 什么是vitepress\r\nVitePress 是基于`vite`的vuepress兄弟版。特别适合写博客网站，技术文档，面试题网站，就有着它先天的优势。基本上现在vue官方团队的网站也都使用了vitepress，例如vuejs、vitejs、Vitest、vueuse...哦，还有vitepress官网自己😝。\r\n\r\n不仅如此，它还有极易上手、构建速度快、开发体检佳等优点。并且，它开箱即用，目前正处于 alpha 阶段，配置和 API 可能会在小版本之间发生变化。\r\n\r\n## 相比vuepress的改进点\r\n\r\n### 构建\r\n\r\n这个结果显而易见，使用vite可以带来：\r\n\r\n- 更快的本地服务启动\r\n- 更快的热更新\r\n- 更快的打包（内部使用Rollup）\r\n\r\n### 更小的页面体积\r\n\r\nvitepress使用了vue3，基于Vue3的tree-shaking + Rollup 代码拆分达到了打包体积更小的效果\r\n\r\n- 每个页面的每个请求不会发送元数据。 这将页面权重与页面总数分离。仅返回当前页面的元数据。客户端导航将同时获取新页面的组件和元数据。\r\n\r\n- 不使用 vue-router，因为 VitePress 的需求非常简单和具体 - 使用简单的自定义router（200行以下代码）代替。\r\n\r\n### 配置\r\n\r\nVitePress 旨在减少当前 VuePress 的复杂性，并从其极简主义根源重新开始。\r\n\r\n## 新特性\r\n\r\n### 布局\r\n\r\nvitepress内置了包括`doc`、`home`、`page`的文档布局，\r\n\r\n如果你不想要任何布局，你可以通过frontmatter传递 `layout: false`。如果您想要一个完全可定制的登录页面(默认情况下没有任何侧边栏、导航栏或页脚)，这个选项很有用。\r\n\r\n### 主题\r\n\r\nVitePress 带有默认主题，并提供许多开箱即用的功能。主题涵盖了导航栏、侧边栏、上下页按钮、编辑链接、最近更新日期、列表、搜索、团队组件等多个功能。\r\n\r\n## [使用自定义主题](https://process1024.github.io/vitepress/guide/theme-introduction#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98)\r\n\r\n你可以通过添加`.vitepress/theme/index.ts` 文件（“主题入口文件”）来启用自定义主题。\r\n\r\n```\r\n.\r\n├─ docs\r\n│  ├─ .vitepress\r\n│  │  ├─ theme\r\n│  │  │  └─ index.js\r\n│  │  └─ config.js\r\n│  └─ index.md\r\n└─ package.json\r\n```\r\n\r\nVitePress 自定义主题是一个只包含四个属性的对象，定义如下：\r\n\r\n\r\n```\r\ninterface Theme {\r\n  Layout: Component // Vue 3 component\r\n  NotFound?: Component\r\n  enhanceApp?: (ctx: EnhanceAppContext) => void\r\n  setup?: () => void\r\n}\r\n\r\n```\r\n\r\n主题入口文件应将主题作为其默认导出：\r\n\r\n\r\n```\r\n// .vitepress/theme/index.js\r\nimport Layout from './Layout.vue'\r\n\r\nexport default {\r\n  Layout,\r\n  NotFound: () => 'custom 404',\r\n}\r\n```\r\n\r\n`Layout` 组件如下所示：\r\n\r\n```\r\n<!-- .vitepress/theme/Layout.vue -->\r\n<template>\r\n  <h1>Custom Layout!</h1>\r\n\r\n  <!-- Content就是markdown渲染的位置 -->\r\n  <Content />\r\n</template>\r\n```\r\n\r\n默认导出是自定义主题的唯一方式。 在自定义主题中，它就像普通的 Vite + Vue 3 应用程序一样工作。\r\n\r\n## [扩展默认主题](https://process1024.github.io/vitepress/guide/theme-introduction#%E6%89%A9%E5%B1%95%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98)\r\n\r\n如果想扩展和自定义默认主题，可以从 `vitepress/theme` 导入它并在导出自定义主题中对其进行扩展。 以下是一些常见自定义的示例：\r\n\r\n### [注册全局组件](https://process1024.github.io/vitepress/guide/theme-introduction#%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6)\r\n\r\n```\r\n// .vitepress/theme/index.js\r\nimport DefaultTheme from 'vitepress/theme'\r\n\r\nexport default {\r\n  ...DefaultTheme,\r\n  enhanceApp({ app }) {\r\n    // 注册一个全局组件\r\n    app.component('MyGlobalComponent', /* ... */)\r\n  }\r\n}\r\n```\r\n\r\n由于我们使用 Vite，你还可以利用 Vite 的 [全局导入特性](https://vitejs.dev/guide/features.html#glob-import) 自动注册组件目录。\r\n\r\n### [自定义 CSS](https://process1024.github.io/vitepress/guide/theme-introduction#%E8%87%AA%E5%AE%9A%E4%B9%89-css)\r\n\r\n默认主题 CSS 可通过覆盖根元素的 CSS 变量进行自定义：\r\n\r\n```\r\n// .vitepress/theme/index.js\r\nimport DefaultTheme from 'vitepress/theme'\r\nimport './custom.css'\r\n\r\nexport default DefaultTheme\r\n```\r\n\r\n```\r\n/* .vitepress/theme/custom.css */\r\n:root {\r\n  --vp-c-brand: #646cff;\r\n  --vp-c-brand-light: #747bff;\r\n}\r\n```\r\n\r\n这里可以看到支持的 [默认的主题 CSS 变量](https://github.com/vuejs/vitepress/blob/main/src/client/theme-default/styles/vars.css).\r\n\r\n### Layout 组件插槽\r\n\r\n默认主题 `<Layout/>` 组件有一些插槽，可用于在页面的某些位置注入内容。具体可以[点击查看](https://process1024.github.io/vitepress/guide/theme-introduction#layout-%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD)\r\n\r\n还有主题颜色，支持亮/暗黑主题，例如下面这个好看的暗黑主题。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43bcb22c27284b94875e64f06208bc63~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 部署\r\n\r\n执行 build 后默认会在(`.vitepress/dist`)生成构建的产物，然后就可以开始部署到服务器上了。\r\n\r\nvitepress 官网提供了 github page 、gitlab page、firebase等多个服务器的部署方式。推荐使用github page，提供了github action的示例代码，基本一步到位。\r\n\r\n我个人的文档网站就发布在github page，使用action自动部署，还不清楚怎么用github action自动部署自己的文档网站的可以看我之前的文章：[用GitHub Action + VuePress自动化部署自己的文档网站](https://juejin.cn/post/6937532951223599141)。\r\n\r\n## 怎么做贡献\r\n\r\n目前vitepress还处在`aplha`阶段，更新比较频繁，并且目前还没有国际化的支持，想必很多人都会想为开源做贡献，这不就是一个很好的机会吗😏。\r\n"
    },
    {
        "article_id": "7169228978559926285",
        "snapshot": "",
        "title": "3天3定制大屏，反向PUA",
        "preview": "摘要     本次分享一段无讨价还价余地的单人3天定制化大屏全过程（强调说拖拽屏的请绕道,和你想的不一样）,要动效、要地图、要流光。天坑的心理博弈到最终解决的过程及技术思路。 前因      没啥征兆",
        "author": "沈二到不行",
        "view_count": 3752,
        "collect_count": 47,
        "comment_count": 11,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/328f88bdfcc9cf39e32b9f936a80d0fb~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: vuepress\r\n---\r\n# 摘要\r\n &ensp;&ensp;&ensp;&ensp;本次分享一段无讨价还价余地的单人3天**定制化大屏**全过程（强调说拖拽屏的请绕道,和你想的不一样）,要动效、要地图、要流光。天坑的心理博弈到最终解决的过程及技术思路。\r\n# 前因\r\n   &ensp;&ensp;&ensp;&ensp; 没啥征兆突然接到说，要在下周完成2个大屏的定制开发,起初没提有动效,定时器等等内容的要求,只是说要根据美工的设计完成相关内容，并不觉得有啥难度，周末突发指令,要3D要3个大屏,给我顿时整傻了,挡了3d的无理要求,拗不过加码,3个大屏又附加了动效、定时器、翻牌器，流光等效果。\r\n     <br/>&ensp;&ensp;&ensp;&ensp;总之是能动的都要动,经过一番心态炸裂的心理建设后，👽推掉了其他开发任务，对你没看错，还有3项任务排着队，（安安静静的写代码都是个奢望）,周末为了缓解惆怅,试着找了找合适能加速开发过程的组件(主要是效果类),到此处可能会有人吐槽，模板多如牛毛找个模板不香嘛，此处补充一下，未定制稍微好说一些,定制的和常规的模板兼容可能还没手写的快,因此着重找了组件。\r\n# 过程\r\n&ensp;&ensp;&ensp;&ensp; 可能是机缘到了运气好,顺手就找了一个符合要求的组件[Vue 大屏数据展示组件库](http://datav.jiaminghi.com/guide/#%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE),想要的装饰、边框、翻牌器、排名轮播等都有,基本把动效问题解决了一大半,剩下的主要就是地图、图表及内容布局、定时器、数据流调整。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a3d6d4ae6b4cc48f7f7a9144171543~tplv-k3u1fbpfcp-watermark.image?)\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d80760f7bfc448389901494b7cd9dc6~tplv-k3u1fbpfcp-watermark.image?)\r\n- 💪 合适的工具找到了,因为内容多,尽量提取卡片等边框组件化,某些可能有标题或者无标题,边框样式不同等,随时写随时加入参兼容,我的步骤是第一个尽量抽组件,第二个兼容扩展组件,第三个基本就不费什么时间了。\r\n- 💪 解决布局问题,Layout每个UI组件基本都有,但有个问题需注意flex布局问题尽量先搞定**gutter栅格间隔**,的原理再去处理,避免随意的padding或者margin造成的时间浪费。\r\n- 💪 echarts之前的社区貌似是被关闭了,很多老哥可能没有找到社区案例的地址，[补充一下](https://www.makeapie.cn/echarts_3.html?queryStr=svg) 地图功能大略和以下差不多，主要就是SVG加载原理加上元素数据的组件。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044fdf2eb7be4307b0ba9adfaf00e423~tplv-k3u1fbpfcp-watermark.image?)\r\n- 💪定时器相关的内容，主要是每个区块触发的时间点要区分,因此存在很多的定时任务,关闭时容易遗漏，因此简单做了处理,销毁时统一销毁\r\n```js\r\n/**\r\n * 调度器\r\n */\r\nexport default class dispatcher {\r\n  constructor() {\r\n    this.watcher = [];\r\n  }\r\n  startNew(callBack, timer) {\r\n    var timer = setInterval(callBack, timer);\r\n    this.watcher.push(timer);\r\n  }\r\n  destroyed() {\r\n    //移除\r\n    for (let index = 0; index < this.watcher.length; index++) {\r\n      const element = array[index];\r\n      clearInterval(element);\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n- 💪 数据流的处理,之前在文章里面吐槽了单端的问题，因此即便是前期的模拟数据，我也习惯梳理好数据流以待后来适配，并不会因为时间问题随意去搞,避免加重后期的工作量。\r\n- 💪 最后初步成型后的好处，逐步反哺体现，细化的部分基本轻松就进行了调整,但你以为用组件就完了嘛，以上的组件原理很好，一些不太归纳的svg动画处理成组件后,的的确确增加了便捷性,但**定制**二字不是说说而已,还是得继承重写,重新定义部分动画。\r\n- 💪 至此逐步进入尾声，也顺利完成和美工的切磋，**加班？开玩笑吧，兽人永不为奴！！**，至于后两天的时间，是专门挤出来给领导提意见修改的，**“唉，卑微的程序猿！！”**\r\n# 题外话\r\n   &ensp;&ensp;&ensp;&ensp; 行业及职业焦虑就像波光粼粼的水面，哪怕微风一吹,也会震颤不止，外加本段工作沉下来，且情况复杂，越来越发现做软件的特质跟人的问题相关性很强,注定 **“江湖只能孤身一人”**,正好又是世界杯，之前有讨论,说是中国团队项目对比“乒乓球”和“足球”,**英雄主义**特质明显,但一直在强调团队协作,工作里面这几年听到最多的是依旧是**和人打交道最难**，我的焦虑又在烦躁不堪的时候突然冒出头来。\r\n   <br/>&ensp;&ensp;&ensp;&ensp; 之后,经历了一些事,又找到一个方向，疫情结束后的方向，在结束前是不是应该预测准备一些东西，于是，内心又莫名的斗志满满，也许焦虑的源头本质就是失去方向,对未来失去斗志和信心才反复的吧。\r\n   \r\n   ***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\r\n"
    },
    {
        "article_id": "7160358329934413837",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d55576b37c8c4e56935461252a18aaf3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "如何花一天时间打造一款前端在线代码编辑器——实现代码预览",
        "preview": "vue-Playground 功能第一次尝试这种在线编码时感觉挺新奇，浏览器端居然可以直接运行 typescript，还具备编译的能力，今天就从技术选型和架构的层面打造一款前端在线代码编辑器。",
        "author": "残月公子",
        "view_count": 3664,
        "collect_count": 87,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4f5f8646f59917e9665b371bf005d000~300x300.image",
        "category": "前端",
        "content": "## 前言\r\n\r\n好久都没写博客了，这两天稍微空闲些打算找个技术专题来写一些东西。本想写写最近非常火的 Turbopack，但考虑到没有深入的研究其运行原理，如果要写可能就要是流于表面讲讲用法，感觉价值也不是很高，故此还是选了之前预研过的在线编辑器。\r\n\r\n目前社区中一些开源的框架在部署文档时为方便开发者快速了解使用，都会实现一套自己的在线编辑器。如\r\n* [omi-Playground](https://omi.cdn-go.cn/play/latest/index.html) \r\n* [typescript-Play](https://www.typescriptlang.org/play) \r\n* [vue-Playground](https://sfc.vuejs.org/) \r\n* [掘金-Code](https://code.juejin.cn/) \r\n\r\n第一次体验这种功能时挺新奇，浏览器端居然可以直接运行 typescript、less、scss 等代码，还可以有自己的独立的运行时环境，最重要的是沙箱环境中可以有自己的依赖项（沙箱中执行代码时可以自动加载对应的依赖，如加载 vue、react 这种运行时依赖）。\r\n\r\n后续也陆续调研了此类工具的一些架构，基于这些理论架构花费了几天的时间简单实现了一套 WebComponent 技术栈的在线编辑器，感兴趣的可以 [在线体验， 浏览器代开奥](https://static-cdn.canyuegongzi.xyz/wu-code-playground/index.html) 。\r\n\r\n既然专题已定，那说干就干，先做一个基本的架构设计。\r\n\r\n## 架构设计\r\n\r\n既然要做在线的编译器，那首先得支持编辑代码，其次得有一个能独立运行的沙箱环境，最后就是需要具备代码的编译能力（浏览器不支持直接执行 typescript、less 此类的代码）。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76795d50d763488db13d6bf3b76eb481~tplv-k3u1fbpfcp-zoom-1.image\\\" class=\\\"medium-zoom medium-zoom-image\\\">\r\n\r\n基于设想做了一个简单的架构，架构基于浏览器以及 WebWorker 环境，Compiler 是核心枢纽负责三方通信，有了基本的架构设计，后续开始针对每个模块进行技术选型以及开发。\r\n\r\n## 模块设计\r\n\r\n### 编辑器\r\n\r\nWeb 编辑器是前端领域中算是比较深入的一个领域了，常见的 Md 编辑器、富文本编辑器等，从能力层来说，任何具备输入能力的控件都能承担架构中 Editor 的角色，但考虑到用户体验，如代码智能提示、代码格式美化、主题色等，故此还是选一款成熟的编辑器。\r\n\r\n目前社区中也有很多优秀代码编辑器，诸如，\r\n* [codemirror](https://github.com/codemirror/codemirror5) \r\n* [monaco-editor](https://github.com/microsoft/monaco-editor) \r\n* [vue-codemirror](https://github.com/surmon-china/vue-codemirror) \r\n\r\ncodemirror是一块比较老牌的插件，功能非常丰富，但工程化集成稍微困难些，因此方案中未采用该插件，故此此处不再赘述演示，感兴趣的可以移步去官网瞅瞅。\r\n\r\n此方案中选用大大名顶顶的 monaco-editor 的编辑器，monaco-editor 是一个浏览器端的代码编辑器库，同时它也是 VS Code 所使用的编辑器。monaco-editor 可以看作是一个编辑器控件，只提供了基础的编辑器与语言相关的接口，可以被用于任何基于 Web 技术构建的项目中，而 VS Code 包含了文件管理、版本控制、插件等功能，是一款桌面软件。monaco-editor 的 GitHub 仓库中不包含任何实际功能代码，因为其源代码与 VS Code 在同一个仓库，只是在版本发布时会构建出独立的编辑器代码。目前社区中对于集成 monaco-editor 的方案比较多，此处大致做一个方案对比。\r\n\r\n#### monaco-editor-webpack-plugin\r\n\r\n**插件安装**\r\n\r\n[monaco-editor-webpack-plugin](https://www.npmjs.com/package/monaco-editor-webpack-plugin) 是一个基于 webpack 的集成方案，周下载量大致 204k 左右，此处拷贝了下官网的集成代码。\r\n\r\n```\r\nconst MonacoWebpackPlugin = require('monaco-editor-webpack-plugin');\r\nconst path = require('path');\r\n\r\nmodule.exports = {\r\n\\tentry: './index.js',\r\n\\toutput: {\r\n\\t\\tpath: path.resolve(__dirname, 'dist'),\r\n\\t\\tfilename: 'app.js'\r\n\\t},\r\n\\tmodule: {\r\n\\t\\trules: [\r\n\\t\\t\\t{\r\n\\t\\t\\t\\ttest: /\\\\.css$/,\r\n\\t\\t\\t\\tuse: ['style-loader', 'css-loader']\r\n\\t\\t\\t},\r\n\\t\\t\\t{\r\n\\t\\t\\t\\ttest: /\\\\.ttf$/,\r\n\\t\\t\\t\\tuse: ['file-loader']\r\n\\t\\t\\t}\r\n\\t\\t]\r\n\\t},\r\n\\tplugins: [new MonacoWebpackPlugin()]\r\n};\r\n```\r\n\r\n**实例化**\r\n\r\n```ts\r\nimport * as monaco from 'monaco-editor';\r\n// or import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\r\n// if shipping only a subset of the features & languages is desired\r\n\r\nmonaco.editor.create(document.getElementById('container'), {\r\n\\tvalue: 'console.log(\\\"Hello, world\\\")',\r\n\\tlanguage: 'javascript'\r\n});\r\n```\r\n\r\n#### @monaco-editor/loader\r\n\r\nmonaco-editor-webpack-plugin 虽好，但限制了工具链只能 webpack 使用，通过开源社区了解到 [@monaco-editor/loader](https://www.npmjs.com/package/@monaco-editor/loader) ，周下载量大致 224k 左右， 用官网的描述就是\r\n\r\n> The utility to easy setup monaco-editor into your browser。Configure and download monaco sources via its loader script, without needing to use webpack's (or any other module bundler's) configuration files\r\n\r\n**实例化**\r\n\r\n```ts\r\nimport loader from '@monaco-editor/loader';\r\n\r\nloader.init().then(monaco => {\r\n  monaco.editor.create(document.querySelector(\\\"#dom\\\"), {\r\n    value: '// some comment',\r\n    language: 'javascript',\r\n  });\r\n});\r\n```\r\n\r\n#### @monaco-editor/react\r\n\r\n@monaco-editor/loader 方案很优秀，但货比三家还是调研了另外一个方案，[@monaco-editor/react](https://www.npmjs.com/package/@monaco-editor/react) ，周下载量大致 219k 左右，是一款基于 react 的组件。\r\n\r\n> Monaco Editor for React · use the monaco-editor in any React application without needing to use webpack (or rollup/parcel/etc) configuration files / plugins\r\n\r\n**实例化**\r\n\r\n```tsx\r\nimport React from \\\"react\\\";\r\nimport ReactDOM from \\\"react-dom\\\";\r\n\r\nimport Editor from \\\"@monaco-editor/react\\\";\r\n\r\nfunction App() {\r\n  return (\r\n   <Editor\r\n     height=\\\"90vh\\\"\r\n     defaultLanguage=\\\"javascript\\\"\r\n     defaultValue=\\\"// some comment\\\"\r\n   />\r\n  );\r\n}\r\n\r\nconst rootElement = document.getElementById(\\\"root\\\");\r\nReactDOM.render(<App />, rootElement);\r\n```\r\n\r\n**Editor 的实现最后使用了 monaco-editor + @monaco-editor/loader 的方案，封装了一个基于 WebComponent 的插件：[wu-code-monaco-editor](https://docs.wu-component.com/component-plus/Complex/CodeEditor.html) 。**\r\n\r\n### 沙箱环境\r\n\r\n因编辑器输入代码的不可信任，所以需要一个沙箱环境来执行代码, 防止程序访问/影响主页面。\r\n\r\n> 在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。\r\n\r\n该方案中选用了最传统的 Iframe 方案，毕竟它的兼容性最好，功能最完善（沙箱做的最彻底，js 作用域、css 隔离等），但此处还是列举了几个社区中其他的沙箱方案。\r\n\r\n#### Proxy Sandbox\r\n\r\n可以通过代理 Proxy 实现对象的劫持， 通过 window 对象的修改进行记录，在卸载时删除这些记录，在应用再次激活时恢复这些记录，来达到模拟沙箱环境的目的。此处贴了一份社区中的实现代码，可以略作研习。\r\n\r\n```ts\r\n// 修改window属性的公共方法\r\nconst updateHostProp = (prop: any, value, isDel?) => {\r\n    if (value === undefined || isDel) {\r\n        delete window[prop];\r\n    } else {\r\n        window[prop] = value;\r\n    }\r\n};\r\n\r\nclass ProxySandbox {\r\n    private currentUpdatedPropsValueMap = new Map()\r\n    private modifiedPropsMap = new Map()\r\n    private addedPropsMap = new Map()\r\n    public name: string = \\\"\\\";\r\n    public proxy: any;\r\n\r\n    /**\r\n     * 激活沙箱\r\n     */\r\n    public active() {\r\n        // 根据记录还原沙箱\r\n        this.currentUpdatedPropsValueMap.forEach((v, p) => updateHostProp(p, v));\r\n    }\r\n\r\n    /**\r\n     * 关闭沙箱\r\n     */\r\n    public inactive() {\r\n        // 1 将沙箱期间修改的属性还原为原先的属性\r\n        this.modifiedPropsMap.forEach((v, p) => updateHostProp(p, v));\r\n        // 2 将沙箱期间新增的全局变量消除\r\n        this.addedPropsMap.forEach((_, p) => updateHostProp(p, undefined, true));\r\n    }\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.proxy = null;\r\n        // 存放新增的全局变量\r\n        this.addedPropsMap  = new Map();\r\n        // 存放沙箱期间更新的全局变量\r\n        this.modifiedPropsMap = new Map();\r\n        // 存在新增和修改的全局变量，在沙箱激活的时候使用\r\n        this.currentUpdatedPropsValueMap = new Map();\r\n\r\n        const { addedPropsMap, currentUpdatedPropsValueMap, modifiedPropsMap } = this;\r\n        const fakeWindow = Object.create(null);\r\n        const proxy = new Proxy(fakeWindow, {\r\n            set(target, prop, value) {\r\n                if (!window.hasOwnProperty(prop)) {\r\n                    // 如果window上没有的属性，记录到新增属性里\r\n                    addedPropsMap.set(prop, value);\r\n                } else if (!modifiedPropsMap.has(prop)) {\r\n                    // 如果当前window对象有该属性，且未更新过，则记录该属性在window上的初始值\r\n                    const originalValue = window[prop];\r\n                    modifiedPropsMap.set(prop, originalValue);\r\n                }\r\n                // 记录修改属性以及修改后的值\r\n                currentUpdatedPropsValueMap.set(prop, value);\r\n                // 设置值到全局window上\r\n                updateHostProp(prop, value);\r\n                return true;\r\n            },\r\n            get(target, prop) {\r\n                return window[prop];\r\n            },\r\n        });\r\n        this.proxy = proxy;\r\n    }\r\n}\r\n\r\nconst newSandBox: ProxySandbox = new ProxySandbox('代理沙箱');\r\nconst proxyWindow = newSandBox.proxy;\r\nproxyWindow.a = '1';\r\nconsole.log('开启沙箱：', proxyWindow.a, window.a);\r\nnewSandBox.inactive(); //失活沙箱\r\nconsole.log('失活沙箱：', proxyWindow.a, window.a);\r\nnewSandBox.active(); //失活沙箱\r\nconsole.log('重新激活沙箱：', proxyWindow.a, window.a);\r\n\r\n```\r\n\r\n以上代码实现了基础版的沙箱， 通过 active 方法开始沙箱代理，社区中的 qiankunu 等此类的微前端架构中基本都采用了此类的设计。\r\n\r\n#### Diff Sandbox\r\n\r\n除 Proxy 方式外，我们可以通过 diff 的方式创建沙箱，一般作为 Proxy Sandbox 的降级方案，在应用运行的时候保存一个快照 window 对象，将当前 window 对象的全部属性都复制到快照对象上，子应用卸载的时候将 window 对象修改做个 diff，将不同的属性用个 modifyMap 保存起来，再次挂载的时候再加上这些修改的属性。\r\n\r\n```ts\r\nclass DiffSandbox {\r\n    public name: any;\r\n    public modifyMap: {};\r\n    private windowSnapshot: {};\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.modifyMap = {}; // 存放修改的属性\r\n        this.windowSnapshot = {};\r\n    }\r\n    public active() {\r\n        // 缓存active状态的沙箱\r\n        this.windowSnapshot = {};\r\n        for (const item in window) {\r\n            this.windowSnapshot[item] = window[item];\r\n        }\r\n\r\n        Object.keys(this.modifyMap).forEach(p => {\r\n            window[p] = this.modifyMap[p];\r\n        });\r\n\r\n    }\r\n\r\n    public inactive() {\r\n        for (const item in window) {\r\n            if (this.windowSnapshot[item] !== window[item]) {\r\n                // 记录变更\r\n                this.modifyMap[item] = window[item];\r\n                // 还原window\r\n                window[item] = this.windowSnapshot[item];\r\n            }\r\n        }\r\n    }\r\n}\r\nconst diffSandbox = new DiffSandbox('diff沙箱');\r\ndiffSandbox.active();  // 激活沙箱\r\nwindow.a = '1';\r\nconsole.log('开启沙箱：', window.a);\r\ndiffSandbox.inactive(); //失活沙箱\r\nconsole.log('失活沙箱：', window.a);\r\ndiffSandbox.active();   // 重新激活\r\nconsole.log('再次激活', window.a);\r\n\r\n```\r\n\r\n#### iframe\r\n\r\niframe 方案是该设计中的沙箱方案，此处细细道说。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcd1137dfccb4f43b86463b0576b2a00~tplv-k3u1fbpfcp-zoom-1.image\\\" class=\\\"medium-zoom medium-zoom-image\\\">\r\n\r\n宿主环境中通过实例化 new ProxySandbox() 操作来创建加载 Iframe， Iframe 加载完毕后会监听来自宿主的消息，诸如执行代码、加载依赖。内部也可以通过 postMessage 向宿主环境发送消息，此逻辑参考了  [@vue/repl](https://github.com/vuejs/repl#readme)  \r\n\r\n```ts\r\nlet uid = 1;\r\nexport class ProxySandbox {\r\n    iframe: HTMLIFrameElement\r\n    handlers: Record<string, Function>\r\n    pending_cmds: Map<\r\n        number,\r\n        { resolve: (value: unknown) => void; reject: (reason?: any) => void }\r\n        >\r\n    handle_event: (e: any) => void\r\n\r\n    constructor(iframe: HTMLIFrameElement, handlers: Record<string, Function>) {\r\n        this.iframe = iframe;\r\n        this.handlers = handlers;\r\n\r\n        this.pending_cmds = new Map();\r\n\r\n        this.handle_event = (e) => this.handle_repl_message(e);\r\n        window.addEventListener('message', this.handle_event, false);\r\n    }\r\n\r\n    destroy() {\r\n        window.removeEventListener('message', this.handle_event);\r\n    }\r\n\r\n    iframe_command(action: string, args: any) {\r\n        return new Promise((resolve, reject) => {\r\n            const cmd_id = uid++;\r\n\r\n            this.pending_cmds.set(cmd_id, { resolve, reject });\r\n\r\n            this.iframe.contentWindow!.postMessage({ action, cmd_id, args }, '*');\r\n        });\r\n    }\r\n\r\n    handle_command_message(cmd_data: any) {\r\n        const action = cmd_data.action;\r\n        const id = cmd_data.cmd_id;\r\n        const handler = this.pending_cmds.get(id);\r\n\r\n        if (handler) {\r\n            this.pending_cmds.delete(id);\r\n            if (action === 'cmd_error') {\r\n                const { message, stack } = cmd_data;\r\n                const e = new Error(message);\r\n                e.stack = stack;\r\n                handler.reject(e);\r\n            }\r\n\r\n            if (action === 'cmd_ok') {\r\n                handler.resolve(cmd_data.args);\r\n            }\r\n        } else if (action !== 'cmd_error' && action !== 'cmd_ok') {\r\n            console.error('command not found', id, cmd_data, [\r\n                ...this.pending_cmds.keys()\r\n            ]);\r\n        }\r\n    }\r\n\r\n    handle_repl_message(event: any) {\r\n        if (event.source !== this.iframe.contentWindow) return;\r\n\r\n        const { action, args } = event.data;\r\n        this.handlers.on_default_event(event);\r\n        switch (action) {\r\n            case 'cmd_error':\r\n            case 'cmd_ok':\r\n                return this.handle_command_message(event.data);\r\n            case 'fetch_progress':\r\n                return this.handlers.on_fetch_progress(args.remaining);\r\n            case 'error':\r\n                return this.handlers.on_error(event.data);\r\n            case 'unhandledrejection':\r\n                return this.handlers.on_unhandled_rejection(event.data);\r\n            case 'console':\r\n                return this.handlers.on_console(event.data);\r\n            case 'console_group':\r\n                return this.handlers.on_console_group(event.data);\r\n            case 'console_group_collapsed':\r\n                return this.handlers.on_console_group_collapsed(event.data);\r\n            case 'console_group_end':\r\n                return this.handlers.on_console_group_end(event.data);\r\n        }\r\n    }\r\n\r\n    eval(script: string | string[]) {\r\n        return this.iframe_command('eval', { script });\r\n    }\r\n\r\n    handle_links() {\r\n        return this.iframe_command('catch_clicks', {});\r\n    }\r\n\r\n    load_depend(options: Record<any, any>) {\r\n        return this.iframe_command('load_dependencies', options);\r\n    }\r\n}\r\n```\r\n\r\n### 在线编译\r\n\r\nEditor 和 Sandbox 方案既定，最后就是代码的编译问题，此方案中仅涉及 TypeScript 的编译。\r\n\r\nmonaco-editor 提供了 Worker 编译代码的能力，使用起来也是非常方便，读取到编辑器中输入的代码后直接输入到 Worker 中，等待编译完成再调用上章中沙箱提供的 eval 的接口送入沙箱中即可。\r\n\r\n```ts\r\n\r\nexport const compileTS = async (uri: InstanceType<typeof monaco.Uri>) => {\r\n    // const tsWorker = await monaco.languages.typescript.getTypeScriptWorker();\r\n    const monaco = window.monaco;\r\n    // 读取编译子线程\r\n    const tsWorker = await monaco.languages.typescript.getTypeScriptWorker();\r\n    const client = await tsWorker(uri);\r\n    const result = await client.getEmitOutput(uri.toString());\r\n    const files = result.outputFiles[0];\r\n    return files.text;\r\n};\r\n\r\nexport class WuCodePlayground extends WuComponent {\r\n    /// .....code\r\n    constructor() {\r\n        super();\r\n    }\r\n    \r\n    /**\r\n     * 核心逻辑， 读取输入的代码，执行 compileTS 编译\r\n     */\r\n    public async runCode() {\r\n        const editor = this.editorContainer.editor;\r\n        const tsJs: string = await compileTS(editor.getModel(\\\"typescript\\\").uri);\r\n        this.previewContainer.runCode('ts', tsJs);\r\n\r\n    }\r\n    /// .....code\r\n}\r\n\r\n```\r\n\r\n至于其他诸如 less, scss 等的编译问题社区中也有成熟的方案：\r\n\r\n* [less](https://lesscss.org/)\r\n* [sass](http://sass.js.org/)\r\n\r\n## 思考\r\n\r\n时间太晚了写不动了，此方案在实时过程中有很多的细节问题后续抽空在记录吧，如沙箱中通过如何通过 import-maps 加载运行时依赖、沙箱与宿主间通信如何保证稳定、以及 WebComponent 不能重复定义等问题。\r\n\r\n* [感兴趣的可以移步到这里参阅源码](https://github.com/wu-component/web-component-plus/tree/master/component/packages/wu-code-playground/src)\r\n* [组件](https://docs.wu-component.com/component-plus/Complex/CodeEditor.html)\r\n\r\n## 参考资料\r\n\r\n* [@vue/repl](https://github.com/vuejs/repl#readme)  \r\n* [monaco-editor](https://microsoft.github.io/monaco-editor/)  \r\n* [writing-a-javascript-framework-sandboxed-code-evaluation](https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/)  \r\n* [create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor](https://betterprogramming.pub/create-a-custom-web-editor-using-typescript-react-antlr-and-monaco-editor-part-1-2f710c69c18c)\r\n* [To create a lightweight WebIDE, reading this article is enough](https://segmentfault.com/a/1190000041686221/en)\r\n* [import-maps](https://html.spec.whatwg.org/multipage/webappapis.html#import-maps)\r\n"
    },
    {
        "article_id": "7187794268009234489",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65f28c17de8b45bf84f67e371761888f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "小兔子在终端给大家拜年啦",
        "preview": "我正在参加「兔了个兔」创意投稿大赛。哈喽大家好，我是陈明勇，今天分享的内容是 使用 Go 语言实现小兔子在终端给大家拜年。如果觉得作品有趣，不妨点个赞。",
        "author": "陈明勇",
        "view_count": 2106,
        "collect_count": 7,
        "comment_count": 10,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/a3ab63b2c3ff666da0fb4251252e92e9~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: smartblue\r\n---\r\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\r\n\r\n> 耐心和持久胜过激烈和狂热。\r\n\r\n哈喽大家好，我是陈明勇，今天分享的内容是 使用 Go 语言实现小兔子在终端给大家拜年。如果觉得作品有趣，不妨点个赞，如果本文有错误的地方，欢迎指出！\r\n \r\n## 前言\r\n看了「兔了个兔」创意投稿大赛规则，思来想去，使用 `Go` 语言创作，没有想到好的创意，最后打算在终端动态打印小兔子，给大家拜年！\r\n\r\n先来看看效果图：\r\n\r\n![rabbit.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7171cd10a44a4c28bba97d0e0cebc8a9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n[码上掘金源码地址](https://code.juejin.cn/pen/7187442241047101451)\r\n[jcode](https://code.juejin.cn/pen/7187442241047101451)\r\n## 创作过程\r\n### 小兔子模型制作\r\n\r\n![0K@E6E`X](EDGJVUR`MM5BQ.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b9971ed1bc4040828eb0f13e0aa96c~tplv-k3u1fbpfcp-watermark.image?)\r\n大部分的时间，都花在了画兔子图案的工作上。创建一个 `txt` 文档，在文档里通过特殊符号，一步一步将模型搭好，然后附上一副春节对联。\r\n### 实现思路\r\n整个动态过程是由几个不同的图案依次打印而成，一共有 7 个图案。起初我是将这 7 个图案放到 `txt` 文件里，然后通过读取文件，分割图案，最后打印图案，这样做的好处是图案和代码分开了，降低图案与代码间的耦合度。\r\n\r\n到最后，由于代码要放到码上掘金上面，而码上掘金不支持读取文件的操作，因此只能将图案放到代码里，用字符串变量接收。\r\n### 代码\r\n```go\r\npackage main\r\n\r\nimport (\r\n\\t\\\"fmt\\\"\r\n\\t\\\"os\\\"\r\n\\t\\\"os/exec\\\"\r\n\\t\\\"time\\\"\r\n)\r\n\r\nvar r1 = \\\"\\\r\n                    /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                   /  : /  |\\\" +\r\n\\t\\\"\\\r\n                  :   :`  /\\\" +\r\n\\t\\\"\\\r\n                   \\\\\\\\     .\\\" +\r\n\\t\\\"\\\r\n                    \\\\\\\\   :.\\\" +\r\n\\t\\\"\\\r\n                    .`     `.\\\" +\r\n\\t\\\"\\\r\n                   :     0   \\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                 ..`          ;\\\" +\r\n\\t\\\"\\\r\n             . `           `.¯\\\" +\r\n\\t\\\"\\\r\n           .`                :\\\" +\r\n\\t\\\"\\\r\n        .`                   .\\\" +\r\n\\t\\\"\\\r\n      .`                     :\\\" +\r\n\\t\\\"\\\r\n     .    Happy New Year     .\\\" +\r\n\\t\\\"\\\r\n    .                     .`\\\" +\r\n\\t\\\"\\\r\n .. `                  .`\\\" +\r\n\\t\\\"\\\r\n:  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n`..`._____________::____)\\\"\r\n\r\nvar r2 = \\\"\\\r\n                        /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                       /  : /  |\\\" +\r\n\\t\\\"\\\r\n                      :   :`  /\\\" +\r\n\\t\\\"\\\r\n                       \\\\\\\\     .\\\" +\r\n\\t\\\"\\\r\n                        \\\\\\\\   :.\\\" +\r\n\\t\\\"\\\r\n                        .`     `.\\\" +\r\n\\t\\\"\\\r\n                       :     0   \\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                     ..`          ;\\\" +\r\n\\t\\\"\\\r\n                 . `           `.¯\\\" +\r\n\\t\\\"\\\r\n               .`                :\\\" +\r\n\\t\\\"\\\r\n            .`                   .\\\" +\r\n\\t\\\"\\\r\n          .`                     :\\\" +\r\n\\t\\\"\\\r\n         .    Happy New Year     .\\\" +\r\n\\t\\\"\\\r\n        .                     .`\\\" +\r\n\\t\\\"\\\r\n     .. `                  .`\\\" +\r\n\\t\\\"\\\r\n    :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n    `..`._____________::____)\\\"\r\nvar r3 = \\\"\\\r\n                            /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                           /  : /  |\\\" +\r\n\\t\\\"\\\r\n                          :   :`  /\\\" +\r\n\\t\\\"\\\r\n                           \\\\\\\\     .\\\" +\r\n\\t\\\"\\\r\n                            \\\\\\\\   :.\\\" +\r\n\\t\\\"\\\r\n                            .`     `.\\\" +\r\n\\t\\\"\\\r\n                           :     0   \\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                         ..`          ;\\\" +\r\n\\t\\\"\\\r\n                     . `           `.¯\\\" +\r\n\\t\\\"\\\r\n                   .`                :\\\" +\r\n\\t\\\"\\\r\n                .`                   .\\\" +\r\n\\t\\\"\\\r\n              .`                     :\\\" +\r\n\\t\\\"\\\r\n             .    Happy New Year     .\\\" +\r\n\\t\\\"\\\r\n            .                     .`\\\" +\r\n\\t\\\"\\\r\n         .. `                  .`\\\" +\r\n\\t\\\"\\\r\n        :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n        `..`._____________::____)\\\"\r\nvar r4 = \\\"\\\r\n                                /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                               /  : /  |\\\" +\r\n\\t\\\"\\\r\n                              :   :`  /\\\" +\r\n\\t\\\"\\\r\n                               \\\\\\\\     .                 ________________\\\" +\r\n\\t\\\"\\\r\n                                \\\\\\\\   :.                |  喜  辞  旧  岁 |\\\" +\r\n\\t\\\"\\\r\n                                .`     `.              ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\\" +\r\n\\t\\\"\\\r\n                               :     0   \\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                             ..`          ;\\\" +\r\n\\t\\\"\\\r\n                         . `           `.¯\\\" +\r\n\\t\\\"\\\r\n                       .`                :\\\" +\r\n\\t\\\"\\\r\n                    .`                   .\\\" +\r\n\\t\\\"\\\r\n                  .`                     :\\\" +\r\n\\t\\\"\\\r\n                 .    Happy New Year     .\\\" +\r\n\\t\\\"\\\r\n                .                     .`\\\" +\r\n\\t\\\"\\\r\n             .. `                  .`\\\" +\r\n\\t\\\"\\\r\n            :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n            `..`._____________::____)\\\"\r\nvar r5 = \\\"\\\r\n                                /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                               /  : /  |\\\" +\r\n\\t\\\"\\\r\n                              :   :`  /\\\" +\r\n\\t\\\"\\\r\n                               \\\\\\\\     .                 ________________\\\" +\r\n\\t\\\"\\\r\n                                \\\\\\\\   :.                |  喜  辞  旧  岁 |\\\" +\r\n\\t\\\"\\\r\n                                .`     `.              ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\\" +\r\n\\t\\\"\\\r\n                               :     0   \\\\\\\\         ____\\\" +\r\n\\t\\\"\\\r\n                             ..`          ;       | 兔 |\\\" +\r\n\\t\\\"\\\r\n                         . `           `.¯        | 跃 |\\\" +\r\n\\t\\\"\\\r\n                       .`                :        | 龙 |\\\" +\r\n\\t\\\"\\\r\n                    .`                   .        | 腾 |\\\" +\r\n\\t\\\"\\\r\n                  .`                     :        | 辞 |\\\" +\r\n\\t\\\"\\\r\n                 .    Happy New Year     .        | 旧 |\\\" +\r\n\\t\\\"\\\r\n                .                     .`          | 岁 |\\\" +\r\n\\t\\\"\\\r\n             .. `                  .`              ¯¯¯\\\" +\r\n\\t\\\"\\\r\n            :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n            `..`._____________::____)\\\"\r\nvar r6 = \\\"\\\r\n                                /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                               /  : /  |\\\" +\r\n\\t\\\"\\\r\n                              :   :`  /\\\" +\r\n\\t\\\"\\\r\n                               \\\\\\\\     .                 ________________\\\" +\r\n\\t\\\"\\\r\n                                \\\\\\\\   :.                |  喜  辞  旧  岁 |\\\" +\r\n\\t\\\"\\\r\n                                .`     `.              ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\\" +\r\n\\t\\\"\\\r\n                               :     0   \\\\\\\\         ____                ____\\\" +\r\n\\t\\\"\\\r\n                             ..`          ;       | 兔 |               | 龙 |\\\" +\r\n\\t\\\"\\\r\n                         . `           `.¯        | 跃 |               | 腾 |\\\" +\r\n\\t\\\"\\\r\n                       .`                :        | 龙 |               | 虎 |\\\" +\r\n\\t\\\"\\\r\n                    .`                   .        | 腾 |               | 跃 |\\\" +\r\n\\t\\\"\\\r\n                  .`                     :        | 辞 |               | 贺 |\\\" +\r\n\\t\\\"\\\r\n                 .    Happy New Year     .        | 旧 |               | 新 |\\\" +\r\n\\t\\\"\\\r\n                .                     .`          | 岁 |               | 春 |\\\" +\r\n\\t\\\"\\\r\n             .. `                  .`              ¯¯¯                  ¯¯¯\\\" +\r\n\\t\\\"\\\r\n            :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n            `..`._____________::____)\\\"\r\n\r\nvar r7 = \\\"\\\r\n                                /\\\\\\\\   /\\\\\\\\\\\" +\r\n\\t\\\"\\\r\n                               /  : /  |\\\" +\r\n\\t\\\"\\\r\n                              :   :`  /\\\" +\r\n\\t\\\"\\\r\n                               \\\\\\\\     .                 ________________\\\" +\r\n\\t\\\"\\\r\n                                \\\\\\\\   :.                |  喜  辞  旧  岁 |\\\" +\r\n\\t\\\"\\\r\n                                .`     `.              ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\\\" +\r\n\\t\\\"\\\r\n                               :     0   \\\\\\\\         ____                ____\\\" +\r\n\\t\\\"\\\r\n                             ..`          ;       | 兔 |               | 龙 |\\\" +\r\n\\t\\\"\\\r\n                         . `           `.¯        | 跃 |       2       | 腾 |\\\" +\r\n\\t\\\"\\\r\n                       .`                :        | 龙 |       0       | 虎 |\\\" +\r\n\\t\\\"\\\r\n                    .`                   .        | 腾 |       2       | 跃 |\\\" +\r\n\\t\\\"\\\r\n                  .`                     :        | 辞 |       3       | 贺 |\\\" +\r\n\\t\\\"\\\r\n                 .    Happy New Year     .        | 旧 |               | 新 |\\\" +\r\n\\t\\\"\\\r\n                .                     .`          | 岁 |               | 春 |\\\" +\r\n\\t\\\"\\\r\n             .. `                  .`              ¯¯¯                  ¯¯¯\\\" +\r\n\\t\\\"\\\r\n            :  ``             ;.  `、\\\" +\r\n\\t\\\"\\\r\n            `..`._____________::____)\\\"\r\n\r\nfunc main() {\r\n\\trabbits := []string{r1, r2, r3, r4, r5, r6, r7}\r\n\\tfor _, rabbit := range rabbits {\r\n                // 通过终端控制符进行清屏\r\n\\t\\t//fmt.Println(\\\"\\\\033c\\\")\r\n\\t\\tcmd := exec.Command(\\\"cmd\\\", \\\"/c\\\", \\\"cls\\\")\r\n\\t\\tcmd.Stdout = os.Stdout\r\n\\t\\tcmd.Run()\r\n\\t\\t// 打印图案\r\n\\t\\tfmt.Printf(\\\"%s\\\", rabbit)\r\n\\t\\ttime.Sleep(time.Millisecond * 500)\r\n\\t}\r\n}\r\n\r\n```\r\n- 首先，使用七个字符串变量，保存七个不同的图案，用于后续打印。\r\n- 其次，将七个字符串变量放入字符串切片里，后续易于操作。\r\n- 接下来，循环遍历切片，打印图案。\r\n    - 打印图案之前，先通过 `exec.Command` 函数，执行 `cls` 命令，达到在 `windows` 系统上清屏的效果。`cls` 的缺点就是清屏时会闪屏，而上面注释掉的一行代码是通过终端控制符进行清屏，基本上不闪烁，适用于 `linux` 终端，在 `windows` 的命令行模式下清屏无效。同时 `cls` 命令和终端控制符在码上掘金上也没有看到清屏的效果，如果读者有好的方法，请多多指教！\r\n- 打印一个图案之后，延时 `0.5` 秒后打印下一个图案，让肉眼可观察到整个过程。\r\n## 小结\r\n动一动手指，让小兔子在终端给大家拜年，简单又有趣。\r\n\r\n除了动手制作图案以外，本次创作遇到最大困难是如何在终端清屏时不闪烁。通过打印 `\\\\033c` 终端控制符进行清屏，基本上不闪烁，但是此操作在 `windows cmd` 终端下不起作用，无奈只能通过执行 `cls` 命令，达到清屏的效果。但是码上掘金上面，两种方式都没有达到清屏效果。\r\n\r\n> 新的一年，祝大家前兔似锦、谈兔不凡、颜值兔出、成绩兔出！"
    },
    {
        "article_id": "7174985128799076389",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b808570b5b1942dfbc92a483974a3c52~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Flutter 的下一步， Dart 3 重大变更即将在 2023 到来",
        "preview": "在过去的四年里 Dart 已经发展成为一门高效、可移植的现代化语言，而下一个版本 Dart 3 将达到可靠的 null 安全语言的最后一步。",
        "author": "恋猫de小郭",
        "view_count": 11980,
        "collect_count": 30,
        "comment_count": 38,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/527994262adc861f9291cad601e7ef8b~300x300.image",
        "category": "Android",
        "content": "---\r\ntheme: smartblue\r\n---\r\n\r\n\r\n> 原文链接 <https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa>\r\n\r\n在过去的四年里 Dart 已经发展成为一门高效、可移植的现代化语言，**而下一个版本 Dart 3 将达到可靠的 null 安全语言**的最后一步。\r\n\r\n作为 null safety 的最后一步，本次将删除几个历史 Dart 和 SDK artifacts，包括**删除对 running without sound null safety 的支持**。\r\n\r\n> 如今许多现代编程语言都支持 null safety ，比如 Swift、C# 和 Kotlin 等语言，可以在其中将变量声明*为非空*（*永远不能*保持空值）或可为*空*（可以保存一个值或 null）的情况，这些类型系统会和静态分析结合使用，以检测将 null 赋值给不可为 null 的变量。\r\n\r\n同样，Dart 语言中的 null 安全支持默认情况下使变量不可为 null，并且仅在显式声明时才允许 null。\r\n\r\n# 在 Dart 3 中，所有 Dart 代码都将使用健全的空安全\r\n\r\n自从 Dart 2.12 引入空安全到现在已经三年了，在此期间开发者可以在没有 null safety 的情况下运行，也可以在具有部分 null safety 的混合模式下运行，也可以在具有完全健全的 null safety 的情况下运行。\r\n\r\n> 当 100% 的代码（包括所有依赖项）已迁移到 null safety 时，就会出现完全可靠的空安全支持，在此期间 Dart 开发人员有时间一步一步地迁移现有代码，但是支持多种模式会增加开销和复杂性。\r\n\r\n首先，Dart 开发人员需要了解以上三种模式，每当阅读一段 Dart 代码时，就必须检查语言版本以查看类型是否默认为非空、默认可为空或它们的某种组合。\r\n\r\n其次，**在我们的编译器和运行时支持所有三种模式会减慢 Dart SDK 的发展速度，这种支持增加了添加新功能的成本和复杂性**。\r\n\r\n从在 Dart 3 开始，[正如之前 2.18 里](https://juejin.cn/post/7137874832988831751)提前宣布的那样，sound null safety 将是[唯一受支持的模式](https://github.com/dart-lang/sdk/issues/49530)，**小于 2.12 的 SDK 约束的 Pubspec 文件将在 Dart 3 及更高版本中停止解析。\r\n\r\n> 当开发者将依赖约束设置为小于 2.12（例如`// @dart=2.9`）时，任何包含语言标记的源代码都将失效。\r\n\r\n根据目前的观测，我们相信此时大约 **85% 的 flutter run 执行都使用了空安全，如果你还在剩余的 15% 中，那请在 Dart 3 发布之前[迁移](https://dart.dev/null-safety/migration-guide)，预计在 2023 年年中左右**。\r\n\r\n# Breaking 和 API 更改\r\n\r\n除了 null 安全更改之外，Dart 3 还进行了一些其他更改，以删除 Dart 和核心库 API 中的一些历史 artifacts，这些更改包括：\r\n\r\n-   删除已停用的核心库 API ( [#49529](https://github.com/dart-lang/sdk/issues/49529) )\r\n-   删除默认参数值的历史语法 ( [#2357](https://github.com/dart-lang/language/issues/2357) )\r\n-   要求明确的 tear-offs ( #[#2399](https://github.com/dart-lang/language/issues/2399) )。\r\n\r\n这些更改对迁移到使用 null 安全的代码的影响很小，当第一个 Dart 3 alpha 版本发布时，开发者可以快速测试这些较小的 Breaking。\r\n\r\n# Dart 3 的新特性和功能\r\n\r\nDart 3 也有望包含许多新功能，包括改进与其他编程语言的交互能力和新的语言特性， 这部分内容将在2023 年 1 月 25 日的 [Flutter Forward](https://flutter.dev/events/flutter-forward) 中详细讨论。\r\n\r\n例如有被称为 ***patterns*** 的语言特性，***patterns*** 让 Dart 语言更具表现力，增加了对更多结构化数据的支持，并使用代数数据类型实现了更实用的风格。\r\n\r\n以下代码显示了在一个函数上使用多个返回值的示例，以及将这些返回值解构为单个变量的能力：\r\n\r\n```\r\n// A function which returns a record -- in this case a pair of two doubles:\r\n(double x, double y) getLocation(String name) {\r\n if (name == 'Aarhus') {\r\n   return (56.1629, 10.2039);\r\n} else {\r\n  ...\r\n}\r\n}\r\n​\r\n// Deconstructing the returned record back into individual variables:\r\nvoid main(List<String> arguments) {\r\n final (lat, long) = getLocation('Aarhus');\r\n print('Current location: $lat, $long');\r\n}\r\n​\r\n// You can also define a hierarchy of classes, and then pattern match on those:\r\nsealed class Shape {\r\n double calculateArea();\r\n}\r\n​\r\nclass Square implements Shape {\r\n final double length;\r\n Square(this.length);\r\n double calculateArea() => length * length;\r\n}\r\n​\r\nclass Circle implements Shape {\r\n final double radius;\r\n...\r\n}\r\n​\r\ndouble calculateArea(Shape shape) => switch (shape) {\r\n Square(length: var l) => l * l,\r\n Circle(radius: var r) => math.pi * r * r\r\n};\r\n```\r\n\r\n# Beyond Dart 3\r\n\r\n目前除了 Dart 3 还有大量并行的潜在的新功能在处理，首先，正如[去年提到的](https://medium.com/dartlang/experimenting-with-dart-and-wasm-ef7f1c065577)， Dart 团队正在努力支持将 Dart 代码编译为 WebAssembly ( **Wasm** )，Wasm 能让 Flutter Web 在浏览器中作为完整的原生代码运行。\r\n\r\n这是一项艰巨的任务，除了更新 Dart 编译器之外还需要很多额外的工作。它需要与 W3C 和浏览器供应商合作，通过 [WasmGC ](https://github.com/WebAssembly/gc/blob/master/proposals/gc/Charter.md)扩展在 Wasm 中添加对垃圾收集语言的支持。\r\n\r\n其次 Dart 团队正在研究 **macros** 启用[静态元编程](https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md)，这种强大的机制允许一段代码（宏）在程序编译期间修改和扩展程序的源代码，**例如可以减少反序列化 JSON 或创建数据类所需的样板文件**。\r\n\r\n# Dart 3 发布路线\r\n\r\n接下来，Dart 3 将在一系列里程碑中陆续推出，目前的期望围绕这些日期\r\n\r\n-   **2023 年 1 月/2 月左右**：Dart 3 alpha 发布，它将专注于启用早期的 Dart 3 兼容性测试，目标是让大家能够运行静态分析 ( `dart analyze`/ `flutter analyze`)，理论上通过 Dart 3 alpha 静态分析的应用或包都可以支持 Dart 3 稳定版。\r\n-   **2023 年 3 月/4 月左右**：Dart 3 测试版发布，此版本预览了 Dart 3 中的新功能，开发者可以使用它来试验新功能并就问题或改进建议提供反馈。\r\n-   **2023 年年中左右**：Dart 3 稳定版发布，健全的空安全将成为唯一支持的模式。\r\n\r\n# 总结\r\n\r\nDart 3 版本计划于 2023 年年中左右发布，它将包含几项重大更改，其中主要是在没有健全的空安全的情况下你的代码将停止运行，**计划在 2023 年 1 月或 2 月左右准备好 Dart 3 alpha 版本，可以将其用于 Dart 3 兼容性测试**。\r\n\r\n在此期间你可以准备：\r\n\r\n-   完成任何未完成的[空安全迁移](https://dart.dev/null-safety/migration-guide)\r\n-   验证代码未使用任何已弃用的 API\r\n-   运行 `dart fix`。\r\n\r\nDart 3 还将包含几个新的强大功能，例如 patterns ，计划是希望在春季发布 Dart 3 beta 版，展示所有新功能，敬请期待～\r\n\r\n"
    },
    {
        "article_id": "7173170441824305188",
        "snapshot": "",
        "title": "无影Flutter for Web技术预研",
        "preview": "介绍 Flutter是Google推出并开源的跨平台开发框架，它采用Skia渲染并兼容了Android、iOS、Mac、Windows、Linux及Web，Flutter在2.0版本正式发布了对Web",
        "author": "幺风",
        "view_count": 1250,
        "collect_count": 17,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/aa87b9745b3dd8059a932ba982c6aae2~300x300.image",
        "category": "前端",
        "content": "\r\n## 介绍\r\n[Flutter](https://flutter.dev/)是Google推出并[开源](https://github.com/flutter)的跨平台开发框架，它采用Skia渲染并兼容了Android、iOS、Mac、Windows、Linux及Web，Flutter在2.0版本正式发布了对Web的支持\r\n\r\n\r\n![Flutter_for_Web技术预研_2022-11-22-20-52-34.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b52cfc6b5dc04b629057bc90b6f40bc2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nFlutter使用Dart开发，Dart本身能通过dart2js将Dart语言转成JavaScript。在Flutter中分为框架层和引擎层。框架层提供了布局渲染更新方式和手势等抽象能力，还提供了常用的组件。引擎层提供了平台差异的抽象同时也抹平了不同平台差异。Flutter for Web通过映射web平台API的代码来取代移动应用所使用的底层C++渲染引擎。\r\n\r\n[无影](https://free.aliyun.com/product/eds)本身是一个支持多端的产品，目前支持MacOS、Windows、零终端(Linux)、iOS、Android及[Web端](https://wuying.aliyun.com/polymerization)，目前PC三端都是通过同一个Flutter工程输出，iOS和Android因为逻辑与UI差异很大，没有使用跟PC端同一工程来开发，但是部分功能如登录逻辑也是通过与PC端引入同一个库的形式集成的。Web端一直采用的是纯Web开发，但目前无影的产品功能迭代很快，经常一个版本UI及功能都有重大变化，目前两端使用不同技术开发给我们开发周期及功能同步带来了很大的挑战。在我们Flutter项目将Flutter引擎升级到3.0.2的时机，提出了将我们Flutter项目转Web的需求，于是有了这次技术预研。\r\n## 现有网站案例\r\n\r\n- https://code.irobot.com/#/\r\n- https://www.omnichess.club/\r\n- https://rive.app\r\n- https://demo.invoiceninja.com/#/\r\n\r\n## 使用\r\n环境\r\n> Flutter: 3.0.2\r\n> MacOS: 12.0.1\r\n\r\n确保Flutter版本在2.0及以上，使用下面命令创建项目，默认会生成支持Web的项目结构\r\n```\r\nflutter create {PROJECTNAME}\r\n```\r\n如果想要对已有项目的支持，只需要控制台进入项目，执行\r\n```\r\nflutter create --platforms web .\r\n```\r\n想要知道项目是否支持Web，可以查看项目文件夹是否包含`web`文件夹，其默认生成的结构如下\r\n```\r\nweb\r\n├─ favicon.png \r\n├─ icons\r\n│    ├─ Icon-192.png\r\n│    ├─ Icon-512.png\r\n│    ├─ Icon-maskable-192.png\r\n│    └─ Icon-maskable-512.png\r\n├─ index.html  入口文件，通过引入编译后的JS渲染页面\r\n└─ manifest.json  配置PWA\r\n```\r\n> 注：icons里的图片是与PWA配合使用，当用户将项目安装到本地时([PWA](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps))，该图标会被当做启动图标使用\r\n\r\n然后我们就可以在控制台输入下面命令启动项目了\r\n```\r\nflutter run -d chrome\r\n```\r\n![Flutter_for_Web技术预研_2022-11-23-11-03-50.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aae292ae5794e4ca924b8ee6b1b33bc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 两种编译模式\r\nflutter提供了两种编译模式，分别适用于开发环境和生产环境。\r\n\r\n- flutterdev: 一种支持增量开发编译模式，可实现代码快速生效。当我们使用flutter run启动项目时就是使用的该方式，它可像开发客户端应用一样支持`hot reload`和`hot restart`。\r\n- dart2js: 它是一个优化的编译器，可以将Dart代码编译为快速、紧凑的JavaScript代码，可以极大提高代码的包大小及运行效率。\r\n\r\n## 渲染模式\r\nFlutter for Web提供了两种渲染模式，HTML和CanvasKit，我们在编译的时候可以选择不同的编译模式\r\n\r\n- auto（默认）自动选择要使用的渲染器。当应用程序在移动浏览器中运行时，此选项选择HTML渲染器，当应用程序在桌面浏览器中运行时，采用CanvasKit渲染器。\r\n- html 使用HTML渲染器。使用HTML元素、CSS、Canvas元素和SVG元素的组合来渲染。此渲染方式采用的包大小更小。\r\n- canvaskit 使用CanvasKit渲染器。使用`WebAssembly`与`WebGL`渲染，将得到与桌面端渲染的一致性，且相比HTML渲染有更高的性能。但是它相比HTML渲染会多7MB左右的包大小(当前使用[canvaskit0.33.0](https://unpkg.com/browse/canvaskit-wasm@0.33.0/bin/))。\r\n\r\n我们可以通过编译时传入参数来指定渲染模式\r\n```shell\r\nflutter run -d chrome --web-renderer html\r\nflutter build web --web-renderer canvaskit\r\n```\r\n或者在index.html中注入JavaScript的方式来指定渲染模式（只有编译时选择了auto才生效）\r\n```html\r\n<script type=\\\"text/javascript\\\">\r\n  window.flutterWebRenderer = \\\"html\\\"; //or\r\n  // window.flutterWebRenderer = \\\"canvaskit\\\";\r\n</script>\r\n```\r\nhtml模式相比canvaskit除了渲染性能更低，还有一些其它问题\r\n\r\n- 不支持`Image.toByteData`\r\n- 不支持`OffsetLayer.toImage`和`Scene.toImage`\r\n- 无法访问动画中的帧数据(Codec.getNextFrame,frameCount始终为1，repetitionCount始终为0)\r\n- 不支持`ImageShader`\r\n- 图像上使用shader功能支持有限\r\n- 图片无法控制内存，dispose回调不会执行（图片内存管理都被浏览器接管了）\r\n\r\n[CanvasKit](https://skia.org/docs/user/modules/canvaskit/)是一种采用`Skia`开发然后通过`WebAssembly`和`WebGL`渲染的技术。我们引入`canvaskit.js`和`canvaskit.wasm`包后，就可以通过JavaScript使用Skia API来绘制页面，[这里](https://skia.org/docs/user/modules/quickstart/)有一个简单的例子。\r\n\r\n## PWA\r\nFlutter转成Web后会默认会把项目编译成一个[PWA](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps)项目([学习资料](https://web.dev/learn/pwa/))，它会提供一个PWA WEB清单文件并生成一个`flutter_server_worker.js`文件，[Service Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)对Flutter内容进行缓存，当第一次加载完成后，再次请求资源下载都会走缓存。\r\n\r\n当我们在Chrome中打开一个PWA项目时，浏览器url右边会出现一个下载按钮，下载后Web应用会被当成一个类似客户端应用来使用。\r\n\r\n\r\n![Flutter_for_Web技术预研_2022-11-23-15-54-21.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/931d01239fd54bd790bef0db11120179~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n这就相当于一个简化版的无影客户端。\r\n\r\nFlutter默认启动了`PWA`，我们可以编辑`manifest.json`文件来更改项目配置，具体可以查看[Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest)来学习如何配置。\r\n\r\n当然如果我们不想使用`PWA`，可以在编译时添加`--pwa-strategy=none`命令来禁止使用它。\r\n\r\n## 平台兼容\r\n由于Web平台和MacOS、Windows、Linux平台差异很大，所以很多功能需要针对平台进行改造\r\n### 通过kIsWeb判断是否在Web平台\r\n跟在客户端使用`Platform.is*`不一样，Flutter是通过`kIsWeb`来识别是否在Flutter平台，它使用一种巧妙的方式通过比较0与0.0是否同一个值类型来实现的，因为在JavaScript中不区分double和int，而dart中是需要区分的。当我们使用`kIsWeb`时就像使用`Platform.is*`一样，如\r\n```dart\r\nString getPlatformName() {\r\n  if (kIsWeb) {\r\n    return 'Flutter Web';\r\n  } else if (Platform.isMacOS) {\r\n    return 'MacOS';\r\n  }\r\n}\r\n```\r\n在Web环境中，使用`Platform`会在运行时报错导致代码执行中断([issue](https://github.com/flutter/flutter/issues/36126))，如果项目要兼容Web平台，需要将项目中的`Platform.is*`代码都改成兼容代码。你可以自己封装一个类来兼容，如\r\n```dart\r\nimport 'package:flutter/foundation.dart';\r\nclass MYPlatform {\r\n  static final bool isMacOS = !kIsWeb && defaultTargetPlatform == TargetPlatform.macOS;\r\n  static final bool isAndroid = !kIsWeb && defaultTargetPlatform == TargetPlatform.android;\r\n  static final bool isIOS = !kIsWeb && defaultTargetPlatform == TargetPlatform.iOS;\r\n  static final bool isFuchsia = !kIsWeb && defaultTargetPlatform == TargetPlatform.fuchsia;\r\n  static final bool isWindows = !kIsWeb && defaultTargetPlatform == TargetPlatform.windows;\r\n  static final bool isLinux = !kIsWeb && defaultTargetPlatform == TargetPlatform.linux;\r\n  static final bool isWeb = kIsWeb;\r\n}\r\n```\r\n使用`MYPlatform.is*`来全局替换`Platform.is*`。\r\n\r\n或者可以引入一个三方库[universal_platform](https://pub.dev/packages/universal_platform)，然后使用`UniversalPlatform.is*`来替换`Platform.is*`。\r\n\r\n顺便提一下，在客户端工程中引入`dart:html`也会报找不到的错误，我们同样可以引入[universal_html](https://pub.dev/packages/universal_html)解决。\r\n\r\n### 有条件导入与导出文件\r\nFlutter提供了导入导出时通过条件判断来支持不同平台引入不同实现。[官方文档](https://dart.dev/guides/libraries/create-library-packages#conditionally-importing-and-exporting-library-files)\r\n```dart\r\nimport 'package:flutter3_demo/ffi/show_image_platform_interface.dart'\r\n    if (dart.library.io) 'show_image_io.dart'\r\n    if (dart.library.html) 'show_image_web.dart';\r\n```\r\n通过这样的代码在静态编译时会默认引入`show_image_platform_interface.dart`代码，当在开发或者打包编译时，如果是Native项目，会引入`show_image_io.dart`文件，如果是Web项目，会引入`show_image_web.dart`文件。需要注意的是，我们需要在`show_image_io.dart`和`show_image_web.dart`拥有相同名称的类与方法或者变量。\r\n\r\n这种方式是通过检查`dart:*`库是否存在实现的，比如在客户端应用程序中会导入`dart:io`库，所以相应的上面会导入`show_image_io.dart`，Web程序中会导入`dart:html`，所以会导入`show_image_web.dart`文件。\r\n\r\nlibrary的[导入规则](https://dart.dev/guides/libraries)(部分库在Flutter中不会被引入，所以没列出来)\r\n\r\n- Core: dart:core, dart:async, dart:collection, dart:convert, dart:developer, dart:math, dart:typed_data\r\n- Native Platform: dart:ffi, dart:io, dart:isolate\r\n- Web: dart:html, dart:js, dar:js_util, package:js\r\n### Federated plugin\r\n[文档](https://docs.flutter.dev/development/packages-and-plugins/developing-packages)\r\n\r\nFlutter提供了一种新的插件开发方式`Federated plugin`，我们可以在插件的`pubspec.yaml`文件中指定对应的平台实现\r\n```yaml\r\nflutter:\r\n  plugin:\r\n    platforms:\r\n      android:\r\n        package: com.example.hello\r\n        pluginClass: HelloPlugin\r\n      ios:\r\n        pluginClass: HelloPlugin\r\n      macos:\r\n        pluginClass: HelloPlugin\r\n      web:\r\n        pluginClass: HelloPlugin\r\n        fileName: hello_web.dart\r\n\r\nenvironment:\r\n  sdk: \\\">=2.1.0 <3.0.0\\\"\r\n  flutter: \\\">=1.12.0\\\"\r\n```\r\n例如上面例子，我们可以针对`Web`平台单独实现`hello_web.dart`，在`hello_web.dart`中，我们需要对插件进行注册。\r\n```dart\r\nclass HelloPluginWindows extends HelloPluginPlatform {\r\n  static void registerWith() {\r\n    HelloPluginPlatform.instance = HelloPluginWindows();\r\n  }\r\n  //...\r\n}\r\n```\r\n更多例子可以参考官方插件[url_launcher](https://github.com/flutter/plugins/blob/main/packages/url_launcher/url_launcher/pubspec.yaml)的实现。\r\n## Dart与JavaScript互调\r\n虽然现在Flutter生态很好，有很多三方库可以使用，但是相比Web生态还是差太多了，在使用`Flutter`开发时能够与`JavaScript`的函数互调是一个比较重要的能力。Flutter提供了`dart:js_utils`和`dart:js`工具来与Web端的`JavaScript`互相调用。\r\n\r\n### Dart调用JavaScript\r\n在web文件夹下新建`hello.js`\r\n```JavaScript\r\nlet i = 0;\r\n// 同步函数\r\nwindow.bindHello = (args) => {\r\n  alert(`Hello ${args}`);\r\n  return i++ % 2 == 0;\r\n}\r\n// 异步函数\r\nwindow.bindHelloAsync = (args) => {\r\n  return new Promise((resolve) => {\r\n    alert(`Hello ${args}`);\r\n    resolve(i++ % 2 == 0);\r\n  })\r\n}\r\n```\r\n上面创建了一个同步函数和异步函数，分别演示Dart调用JavaScript的同步函数和异步函数方式。我们需要把函数绑定到window上，Dart才能通过window拿到函数。\r\n\r\n在`index.html`中引入`hello.js`\r\n```html\r\n<script src=\\\"hello.js\\\" defer></script>\r\n```\r\n然后在Dart中分别调用同步函数和异步函数\r\n```dart\r\nimport 'dart:html' as html;\r\nimport 'dart:js' as js;\r\nimport 'dart:js_util' as js_util;\r\nclass CallJS {\r\n  static bool callHello() {\r\n    bool result = js.context.callMethod('bindHello', ['Flutter Web Sync']);\r\n    return result;\r\n  }\r\n\r\n  static Future<bool> callHelloAsync() async {\r\n    var result = js_util\r\n        .callMethod(html.window, 'bindHelloAsync', ['Flutter Web Async']);\r\n    bool returnObj = await js_util.promiseToFuture<bool>(result);\r\n    return returnObj;\r\n  }\r\n}\r\n```\r\nDart调用JavaScript有两种方式，可以通过`js.context.callMethod(Object method, [List<dynamic>? args])`或者`js_util.callMethod(html.window,Object method, [List<dynamic>? args])`，`js.context`在Web端相当于`window`。\r\n\r\n当我们调用`callHello`时，就能拿到`JavaScript`执行后的返回结果，调用`callHelloAsync`时能拿到`JavaScript`异步的执行结果\r\n\r\n### JavaScript调用Dart\r\n#### 同步\r\n可以通过`js_util.setProperty`来提供`JavaScript`调用`Dart`能力，例如\r\n```dart\r\nimport 'dart:html' as html;\r\nimport 'dart:js' as js;\r\nimport 'dart:js_util' as js_util;\r\nvoid bindJS() {\r\n  js_util.setProperty(html.window, \\\"callHello\\\", js.allowInterop((args) {\r\n        return '$args from dart';\r\n      }));\r\n}\r\n```\r\n我们可以通过`setProperty`第三个参数可以是值类型、数组(`js.JsArray`)、对象(`js.JsObject`)等，我们可以通过使用`js.allowInterop`将Dart函数转成JavaScript函数。\r\n\r\n然后在JavaScript中调用\r\n```JavaScript\r\nwindow.callHello('Flutter');\r\n```\r\n#### 异步\r\nFlutter并没有提供异步JavaScript调用Dart的方式，但我们可以通过使用`Dart`调`JavaScript`的能力间接达到异步能力。\r\n\r\nDart代码：\r\n```dart\r\njs_util.setProperty(html.window, \\\"callHelloAsync\\\",\r\n        js.allowInterop((returnName, arg) async {\r\n    // do some thing async\r\n    console.log(arg); // 接收参数\r\n    await Future.delayed(Duration(milliseconds: 1000));\r\n    js.context.callMethod(returnName, ['Result from Dart']);\r\n}));\r\n```\r\nJavaScript代码\r\n```JavaScript\r\nfunction callDartAsync() {\r\n  return new Promise((resolve) => {\r\n    window.callHelloAsync('callResult', 'hello');\r\n    window.callResult = (args) => {\r\n      resolve(args);\r\n      window.callResult = null;\r\n    }\r\n  })\r\n}\r\n```\r\n这样`JavaScript`调用`callDartAsync`函数就能拿到Dart异步执行后返回的结果了。\r\n## 首屏加载\r\n### 资源下载\r\n当Flutter项目转成web后有几个文件比较大\r\n1. main.dart.js 2.0+ MB\r\n2. canvaskit.wasm 7.0 MB\r\n3. MaterialIcons-Regular.otf 等字体或图标文件\r\n\r\nFlutter提供了一系列JavaScript API来控制整个资源下载及加载过程，在`index.html`默认会生成这样的函数调用\r\n```JavaScript\r\nwindow.addEventListener('load', function (ev) {\r\n    // flutter.js加载完成，开始下载main.dart.js资源\r\n    _flutter.loader.loadEntrypoint({\r\n      serviceWorker: {\r\n          serviceWorkerVersion: serviceWorkerVersion,\r\n      }\r\n    }).then(function (engineInitializer) {\r\n      // 加载main.dart.js，下载canvaskit.js canvaskit.wasm 及字体资源\r\n      return engineInitializer.initializeEngine();\r\n    }).then(function (appRunner) {\r\n      // 启动引擎，渲染界面\r\n      return appRunner.runApp();\r\n    }).then(() => {\r\n      // load end\r\n    });\r\n});\r\n```\r\n当index.html开始加载到第一帧显示，Flutter提供了一系列加载函数并加载\r\n\r\n- window.addEventListener('load'): index.html中的flutter.js文件下载成功\r\n- loadEntrypoint: 下载favicon.png、main.dart.js、manifest.json等文件\r\n- initializeEngine: 加载main.dart.js，下载canvaskit.js、canvaskit.wasm、FontManifest.json、MaterialIcons-Regular.otf等项目中使用的资源\r\n- runApp: 运行app\r\n\r\n我针对该过程测试了大致的时间消耗\r\n\r\n| 网速         | begin(s) | load(s) | loadEntrypoint(s) | initializeEngine(s) | runApp(s) |\r\n| ------------ | -------- | ------- | ----------------- | ------------------- | --------- |\r\n| 4G(4Mb/s)    | 0        | 0.22    | 9.96              | 31.346              | 31.447    |\r\n| WIFI(30Mb/s) | 0        | 0.12    | 2.115             | 6.645               | 6.645     |\r\n| 比例(%)      | 0        | 5       | 26                | 67                  | 2         |\r\n\r\n这样，我们就可以根据上面的Web资源加载函数配合上表的每一段函数执行时间比例做一个首屏资源加载进度条来提高用户体验。如果在我们Flutter Web页面前面还有其它Web页面，也可以利用这些API对资源进行预加载。\r\n\r\n### 拆分文件\r\n整个项目都打包到一个文件中，会使首次下载文件变大，Flutter提供了一些方式来拆分文件，只有在加载对应的页面时才下载对应文件，[相关资料](https://github.com/flutter/flutter/issues/50196)\r\n\r\n代码方案\r\n```dart\r\nimport 'mywidget.dart' deferred as foo\r\nfinal Future<void> loadedLibrary = foo.loadLibrary();\r\nWidget build(BuildContext context) {\r\n  return FutureBuilder(future: loadedLibrary, builder:(context, snapshot) { return foo.MyWidget(); });\r\n}\r\n```\r\n我们可以使用`deferred as`来引入其它文件，拿到的`foo`会有一个`loadLibrary`函数，它返回一个Future，当这个Future返回时，就能拿到引入文件的具体函数并执行了。\r\n\r\n`flutter build web`后，会在文件夹中生成一个`main.dart.js_x.part.js`文件，它会在Flutter调用上面`FutureBuilder`时才下载文件并加载。一般情况下，我们可以使用它对不同页面进行路由拆分以获得最大收益。\r\n\r\n## 路由兼容\r\n传统的路由方式也能在Flutter Web上使用，但是不会更新浏览器的url，所以需要针对传统路由进行兼容处理。\r\n\r\n### 方案1: 升级到Navigaoion2.0并添加兼容URI调整\r\nNavigator2.0网络上有很多文章及教程，展开讲很啰嗦。可以参考[Flutter Navigator 2.0 for Authentication and Bootstrapping](https://medium.com/flutter-community/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849)，它是一篇关于Navigator 2.0使用系列文章，[最后一篇](https://medium.com/geekculture/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df)讲的是Web适配。\r\n\r\n### 方案2：使用go_router\r\n[go_router](https://pub.dev/packages/go_router)是Flutter官方基于Navigator 2.0出的一个响应式的三方库，它提供了更多路由通用功能，相比我们直接使用`Navigator 2.0`，很多功能不需要再重复造轮子。\r\n```dart\r\nimport 'package:go_router/go_router.dart';\r\n\r\n// GoRouter configuration\r\nfinal _router = GoRouter(\r\n  initialLocation: '/',\r\n  routes: [\r\n    GoRoute(\r\n      path: '/',\r\n      builder: (context, state) => HomeScreen(),\r\n    ),\r\n    GoRoute(\r\n      path: '/users/:userId',\r\n      builder: (context, state) => const UserScreen(id: state.params['userId']),\r\n    )\r\n  ],\r\n);\r\nclass MyApp extends StatelessWidget {\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp.router(\r\n      routerDelegate: _router.routerDelegate,\r\n      routeInformationParser: _router.routeInformationParser,\r\n    );\r\n  }\r\n}\r\n```\r\n然后可以通过\r\n```dart\r\ncontext.go('/users/123')\r\n//或者\r\nGoRouter.of(context).push('/users/123');\r\n```\r\n进行路由跳转。\r\n\r\n更多可以点击[这里](https://pub.dev/documentation/go_router/latest/index.html)。\r\n\r\n## 浏览器兼容性\r\n\r\n- Chrome: 84版本及以上\r\n- Firefox: 72.9版本及以上\r\n- Safari: 9及以上（对应MacOS10.11)\r\n- Edge: 1.2.0及以上\r\n\r\n## 疑难问题记录\r\n1. 构建的项目中通过`https://unpkg.com/canvaskit-wasm@0.33.0/bin/`来引入`canvaskit.js`和`canvaskit.wasm`\r\n\r\n相关[issue](https://github.com/flutter/flutter/issues/70101)\r\n\r\n如果使用`canvasKit`渲染模式构建web，会引入`canvaskit.js`和`canvaskit.wasm`文件，默认它会指向一个默认的cdn地址，这个cdn地址可能在国内无法访问，解决办法是在index.html中添加script脚本指定文件地址\r\n```JavaScript\r\nwindow.flutterConfiguration = {\r\n    canvasKitBaseUrl: \\\"/canvaskit/\\\" // 指向本目录的canvaskit文件夹下，编译会自动生成该文件；或者指向自己的CDN地址\r\n};\r\n```\r\n或者在构建时指定\r\n```\r\nflutter build web --web-renderer canvaskit --dart-define=FLUTTER_WEB_CANVASKIT_URL=/canvaskit/\r\n```\r\n\r\n2. 构建未生成`flutter.js`文件和`canvaskit`文件夹\r\n\r\n如果构建未指定构建类型，可能会使用html渲染方式构建，所以需要构建时指定`flutter build web --web-renderer canvaskit`\r\n\r\n3. 构建后项目中会有一个字体文件指向了如`https://fonts.gstatic.com/s/roboto/`等地址\r\n\r\n相关[issue](https://github.com/flutter/flutter/issues/77580)，解决方案是先去[Roboto](https://fonts.google.com/specimen/Roboto)下载字体文件导入到项目中，然后在项目pubspec.yaml中引入\r\n```yaml\r\nflutter:\r\n  fonts:\r\n    - family: Roboto\r\n      fonts:\r\n        - asset: assets/Roboto-Regular.ttf\r\n```\r\n\r\n## 总结\r\n目前Flutter for Web逐渐趋于成熟，但是它本身还有一些问题\r\n\r\n1. 首次下载资源文件太大\r\n2. 无法友好支持搜索引擎SEO\r\n3. 与客户端API有兼容差异，工程化考验开发者能力\r\n\r\n相应的也有一些好处\r\n\r\n1. 支持PWA\r\n2. 如果已有Flutter客户端工程，只需要维护一套代码\r\n\r\n所以这些问题和收益需要团队自己去衡量。这次预研也有很多收获，如果后续在我们工程中应用，我再来分享我们在工程中遇到的挑战与实战干货。\r\n\r\n## 参考资料\r\n1. [Flutter Dev](https://docs.flutter.dev/development/platform-integration/web/faq)\r\n2. [Dart Dev](https://dart.dev/web)\r\n3. [Flutter Web 支持现已进入稳定版](https://zhuanlan.zhihu.com/p/355976725)\r\n4. [Flutter For Web多端一体化开发和原理分析](https://mp.weixin.qq.com/s/rxapVTJIGfnqCNzB3S7C4Q)"
    },
    {
        "article_id": "7186635257285148732",
        "snapshot": "",
        "title": "Git 之命令行工具",
        "preview": "引言 本文介绍常用的命令行工具以及常用的 Git 命令，让读者熟练掌握命令行下 Git 的使用，享受命令行编程的乐趣。本文适合使用过 Git，最好熟悉 但是对其在命令行下使用不熟悉的读者，读者最好对 ",
        "author": "郁乎文",
        "view_count": 5118,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afe48e9ad8d548~tplv-t2oaga2asx-image.image",
        "category": "开发工具",
        "content": "# 引言\r\n\r\n本文介绍常用的命令行工具以及常用的 Git 命令，让读者熟练掌握命令行下 Git 的使用，享受命令行编程的乐趣。本文适合使用过 Git，最好熟悉 但是对其在命令行下使用不熟悉的读者，读者最好对 vim 操作有一定的了解。\r\n\r\n# 软件安装\r\n\r\n### Iterm2\r\n\r\n[iTerm2 - macOS Terminal Replacement](https://iterm2.com/)是一个 Mac 下的终端工具。进入官网下载安装即可，下面是官网介绍。\r\n> iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.14 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.\r\n\r\n### Oh My ZSH\r\n\r\n[Oh My Zsh](https://ohmyz.sh/) 是一个轻量的、开源的、社区驱动管理 [zsh](https://www.zsh.org/) 配置的工具。下面是官网介绍。\r\n\r\n> Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration\r\n\r\n在命令行中执行下面的命令安装 Oh My ZSH，其他安装方式见 [oh my zsh github](https://github.com/ohmyzsh/ohmyzsh) 或者 [Oh My Zsh](https://ohmyz.sh/#install)。\r\n\r\n```shell\r\nsh -c \\\"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\\\"\r\n```\r\n\r\n### Oh My ZSH 插件\r\n\r\n安装好 Oh My ZSH 之后当前用户目录下会有一个配置文件叫做 `.zshrc`。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37275f7311d40468ce833b06daad852~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\r\n\r\n其中一行是我们的插件配置，使用的 `oh my zsh` 插件都必须添加进去，如下：\r\n\r\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6a3c5645bc42d79b7fe201293a5092~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n#### git 插件\r\n\r\n默认打开，无需配置，git 是后面的重要主题。\r\n\r\n#### Z 插件\r\n\r\n[Z](https://github.com/agkozak/zsh-z) 目录跳转插件。注意安装插件后，只有再次访问过的目录才会被 Z 识别。添加到 `oh my zsh` 的配置文件 `～/.zshrc` 中，见插件配置。\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42ecb162b17a4b5e8cb9d5867f44e855~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\r\n\r\n如图，我们第一次使用 `z mytest` 没有进入 `mytest` 目录，当我们使用 `cd mytest` 以后再次尝试成功进入 `mytest` 。事实上我们使用 `z my` 和 `z test` 都是可以的。\r\n\r\n#### zsh-autosuggestions\r\n\r\n[zsh-autosuggestions](https://github.com/zsh-users/zsh-autosuggestions) 是一款命令行提示插件。使用下面的命令安装，并且添加到 `oh my zsh` 的配置文件 `～/.zshrc` 中，见插件配置。\r\n\r\n```\r\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\r\n```\r\n\r\n下图中用红色标出的灰色部分是提示部分。\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9757a590fe96417ba6f6e013fc312736~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"30%\\\" />\r\n\r\n#### git-open\r\n\r\n[git-open](https://github.com/paulirish/git-open) git-open 是一款快速在命令用浏览器快速打开当前 git 项目的的插件。使用下面命令进行安装，并且添加到 `oh my zsh` 的配置文件 `～/.zshrc` 中，见插件配置。\r\n\r\n```shell\r\ngit clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open\r\n```\r\n在仓库目录执行 `git-open` 浏览器就能帮你打开当前项目。\r\n\r\n### Git 命令行 gui\r\n\r\n[extrawurst/gitui](https://github.com/extrawurst/gitui) 是一款命令行 ui 工具。不是本文重点，作为推荐工具，感兴趣的朋友参见官网学习。效果图如下：\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e6f57432e74001868ab402acece9b2~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"80%\\\" />\r\n\r\n# Git\r\n\r\n## 基本设置\r\n\r\n### git config\r\n\r\n`git config` 命令用于设置 git 仓库的配置。全局配置文件在 `~/.gitconfig`，仓库的配置文件在 `you-repo/.git/config`。通常将自己的个人配置设置为全局的，公司的配置按照仓库设置。\r\n\r\n**配置用户名和邮箱**\r\n\r\n```shell\r\n# 仓库配置\r\ngit config  user.name \\\"your name\\\"\r\ngit config user.email 'yourname@gmail.cn'\r\n\r\n# 全局配置\r\ngit config --global user.name \\\"your name\\\"\r\ngit config --global user.email 'yourname@gmail.cn'\r\n```\r\n\r\n**配置拉取代码的合并模式**，git默认使用 merge 模式，当前本地和远程都有修改时，这种模式会生成新的不必要的提交，如下为原来 commit：\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c9a3294d5254726becd9fa4c85271a7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n执行 `git pull` 之后的 commit：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92ef25f29c04cd586e1366ee9ce929e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看到我们多了一个合并代码的提交，因为在同一个分支，这个合并提交很可能是我们不需要的。为此我们可以用下面的命令设置，建议设置为全局：\r\n\r\n```shell\r\ngit config --global pull.rebase true\r\n```\r\n\r\n## 重要命令\r\n\r\n接下来结合 `oh my zsh` 的 git 插件，着重介绍开发最常用 git 命令。git 插件的配置文件在 `～/.oh-my-zsh/plugins/git/git.plugin.zsh`，主要是对常用 git 命令进行别名。我们通过下列命令查询相关命令的别名：\r\n\r\n```shell\r\nalias | grep \\\"git commit\\\"\r\n```\r\n效果如下：\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00b9321d67864e6eb76fc2200ff33c6c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"50%\\\" />\r\n\r\n下面主要通过别名介绍相关命令。\r\n\r\n### git status\r\n\r\n查看当前仓库的状态。这个命令非常重要，每次执行操作前后都要看一下状态，当前状态是否适合执行命令和是否执行命令成功。\r\n\r\n```shell\r\ngst='git status'\r\n```\r\n\r\n### git commit\r\n\r\ncommit命令记录改变，主要掌握两个命令。\r\n\r\n命令一：提交一个修改到新的提交\r\n```shell\r\n# 别名\r\ngcam='git commit -a -m'\r\n\r\n# 实例\r\ngcam \\\"feat: this is a commit messsage\\\"\r\n```\r\n命令二：提交当前修改到前一个提交，并且不编辑提交消息。\r\n```shell\r\n# 别名\r\ngcan!='git commit -v -a --no-edit --amend'\r\n\r\n# 实例\r\ngcan!\r\n```\r\n\r\n### git checkout\r\n\r\n命令一：创建分支并切换\r\n\r\n```shell\r\n# 别名\r\ngcb='git checkout -b'\r\n\r\n# 实例\r\ngcb feat/user_module_dev\r\n```\r\n\r\n命令二：切换到某个分支或者提交\r\n\r\n```shell\r\n# 别名\r\ngco='git checkout'\r\n\r\n# 实例\r\ngc0 feat/user_module_dev\r\ngco 31c98c8\r\ngco - # 切回上一个分支\r\ngcm #切换到主分支\r\ngcd #切换到开发分支\r\n```\r\n### git log\r\n\r\n命令一：查看当前分支的 log\r\n\r\n```shell\r\n# 别名\r\nglol='git log --graph --pretty='\\\\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset'\\\\'\r\n\r\n# 实例\r\nglol\r\n```\r\n命令二：查看当前分支的 log，并且显示每次修改的文件。\r\n\r\n```shell\r\n# 别名\r\nglols='git log --graph --pretty='\\\\''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset'\\\\'' --stat'\r\n\r\n# 实例\r\nglols\r\n```\r\n\r\n### git diff\r\n\r\n命令一： 查看工作区的修改\r\n\r\n```shell\r\n# 别名\r\ngd='git diff'\r\n\r\n# 实例\r\ngd\r\n```\r\n\r\n命令二： 查看暂存区的修改\r\n\r\n```shell\r\n# 别名\r\ngds='git diff --staged'\r\n\r\n# 实例\r\ngds\r\n```\r\n\r\n### git show\r\n\r\n查看每次提交的内容\r\n\r\n```shell\r\n# 别名\r\ngsh='git show'\r\n\r\n# 实例\r\ngsh # 查看当前最新提交\r\ngsh HEAD # 同上，也可以用 gsh head\r\n\r\ngsh HEAD～1 # 查看次新提交，也可以用 gsh head^\r\ngsh HEAD～2 # 查看次次新提交，也可以用 gsh head^^\r\n```\r\n\r\n### git push\r\n\r\n命令一：强制推送代码到远程，有冲突时则拒绝。\r\n\r\n```shell\r\n# 别名\r\ngpf='git push --force-with-lease'\r\n\r\n# 实例\r\ngpf\r\n```\r\n\r\n命令二：将本地新分支推送到远程\r\n\r\n```shell\r\n# 别名\r\ngpsup='git push --set-upstream origin $(git_current_branch)'\r\n\r\n# 实例\r\ngpsup\r\n```\r\n\r\n### git reset \r\n\r\n命令一：git reset --hard\r\n此命令会丢弃修改，慎用。\r\n\r\n```shell\r\n# 别名\r\ngrhh='git reset --hard'\r\n\r\n# 实例\r\ngrhh # 丢弃工作区和暂存区的改动\r\ngrhh head^ # 丢弃最新的提交\r\ngrhh head^^ # 丢弃最新的和次新的提交\r\n\r\ngrhh 31c98 # 删除比 31c98 新的提交\r\n```\r\n\r\n命令一：git reset --soft\r\n\r\n```shell\r\n# 别名\r\ngrh='git reset'\r\n\r\n# 实例\r\ngrh --soft 31c98 # 将比 31c98 新的所有改动移动到暂存区，适合将许多个提交合并成一个的场景。\r\n```\r\n\r\n### git rebase\r\n\r\n前面介绍的命令都比较简单易学，下面开始介绍 `git rebase` 命令，它相对复杂，但是也相对重要很多。看看[Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)解释。\r\n\r\n> git-rebase - Reapply commits on top of another base tip\r\n\r\n一句话解释就是，将某些提交变基。看一个官方的例子。\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44b16b9fbbb64f09a7b82b9acbcdf152~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\ntopic 是基于 master 切出来的分支，已经有了 ABC 三个新的提交。现在 topic 分支想要更新 master 分支的代码，可以在 topic 上使用下面的命令。\r\n\r\n```shel\r\n# 别名\r\ngrb='git rebase'\r\ngrbm='git rebase $(git_main_branch)'\r\n\r\n# 实例\r\ngrb master\r\ngrbm\r\n```\r\n下面执行完成功之后的样子。\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8a3c007d644b448fb9b88293bf22e0~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n#### git rebase 有冲突的情况\r\n\r\ntopic 分支有多个领先 master 分支的提交，`git rebase` 是一个一个分别处理。比如上文所示，先处理 A 提交，没有冲突或者冲突处理完成以后再处理 B 提交，以此类推。下面介绍有冲突的情况。\r\n\r\n有一个名称为 rebase_main 的分支，最新提交如下：\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60615034cfcf4412a8ba7468ab20388b~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n另外有一个名称为 rebase_feat 的分支，最新提交如下：\r\n\r\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/623f8a4a926f4df097bb49d390395dfa~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n接下来在 rebase_feat 分支执行 `grb rebase_main`，结果如下。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e688c7b82e7048d9aaf4c877cc297b9a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"85%\\\" />\r\n\r\n根据 Git 提示，我们知道以下几点：\r\n\r\n- rebase 操作导致了文件内容冲突，文件名称为 README.md。\r\n- 我们必须手动解决冲突，并且标记冲突已经解决。\r\n- 解决冲突后，我们要使用 `git add` 表明已经解决了冲突，然后使用 `git rebase --continue` 命令告诉 Git 继续执行 rebase 操作。\r\n- 使用 `git rebase --skip` 命令丢弃当前冲突的提交，即 rebase_feat 分支的最新提交。\r\n- 使用 `git rebase --abort` 命令放弃本次 rebase 操作，回到之前的状态。\r\n\r\n下面我们开始解决冲突：\r\n\r\n第一步：查看冲突的文件，删除或者合并代码。\r\n\r\n合并之前\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92840dbd318246cea7de3ea471245442~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n怎么合并代码按照你的需求决定，可以选择只留下 rebase_main 分支的内容，或者只留下 rebase_feat 分支的内容，或者二者皆留下，或者二者皆丢弃，或者手动修改添加。\r\n\r\n合并以后\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c74d19606e40fea6e1d79662317bbb~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n第二步：执行 `git add`，如下图。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6691bbbc52d4b34a88784ea53fb8cbc~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"100%\\\" />\r\n\r\n第三步：执行 `git rebase --continue`，执行此操作会让你编辑提交信息。执行成功后如下图。\r\n\r\n<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b224c43a0962461883c2fa49653a4258~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"100%\\\" />\r\n\r\n如果 rebase_feat 分支多个新的提交，每个提交都有冲突，需要按照上述方式一个一个的解决。\r\n\r\n#### git rebase -i\r\n\r\n对从某个提交开始到最新的提交进行编辑、合并、改变顺序、删除等操作。有两种形式。\r\n\r\n第一种：`grbi 57cebe6`，不包含 `57cebe6` 提交。\r\n第二种：`grbi HEAD~3`，表示对最新的三个提交进行操作，这是比较常用的形式，下面着重对其进行介绍。\r\n\r\n首先查看一下目前的提交。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3c1b2a5598a4710981f5c2b6892f2d3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后执行 `grbi HEAD~3` 对最新的三个提交进行操作。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6426cb4514bb45a2be9a92c79fbd867f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n对照列出命令依次说明\r\n\r\n- pick，默认需要此提交，无变化。\r\n- reword，需要此提交，但是编辑提交信息。\r\n- edit，需要此提交，能编辑提交信息和提交内容，与 reword 差异见 [git rebase - what's the difference between 'edit' and 'reword' - Stack Overflow](https://stackoverflow.com/questions/30194796/git-rebase-whats-the-difference-between-edit-and-reword)\r\n- sqush，将当前提交合并到前一个提交，需要编辑提交消息。\r\n- fixup，和 sqush 类似，但是不需要编辑提交信息。\r\n- drop，删除此提交\r\n- 改变提交在文件中的位置，也即改变了提交在 git 中的位置。比如把提交 `150dc60` 和 `57cebe6` 在文件中的顺序就能改变它们在 git 中的顺序。\r\n\r\n以上是常用的命令，其他命令可以对照官网进行学习，下面以 `sqush` 为例，演示使用流程。\r\n\r\n第一步：编辑 `pick -> s`，然后保存。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e551121b7f4d56b26e301b6b038584~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第二步：进入信息重新编辑页面，编辑信息，然后保存。如果过程中发生冲突，按照 rebase 有冲突的情况进行解决。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6c422810855427ca2d5360a8475b3aa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n下面是最新两个提交的结果\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe36a238fdf4b38b5d659ae046f73cc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### git chery-pick\r\n\r\n`git chery-pick` 用于将一个或者多个提交应用到目前分支。如果有冲突，和 `git rebase` 的处理流程一样。\r\n\r\n主要有三个命令。\r\n\r\n```shell\r\n# 别名\r\ngcp='git cherry-pick' \r\ngcpa='git cherry-pick --abort'\r\ngcpc='git cherry-pick --continue'\r\n\r\n#实例\r\ngcp 150dc60 # 将提交 150dc60 应用于当前分支\r\ngcpa # 放弃当前操作\r\ngcpc # 解决冲突后，继续执行 cherry-pick 操作\r\n```\r\n\r\n# 总结\r\n- 所有别名只需要简单的记忆，忘记了就用 `alias | grep 'git commit'` 查询相关的功能。\r\n- `git rebase` 命令相对复杂，需要多体会，多实践。\r\n- 上述命令基本可以满足日常开发需要，也可以尝试 [gitui](https://github.com/extrawurst/gitui) 和 [tig](https://github.com/jonas/tig) 等命令行 ui。\r\n- 最好熟悉一下 `vim` 编辑文件的操作。"
    },
    {
        "article_id": "7188153510922289207",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f08ed1ee4b9242e3ad1fab45b50872a4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【HTML】【消失的花木兰】花木兰：三兔蹦迪走，安能辨我是兔子？",
        "preview": "某日，参军后的花木兰刚回到家乡，却不料遇上抓拿自己的官兵... 因此，花木兰变成兔子躲了起来，花木兰的命运是否...",
        "author": "南方者",
        "view_count": 1284,
        "collect_count": 9,
        "comment_count": 7,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/db3b09f9ca107d8843cee3fe8f4f0cd4~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: orange\r\nhighlight: monokai\r\n---\r\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\r\n# 前言\r\n（改编）<br>　　某日，参军后的花木兰刚回到家乡，却不料遇上抓拿自己的官兵... 因此，花木兰变成兔子躲了起来，你能否找到躲起来的花木兰呢？一起来拭目以待...\r\n# 一、游戏名称与游戏规则（玩法）\r\n## 游戏名称\r\n**花木兰：安能辨我是兔子**\r\n\r\n## 游戏规则（玩法）\r\n游戏的规则非常简单，游戏开始后，花木兰会变成兔子，会与另外两只一模一样的兔子进行交换位置。找到最后的花木兰所变的兔子的位置即可获胜！<br> 　　玩法如图所示（会有背景声音，也可进行关闭声音。）：\r\n\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bec688ea3914d6dacc5b2c7bdbff294~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"find-rabbit.gif\\\"  width=\\\"40%\\\"/></p>\r\n\r\n# 二、大体设计与代码讲解\r\n## 大体设计\r\n1. 首先，找素材（图片和音频）。弄个背景图，这里选择青青草地。（让兔子在进行跳跃起来的时候，能达到合理）\r\n2. 我们曾经玩过[躲包包的游戏](https://juejin.cn/post/7140398559156764703)，学习了互换位置的思路。我们在这个基础上实现平行移动互换位置，并且完成小幅度的跳跃即可。（代码中有注释）\r\n\r\n## 代码讲解\r\n由于代码也比较简单，而且也有注释；这里就直接上完整的代码啦~\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n\r\n<head>\r\n    <meta charset=\\\"UTF-8\\\">\r\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\r\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\r\n    <meta name=\\\"description\\\" content=\\\"花木兰：安能辨我是兔子, 南方者\\\">\r\n    <meta name=\\\"keywords\\\" content=\\\"花木兰：安能辨我是兔子, 南方者\\\">\r\n    <title>花木兰：安能辨我是兔子</title>\r\n    <link rel=\\\"shortcut icon\\\" href=\\\"./img/rabbit.png\\\" size=\\\"32x32\\\">\r\n</head>\r\n\r\n<body>\r\n    <div class=\\\"head\\\">\r\n        <h1>花木兰：安能辨我是兔子</h1>\r\n        <h1 style=\\\"color: red; cursor: pointer;\\\" onclick=\\\"gameStart()\\\">开始游戏</h1>\r\n        <h3 onclick=\\\"changeBGM()\\\">声音状态：<span id=\\\"bgmStatus\\\">开启</span>（点击这里可关闭）</h3>\r\n        <div style=\\\"font-size: medium; color: #919191;\\\">（注意：背景声音会有些大。）</div>\r\n    </div>\r\n    <div class=\\\"game\\\">\r\n        <div class=\\\"rabbit\\\" onclick=\\\"gameOver(0)\\\">\r\n            <div style=\\\"display: none;\\\" class=\\\"v-talk\\\">\r\n                <img src=\\\"./img/talk.png\\\" alt=\\\"\\\">\r\n            </div>\r\n            <img class=\\\"i-rabbit\\\" src=\\\"./img/rabbit.png\\\" alt=\\\"\\\" style=\\\"opacity: 1;\\\">\r\n        </div>\r\n        <div class=\\\"rabbit\\\" onclick=\\\"gameOver(1)\\\">\r\n            <div style=\\\"display: none;\\\" class=\\\"v-talk\\\">\r\n                <img src=\\\"./img/talk.png\\\" alt=\\\"\\\">\r\n            </div>\r\n            <img class=\\\"i-rabbit\\\" src=\\\"./img/rabbit.png\\\" alt=\\\"\\\" style=\\\"opacity: 1;\\\">\r\n        </div>\r\n        <div class=\\\"rabbit\\\" onclick=\\\"gameOver(2)\\\">\r\n            <div style=\\\"display: none;\\\" class=\\\"v-talk\\\">\r\n                <img src=\\\"./img/talk.png\\\" alt=\\\"\\\">\r\n            </div>\r\n            <!-- <img src=\\\"./img/Mulan.png\\\" alt=\\\"\\\" id=\\\"mulan\\\" style=\\\"opacity: 1;\\\"> -->\r\n            <!-- <img src=\\\"./img/rabbit.png\\\" alt=\\\"\\\"> -->\r\n            <img class=\\\"i-rabbit\\\" src=\\\"./img/rabbit.png\\\" alt=\\\"\\\" style=\\\"opacity: 1;\\\">\r\n        </div>\r\n    </div>\r\n\r\n    <!-- 信息弹窗框 （该初始模板来源地址：http://www.webkaka.com/tutorial/html/2021/1015185/）-->\r\n    <div class=\\\"modal-dialog\\\" id=\\\"modal-dialog\\\">\r\n        <div class=\\\"modal-header\\\">\r\n            <h2 id=\\\"modal-title\\\">提示框标题</h2>\r\n            <span class=\\\"btn-close\\\" onclick=\\\"closeModal()\\\">×</span>\r\n        </div>\r\n        <div class=\\\"modal-body\\\">\r\n            <p id=\\\"modal-content\\\">内容</p>\r\n        </div>\r\n        <div class=\\\"modal-footer\\\">\r\n            <span class=\\\"btn\\\" onclick=\\\"closeModal()\\\">确定</span>\r\n        </div>\r\n    </div>\r\n</body>\r\n\r\n</html>\r\n<script>\r\n    var isPlayBgm = true;\r\n    var talkList = document.getElementsByClassName(\\\"v-talk\\\");\r\n    // var mulan = document.getElementById(\\\"mulan\\\");\r\n    var imgList = document.getElementsByClassName('i-rabbit');\r\n    var isStart = false;\r\n    var isMove = false;\r\n    var answer = getRan(); // 随机生成木兰的位置，0,1,2\r\n\r\n    function getRan() {\r\n        return Math.floor(Math.random() * 3);\r\n    }\r\n    imgList[answer].src = \\\"./img/Mulan.png\\\"; // 设置为木兰\r\n    // console.log(\\\"init answer：\\\", answer)\r\n    // gameStart();\r\n    function gameStart() {\r\n        // console.log(mulan)\r\n        // console.log(\\\"answer：\\\", answer)\r\n        if (isStart || isMove) {\r\n            return;\r\n        }\r\n        var mulan = imgList[answer];\r\n        isStart = true;\r\n        isMove = true;\r\n        var count = 1;\r\n        talkList[answer].style.display = \\\"\\\";\r\n        talkList[answer].style.opacity = 0.8;\r\n        mulan.style.opacity = 1;\r\n        playBGM('./mp3/change.mp3');\r\n        // 播放木兰变身动画\r\n        var interval = setInterval(() => {\r\n            var opacity = mulan.style.opacity;\r\n            // console.log(opacity);\r\n            if (opacity <= 0) {\r\n                window.clearInterval(interval)\r\n                // 播放变身成兔子（“碰”的一声）\r\n                changeBody();\r\n                return;\r\n            }\r\n            opacity -= count * 0.28;\r\n            // console.log(opacity, count);\r\n            if (0.8 > opacity)\r\n                talkList[answer].style.opacity = opacity;\r\n            mulan.style.opacity = opacity;\r\n            count++;\r\n        }, 400);\r\n    }\r\n\r\n    function changeBody() {\r\n        var mulan = imgList[answer];\r\n        // console.log(mulan)\r\n        setTimeout(() => {\r\n            talkList[answer].style.display = \\\"none\\\";\r\n        }, 200)\r\n        setTimeout(() => {\r\n            mulan.src = \\\"./img/smoke.png\\\";\r\n            playBGM('./mp3/peng.mp3');\r\n            mulan.style.opacity = 0.8;\r\n        }, 300)\r\n        setTimeout(() => {\r\n            mulan.style.opacity = 1;\r\n            mulan.src = \\\"./img/rabbit.png\\\";\r\n            setTimeout(() => {\r\n                move(5); // 移动5次\r\n            }, 200);\r\n        }, 800)\r\n        changePointer(true);\r\n    }\r\n\r\n    // window.onload = function () { move(2); }\r\n\r\n    function move(sum) {\r\n        // 小兔跳动（移动）\r\n\r\n        // moveOne(imgList[0], imgList[1]);\r\n        var num = getRan();\r\n        while (answer == num) {\r\n            num = getRan();\r\n        }\r\n        moveOne(answer, num, sum);\r\n    }\r\n\r\n    function moveOne(p1, p2, sum) {\r\n        var node1 = imgList[p1], node2 = imgList[p2];\r\n        // console.log(\\\"p1:\\\", p1, \\\"p2:\\\", p2, \\\"answer:\\\", answer)\r\n        playBGM(\\\"./mp3/jump.mp3\\\");\r\n        var t1 = node1.offsetTop;\r\n        var l1 = node1.offsetLeft;\r\n        var t2 = node2.offsetTop;\r\n        var l2 = node2.offsetLeft;\r\n        // console.log(node1, node1.offsetLeft, node2, node2.offsetLeft)\r\n        // console.log(\\\"l1:\\\" + l1, \\\"t1:\\\" + t1, \\\" --- \\\", \\\"l2:\\\" + l2, \\\"t2:\\\" + t2);\r\n        var moveX = Math.abs(l1 - l2); // 取绝对值\r\n        var moveY = Math.abs(t1 - t2);\r\n        var translate1 = \\\"-webkit-transform:\\\";\r\n        var translate2 = \\\"-webkit-transform:\\\";\r\n        var translate1;\r\n        var translate2;\r\n        if (l1 >= l2) {\r\n            translate1 += \\\" translate(\\\" + String(moveX) + \\\"px,\\\";\r\n            translate2 += \\\" translate(\\\" + String(-moveX) + \\\"px,\\\";\r\n        } else {\r\n            translate1 += \\\" translate(\\\" + String(-moveX) + \\\"px,\\\";\r\n            translate2 += \\\" translate(\\\" + String(moveX) + \\\"px,\\\";\r\n        }\r\n        node1.classList.add(\\\"game-trans\\\");\r\n        node2.classList.add(\\\"game-trans\\\");\r\n        // console.log(translate2, translate1)\r\n        node1.style.cssText = translate2 + String(-100) + \\\"px);\\\"; // y轴进行范围性移动\r\n        node2.style.cssText = translate1 + String(-100) + \\\"px);\\\";\r\n\r\n        setTimeout(function () {\r\n            node1.style.cssText = translate2 + String(0) + \\\"px);\\\";\r\n            node2.style.cssText = translate1 + String(0) + \\\"px);\\\";\r\n            sum--;\r\n            setTimeout(function () {\r\n                // 这里瞬间变回原来的位置，实际上是并没有变化的。\r\n                // 主要是为了形成视觉上的切换，因此只需要记录最终位置即可。（即 anster 的最终值）\r\n                node1.classList.remove(\\\"game-trans\\\");\r\n                node2.classList.remove(\\\"game-trans\\\");\r\n                node1.style.cssText = \\\"translate(0px,0px)\\\";\r\n                node2.style.cssText = \\\"translate(0px,0px)\\\";\r\n            }, 800);\r\n            if (p1 == answer) {\r\n                answer = p2;\r\n            } else if (p2 == answer) {\r\n                answer = p1;\r\n            }\r\n            if (sum < 0) {\r\n                isMove = false;\r\n                return;\r\n            }\r\n            var num1 = getRan();\r\n            var num2 = getRan();\r\n            while (num2 == num1) {\r\n                num2 = getRan();\r\n            }\r\n            setTimeout(() => {\r\n                moveOne(num1, num2, sum);\r\n            }, 1000)\r\n        }, 300);\r\n    }\r\n\r\n\r\n    function changePointer(isPointer) {\r\n        var imgList = document.getElementsByTagName('img');\r\n        // 图片是否变鼠标滑入变小手\r\n        var txt = \\\"\\\";\r\n        if (isPointer) {\r\n            txt = \\\"pointer\\\";\r\n        }\r\n        for (img of imgList) {\r\n            // console.log(img)\r\n            img.style.cursor = txt;\r\n        }\r\n    }\r\n\r\n    function playBGM(url) {\r\n        if (!isPlayBgm) {\r\n            // 当前不开启\r\n            return;\r\n        }\r\n        //浏览器适用       \r\n        contextClass = window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext;\r\n        try {\r\n            var context = new contextClass();\r\n            var source = null;\r\n            var audioBuffer = null;\r\n            function stopSound() {\r\n                if (source) {\r\n                    source.stop(0); //立即停止\r\n                }\r\n            }\r\n            function playSound() {\r\n                source = context.createBufferSource();\r\n                source.buffer = audioBuffer;\r\n                source.loop = false;\r\n                source.connect(context.destination);\r\n                source.start(0); //立即播放    \r\n            }\r\n            function initSound(arrayBuffer) {\r\n                context.decodeAudioData(arrayBuffer, function (buffer) { //解码成功时的回调函数\r\n                    audioBuffer = buffer;\r\n                    playSound();\r\n                }, function (e) { //解码出错时的回调函数\r\n                    console.log('404', e);\r\n                });\r\n            }\r\n            function loadAudioFile(url) {\r\n                var xhr = new XMLHttpRequest(); //通过XHR下载音频文件\r\n                xhr.open('GET', url, true);\r\n                xhr.responseType = 'arraybuffer';\r\n                xhr.onload = function (e) { //下载完成\r\n                    initSound(this.response);\r\n                };\r\n                xhr.send();\r\n            }\r\n            //这里用来存储背景音乐的路径\r\n            loadAudioFile(url);\r\n        } catch (e) {\r\n            console.log('无法找到音乐！');\r\n        }\r\n    }\r\n\r\n    function changeBGM() {\r\n        var bgmStatus = document.getElementById(\\\"bgmStatus\\\");\r\n        // console.log(bgmStatus);\r\n        var txt = \\\"\\\";\r\n        if (isPlayBgm) {\r\n            isPlayBgm = false;\r\n            txt += \\\"关闭\\\";\r\n        } else {\r\n            isPlayBgm = true;\r\n            txt += \\\"开启\\\";\r\n        }\r\n        // console.log(txt)\r\n        bgmStatus.innerHTML = txt;\r\n    }\r\n\r\n    // 展开答案并且判断是否正确\r\n    function gameOver(id) {\r\n        if (!isStart || isMove) { // 游戏未开始 或 正在跳动\r\n            return;\r\n        }\r\n        var titleValue, contentValue;\r\n        // console.log(\\\"end answer：\\\", answer, id)\r\n        if (answer == id) {\r\n            playBGM(\\\"./mp3/victory.mp3\\\")\r\n            titleValue = \\\"胜利！\\\";\r\n            contentValue = \\\"恭喜你成功找到了变身的兔子！<br>成功拿下花木兰！\\\";\r\n        } else {\r\n            playBGM(\\\"./mp3/defeat.mp3\\\")\r\n            titleValue = \\\"失败！\\\";\r\n            var text = \\\"\\\";\r\n            switch (answer) {\r\n                case 0:\r\n                    text = \\\"第一个\\\";\r\n                    break;\r\n                case 1: text = \\\"中间\\\";\r\n                    break;\r\n                case 2: text = \\\"最后一个\\\";\r\n                    break;\r\n            }\r\n            contentValue = \\\"很抱歉，你找的并不是花木兰。<br>花木兰太狡猾了，她躲在了\\\" + text + \\\"！\\\";\r\n        }\r\n        showModalMsg(titleValue, contentValue);\r\n        imgList[answer].src = \\\"./img/Mulan.png\\\";\r\n        changePointer(false);\r\n        isStart = false;\r\n    }\r\n\r\n    // 显示弹窗框\r\n    function showModalMsg(titleValue, contentValue) {\r\n        var title = document.getElementById(\\\"modal-title\\\");\r\n        title.innerText = titleValue;\r\n        var content = document.getElementById(\\\"modal-content\\\");\r\n        content.innerHTML = contentValue;\r\n        var modal = document.getElementById(\\\"modal-dialog\\\");\r\n        modal.style.display = \\\"block\\\";\r\n    }\r\n    // 关闭弹窗框\r\n    function closeModal() {\r\n        var modal = document.getElementById(\\\"modal-dialog\\\");\r\n        modal.style.display = \\\"\\\";\r\n    }\r\n\r\n\r\n</script>\r\n<style>\r\n    .head {\r\n        position: fixed;\r\n        width: 100%;\r\n        text-align: center;\r\n    }\r\n\r\n    .head h1 {\r\n        font-size: -webkit-xx-large;\r\n    }\r\n\r\n    body {\r\n        /* 背景图设置 */\r\n        background: url(\\\"./img/bg.png\\\") no-repeat center center;\r\n        background-size: cover;\r\n        background-attachment: fixed;\r\n        margin: 0px;\r\n    }\r\n\r\n    body,\r\n    html,\r\n    .game {\r\n        height: 100%;\r\n        width: 100%;\r\n        /* margin: 50px; */\r\n    }\r\n\r\n    .game {\r\n        display: flex;\r\n        justify-content: space-around;\r\n    }\r\n\r\n    .rabbit {\r\n        display: flex;\r\n        /* 垂直居中 */\r\n        align-items: center;\r\n        /* 水平居中 */\r\n        justify-content: center;\r\n        /* 文字居中 */\r\n        text-align: center;\r\n        height: 100%;\r\n        width: 25%;\r\n        /* background: #000; */\r\n    }\r\n\r\n\r\n    img {\r\n        max-width: 100%;\r\n        max-height: 100%;\r\n    }\r\n\r\n    .game-trans {\r\n        transition: transform 0.5s linear 0s;\r\n    }\r\n\r\n    .modal-body {\r\n        padding: 20px;\r\n    }\r\n\r\n    .modal-header,\r\n    .modal-footer {\r\n        padding: 10px 20px;\r\n    }\r\n\r\n    .modal-header {\r\n        border-bottom: #eee solid 1px;\r\n    }\r\n\r\n    .modal-header h2 {\r\n        font-size: 20px;\r\n    }\r\n\r\n    .modal-footer {\r\n        border-top: #eee solid 1px;\r\n        text-align: right;\r\n    }\r\n\r\n    .modal-dialog {\r\n        display: none;\r\n        background: #fefefe;\r\n        border: #333 solid 1px;\r\n        border-radius: 5px;\r\n        margin-left: -180px;\r\n        margin-top: -50px;\r\n        position: fixed;\r\n        left: 50%;\r\n        top: 30%;\r\n        z-index: 11;\r\n        width: 360px;\r\n    }\r\n\r\n    .btn-close {\r\n        cursor: pointer;\r\n        color: #aaa;\r\n        font-size: 30px;\r\n        text-decoration: none;\r\n        position: absolute;\r\n        right: 5px;\r\n        top: 0;\r\n    }\r\n\r\n    .btn-close:hover {\r\n        color: #919191;\r\n    }\r\n\r\n    .btn {\r\n        cursor: pointer;\r\n        background: #428bca;\r\n        border: #357ebd solid 1px;\r\n        border-radius: 3px;\r\n        color: #fff;\r\n        display: inline-block;\r\n        font-size: 14px;\r\n        padding: 8px 15px;\r\n        text-decoration: none;\r\n        text-align: center;\r\n        min-width: 60px;\r\n        position: relative;\r\n        transition: color 0.1s ease;\r\n    }\r\n\r\n    .btn:hover {\r\n        background: #357ebd;\r\n    }\r\n\r\n    .v-talk {\r\n        position: fixed;\r\n        z-index: 10;\r\n        opacity: 0.8;\r\n    }\r\n</style>\r\n```\r\n# 仓库地址与体验地址\r\n　　这里代码片段展示（手机端、pc 端都可放心食用 ~ ）点击右上角可直达码上掘金!查看更完整的代码！\r\n<p align=center><br><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf59b54320b481bab882ff347d517e7~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  /></p>\r\n\r\n[代码片段](https://code.juejin.cn/pen/7188144496910008376)\r\n\r\n<br>　　大家可以直接来笔者的网站来体验<br>　　在线体验（pc端）：[**体验传送门**](https://game.nanfangzhe.cn/game/Mulan-rabbit/Mulan-rabbit.html)<br>　　仓库地址：暂无（想要的可以直接去扒笔者的网站[**传送门**](https://game.nanfangzhe.cn/game) ）\r\n\r\n\r\n\r\n# 以前的小游戏\r\n- [【HTML】【休闲益智】还有9块月饼并未获得！请及时出战！（解锁月饼小游戏 - 掘金 (juejin.cn)](https://juejin.cn/post/7142478453945106440)\r\n- [【微信小游戏】合成大灯笼 丨 2022🧭寻找暴富人🧧（首次个人小活动） - 掘金 (juejin.cn)](https://juejin.cn/post/7053331732669562888)\r\n- [【HTML】【休闲益智】真相？真香？只有一个！看看谁是大馋虫 or 贪吃鬼（找出真正吃了月饼的人 - 掘金 (juejin.cn)](https://juejin.cn/post/7142320789604270116)\r\n- [【HTML】【休闲益智】还有9块月饼并未获得！请及时出战！（解锁月饼小游戏 - 掘金 (juejin.cn)](https://juejin.cn/post/7142478453945106440)\r\n- [更多好玩的游戏](https://juejin.cn/column/7140398633710518302)\r\n\r\n## 文章小尾巴\r\n文章写作、模板、文章小尾巴可参考：[《写作“小心思”》](https://juejin.cn/post/7041996365487931423)\r\n<br>  　　感谢你看到最后，最后再说两点~<br>　　①如果你持有不同的看法，欢迎你在文章下方进行留言、评论。<br>　　②如果对你有帮助，或者你认可的话，欢迎给个小点赞，支持一下~<br>　　　**[我是南方者，一个热爱计算机更热爱祖国的南方人。](https://nanfangzhe.gitee.io/)**<br>　　（文章内容仅供学习参考，如有侵权，非常抱歉，请立即联系作者删除。）\r\n"
    },
    {
        "article_id": "7188168798753521701",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bfcbe0cf1b54e798fde2595c3edd912~tplv-k3u1fbpfcp-watermark.image?",
        "title": "不要阻碍浏览器 preload scanner 的运行",
        "preview": "我们都知道浏览器在渲染页面时候，其内部会帮开发者做各种优化，其中有一项就是`preload scanner`。通过这篇文章，我们可以了解什么是`preload scanner`，以及它是如何有助于性能",
        "author": "NuoHui",
        "view_count": 1091,
        "collect_count": 3,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/4852b9395d37390baffe3de20c9855cc~300x300.image",
        "category": "前端",
        "content": "# 不要阻碍浏览器 preload scanner 的运行\r\n\r\n我们都知道浏览器在渲染页面时候，其内部会帮开发者做各种优化，其中有一项就是`preload scanner`。通过这篇文章，我们可以了解什么是`preload scanner`，以及它是如何有助于性能的。\r\n\r\n\r\n## preload scanner 是什么？\r\n\r\n我们都知道浏览器解析页面时候正常是通过`html parser`  从上往下解析标签。直到解析器遇到一个阻塞资源时候会暂停往下解析。比如遇到加载样式表带`<link>`标签、或者是没有`async` or `defer`的`script`标签。\r\n\r\n![图1: 如何阻塞浏览器的 HTML 解析器的示意图。在这种情况下，解析器会遇到一个外部 CSS 文件的 < link > 元素，该元素阻塞浏览器解析文档的其余部分(甚至是渲染) ，直到下载并解析 CSS。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8ad644d1264ee5937a37d51c33d8d5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n在遇到外部css文件情况下，解析跟渲染都会被阻塞。因为阻塞了所以不会出现 `flash of unstyled content (FOUC)`的场景，简单理解就是如果不阻塞，继续往下解析渲染。那么就会导致从没有应用样式的状态突然跳变到应用样式的状态（因为你异步加载解析css去了）。\r\n\r\n\r\n![图2: FOUC 的模拟实例。左边是没有样式的 web.dev 的首页。右边是应用样式的相同页面。如果在下载和处理样式表时浏览器没有阻塞渲染，则未应用样式的状态可能会有跳变的过程。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d44bf9fc916642e082fb598cd1321e2c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当 `HTML Parser`遇到没有`async`或者`defer`属性的`script`标签时候，同样也会阻塞页面的解析与渲染。\r\n\r\n> 小知识：如果是`type = module`属性的`script`标签，默认相当于加了`defer`属性。(`defer`：异步加载，但是等浏览器解析完才会执行)\r\n\r\n浏览器之所以这么处理，是因为如果`html parser`继续工作，它不确定`js`脚本是否会去修改`dom`。这就是为什么我们一般建议在文档末尾去加载js脚本了。\r\n\r\n\r\n我们上面说的都是浏览器在遇到上述场景时候，应该阻塞解析跟渲染的理由。但是光靠阻塞也不是最终解决问题的好办法，它会影响后面其他重要资源的加载，比如图片。于是我们的主角登场了，浏览器通过一种叫`preloader scaner`的东西来辅助`html parser`解决上述问题。\r\n\r\n\r\n![图3: 描述preloader scanner 如何与HTML 解析器并行工作以推测加载资源的图。在这里，HTML 解析器在开始处理 < body > 元素中的图像标记之前加载并处理 CSS 时被阻塞，但是preloader scanner可以在原始标记标签中向前查找该图像资源，并在HTML 解析器解除阻塞之前开始加载它。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee106bd2cc0453ba3245875b34ad68d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n`preloader scaner`是推测性的，因为它是解析原始 `html`标签，以便在`html parse`之前提前发现需要加载的资源。\r\n\r\n## 如果判断 preloader scanner 是否正常工作\r\n\r\n我们通过一个人为的示例页面，https://preload-scanner-fights.glitch.me/artifically-delayed-requests.html，在这个html页面会引用一个外部css样式表，然后这个样式表我们通过人为给他引入了2s的延迟（为了更方便的看出css已经阻塞了解析跟渲染的执行，但是我们依旧提前下载到了jpg图片）。\r\n\r\n这里我们借助https://www.webpagetest.org/result/230113_BiDcK0_9ZX/1/details/#waterfall_view_step1，来辅助我们进行网络瀑布图的分析。\r\n\r\n\r\n![图4: 通过模拟3G 连接在移动设备上运行的 Chrome 网页的 WebPageTest 网络瀑布图。即使样式表在开始加载之前通过代理被人为地延迟了两秒钟，preloader scanner 也会发现稍后位子的图像资源。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c740fc61534cb3945572dcf2595b96~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n正如您在网络瀑布图看到的，即使文档解析和渲染被阻塞。`preloader scanner`还是发现 `< img >` 元素。如果没有这种优化，浏览器就不能在阻塞期间机会性地获取内容，\r\n\r\n接下来我们看看在什么场景下`preload scanner`会失效？以及如果避免这种失效。\r\n\r\n### 注入一个异步的脚本\r\n\r\n假设在你的 `< head > `标签中，其中包含一些内联的 JavaScript，如下所示:\r\n\r\n```html\r\n<script>\r\n  const scriptEl = document.createElement('script');\r\n\r\n  scriptEl.src = '/yall.min.js';\r\n\r\n\r\n  document.head.appendChild(scriptEl);\r\n\r\n</script>\r\n```\r\n\r\njs动态注入的脚本文件默认是`async`异步的。如果我们把这个内联的`script`放在`link`之后。那么我们会得到一个糟糕的结果。\r\n\r\n![该页面包含一个样式表和一个注入的异步脚本。preloader scanner无法在阻塞阶段发现脚本，因为脚本是在客户端上动态注入的。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca6ce0880f24baf82669e6c551d599d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其实也很好理解，我们之前说过`preloader scanner`它是通过解析`html`原始标签来进行推测，而我们是动态注入`script`标签，它肯定是推测不出来的。\r\n\r\n在上述图你也可以看到`动态js`是在2.6s(css下载解析后)后才可以下载、解析执行。所以js脚本被阻塞了，这可能会影响页面的交互时间(TTI)。而上面的img标签是可以被`preloader scanner`发现的。\r\n\r\n那如果我们改为外部引用js的方式呢？\r\n\r\n```html\r\n<script src=\\\"/yall.min.js\\\" async></script>\r\n```\r\n\r\n\r\n![该页面包含一个样式表和一个异步 < script > 元素。preloader scanner在阻塞阶段发现了脚本，并与 CSS 同时加载该脚本。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e08b0b82d8c74958a07b8c3933a28be5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当然聪明的同学可能提出另外一个方法，通过`rel = preload`属性来让浏览器预先加载资源。这个方案当然有用，但是它会带来别的副作用。最主要的是我们不应该用`hack`的方式来为一个错误的方案兜底。\r\n\r\n\r\n![页面包含一个样式表和一个注入的异步脚本，但是预先加载了异步脚本以确保更快地发现它](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddc18f0b4fce46d2b011466389bc4db1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们通过预加载方式hack的“修复”了这里的问题，但它引入了一个新问题: 前两个演示中的异步脚本(尽管在 < head > 中加载)以“低”优先级加载，而样式表以“最高”优先级加载。在预加载异步脚本的最后一个演示中，样式表仍然以“最高”优先级加载，但脚本的优先级已经提升到“最高”。导致 js脚本先于css被浏览器加载了。\r\n\r\n当资源的优先级提高时，浏览器会为其分配更多的带宽。这意味着ーー即使样式表具有最高的优先级ーー脚本提高的优先级可能会导致带宽占用。 如果这个js资源刚好特别大就会显得我们页面打开链接特别慢。\r\n\r\n所以最好就是`script`标签放在合适的位置，根据场景合理使用`async`与`defer`属性。\r\n\r\n\r\n\r\n### 使用 JavaScript 进行懒加载\r\n\r\n我们应该经常看到大家通过懒加载方式来加载图片吧。然而有时候可能会被我们误用。\r\n\r\n```html\r\n<img data-src=\\\"/sand-wasp.jpg\\\" alt=\\\"Sand Wasp\\\" width=\\\"384\\\" height=\\\"255\\\">\r\n```\r\n\r\n使`data-`前缀是 JavaScript 实现懒加载的一种常见模式。当图像滚动到可视区中时，延迟加载程序去掉 `data-`前缀，这意味着在前面的示例中，`data-src` 变成 `src`。提示浏览器获取资源。\r\n\r\n`preloader scanner`读取`data-src`这样的前缀属性跟读取`src`或者`srcset`属性处理不同，所以`preloader scanner`确实发现不了图片资源因此不会提前加载。所以正常情况下懒加载的使用没有问题。\r\n\r\n但是，假设如果一个图片按照上述的标签方式使用，而这个图像恰好又是在可视区中开始滚动。\r\n\r\n\r\n![图片资源是没有必要懒加载，这导致preload scanner失效了](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e5649cf8c5b4ed9b561efaa4a751f08~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果一个图片资源恰好是LCP的一个元素时候，不恰当的懒加载操作，可能是在页面的样式表阻止渲染时，LCP就会受到影响。\r\n\r\n对于懒加载图片，启动时候就处于`viewport`内的图片， 正确的解决方案如下：\r\n\r\n```html\r\n<img src=\\\"/sand-wasp.jpg\\\" alt=\\\"Sand Wasp\\\" width=\\\"384\\\" height=\\\"255\\\">\r\n```\r\n\r\n\r\n![预加载扫描器在 CSS 和 JavaScript 开始加载之前发现图像资源，这使浏览器在加载图像资源时有了先机](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe092f9d3504989820292afd7cc2b48~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n在这个简化的示例中，结果是在慢速连接上对 LCP 进行了100毫秒的改进。这可能看起来不像是一个巨大的改进，但是当你认为解决方案只是一个html属性的优化，并且大多数网页比这组例子更复杂的时候。这样的优化变得越来越重要。\r\n\r\n> 图像并不是唯一可能遭受次优延迟加载模式影响的资源类型。< iframe > 元素也可能受到影响，而且由于 < iframe > 元素可以加载许多子资源，因此性能的影响可能会严重恶化。\r\n\r\n### CSS 背景图片\r\n\r\n前面我们提到过`preloader scanner`只会扫描`row html makeup`，它不会扫描你的`css`文件，因此我们会想到如果在css文件内，把图片作为背景属性会怎么样。\r\n\r\n像 HTML 一样，浏览器将 CSS 处理成自己的对象模型，称为 CSSOM。如果在构造 CSSOM 时发现了外部资源，那么这些资源将在发现时被请求，而不是`preloader scanner`请求。\r\n\r\n假设页面的 LCP 元素是一个具有 CSS 背景图像属性的元素。下面是资源加载时发生的情况:\r\n\r\n\r\n![页面的 LCP 元素是一个具有 CSS 背景图像属性的元素(第3行)。在 CSS 解析器找到它之前，它请求的图像不会提前获取。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fdb205f6d9e4ae8beb374b671904c31~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在上面这种情况，`preloader scanner`就发挥不了作用了。那我们可能会想到另外一个解法：\r\n\r\n```html\r\n<!-- Make sure this is in the <head> below any\r\n     stylesheets, so as not to block them from loading -->\r\n<link rel=\\\"preload\\\" as=\\\"image\\\" href=\\\"lcp-image.jpg\\\">\r\n```\r\n\r\n> 如果您的 LCP 对象来自背景图像 CSS 属性，但是该图像根据视口大小而变化，则需要在 < link > 元素上指定 imagesrcset 属性。\r\n\r\n尽管`Rel = preload`的作用有限，但是它仍然可以帮助浏览器比其他方式更快地发现图像:\r\n\r\n\r\n![页面的 LCP 元素是一个具有 CSS 背景图像属性的元素(第3行)。Rel = preload 提示可以帮助浏览器比没有提示的情况下提前约250毫秒发现图像。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3d516147514b38b9fbc5d19dc7d858~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n使用 rel = preload 降低 LCP 时间。虽然这个提示有助于解决这个问题，但是更好的选择可能是评估图像作为 LCP 元素是否必须从 CSS 加载。使用 `< img >` 标记，您可以更好地控制加载适合视口的图像，同时允许`preloader scanner`发现它。\r\n\r\n\r\n### 内嵌了太多资源\r\n\r\n我们都知道内联引用也是常用的一种引用资源的方式，而且它比可能外部引用更快，因为它不需要发出网络请求。它就在文档中，并且可以立即加载。然而，它也有明显的缺点:\r\n\r\n- 如果不缓存 HTML ーー如果 HTML 响应是动态的，那么就不能缓存内联资源ーー那么内联资源永远不会被缓存。这会影响性能，因为内联资源不可重用。\r\n\r\n- 即使可以缓存 HTML，内联资源也不会在文档之间共享。与可以跨整个源缓存和重用的外部文件相比，这降低了缓存效率。\r\n\r\n- 如果内联资源过多，将延迟`preload scanner`扫描文档时候发现后面的资源，因为下载额外的内联内容需要更长的时间。\r\n\r\n以这个示例页面为例子https://preload-scanner-fights.glitch.me/inline-nothing.html，LCP 元素是页面顶部的图像，CSS 位于由 < link > 元素加载的单独文件中。该页面还使用了四种网页字体，这些字体在CSS 资源的文件中单独请求的。\r\n\r\n\r\n![页面的 LCP 元素是从 < img > 元素加载的图像，但是由preloade scanner发现，因为页面加载所需的 CSS 和字体位于单独的资源中，这不会延迟预加载扫描器的工作。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4c8a6987f7945598c286e8db446f972~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n现在，如果 CSS 和所有字体都内联为 base64资源，会发生什么情况？\r\n\r\n\r\n![页面的 LCP 元素是一个从 < img > 元素加载的图像，但是 CSS 及其四个字体资源的内联“延迟了preloader scanner 发现图像，直到这些资源被完全下载。](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c415aca578b14866b38af9e3ad1da16c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在这个例子中，内联的影响会对 LCP 产生负面影响，并且一般来说会对性能产生负面影响。不内联任何内容的页面版本只需3.5秒就可以绘制 LCP 图像。内联所有内容的页直到刚刚超过7秒时才绘制 LCP 图像。\r\n\r\n\r\n这不仅仅是`preloader scanner`的问题。内联字体不是一个很好的策略，因为 base64是一种低效的二进制资源格式。另一个影响因素是，除非 CSSOM 认为有必要，否则不会下载外部字体资源。当这些字体内联为 base64时，无论当前页面是否需要它们，它们都会被下载。\r\n\r\n所以对于内联到 HTML 中的内容要非常小心，特别是 base64编码的资源。一般来说，除了非常小的资源外，不推荐使用它。内嵌越少越好，因为内嵌太多是在玩火。\r\n\r\n### CSR 渲染\r\n\r\n毫无疑问: JavaScript 肯定会影响页面速度。开发人员不仅依赖它来提供交互性，而且还倾向于依赖它来交付内容本身。这在某些方面会带来更好的开发人员体验; 但是对开发人员的好处并不总是转化为对用户的好处。\r\n\r\n一种可以打败`preloader scanner`的模式是 `CSR`：\r\n\r\n你可以看示例页面https://preload-scanner-fights.glitch.me/client-rendered.html。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2d8d8892e649db8a2ed525d8c77b58~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nhtml是通过外部js进行渲染的。\r\n\r\n```javascript\r\nrender(content, document.body);\r\n```\r\n本质就是我们现在流行的CSR。\r\n\r\n![CSR中图片资源对preloader scanner是隐藏的](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a64b0270e18a428f8e58ee779d18ca8c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以举个例子如果你的LCP元素是图片比较多的大，那么CSR就会对你的LCP造成影响。所以有时候可以考虑服务器端渲染(SSR)或静态生成的标记，因为它将帮助preloader scanner提前发现并机会性地获取重要资源。\r\n\r\n## 文献\r\n\r\n\r\n1. 原文：https://web.dev/preload-scanner/\r\n\r\n\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3523577e39d4a09a7eee82cf6d1f751~tplv-k3u1fbpfcp-watermark.image?)\r\n"
    },
    {
        "article_id": "7189645395638059045",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df58d882dd3406b8bf00a82b7767653~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Canvas 图像处理之 getImageData",
        "preview": "简单介绍 <canvas> 的方法 getImageData ，并用其构建颜色选择器和兔年祝福粒子效果。",
        "author": "天行无忌",
        "view_count": 900,
        "collect_count": 3,
        "comment_count": 3,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ee5b3d33c959244bf7b70b28bb3a4d07~300x300.image",
        "category": "前端",
        "content": "> 我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\r\n\r\n在本文中，将简单介绍 `<canvas>` 的方法 getImageData ，并用其构建颜色选择器和兔年祝福粒子效果。为了简单并且快速看到效果，本文代码及效果将使用[码上掘金](https://code.juejin.cn/)。\r\n\r\n`<canvas>`元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上`<canvas>`是一个可以用 JavaScript 操作的位图（bitmap）。\r\n\r\n`getImageData()`方法用来读取`<canvas>`的内容，返回一个 ImageData 对象，包含了每个像素的信息，语法如下：\r\n\r\n> `ctx.getImageData(sx, sy, sw, sh)`\r\n\r\n接受四个参数，分别是 `sx`和`sy`是读取区域的左上角坐标，`sw`和`sh`是读取区域的宽度和高度。\r\n\r\n`getImageData()` 返回的是一个`ImageData`对象，有三个属性：\r\n\r\n-   `ImageData.data`：一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、`alpha` 通道值（每个值的范围是 `0～255`），因此该数组的长度等于`图像的像素宽度 x 图像的像素高度 x 4`。这个数组不仅可读，而且可写，因此通过操作这个数组，就可以达到操作图像的目的。\r\n-   `ImageData.width`：浮点数，表示 ImageData 的像素宽度。\r\n-   `ImageData.height`：浮点数，表示 ImageData 的像素高度。\r\n\r\n### 兔年祝福粒子效果\r\n\r\n在过几天将迎来兔年，提前祝大家兔飞猛进！具体的步骤是编写HTML、CSS和JavaScript。使用 `getImageData()` 方法扫描图像获取像素信息，计算每个区域的相对亮度，创建一个简单的粒子系统，并根据粒子当前移动区域的亮度调整每个粒子的速度和不透明度。\r\n\r\n这里使用的素材是一个很可爱的兔子形象，很生动。\r\n\r\n[jcode](https://code.juejin.cn/pen/7139836854412509219)\r\n\r\n\r\n### 颜色选择器\r\n\r\n将在画布上绘制所有颜色。首先，需要添加一个画布标签来绘制颜色。将以下 HTML 添加到您的 HTML 中。\r\n\r\n```\r\n<div class=\\\"container\\\">\r\n  <h1>颜色选择器：Color Picker</h1>\r\n</div>\r\n<div class=\\\"container\\\">\r\n  <div class=\\\"color-picker\\\"></div>\r\n</div>\r\n```\r\n\r\n接下来，需要在画布上绘制所有颜色。要在画布上绘制颜色，需要获取画布的 `context`、`width` 和 `height`。这些变量将用于创建线性渐变和绘制矩形框。\r\n\r\n#### 1. 获取画布的 context、width、height\r\n\r\n```\r\nconst [width, height] = [container.offsetWidth, container.offsetHeight];\r\n[canvas.width, canvas.height] = [width, height];\r\n```\r\n\r\n#### 2. 涂红、绿、蓝\r\n\r\n在这里绘制没有透明度的颜色。例如红色，绿色，蓝色。下面是在一个框中绘制所有颜色的 Javascript 代码。\r\n\r\n```\r\nconst gradientH = context.createLinearGradient(0, 0, width, 0);\r\ngradientH.addColorStop(0, \\\"rgb(255, 0, 0)\\\"); // red\r\ngradientH.addColorStop(1/6, \\\"rgb(255, 255, 0)\\\"); // yellow\r\ngradientH.addColorStop(2/6, \\\"rgb(0, 255, 0)\\\"); // green\r\ngradientH.addColorStop(3/6, \\\"rgb(0, 255, 255)\\\");\r\ngradientH.addColorStop(4/6, \\\"rgb(0, 0, 255)\\\"); // blue\r\ngradientH.addColorStop(5/6, \\\"rgb(255, 0, 255)\\\");\r\ngradientH.addColorStop(1, \\\"rgb(255, 0, 0)\\\"); // red\r\ncontext.fillStyle = gradientH;\r\ncontext.fillRect(0, 0, width, height);\r\n```\r\n\r\n#### 3.滤镜画布与线性梯度\r\n\r\n接下来，会发现浅色和深色。例如，浅红色，深红色。为此将使用带有透明度的白色和黑色。这是使它变暗或变亮的 Javascript 代码。\r\n\r\n```\r\nconst gradientV = context.createLinearGradient(0, 0, 0, height);\r\ngradientV.addColorStop(0, \\\"rgba(255, 255, 255, 1)\\\"); // white\r\ngradientV.addColorStop(0.5, \\\"rgba(255, 255, 255, 0)\\\");\r\ngradientV.addColorStop(0.5, \\\"rgba(0, 0, 0, 0)\\\"); // transparent\r\ngradientV.addColorStop(1, \\\"rgba(0, 0, 0, 1)\\\"); // black\r\ncontext.fillStyle = gradientV;\r\ncontext.fillRect(0, 0, width, height);\r\n```\r\n\r\n最后，当点击画布时，需要点击颜色。这里使用的技术是定位鼠标单击事件的 `x/y` 位置。然后，在 `x/y` 位置使用 `getImageData` 函数获取该位置的红色、绿色和蓝色值。\r\n\r\n```\r\ncanvas.addEventListener('click', e => pickColor(e, canvas, circle, selected));\r\n\r\nfunction pickColor(event, canvas, circle, selected) {\r\n  const rect = event.target.getBoundingClientRect();\r\n  const x = event.clientX - rect.left; \r\n  const y = event.clientY - rect.top;  \r\n\r\n  const context = canvas.getContext('2d');\r\n  const imgData = context.getImageData(x, y, 1, 1);\r\n  const [r, g, b] = imgData.data;\r\n  const [h, s, l] = rgb2hsl(r, g, b);\r\n  const selectedColor = l < 0.5 ? '#FFF' : '#000';\r\n  circle.style.top = (y - 6) + 'px';\r\n  circle.style.left = (x - 6) + 'px';\r\n  circle.style.borderColor = selectedColor;\r\n\r\n  selected.innerText = Object.values(toCss(r,g,b,h,s,l))\r\n    .toString().replace(/\\\\)\\\\,/g, ') ');\r\n  selected.style.backgroundColor = toCss(r,g,b,h,s,l).hex;\r\n  selected.style.color = selectedColor;\r\n  canvas.dispatchEvent(new CustomEvent('color-selected', {\r\n    bubbles: true,  detail: {r, g, b, h, s, l} \r\n  }));\r\n}\r\n```\r\n\r\n完整代码如下：\r\n\r\n[jcode](https://code.juejin.cn/pen/7189637166212284477)\r\n\r\n### 总结\r\n\r\n`getImageData` 常用的场景就是制作颜色选择器、像素粒子效果和图片的灰度。\r\n"
    },
    {
        "article_id": "7189271181646626872",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0851da9d7e94b6493dda52953bba7cc~tplv-k3u1fbpfcp-watermark.image?",
        "title": "关于“交互密集型”组件的设计",
        "preview": "主要讲解关于交互密集型组件的设计思路，用到了photoswipe插件。组件设计可能比较常用的技能，不过不管怎样，当时也是花了心思的，所以还是想把它总结出来。",
        "author": "大洋洋2020",
        "view_count": 644,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/52786ecf5757af75666db8433b274d4d~300x300.image",
        "category": "前端",
        "content": "这是一篇酝酿了2年的文章，在职的时候团队考虑产品保密不让发技术文章。后来也是一直犹豫，因为涉及到组件设计的问题好像很少有人来说，可能是太简单了。最近做项目时，做到了数据源比较多，而且数据显示的处理也比较复杂。再加上之前做过的这种交互比较多，事件比较杂的这种组件。于是自己稍加总结，虽然简单，也可以着手写一个新的专题类型来讲各种类型组件的设计。那么第一篇就来写一下这篇等了2年的组件设计讲解，我自己起了一个名字叫做“交互密集型”组件。\r\n\r\n## 功能简介\r\n\r\n这是一个相册的功能，分为大图模式（图1）和照片墙模式（图2）。\r\n\r\n![截屏2023-01-16 20.55.21.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbb68b405b62462c8135d751fdd22133~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![截屏2023-01-16 20.55.45.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ea88d4442744b6d860017515fcd5f7a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n本篇所要分析的主要是进入大图模式的交互：1.用户可以通过点击图2照片墙中的某个图片进入大图模式。2.用户可以在大图模式中右滑图片，来切换大图的显示。3.用户还可以在大图模式中点击顶部的tab菜单，来切换到相应Tab类型的首张图片。\r\n\r\n## 前期设计\r\n相册的大图模式需要支持左右滑动切换图片，双击放大等交互，所以直接用photoswipe这个图片预览的库。\r\n\r\n状态变量需要有3个，一个是当前正在显示的图片序号（bigPicIndex）、当前显示的类别编号（TypeIndex）、类别中的子序号（SubIndex）。\r\n\r\n在手动滑动图片的时候，需要更新这三个状态，可以通过photoswipe库的beforeChange事件的回调函数swipeMove()来捕获。需要注意，swipeMove()的参数只有一个，就是照片前进和后退的个数。\r\n\r\n而点击顶部Tab菜单和照片墙状态下点击图片这两个操作都不是photoswipe库能够捕获的，而且这两个组件直接调用photoswipe库的goTo方法来跳转相应的大图并不方便。所以我们需要让这两个操作变更全局变量bigPicIndex，在大图组件中通过监听bigPicIndex来执行photoswipe库的goTo()函数，切换到相应序号的大图。\r\n\r\n但是这里需要注意的是photoswipe库的goTo方法，同样会触发beforeChange事件，来激活swipeMove()函数。\r\n\r\n## 整理事件流\r\n我们首先来看比较特殊的事件流程，就是直接触发swipeMove()的滑动图片。\r\n\r\n![1.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816e18dd16c04494b1e7bbdd43f8a41c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n左右滑动图片确是一开始就触发了swipeMove()，在这里必须要通过图片前进和后退的个数，来计算出新的bigPicIndex，而bigPicIndex的更新在之前的设计中，一定会触发goTo()函数，从而又会回来触发swipeMove()导致异常。如果不需要触发goTo()函数，这里有一个比较hack的方式，就是可以通过加上标志位的方式，执行swipeMove()时，设置一个标志位，监听bigPicIndex的函数判断标志位，如果不要去调用goTo()函数，就直接恢复标志位后返回。\r\n\r\n而点击顶部Tab菜单（红色）、点击照片墙状态的小图（黄色）都会通过全局变量bigPicIndex来触发goTo()函数来切换大图，并且最终都会触发swipeMove()函数。因为swipeMove()计算出的全局bigPicIndex与这两个操作更新的bigPicIndex相同所以并不会再去激活bigPicIndex的监听函数，造成重复调用了。\r\n\r\n所以经过了标志位的修改，我们的事件流就长成了这样：\r\n\r\n![2.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c04bcb092dc455994c750ad672ac73d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n本来从bigPicIndex出来的绿线调用goTo()函数已经变成了虚线。并且如果我们需要加上其他修改全部变量的副作用逻辑，例如：当前显示的类别编号（TypeIndex）、类别中的子序号（SubIndex），可以加在swipeMove中，因为三种交互都可以走到这个函数，并且它本身也存在一些计算逻辑。\r\n\r\n至此，就完成了一个大图组件的设计流程。"
    },
    {
        "article_id": "7180977411633184823",
        "snapshot": "",
        "title": "2022, 6年技术路, 后疫情时代复盘",
        "preview": "又到了每年一度的复盘时间。 转眼一想, 做技术已经 6 年了。 说实话，有点疲惫了。今年整个互联网行业都不好过, 加上疫情的反复不断, 从耳边流出了很多裁员的信息, 股市也比较低迷, 身处底层的我们只",
        "author": "徐小夕",
        "view_count": 1839,
        "collect_count": 6,
        "comment_count": 4,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/d08df4df3fe80db668014b4b815390a5~300x300.image",
        "category": "前端",
        "content": "\r\n> **专注** - **聚焦** - **反思** - **解决方案**\r\n\r\n又到了每年一度的复盘时间。\r\n\r\n转眼一想, 做技术已经 6 年了。\r\n\r\n说实话，有点疲惫了。今年整个互联网行业都不好过, 加上疫情的反复不断, 从耳边流出了很多裁员的信息, 股市也比较低迷, 身处底层的我们只能夹缝生存。\r\n\r\n但是, 我又是个信奉自由的人, 不, 严格意义上来说是个信奉自由的**程序猿**。所以**追求价值**才是我最关注的点, 每年总得做点有价值的事, 生活才算过的有价值。\r\n\r\n所以接下来还是要复盘一下这一整年的价值和思考感悟。\r\n\r\n### 工作上\r\n\r\n一年时间, 在工作上, 感觉自己还是那个兢兢业业的自己, 每天远程办公 8-10 小时, 基本 12 小时在线, 喜欢有挑战的任务, 积极解决工作上的问题。\r\n\r\n从**组件化**到**可视化**, 再到**原生实现可视化**, 在技术上经历了一定程度的蜕变, 也具备了百度搜索不到的解决问题的能力。\r\n\r\n这里分享几个工作的经验和技巧:\r\n\r\n1. 情绪永远不要过于激动, 即使是你没错, 也要理智应对\r\n2. 效率优先, 永远不要觉得上班摸鱼能割公司韭菜, 这样只会让自己丧失竞争力和格局感\r\n3. 有问题要主动沟通, 但不要过渡沟通\r\n4. 尽量让自己远离无效加班的状态\r\n5. 持续学习, 定期复盘\r\n\r\n以上是今年分享的一些提高职场竞争力的方法, 各位可以参考一下。\r\n\r\n今年也有很多朋友和我分享了他们的被裁经历, 消化了他们的部分焦虑, 但是我要说的是, 裁员迟早会来, 不如好好思考一下如何**利用这段时间, 提高自我的价值, 好好休养生息**。\r\n\r\n我曾经也经历过职场中的大起大落, 经历过裁员, 但是我觉得始终**把工作当成自己摆脱枯燥生活的一种方式, 就好了**。毕竟赚钱的方式有很多种, 顺从自己内心就好了。\r\n\r\n**做程序**是一件辛苦且不易的事情, 且行切珍惜, **工作再忙, 也要好好享受生活**。\r\n\r\n切记我们老祖宗的养生文化: **日出而作, 日落而息**。所以今年之后, 建议大家都制定一个健身计划~\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c655f7f87045939d63ee1144b84a63~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 关于开源和产品\r\n\r\n在接触技术的第二个年头, 我就迷上了做开源, 一方面可以提升自己解决问题的能力和效率, 另一方面通过和一些技术爱好者的交流, 也锻炼了我对程序设计的全面性思考。几乎每年都会利用业余时间做一些实用的开源项目, 今年也不例外:\r\n\r\n#### react-slider-vertify\r\n\r\n基于react实现的滑动验证码组件。\r\n\r\ngithub: https://github.com/MrXujiang/react-slider-vertify\r\n\r\n#### react-cropper-pro\r\n基于react开发的轻量级图片上传裁切组件。\r\n\r\ngithub: https://github.com/MrXujiang/react-cropper-pro\r\n\r\n#### xijs\r\n\r\n一款面向复杂业务场景的 js 类库。\r\n\r\ngithub: https://github.com/MrXujiang/xijs\r\n\r\n#### vue-slider-vertify\r\n\r\n基于Vue3的滑动验证码组件。\r\n\r\ngithub: https://github.com/MrXujiang/vue-slider-vertify\r\n\r\n#### blink\r\n\r\n一款自定义的生成故障艺术动画的组件库。\r\n\r\ngithub: https://github.com/MrXujiang/blink\r\n\r\n\r\n同时, 对于前几年做的几个开源项目和产品, 我也在持续维护中, 比如大家最熟悉的 **H5-Dooring**, **V6.Dooring** 等, 后续也会更加站在产品设计的角度做一些高价值的产品, 来回馈这6年的技术生涯。\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc153500e768466a8fd2a3798d99ffed~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这里也分享一下我做开源或者产品的心得:\r\n\r\n1. 做产品或者开源, 需要有绝对的执行力, 没有执行力的团队是做不出好产品的\r\n2. 永远只做小而精的产品或者开源项目\r\n3. 不要沉迷于技术上的酷炫, 要从实际需求出发, 直击用户痛点\r\n4. 做开源或者产品要有持续性, 坚持不了1年的开源或者产品, 是不长久的\r\n5. 不要一开始就想着变现, 先用爱发电\r\n\r\n我之前做了一款开源产品, 坚持迭代了3年多, 才被市场慢慢认可。\r\n\r\n所以, **不卑不亢, 坚持去浮, 也许才是做产品或者开源最好的态度**。\r\n\r\n### 技术分享\r\n\r\n今年的技术分享比较贫瘠, 2021年写了100篇, 今年写了10篇, 但值得庆幸的是文章仍然都是慢满满的干货, 不水文, 这也许是作为技术人的我最后的倔强。\r\n\r\n感兴趣的朋友可以参考我往期的技术分享文章, 包括了很多组件化, 可视化, 低代码相关的技术好分享。\r\n\r\n那么今年为什么写这么少的文章呢? 这里和大家解释一下, 我都在**认真工作**。不管是公司上的工作, 还是开源上的任务。 \r\n\r\n成年人的烦恼有时候就是这么简单, 又枯燥。\r\n\r\n不过 2023年, 目标输出 **12篇** 干货满满的文章, 每月一篇, 绝不打烊。\r\n\r\n\r\n### 疫情之下的生活\r\n\r\n他们都说疫情之下没有生活, 但是我觉得, 疫情之下不但没有生活, 还没有工作。\r\n\r\n哈哈, 当然是个玩笑话, 疫情确实打乱了很多人的出行计划, 新疆的3个月封锁, 让很多人成了自由职业者, 其他地方也打响了防疫的“保卫战”, 虽然最后都被“生活”妥协了, “阳”了你我他。\r\n\r\n但是, 这些都不是阻止我们不学习, 不锻炼身体的理由, 人为运动生, 2023年好好运动来增强抵抗力吧, 毕竟, 免疫系统也不是吃“素”的。\r\n\r\n\r\n### 2023, 勇往直前\r\n\r\n除了上面说的学习, 运动之外, 2023年, 更多的还是学会聚焦, 专注于做小而美的事情, 让值得珍惜的日子, 彰显价值。\r\n\r\n2023, **我们**不见不散,\r\n\r\n2023, **趣谈前端**, **我**, 和**你们**不见不散。\r\n\r\n"
    },
    {
        "article_id": "7186274471102119991",
        "snapshot": "",
        "title": "Spring 响应式编程，真香！！！",
        "preview": "一、前言 响应式编程是啥？ 为啥要有响应式编程？ 响应式流的核心机制是什么？ Spring 响应式编程能解决我们平时开发的什么痛点？ Spring 响应式编程有哪些应用场景？ Spring 响应式编程",
        "author": "老周聊架构",
        "view_count": 4779,
        "collect_count": 39,
        "comment_count": 3,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e15967f27c0244396fa6d8415a924a65~300x300.image",
        "category": "后端",
        "content": "## 一、前言\r\n\r\n - 响应式编程是啥？\r\n - 为啥要有响应式编程？\r\n - 响应式流的核心机制是什么？\r\n - Spring 响应式编程能解决我们平时开发的什么痛点？\r\n - Spring 响应式编程有哪些应用场景？\r\n - Spring 响应式编程未来的趋势如何？\r\n\r\n开篇六连问，等咱们熟悉完再来真香也不迟，我们废话少说，直接来畅游 Spring 响应式编程的世界。\r\n\r\n## 二、响应式编程是啥？\r\n\r\n> 在计算中，响应式编程或反应式编程（Reactive programming）是一种面向数据串流和变化传播的声明式编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。\r\n\r\n有点抽象？没有关系，老周这就来说道说道。核心的一点响应式编程是声明式编程范式，对命令式编程进行替代的一个范例，这种替代的存在是因为响应式编程解决了命令式编程的限制。大多数开发者都是命令式编程起步的，你写的代码就是一行接一行的指令，按照它们的顺序一次一条地出现。一个任务被执行，程序就需要等到它执行完了，才能执行下一个任务。每一步，数据都需要完全获取到了才能被处理，因此它需要作为一个整体来处理。\r\n\r\n命令式编程有个最大的弊端是：当正在执行的任务被阻塞了，特别是一个 IO 任务，例如将数据写入到数据库或从远程服务器获取数据，那么调用该任务的线程将无法做任何事情，直到任务完成。说白了，阻塞的线程就是一种浪费，在如今的环境，线程的资源是那么的宝贵。\r\n\r\n相反，响应式编程是函数式和声明式的。响应式编程涉及描述通过该数据流的 pipeline 或 stream，而不是描述的一组按顺序执行的步骤。响应式流处理数据时只要数据是可用的就进行处理，而不是需要将数据作为一个整体进行提供。\r\n\r\n## 三、为啥要有响应式编程？\r\n我们上面也说了命令式编程会线程阻塞，而响应式编程是声明式编程范式的，是对命令式编程进行替代的一个范例。\r\n\r\n对于命令式编程的同步阻塞，其实业界是有一些处理方案的，比如在 Java 中，为了实现异步非阻塞，一般会采用回调和 Future 这两种机制，但这两种机制都存在一定局限性。\r\n\r\n### 3.1 回调机制\r\n\r\n我们来看下面这个图：\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fe50ccaad324343bd9c94cedb0c7e29~tplv-k3u1fbpfcp-zoom-1.image)\r\n服务 B 的 methodB() 方法调用服务 A 的 methodA() 方法，然后服务 A 的 methodA() 方法执行完毕后，再主动调用服务 B 的 callback() 方法。\r\n\r\n回调体现的是一种双向的调用方式，实现了服务 A 和服务 B 之间的解耦。在这个 callback 回调方法中，回调的执行是由任务的结果来触发的，所以我们就可以异步来执行某项任务，从而使得调用链路不发生任何的阻塞。\r\n\r\n回调的最大问题是复杂性，一旦在执行流程中包含了多层的异步执行和回调，那么就会形成一种嵌套结构，给代码的开发和调试带来很大的挑战。所以回调很难大规模地组合起来使用，因为很快就会导致代码难以理解和维护，从而造成所谓的“回调地狱”问题。之前公司就遇到代码“回调地狱”问题，十几层的回调，后面的人进来维护估计会吐。\r\n\r\n### 3.2 Future 机制\r\n\r\n我们再来看看 Future 这种机制，有一个需要处理的任务，然后把这个任务提交到 Future，Future 就会在一定时间内完成这个任务，而在这段时间内我们可以去做其他事情。下面我们来看看来自 Doug Lea 大神在 Java 中的 Future 接口设计：\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21dfe9bbc9a142c8b81ee7194da22435~tplv-k3u1fbpfcp-zoom-1.image)\r\n我们可以看到，大神在上面的设计来达到一定的异步执行效果。但从本质上讲，Future 以及由 Future 所衍生出来的 CompletableFuture 等各种优化方案就是一种多线程技术。多线程假设一些线程可以共享一个 CPU，而 CPU 时间能在多个线程之间共享，这一点就引入了“上下文切换”的概念。\r\n\r\n如果想要恢复线程，就需要涉及加载和保存寄存器等一系列计算密集型的操作。因此，大量线程之间的相互协作同样会导致资源利用效率低下。\r\n\r\n### 3.3 响应式编程实现方法\r\n#### 3.3.1 数据流与响应式\r\n数据流就是数据像水流一样源源不断的输入过来，而系统的响应能力就体现在对这些数据流的即时响应过程上。我们可以不采用传统的同步调用方式来处理数据，而是由处于数据库上游的各层组件自动来执行事件，从web到service再到dao层，这个过程就像水流一样，整个数据传递链路都应该是采用事件驱动的方式来进行运作的，这个过程都应该是异步非阻塞的，这就是响应式编程的核心特点。\r\n\r\n相较传统开发所普遍采用的“拉”模式，在响应式编程下，基于事件的触发和订阅机制，这就形成了一种类似“推”的工作方式。说白了，就类似现在的 Kafka 等消息引擎，大部分都采用事件驱动的 pub/sub 模式的架构。这种模式的最大优势是生成事件和消费事件的过程是异步执行的，意味着资源之间的竞争关系较少，故服务器的响应能力也就越高。\r\n\r\n#### 3.3.2 响应式宣言\r\n响应式宣言是一份构建现代云扩展架构的处方。这个框架主要使用消息驱动的方法来构建系统，在形式上可以达到弹性和韧性，最后可以产生响应性的价值。所谓弹性和韧性，通俗来说就像是橡皮筋，弹性是指橡皮筋可以拉长，而韧性指在拉长后可以缩回原样。\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ea241e0b644c3eb6f41ae5b8a4d1a5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n - **响应性**: ：只要有可能，系统就会及时地做出响应。即时响应是可用性和实用性的基石，而更加重要的是，即时响应意味着可以快速地检测到问题并且有效地对其进行处理。即时响应的系统专注于提供快速而一致的响应时间，确立可靠的反馈上限，以提供一致的服务质量。这种一致的行为转而将简化错误处理、建立最终用户的信任并促使用户与系统作进一步的互动。\r\n \r\n - **韧性**：系统在出现失败时依然保持即时响应性。这不仅适用于高可用的、任务关键型系统——任何不具备回弹性的系统都将会在发生失败之后丢失即时响应性。回弹性是通过复制、遏制、隔离以及委托来实现的。失败的扩散被遏制在了每个组件内部，与其他组件相互隔离，从而确保系统某部分的失败不会危及整个系统，并能独立恢复。每个组件的恢复都被委托给了另一个（外部的）组件，此外，在必要时可以通过复制来保证高可用性。（因此）组件的客户端不再承担组件失败的处理。\r\n \r\n - **弹性**： 系统在不断变化的工作负载之下依然保持即时响应性。反应式系统可以对输入（负载）的速率变化做出反应，比如通过增加或者减少被分配用于服务这些输入（负载）的资源。这意味着设计上并没有争用点和中央瓶颈，得以进行组件的分片或者复制，并在它们之间分布输入（负载）。通过提供相关的实时性能指标，反应式系统能支持预测式以及反应式的伸缩算法。这些系统可以在常规的硬件以及软件平台上实现成本高效的弹性。\r\n\r\n - **消息驱动**：反应式系统依赖异步的消息传递，从而确保了松耦合、隔离、位置透明的组件之间有着明确边界。这一边界还提供了将失败作为消息委托出去的手段。使用显式的消息传递，可以通过在系统中塑造并监视消息流队列，并在必要时应用回压，从而实现负载管理、 弹性以及流量控制。使用位置透明的消息传递作为通信的手段， 得跨集群或者在单个主机中使用相同的结构成分和语义来管理失败成为了可能。非阻塞的通信使得接收者可以只在活动时才消耗资源，从而减少系统开销。\r\n\r\n**问题：消息驱动与上面提到的事件驱动有啥区别呢？**\r\n\r\n响应式宣言指出了两者的区别：“消息驱动”中消息数据被送往明确的目的地址，有固定导向；“事件驱动”是事件向达到某个给定状态的组件发出的信号，没有固定导向，只有被观察的数据。\r\n\r\n - 在一个消息驱动系统中，可寻址的接收者等待消息的到来然后响应消息，否则保持休眠状态，消息驱动系统专注于可寻址的接收者。响应式系统更加关注分布式系统的通信和协作以达到解耦、异步的特性，满足系统的弹性和容错性，所以响应式系统更倾向于使用消息驱动模式。\r\n - 在一个事件驱动系统中，通知的监听者被绑定到消息源上。这样当消息被发出时，它就会被调用，所以，响应式编程更倾向于事件驱动。\r\n\r\n下一篇老周会来说下响应式流的核心机制是什么？敬请期待~"
    },
    {
        "article_id": "7160852432916856840",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47cdc66ca06641678a1984ecf07add52~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Github上5.3k的游戏！异形工厂的制作思路",
        "preview": "很早之前，我就关注到了Github上一款叫做shapez的高星游戏,主要玩法就和他的名字一样，是个需要利用开采器，传送带等各种工具来完成每个关卡所需要收集的开采物的游戏。。",
        "author": "Gatsby",
        "view_count": 5278,
        "collect_count": 170,
        "comment_count": 23,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ad5e8d60463e248a9e576250337fcf1a~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: smartblue\r\n---\r\n# 前言\r\n**很早之前**，我就关注到了Github上一款叫做**shapez**的高星游戏,主要玩法就和他的名字一样，是个需要利用开采器，传送带等各种工具来完成每个关卡所需要收集的开采物的游戏（游戏链接：https://shapez.io/ , 原创作者：https://github.com/tobspr-games/shapez.io ）。边玩的时候一边感叹，怎么能用JS做出性能这么优秀的高难度逻辑的游戏。那时候的我对JS的运用只能说是停留在能操控DOM元素。做点简单逻辑游戏的份上。也幻想尝试着做这个游戏，但是直接就在创建地图的阶段就暴毙了。\r\n\r\n**往后的时间里**，我一直都在不断磨炼自己的JS运用技术，特意去参考学习了很多大佬解析的一些游戏源代码。相对的在这方面的提升也是肉眼可见的。\r\n\r\n到了今天的10月中旬慢慢终于闲下来的时候，我终于是想起了shapez这款游戏，决心一定要挑战一下哪怕只是抽象的能完成多少就完成多少。\r\n\r\n# 分析\r\n## 原版游戏分析\r\n先对原版游戏进行一下分析，他的地图是可以**不断动态创建**的，且进行缩小到最小地图之后大概显示**50万**个网格，但是经过研究了一段时间后发现，在不放置任何工具的时候他永远只会不断更新一块4块16*16大小的网格高亮区域。其余地方是**不会以高刷新率重新更新全部画布**的，但如果在其他区域放置一个工具的话，会在那个放置点的16 * 16的方向上形成一个新的高亮刷新区域。\r\n\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0e468a335848d1ac17dc68ca86582a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"高亮刷新.gif\\\" width=\\\"70%\\\" /></p>\r\n\r\n那么对于地图上那些蓝的绿的红的开采区是如何生成的我后面也慢慢想到一个叫做**柏林噪点**的东西，虽然不能百分百确定，但至少我觉得生成的东西就和这游戏地图上的板块是非常相似的\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96211a87397c41c7bbc442376d2b117d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f09a64c0ad5437f95d7d9329ad02d3f~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" /></p>\r\n\r\n其余的工具放置之类的功能相对就比较简单这里就不做更多讲解了\r\n\r\n## 制作流程\r\n这是我对自己要所要完成的功能做的一个最基本的规划，规划内容如下：\r\n```mermaid\r\ngraph TD\r\ncanvas网格地图绘制 --> 地图缩放拖动动态创建显示 --> 地图板块填充噪点等 --> 地图工具放置 --> 地图开采运行/中心接收/进入下一关\r\n```\r\n\r\n# 制作\r\n那么分析完了就可以开始动手了，但是为了方便以后的制作，我对自己的代码规范，以及预留一些添加后面功能板块的位置也是很有必要的。\r\n\r\n## canvas网格地图绘制\r\n先要想想这个网格怎么创建，根据刚刚的分析如果光是创建2级数组作为地图存储的话会导致后面要完成放置工具变成高亮刷新区域后期就很难添加了，所以我的想法是这样的。 地图X Y坐标分别代表分别是二维数组的maps[y][x],在数组值里保存一个Class类，里面再存一个二维数组：如下面的。（ps：应该是还有别的方法的但是我觉得最简单的就是这种）\r\n\r\n```js\r\n[\r\n    [\r\n        {grids: [[]]},{},{},{}\r\n    ],\r\n    [{},{},{},{}],\r\n    [{},{},{},{}],\r\n]\r\n```\r\n然后就是封装类开始实现，先封装好canvas相关操作的类\r\n```\r\n// 绘制canvas地图\r\nclass Map {\r\n    constructor() {\r\n        this.canvas = document.querySelector('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n        // 屏幕大小一致的canvas\r\n        window.onresize = () => {\r\n            this.canvas.width = document.documentElement.clientWidth;\r\n            this.canvas.height = document.documentElement.clientHeight;\r\n        }\r\n        // 保存加载好的图片\r\n        this.loadImg = {}\r\n\r\n        this.runTimer = null;\r\n    }\r\n\r\n    // 绘画开始\r\n    begin(){\r\n        this.ctx.beginPath();\r\n        this.ctx.save();\r\n    }\r\n\r\n    // 绘画结束\r\n    close(){\r\n        this.ctx.closePath();\r\n        this.ctx.restore();\r\n    }\r\n    \r\n    // 重新绘制地图\r\n    one(){\r\n        this.ctx.clearRect(0,0, document.documentElement.clientWidth, document.documentElement.clientHeight)\r\n\r\n        app.maps.flat().map(item => item.update());\r\n    }\r\n   \r\n    // 旋转\r\n    rotate(x, y, rotate){\r\n        this.ctx.translate(x + 3.25, y + 3.25);\r\n        this.ctx.rotate(rotate * Math.PI / 180);\r\n        this.ctx.translate(-x - 3.25, -y - 3.25);\r\n    }\r\n\r\n    // 绘画图片\r\n    drawImage(x, y, name, w = 20, h, cx, cy, cw, ch){\r\n        if(this.loadImg[name]){\r\n            if(cw && ch){\r\n                console.log(cx, cy, cw, ch, x, y, w, h || w);\r\n                this.ctx.drawImage(this.loadImg[name], cx, cy, cw, ch, x, y, w, h || w);\r\n            }else{\r\n                this.ctx.drawImage(this.loadImg[name], x, y, w, h || w);\r\n            }\r\n        }else{\r\n            let img = new Image();\r\n            img.src = `${name}`;\r\n            img.onload = () => this.loadImg[name] = img;\r\n        }\r\n    }\r\n}\r\n```\r\n再去封装一个存入地图数据的Grid类，因为是用**Vue**写的里面有带**app.???** 一般都是之前封装的函数\r\n```\r\n// 地图里的网格方块\r\nclass Item {\r\n    constructor(i, j) {\r\n        this.i = i;\r\n        this.j = j;\r\n        this.x = i * app.game.w;\r\n        this.y = j * app.game.h;\r\n        this.img = '';\r\n        this.w = (app.game.w / 16);\r\n    }\r\n}\r\n\r\nclass Grid extends Item{\r\n    constructor(i, j, color, prop) {\r\n        super(i, j)\r\n        // 随机的开采区的颜色\r\n        this.color = color;\r\n        // 假如是灰色的添加图形\r\n        this.prop = prop;\r\n\r\n        this.main = null;\r\n\r\n        // 根据show来判断是否随机在二维数组中生成存入一个噪点\r\n        this.show = ~~(Math.random() * 3);\r\n        this.first = false;\r\n        // 存入一个16*16的二维数组\r\n        this.grids = new Array(16).fill(0).map((item, j) => {\r\n            return new Array(16).fill(0).map((item, i) => {\r\n                return new Block(i, j, false, false)\r\n            })\r\n        })\r\n        if(this.show > 0) return;\r\n        this.getRandomHP(7, 7, 20)\r\n    }\r\n\r\n    update(){\r\n        if(this.show > 0) return;\r\n        this.add();\r\n\r\n        app.map.begin();\r\n        this.grids.map((item, j) => {\r\n            item.map((item, i) => {\r\n                if(app.line){\r\n                    app.map.ctx.strokeStyle = '#E3E7EA';\r\n                    app.map.ctx.lineWidth = '0.2'\r\n                    app.map.ctx.strokeRect(this.x + (i * 6.5), this.y + (j * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16);\r\n                }\r\n            })\r\n        })\r\n        app.map.close();\r\n    }\r\n}\r\n```\r\n初步就绘制出以下的区块\r\n\r\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/137877aca1f6465996b24c91edf185dc~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n## 地图缩放拖动\r\n这个拖动功能基本就是计算个偏移量的事情，所以不用多做解释啦。但对于这个定点缩放确实让我想了好一阵子。首先我的想法是通过直接增加绘制方块时候canvas增减绘制 **x y** 的偏移位和 **w h** 的大小来完成缩放效果发现并不理想。于是我直接采用了 canvas的 **scale** 和 **translate** 方法来进行偏移和缩放。\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9768cac3df9d4942b37e7fe3ad07a918~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"原缩放.gif\\\"  width=\\\"70%\\\"/></p>\r\n大概就是这样的方法\r\n\r\n```\r\nlet ctx = document.getElementById('canvas').getContext('2d');\r\nlet obj = {\r\n    fontX: 0,\r\n    fontY: 0,\r\n    fontZoom: 1,\r\n    curZoom: 1,\r\n    translateX: 0,\r\n    translateY: 0,\r\n    draw() {\r\n        ctx.fillRect(150, 150, 50, 50)\r\n    },\r\n    zoom(offsetX, offsetY, z) {\r\n        ctx.save()\r\n        ctx.clearRect(0, 0, 300, 300);\r\n        this.curZoom = this.fontZoom + z\r\n        this.translateX = offsetX - (offsetX - this.translateX) * this.curZoom / this.fontZoom\r\n        this.translateY = offsetY - (offsetY - this.translateY) * this.curZoom / this.fontZoom\r\n        ctx.translate(this.translateX, this.translateY);\r\n        ctx.scale(this.curZoom, this.curZoom);\r\n        this.draw()\r\n        ctx.restore()\r\n        this.fontY = offsetY\r\n        this.fontX = offsetX\r\n        this.fontZoom = this.curZoom\r\n    }\r\n}\r\nobj.draw()\r\ndocument.getElementById('canvas').addEventListener('mousewheel', (e) => {\r\n    let z = e.deltaY > 0 ? -0.1 : 0.1\r\n    obj.zoom(e.offsetX, e.offsetY, z)\r\n})\r\n```\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d7d81d6b11c48888f1eb340f7a4126a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"缩放.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n## 地图板块填充\r\n\r\n### 噪点生成\r\n那种真的像**我的世界地图**一样的噪点生成代码理解和写起来实在是麻烦了，所以我只要自创一个符合我要求的也不知道算不算“噪点”的demo。原理很简单，这里我直接用**exl表**来做一个简单的模型：简单来说就是假如中心点的位置是7，他的四周都是7的以内的随机数。当然为了避免7直接随机到1的尴尬状况，所以我是采用 **7/2+(7*Math.random())** 就可以保证得到的数字至少是在一半以上，接下来通过图片就很好理解了\r\n\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03c1fb1f56140e4ba0f4cb4f37f625d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n> （注意：这些代码只是方便看我单独做的demo，在实际游戏中运用请看在线代码）\r\n```\r\nclass Grid{\r\n    constructor() {\r\n        this.canvas = document.querySelector('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.grids = new Array(15).fill(0).map((item, j) => {\r\n            return new Array(15).fill(0).map((item, i) => {\r\n                return {if: false, rp: false};\r\n            })\r\n        })\r\n        this.getRandomHP(7, 7, 15)\r\n    }\r\n\r\n    //寻找附近的方块\r\n    getNearby(i, j, rp){\r\n        return [\r\n            [i - 1, j],\r\n            [i + 1, j],\r\n            [i, j - 1],\r\n            [i, j + 1],\r\n        ].map(item => {\r\n            // console.log((this.grids[item[1]][item[0]].rp <= 1 && this.grids[item[1]][item[0]].rp !== false), this.grids[item[1]][item[0]].rp)\r\n            if(!(this.grids[item[1]] && this.grids[item[1]][item[0]]) || rp <= 1 || this.grids[item[1]][item[0]].if === true) return false;\r\n            this.grids[item[1]][item[0]].if = true;\r\n            let rand = ~~(Math.random() * rp / 2) + ~~(rp / 2);\r\n\r\n            return {\r\n                i: item[0],\r\n                j: item[1],\r\n                rp: rand\r\n            }\r\n        })\r\n    }\r\n\r\n    // 随机生成一个噪点\r\n    getRandomHP(i, j, rp){\r\n        this.getNearby(i, j, rp).filter(item => {\r\n            if(!item) return;\r\n            this.getRandomHP(item.i, item.j, item.rp)\r\n        })\r\n    }\r\n\r\n    // 根据噪点填充方格\r\n    createMap(){\r\n        this.grids.map((item, j) => {\r\n            item.map((items, i) => {\r\n                this.stroke(i, j)\r\n                if(items.if) this.draw(i, j)\r\n            })\r\n        })\r\n    }\r\n\r\n    // 填充方格\r\n    draw(i, j){\r\n        this.ctx.beginPath();\r\n        this.ctx.save()\r\n        this.ctx.fillStyle = 'red';\r\n        this.ctx.fillRect(i * 30, j * 30, 30, 30);\r\n        this.ctx.closePath();\r\n        this.ctx.restore()\r\n    }\r\n\r\n    // 划线\r\n    stroke(i, j){\r\n        this.ctx.beginPath();\r\n        this.ctx.save()\r\n        this.ctx.strokeStyle = 'red';\r\n        this.ctx.strokeRect(i * 30, j * 30, 30, 30);\r\n        this.ctx.closePath();\r\n        this.ctx.restore()\r\n    }\r\n}\r\n\r\nlet grid = new Grid();\r\nlet btn = document.querySelector('button');\r\nbtn.onclick = function (){\r\n    grid.createMap();\r\n}\r\n```\r\n实现出来的效果和原版对比\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044a7eaca4d5484b884c1e9fbacb3c32~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab7e5faacce94907baebe7c6e4fa9ed0~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n看看 看看，对比一下还是很像的嘛！\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02d3d5947734589b51321f0ebeb427d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"_@8((VME1[B~HW8L]KC`3R4.png\\\" width=\\\"50%\\\" /></p>\r\n\r\n### 各种类型的开采区\r\n开采区就比较简单啦，无非就是把噪点里填充的红色板块填充些别的什么。封装一个通用的开采区的Class类，然后再通过继承来分别创建不同类型的开采区。现在看起来可能有点多余了，但后面是有这几种开采区都需要添加不同的功能的。\r\n```\r\n// 所有图片网址保存成的对象\r\nlet urlImg = {\r\n    red: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcdf1d95fb2f4203899f56ac4e0d5177~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    blue: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1a8496861a64eb8b72ca6e77a969edb~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    green: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e03f33112ab486b8fbca50797782a78~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    circular: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da017de4947847acb217eb51e3a778a5~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    square: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccdd6b9183b745f8914cea5797b677e2~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    cut: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6336eefefa94937adfe7e0ade7d25b1~tplv-k3u1fbpfcp-watermark.image?',\r\n    main: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/971af565f1b54f9494614722e50fc6da~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    weizi: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1b5fdb97a54668914529840c037a6e~tplv-k3u1fbpfcp-zoom-mark-crop-v2:240:240:0:0.awebp?',\r\n    miner: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7bc18ef96c40af8e8ff74fbed9c5bb~tplv-k3u1fbpfcp-watermark.image?',\r\n    remove: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934ebad4852405dab42d5e956c4d70f~tplv-k3u1fbpfcp-zoom-mark-crop-v2:460:460:0:0.awebp?',\r\n    path_top_bottom: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f5ba39cbf6a470b9091164eb1e469f0~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_bottom_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a739cc9118468cbb9d2a70a22bffc2~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_left_right: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1cbdfa5844d4deb87ac23624e6898e2~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_right_left: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c6bac94f3b4837a4c5bbdc29fd8979~tplv-k3u1fbpfcp-watermark.image?',\r\n\r\n    path_left_bottom: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5416f686ed1a4f80ac940e6ced5459f5~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_top_left: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6274f62a2ffc458f9851e679b96a8134~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_right_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24490d7fc5de4c9ea0694bdea8e90f77~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_bottom_right: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/148fbcef46e341f19e444fbceabca65c~tplv-k3u1fbpfcp-watermark.image?',\r\n\r\n    path_right_bottom: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bbd233b4d6415f8da8781b91fee3b1~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_top_right: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5f15016ac940a28b599e38e43d3636~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_left_top: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f22d1be13e6424d8274d304a6082ea7~tplv-k3u1fbpfcp-watermark.image?',\r\n    path_bottom_left: 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4461257ffd7b4f9fb66f761ef16f0d56~tplv-k3u1fbpfcp-watermark.image?',\r\n}\r\n\r\n// 每个方块里的矿物继承Class\r\nclass Color extends Item{\r\n    constructor(i, j, color, prop = null) {\r\n        super(i, j);\r\n        this.color = color;\r\n        this.prop = prop;\r\n    }\r\n\r\n    update(){\r\n        if(app.line){\r\n            app.map.ctx.globalAlpha = .5;\r\n            app.map.drawImage(this.i + 1.5, this.j + 1.5, urlImg[this.prop || Object.keys(this.color)[0]], Math.abs(app.game.w) / 32);\r\n        }\r\n        app.map.ctx.fillStyle = Object.values(this.color)[0];\r\n        app.map.ctx.fillRect(this.i, this.j, Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16)\r\n    }\r\n}\r\n\r\n// 绿色染料块\r\nclass Green extends Color{\r\n    constructor(i, j, color) {\r\n        super(i, j, color);\r\n    }\r\n}\r\n\r\n// 蓝色染料块\r\nclass Blue extends Color{\r\n    constructor(i, j, color) {\r\n        super(i, j, color);\r\n    }\r\n}\r\n\r\n// 红色染料块\r\nclass Red extends Color{\r\n    constructor(i, j, color) {\r\n        super(i, j, color);\r\n    }\r\n}\r\n\r\n// 灰色染料块，同时里面的正方形或者圆形\r\nclass Grey extends Color{\r\n    constructor(i, j, color, prop) {\r\n        super(i, j, color, prop);\r\n    }\r\n}\r\n\r\n// 地图中心点\r\nclass Main extends Item{\r\n    constructor(i, j, grids) {\r\n        super(i, j);\r\n        this.grids = grids\r\n        this.img = 'main';\r\n        this.w = 26;\r\n        this.init();\r\n    }\r\n\r\n    init(){\r\n        this.type = app.levels[app.level].type;\r\n        this.num = app.levels[app.level].num;\r\n        this.getNum = 0;\r\n    }\r\n\r\n    update(){\r\n        if(app.line){\r\n            app.map.drawImage(this.x + 39, this.y + 39, urlImg['main'], 26);\r\n\r\n            this.info(this.x, this.y)\r\n        }else{\r\n            new Array(4).fill(0).map((item, j) => {\r\n                new Array(4).fill(0).map((item, i) => {\r\n                    this.grids[6 + j][6 + i].tool = 'main';\r\n                    app.map.ctx.fillStyle = 'red';\r\n                    app.map.ctx.fillRect(this.x + ((i + 6) * 6.5), this.y + ((j + 6) * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16)\r\n                })\r\n            })\r\n\r\n            app.map.drawImage((this.x + 26), this.y, urlImg['weizi'], 52);\r\n        }\r\n    }\r\n\r\n    info(x, y){\r\n        app.map.ctx.font = 'bold 1.5px Arial';\r\n        app.map.ctx.textAlign = 'left';\r\n        app.map.ctx.fillStyle = '#ffffff';\r\n        app.map.ctx.fillText('关卡', x + (6 * 6.5) + 3.5, y + (7 * 6.5) - 2.5);\r\n        app.map.ctx.fillText(app.level + 1, x + (6 * 6.5) + 4.5, y + (7 * 6.5) - 0.5);\r\n\r\n\r\n        app.map.drawImage((x + (6 * 6.5) + 4.5), y + (7 * 6.5) + 1, urlImg[this.type], 7.5);\r\n        // app.map.drawImage(\r\n        //     x + (6 * 6.5) + 4.5,\r\n        //     y + (7 * 6.5) + 1,\r\n        //     urlImg[this.type],\r\n        //     7.5,\r\n        //     7.5,\r\n        //     -30,\r\n        //     0,\r\n        //     60,\r\n        //     60\r\n        // )\r\n\r\n        app.map.ctx.font = 'bold 3px Arial';\r\n        app.map.ctx.textAlign = 'left';\r\n        app.map.ctx.fillStyle = '#555';\r\n        app.map.ctx.fillText('关卡', x + (8 * 6.5) - 1.8, y + (7 * 6.5));\r\n        app.map.ctx.fillText('解锁', x + (8 * 6.5) - 1.8, y + (9 * 6.5) - 2);\r\n        app.map.ctx.fillStyle = '#FD0752';\r\n        app.map.ctx.fillText(app.levels[app.level].info, x + (8 * 6.5) - 1.8, y + (9 * 6.5) + 1.5);\r\n\r\n\r\n        app.map.ctx.font = 'bold 5px Arial';\r\n        app.map.ctx.textAlign = 'left';\r\n        app.map.ctx.fillStyle = '#555';\r\n        app.map.ctx.fillText(this.getNum, x + (8 * 6.5) + 1.5, y + (8 * 6.5) - 2);\r\n        app.map.ctx.font = 'bold 3px Arial';\r\n        app.map.ctx.fillStyle = '#b1b1b1';\r\n        app.map.ctx.fillText(\\\"/\\\" + this.num, x + (8 * 6.5) + 1.5, y + (8 * 6.5) + 1);\r\n    }\r\n}\r\n\r\n```\r\nGrid类里新增一个 **add方法** 放入的生成的噪点里\r\n```\r\n// 添加噪点\r\nadd(){\r\n    if(this.show > 0 && !app.line) return;\r\n    if(this.first) return;\r\n    this.grids = this.grids.map((item, j) => {\r\n        return item.map((item, i) => {\r\n            if(item.if) {\r\n                let color = new cont[Object.keys(this.color)[0]](this.x + (i * 6.5), this.y + (j * 6.5), this.color, this.prop)\r\n                color.update();\r\n                item.color = color;\r\n                return item;\r\n            }\r\n            return item\r\n        })\r\n    })\r\n    this.first = true;\r\n}\r\n\r\n// canvas网格地图绘制里的 Grid 类里的 update\r\nupdate(){\r\n    if(this.show > 0 && !app.line) return;\r\n    // 调用把不同类型的开采区添加进噪点\r\n    this.add();\r\n\r\n    app.map.begin();\r\n    this.grids.map((item, j) => {\r\n        item.map((item, i) => {\r\n            if(app.line){\r\n                app.map.ctx.strokeStyle = '#E3E7EA';\r\n                app.map.ctx.lineWidth = '0.2'\r\n                app.map.ctx.strokeRect(this.x + (i * 6.5), this.y + (j * 6.5), Math.abs(app.game.w) / 16, Math.abs(app.game.h) / 16);\r\n            }\r\n            if(item.if) {\r\n                item.color.update();\r\n            }\r\n        })\r\n    })\r\n    app.map.close();\r\n}\r\n\r\nlet cont = {red: Red, green: Green, blue: Blue, grey: Grey};\r\n```\r\n别眨眼！看看完成出来的效果（图一原版，图二完成的效果），是不是有一种以假乱真甚至更好看的感觉！\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41a4691aa11448d0a0dd8ec132559b5d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d7742306b804724b5b2c62088f2e914~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n## 地图工具放置\r\n因为只写了第一关的原因，目前我只搞的工具也就是第一关和第二关的首先创建一个tools的大数组，里面保存的每个对象都代表一个工具，我来讲讲对象里面的每个属性都代表什么：\r\n\r\n| 属性 | 代表的东西 |\r\n| --- | --- |\r\n| type | 工具类型 |\r\n| img | 工具的图片 |\r\n| level | 解锁这个工具的关卡 |\r\n\r\n```\r\n// 所有工具\r\nlet tools: [\r\n    {type: 'path', img: 'https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a739cc9118468cbb9d2a70a22bffc2~tplv-k3u1fbpfcp-watermark.image?', level: 0},\r\n    {type: '', img: '', level: 9},\r\n    {type: '', img: '', level: 9},\r\n    {type: 'miner', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7bc18ef96c40af8e8ff74fbed9c5bb~tplv-k3u1fbpfcp-watermark.image?', level: 0},\r\n    {type: 'cut', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6336eefefa94937adfe7e0ade7d25b1~tplv-k3u1fbpfcp-watermark.image?', level: 1},\r\n    {type: '', img: '', level: 9},\r\n    {type: '', img: '', level: 9},\r\n    {type: '', img: '', level: 9},\r\n    {type: '', img: '', level: 9},\r\n    {type: 'remove', img: 'https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934ebad4852405dab42d5e956c4d70f~tplv-k3u1fbpfcp-zoom-mark-crop-v2:460:460:0:0.awebp?', level: 1},\r\n];\r\n// 正在使用的工具保存\r\nlet tool = [];\r\n\r\n// 方向数组\r\nlet dirs = [\r\n    'top',\r\n    'right',\r\n    'bottom',\r\n    'left',\r\n];\r\n// 现在的方向\r\nlet dir = 0;\r\n```\r\n然后就是和开采区的创建一样，一个主类，然后分出每个工具的继承类\r\n```\r\n// 工具通用继承Class\r\nclass Tool{\r\n    constructor(i, j) {\r\n        this.i = i;\r\n        this.j = j;\r\n        this.w = app.game.w / 16;\r\n        this.h = app.game.h / 16;\r\n        this.x = this.i * this.w;\r\n        this.y = this.j * this.h;\r\n        this.img = '';\r\n        this.pre = false;\r\n        this.timer = false;\r\n        this.goods = []\r\n    }\r\n\r\n    update(fn){\r\n        if(this.img === '') return;\r\n\r\n        app.map.begin();\r\n        fn && fn();\r\n        app.map.drawImage(this.x, this.y, urlImg[this.img], this.w);\r\n        app.map.close();\r\n    }\r\n\r\n    getNearby() {\r\n        return [\r\n            [this.i - 1, this.j, 'left'],\r\n            [this.i + 1, this.j, 'right'],\r\n            [this.i, this.j - 1, 'top'],\r\n            [this.i, this.j + 1, 'bottom'],\r\n        ].map(item => {\r\n            return {\r\n                grid: app.game.getGrid(...item),\r\n                dir: item[2]\r\n            }\r\n        }).filter(item => item.grid.tool)\r\n    }\r\n\r\n    getNearbyGrid(){\r\n        return [\r\n            [this.i - 1, this.j, 'left'],\r\n            [this.i + 1, this.j, 'right'],\r\n            [this.i, this.j - 1, 'top'],\r\n            [this.i, this.j + 1, 'bottom'],\r\n        ].map(item => {\r\n            return {\r\n                grid: app.game.getGrid(...item),\r\n                dir: item[2]\r\n            }\r\n        }).filter(item => item.grid)\r\n    }\r\n}\r\n\r\n// 开采器工具\r\nclass Miner extends Tool{\r\n    constructor(i, j, dir) {\r\n        super(i, j, dir);\r\n        this.img = 'miner';\r\n        this.dir = dir;\r\n        this.pre = false;\r\n    }\r\n\r\n    update(){\r\n        super.update(() => {\r\n            if(this.dir === 'right'){\r\n                this.rotate = 90;\r\n            }else if(this.dir === 'bottom'){\r\n                this.rotate = 180;\r\n            }else if(this.dir === 'left'){\r\n                this.rotate = 270\r\n            }else if(this.dir === 'top'){\r\n                this.rotate = 0;\r\n            }\r\n            app.map.ctx.globalAlpha = this.pre ? .4 : 1;\r\n            app.map.rotate(this.x, this.y, this.rotate);\r\n        })\r\n    }\r\n}\r\n\r\n// 剪切工具\r\nclass Cut extends Tool{\r\n    constructor(i, j, dir) {\r\n        super(i, j, dir);\r\n        this.img = 'cut'\r\n        this.dir = dir;\r\n        this.pre = false;\r\n    }\r\n\r\n    update(){\r\n        if(this.dir === 'right'){\r\n            this.rotate = 90;\r\n        }else if(this.dir === 'bottom'){\r\n            this.rotate = 180;\r\n        }else if(this.dir === 'left'){\r\n            this.rotate = 270\r\n        }else if(this.dir === 'top'){\r\n            this.rotate = 0;\r\n        }\r\n\r\n        app.map.begin();\r\n        app.map.ctx.globalAlpha = this.pre ? .4 : 1;\r\n        app.map.rotate(this.x, this.y, this.rotate);\r\n        console.log(this.w * this.wd, this.h * this.hd)\r\n        app.map.drawImage(this.x, this.y, urlImg[this.img], this.w * 2, this.h);\r\n        app.map.close();\r\n    }\r\n}\r\n\r\n// 画路工具\r\nclass Path extends Tool{\r\n    constructor(i, j, dir, nextDir) {\r\n        super(i, j, dir);\r\n        this.dir = dir;\r\n        this.img = '';\r\n        if (nextDir) {\r\n            this.nextDir = nextDir;\r\n            this.img = `path_${this.dir}_${this.nextDir}`;\r\n            return;\r\n        }\r\n        this.nextDir = app.reversePos(this.dir)\r\n\r\n        this.img = `path_${this.dir}_${this.nextDir}`;\r\n    }\r\n\r\n    update(){\r\n        super.update(() => {\r\n            app.map.ctx.globalAlpha = this.pre ? .4 : 1;\r\n        })\r\n    }\r\n}\r\n```\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa463c2c01f846b6b93fb33b8688f000~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"工具使用.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n## 地图开采与运行\r\n逻辑很浅显，就是开采器的放置位置是可开采的区域里，并且开采器的朝向旁边的路起始方向是一致的就能进行开采，那么这层逻辑有了，需要思考的就是怎么生成开采出的东西，还有中心收集点的正确收集判断了\r\n\r\n### 判断是否达到生成的条件\r\n```\r\nclass Tool{\r\n    // 生成开采物判断\r\n    isCorrect(){\r\n        if(this instanceof Miner) {\r\n            if(app.game.getGrid(this.i, this.j).color){\r\n                let nearby = this.getNearbyGrid().filter(item => {\r\n                    if(item.grid.tool && (app.reversePos(item.grid.tool.dir) === this.dir)){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                })\r\n\r\n                if(nearby.length < 1) return false;\r\n                return true\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n### 生成开采物\r\n```\r\n// 每个方块开采出来的东西\r\nclass Goods{\r\n    constructor(i ,j, type, dir) {\r\n        this.i = i;\r\n        this.j = j;\r\n        this.x = this.i * 6.5;\r\n        this.y = this.j * 6.5;\r\n        this.type = type;\r\n        this.dir = dir;\r\n    }\r\n\r\n    // 判断下一步该往哪走\r\n    update(){\r\n        this.i = ((parseFloat(this.x.toFixed(1)) + 6.5) / 6.5);\r\n        this.j = ((parseFloat(this.y).toFixed(1)) / 6.5);\r\n        let grid = app.game.getGrid(this.i, this.j);\r\n        if(((parseFloat(this.x.toFixed(1)) + 6.5) % 6.5 === 0) && ((parseFloat(this.y).toFixed(1)) % 6.5 === 0)){\r\n\r\n            if(grid.tool) this.dir = grid.tool.nextDir || grid.tool.dir;\r\n            else this.dir = '';\r\n\r\n            let nearby = [];\r\n            if(grid.tool !== 'main') nearby = grid.tool.getNearby().filter(item => {\r\n                return item.dir === this.dir && item.grid.tool\r\n            })\r\n            this.getMain(grid)\r\n            if(nearby.length < 1) this.dir = '';\r\n        }\r\n        app.map.drawImage(this.x + (8), this.y + (1.5), urlImg[this.type], 104 / 32);\r\n        // app.map.drawImage(this.x + (8), this.y + (1.5), urlImg[this.type], 104 / 32, 104 / 32, this.x + (8), this.y + (1.5), 104 / 32, 104 / 32);\r\n    }\r\n\r\n    // 是否传输进入中心点，并判断是否符合中心点需求\r\n    getMain(grid){\r\n        if(!grid.tool || grid.tool === 'main') return;\r\n\r\n        let nearby = grid.tool.getNearby().filter(item => {\r\n            return grid.tool && (grid.tool.nextDir === item.dir) && item.grid.tool === 'main';\r\n        })\r\n\r\n        if(nearby.length >= 1) {\r\n            if(this.type === app.game.get(40, 39).main.type){\r\n                setTimeout(() => {\r\n                    app.game.get(40, 39).main.getNum += 1;\r\n                    app.game.get(40, 39).main.info();\r\n                    if(app.game.get(40, 39).main.getNum === app.game.get(40, 39).main.num){\r\n                        app.level += 1\r\n                        app.game.get(40, 39).main.init();\r\n                        $('.rank').show();\r\n                        app.game.get(40, 39).main.info();\r\n                    }\r\n                }, 1000)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n最终效果.\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0401685e6d4f08aaa23d96d7952127~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"完成游戏.gif\\\"  width=\\\"70%\\\"/></p>\r\n\r\n# 在线代码链接\r\n\r\n[https://code.juejin.cn/pen/7157617542360465416](url) \r\n\r\n[异形工厂（更新中） - 码上掘金 (juejin.cn)](https://code.juejin.cn/pen/7157617542360465416)\r\n\r\n# 结束语\r\n目前截止到我准备发布这篇文章的时候，这个游戏其实也才做到第二关。但接下来关卡的制作无疑是飞速的，因为剩下需要考虑的知识变成了每个关卡解锁的工具使用上的思路编写了，如果这个星期的时间充裕的话我会抓经更新完剩下的关卡~ 当然上面的代码解析也只是讲了一些比较模糊的概念，如果掘友们有需要我进行**详细解析的功能板块**可以在**评论区留言**我会抓经和下几关的内容同时更新出一篇相关文章的！！也希望掘友们能为我的**文章**和**在线代码** 动动手指 **点个赞**！爱你们~\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883ced87fc0a47428099d17c7c5be66c~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"B8JEXOV)94WX`PQ(0YV6V1K.gif\\\"  width=\\\"70%\\\"/></p>\r\n"
    },
    {
        "article_id": "7181788687922004026",
        "snapshot": "",
        "title": "大文件上传",
        "preview": "如何上传 10GB 左右的视频文件？ 如果通过以前的二进制上传方式，将它一次性上传将会产生一系列问题。 Request Body 过大，在上传 9GB 左右失败时，需要重新全部上传，浪费时间 Requ",
        "author": "程序员山月",
        "view_count": 3873,
        "collect_count": 57,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1df0b16dca8f55848b52fbb94f6c058b~300x300.image",
        "category": "前端",
        "content": "如何上传 10GB 左右的视频文件？\r\n\r\n如果通过以前的二进制上传方式，将它一次性上传将会产生一系列问题。\r\n\r\n1. `Request Body` 过大，在上传 9GB 左右失败时，需要重新全部上传，浪费时间\r\n1. `Request Body` 过大，导致时间过长\r\n\r\n既然上传整个视频文件过大，那将它**分割成 N 个小块上传**，服务器端再将其进行拼接，岂不是可以解决问题？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e875510e4524015b510f3db094947bf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上传效果可在 [Apifox](https://www.apifox.cn/a1shanyue) 查看：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37d2ebe3d6d4e62863287ebbf99f6aa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 客户端分割\r\n\r\n资源分为二进制资源与文本资源，文本资源很容易被分割与拼接，那二进制资源呢？\r\n\r\n我们在浏览器端上传二进制资源时，通过 `Blob` 进行上传，可使用 [Blob.prototype.slice](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) 进行切片。\r\n\r\n``` js\r\nconst blob = instanceOfBlob.slice([start [, end [, contentType]]]}\r\n```\r\n\r\n通过 `createChunks` 函数可创建分片，并通过 `uploadChunks` 上传分片，在所有分片上传完成之后发送请求通知服务端进行切片合并。\r\n\r\n``` js\r\nfunction createChunks(blob, chunkSize) {\r\n  const chunks = []\r\n  let id = 0\r\n  while (start < blob.size) {\r\n    chunks.push({\r\n      blob: blob.slice(id * chunkSize, (id + 1) * chunkSize),\r\n      id: id\r\n    })\r\n    id++\r\n  }\r\n  return chunks\r\n}\r\n\r\nasync function uploadChunks(chunks) {\r\n  for (const chunk of chunks) {\r\n    const form = new FormData()\r\n    form.append('blob', chunk.blob)\r\n    form.append('id', chunk.id)\r\n    \r\n    // 分片上传大文件\r\n    await fetch('/upload-bigfile', {\r\n      body: form\r\n    })\r\n  }\r\n  // 全部分片上传完成之后，可以通知服务器端合并所有分片\r\n  await fetch('/upload-bigfile/merge')\r\n}\r\n```\r\n\r\n在上传切片的过程中，为了保证上传速度，可通过 [p-map](https://github.com/sindresorhus/p-map) 控制并发上传。\r\n\r\n上传效果可在 [Apifox](https://www.apifox.cn/a1shanyue) 查看：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37d2ebe3d6d4e62863287ebbf99f6aa~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 服务器拼接\r\n\r\n## 作业\r\n\r\n1. 如何实现大文件上传"
    },
    {
        "article_id": "7186880907582636069",
        "snapshot": "",
        "title": "RocketMQ消息短暂而又精彩的一生",
        "preview": "大家好，我是三友~~ 这篇文章我准备来聊一聊RocketMQ消息的一生。 不知你是否跟我一样，在使用RocketMQ的时候也有很多的疑惑： 消息是如何发送的，队列是如何选择的？ 消息是如何存储的，是如",
        "author": "zzyang90",
        "view_count": 2625,
        "collect_count": 63,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/358bdb9bb0877f0b0667b577faca7ab5~300x300.image",
        "category": "后端",
        "content": "大家好，我是三友~~\r\n\r\n这篇文章我准备来聊一聊RocketMQ消息的一生。\r\n\r\n不知你是否跟我一样，在使用RocketMQ的时候也有很多的疑惑：\r\n\r\n-   消息是如何发送的，队列是如何选择的？\r\n-   消息是如何存储的，是如何保证读写的高性能？\r\n-   RocketMQ是如何实现消息的快速查找的？\r\n-   RocketMQ是如何实现高可用的？\r\n-   消息是在什么时候会被清除？\r\n-   ...\r\n\r\n本文就通过探讨上述问题来探秘消息在RocketMQ中短暂而又精彩的一生。\r\n\r\n如果你还没用过RocketMQ，可以看一下这篇文章 [RocketMQ保姆级教程](https://mp.weixin.qq.com/s/4h6VoywgZgnrxMBx-rqCLg)\r\n\r\n## 核心概念\r\n\r\n-   **NameServer**：可以理解为是一个注册中心，主要是用来保存topic路由信息，管理Broker。在NameServer的集群中，NameServer与NameServer之间是没有任何通信的。\r\n-   **Broker**：核心的一个角色，主要是用来保存消息的，在启动时会向NameServer进行注册。Broker实例可以有很多个，相同的BrokerName可以称为一个Broker组，每个Broker组只保存一部分消息。\r\n-   **topic**：可以理解为一个消息的集合的名字，一个topic可以分布在不同的Broker组下。\r\n-   **队列（queue）** ：一个topic可以有很多队列，默认是一个topic在同一个Broker组中是4个。如果一个topic现在在2个Broker组中，那么就有可能有8个队列。\r\n-   **生产者**：生产消息的一方就是生产者\r\n-   **生产者组**：一个生产者组可以有很多生产者，只需要在创建生产者的时候指定生产者组，那么这个生产者就在那个生产者组\r\n-   **消费者**：用来消费生产者消息的一方\r\n-   **消费者组**：跟生产者一样，每个消费者都有所在的消费者组，一个消费者组可以有很多的消费者，不同的消费者组消费消息是互不影响的。\r\n\r\n## 消息诞生与发送\r\n\r\n我们都知道，消息是由业务系统在运行过程产生的，当我们的业务系统产生了消息，我们就可以调用RocketMQ提供的API向RocketMQ发送消息，就像下面这样\r\n\r\n```java\r\nDefaultMQProducer producer = new DefaultMQProducer(\\\"sanyouProducer\\\");\r\n//指定NameServer的地址\r\nproducer.setNamesrvAddr(\\\"localhost:9876\\\");\r\n//启动生产者\r\nproducer.start();\r\n//省略代码。。\r\nMessage msg = new Message(\\\"sanyouTopic\\\", \\\"TagA\\\", \\\"三友的java日记 \\\".getBytes(RemotingHelper.DEFAULT_CHARSET));\r\n// 发送消息并得到消息的发送结果，然后打印\r\nSendResult sendResult = producer.send(msg);\r\n```\r\n\r\n虽然代码很简单，我们不经意间可能会思考如下问题：\r\n\r\n-   代码中只设置了NameServer的地址，那么生产者是如何知道Broker所在机器的地址，然后向Broker发送消息的？\r\n-   一个topic会有很多队列，那么生产者是如何选择哪个队列发送消息？\r\n-   消息一旦发送失败了怎么办？\r\n\r\n#### 路由表\r\n\r\n当Broker在启动的过程中，Broker就会往NameServer注册自己这个Broker的信息，这些信息就包括自身所在服务器的ip和端口，还有就是自己这个Broker有哪些topic和对应的队列信息，这些信息就是路由信息，后面就统一称为路由表。\r\n\r\n![Broker向NameServer注册](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e96c964565b499d93d5d86baf0f206f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nBroker向NameServer注册\r\n\r\n当生产者启动的时候，会从NameServer中拉取到路由表，缓存到本地，同时会开启一个定时任务，默认是每隔30s从NameServer中重新拉取路由信息，更新本地缓存。\r\n\r\n#### 队列的选择\r\n\r\n好了通过上一节我们就明白了，原来生产者会从NameServer拉取到Broker的路由表的信息，这样生产者就知道了topic对应的队列的信息了。\r\n\r\n但是由于一个topic可能会有很多的队列，那么应该将消息发送到哪个队列上呢？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0adf7cc8db3644dc939bb7ecc1e3f033~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n面对这种情况，RocketMQ提供了两种消息队列的选择算法。\r\n\r\n-   轮询算法\r\n-   最小投递延迟算法\r\n\r\n**轮询算法** 就是一个队列一个队列发送消息，这些就能保证消息能够均匀分布在不同的队列底下，这也是RocketMQ默认的队列选择算法。\r\n\r\n但是由于机器性能或者其它情况可能会出现某些Broker上的Queue可能投递延迟较严重，这样就会导致生产者不能及时发消息，造成生产者压力过大的问题。所以RocketMQ提供了最小投递延迟算法。\r\n\r\n**最小投递延迟算法** 每次消息投递的时候会统计投递的时间延迟，在选择队列的时候会优先选择投递延迟时间小的队列。这种算法可能会导致消息分布不均匀的问题。\r\n\r\n如果你想启用最小投递延迟算法，只需要按如下方法设置一下即可。\r\n\r\n```java\r\nproducer.setSendLatencyFaultEnable(true);\r\n```\r\n\r\n当然除了上述两种队列选择算法之外，你也可以自定义队列选择算法，只需要实现MessageQueueSelector接口，在发送消息的时候指定即可。\r\n\r\n```java\r\nSendResult sendResult = producer.send(msg, new MessageQueueSelector() {\r\n    @Override\r\n    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\r\n        //从mqs中选择一个队列\r\n        return null;\r\n    }\r\n}, new Object());\r\n```\r\n\r\nMessageQueueSelector RocketMQ也提供了三种实现\r\n\r\n-   随机算法\r\n-   Hash算法\r\n-   根据机房选择算法（空实现）\r\n\r\n#### 其它特殊情况处理\r\n\r\n##### 发送异常处理\r\n\r\n终于，不论是通过RocketMQ默认的队列选择算法也好，又或是自定义队列选择算法也罢，终于选择到了一个队列，那么此时就可以跟这个队列所在的Broker机器建立网络连接，然后通过网络请求将消息发送到Broker上。\r\n\r\n但是不幸的事发生了，Broker挂了，又或者是机器负载太高了，发送消息超时了，那么此时RockerMQ就会进行重试。\r\n\r\nRockerMQ重试其实很简单，就是重新选择其它Broker机器中的一个队列进行消息发送，默认会重试两次。\r\n\r\n当然如果你的机器比较多，可以将设置重试次数设置大点。\r\n\r\n```java\r\nproducer.setRetryTimesWhenSendFailed(10);\r\n```\r\n\r\n##### 消息过大的处理\r\n\r\n一般情况下，消息的内容都不会太大，但是在一些特殊的场景中，消息内容可能会出现很大的情况。\r\n\r\n遇到这种消息过大的情况，比如在默认情况下消息大小超过4M的时候，RocketMQ是会对消息进行压缩之后再发送到Broker上，这样在消息发送的时候就可以减少网络资源的占用。\r\n\r\n## 消息存储\r\n\r\n好了，经过以上环节Broker终于成功接收到了生产者发送的消息了，但是为了能够保证Broker重启之后消息也不丢失，此时就需要将消息持久化到磁盘。\r\n\r\n#### 如何保证高性能读写\r\n\r\n由于涉及到消息持久化操作，就涉及到磁盘数据的读写操作，那么如何实现文件的高性能读写呢？这里就不得不提到的一个叫零拷贝的技术。\r\n\r\n##### 传统IO读写方式\r\n\r\n说零拷贝之前，先说一下传统的IO读写方式。\r\n\r\n比如现在需要将磁盘文件通过网络传输出去，那么整个传统的IO读写模型如下图所示\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a6100c5e534869a7aabc10fe3e2970~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n传统的IO读写其实就是read + write的操作，整个过程会分为如下几步\r\n\r\n-   用户调用read()方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换1\r\n-   将磁盘数据通过DMA拷贝到内核缓存区\r\n-   将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据\r\n-   read()方法返回，此时就会从内核态切换到用户态，也就是图示的切换2\r\n-   当我们拿到数据之后，就可以调用write()方法，此时上下文会从用户态切换到内核态，即图示切换3\r\n-   CPU将用户缓冲区的数据拷贝到Socket缓冲区\r\n-   将Socket缓冲区数据拷贝至网卡\r\n-   write()方法返回，上下文重新从内核态切换到用户态，即图示切换4\r\n\r\n整个过程发生了4次上下文切换和4次数据的拷贝，这在高并发场景下肯定会严重影响读写性能。\r\n\r\n所以为了减少上下文切换次数和数据拷贝次数，就引入了零拷贝技术。\r\n\r\n##### 零拷贝\r\n\r\n零拷贝技术是一个思想，指的是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。\r\n\r\n实现零拷贝的有以下几种方式\r\n\r\n-   mmap()\r\n-   sendfile()\r\n\r\n###### mmap()\r\n\r\nmmap（memory map）是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。\r\n\r\n简单地说就是内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。\r\n\r\n比如基于mmap，上述的IO读写模型就可以变成这样。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ef512115914bd38a2a919dd34dbf81~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n基于mmap IO读写其实就变成mmap + write的操作，也就是用mmap替代传统IO中的read操作。\r\n\r\n当用户发起mmap调用的时候会发生上下文切换1，进行内存映射，然后数据被拷贝到内核缓冲区，mmap返回，发生上下文切换2；随后用户调用write，发生上下文切换3，将内核缓冲区的数据拷贝到Socket缓冲区，write返回，发生上下文切换4。\r\n\r\n整个过程相比于传统IO主要是不用将内核缓冲区的数据拷贝到用户缓冲区，而是直接将数据拷贝到Socket缓冲区。上下文切换的次数仍然是4次，但是拷贝次数只有3次，少了一次CPU拷贝。\r\n\r\n在Java中，提供了相应的api可以实现mmap，当然底层也还是调用Linux系统的mmap()实现的\r\n\r\n```java\r\nFileChannel fileChannel = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\").getChannel();\r\nMappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size());\r\n```\r\n\r\n如上代码拿到MappedByteBuffer，之后就可以基于MappedByteBuffer去读写。\r\n\r\n###### sendfile()\r\n\r\nsendfile()跟mmap()一样，也会减少一次CPU拷贝，但是它同时也会减少两次上下文切换。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f4c7fb31e2a45de93cca535b2e8ab96~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如图，用户发起sendfile()调用时会发生切换1，之后数据通过DMA拷贝到内核缓冲区，之后再将内核缓冲区的数据CPU拷贝到Socket缓冲区，最后拷贝到网卡，sendfile()返回，发生切换2。\r\n\r\n同样地，Java也提供了相应的api，底层还是操作系统的sendfile()\r\n\r\n```java\r\nFileChannel channel = FileChannel.open(Paths.get(\\\"./test.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\r\n//调用transferTo方法向目标数据传输\r\nchannel.transferTo(position, len, target);\r\n```\r\n\r\n通过FileChannel的transferTo方法即可实现。\r\n\r\ntransferTo方法（sendfile）主要是用于文件传输，比如将文件传输到另一个文件，又或者是网络。\r\n\r\n在如上代码中，并没有文件的读写操作，而是直接将文件的数据传输到target目标缓冲区，也就是说，sendfile是无法知道文件的具体的数据的；但是mmap不一样，他是可以修改内核缓冲区的数据的。假设如果需要对文件的内容进行修改之后再传输，只有mmap可以满足。\r\n\r\n通过上面的一些介绍，主要就是一个结论，那就是基于零拷贝技术，可以减少CPU的拷贝次数和上下文切换次数，从而可以实现文件高效的读写操作。\r\n\r\nRocketMQ内部主要是使用基于mmap实现的零拷贝(其实就是调用上述提到的api)，用来读写文件，这也是RocketMQ为什么快的一个很重要原因。\r\n\r\n![RocketMQ中使用mmap代码](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d063f8e2da504e05b33dbf75b2f49892~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nRocketMQ中使用mmap代码\r\n\r\n#### CommitLog\r\n\r\n前面提到消息需要持久化到磁盘文件中，而CommitLog其实就是存储消息的文件的一个称呼，所有的消息都存在CommitLog中，一个Broker实例只有一个CommitLog。\r\n\r\n由于消息数据可能会很大，同时兼顾内存映射的效率，不可能将所有消息都写到同一个文件中，所以CommitLog在物理磁盘文件上被分为多个磁盘文件，每个文件默认的固定大小是1G。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e4614734fb4298ba27c110ce424b40~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当生产者将消息发送过来的时候，就会将消息按照顺序写到文件中，当文件空间不足时，就会重新建一个新的文件，消息写到新的文件中。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962ddc06377045e3935271a9f7c60bef~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n消息在写入到文件时，不仅仅会包含消息本身的数据，也会包含其它的对消息进行描述的数据，比如这个消息来自哪台机器、消息是哪个topic的、消息的长度等等，这些数据会和消息本身按照一定的顺序同时写到文件中，所以图示的消息其实是包含消息的描述信息的。\r\n\r\n#### 刷盘机制\r\n\r\nRocketMQ在将消息写到CommitLog文件中时并不是直接就写到文件中，而是先写到PageCache，也就是前面说的内核缓存区，所以RocketMQ提供了两种刷盘机制，来将内核缓存区的数据刷到磁盘。\r\n\r\n##### 异步刷盘\r\n\r\n异步刷盘就是指Broker将消息写到PageCache的时候，就直接返回给生产者说消息存储成功了，然后通过另一个后台线程来将消息刷到磁盘，这个后台线程是在RokcetMQ启动的时候就会开启。异步刷盘方式也是RocketMQ默认的刷盘方式。\r\n\r\n其实RocketMQ的异步刷盘也有两种不同的方式，一种是固定时间，默认是每隔0.5s就会刷一次盘；另一种就是频率会快点，就是每存一次消息就会通知去刷盘，但不会去等待刷盘的结果，同时如果0.5s内没被通知去刷盘，也会主动去刷一次盘。默认的是第一种固定时间的方式。\r\n\r\n##### 同步刷盘\r\n\r\n同步刷盘就是指Broker将消息写到PageCache的时候，会等待异步线程将消息成功刷到磁盘之后再返回给生产者说消息存储成功。\r\n\r\n同步刷盘相对于异步刷盘来说消息的可靠性更高，因为异步刷盘可能出现消息并没有成功刷到磁盘时，机器就宕机的情况，此时消息就丢了；但是同步刷盘需要等待消息刷到磁盘，那么相比异步刷盘吞吐量会降低。所以同步刷盘适合那种对数据可靠性要求高的场景。\r\n\r\n如果你需要使用同步刷盘机制，只需要在配置文件指定一下刷盘机制即可。\r\n\r\n## 高可用\r\n\r\n在说高可用之前，先来完善一下前面的一些概念。\r\n\r\n在前面介绍概念的时候也说过，一个RokcetMQ中可以有很多个Broker实例，相同的BrokerName称为一个组，同一个Broker组下每个Broker实例保存的消息是一样的，不同的Broker组保存的消息是不一样的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1873e00b93241deb918aaab39e26b29~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如图所示，两个BrokerA实例组成了一个Broker组，两个BrokerB实例也组成了一个Broker组。\r\n\r\n前面说过，每个Broker实例都有一个CommitLog文件来存储消息的。那么两个BrokerA实例他们CommitLog文件存储的消息是一样的，两个BrokerB实例他们CommitLog文件存储的消息也是一样的。\r\n\r\n那么BrokerA和BrokerB存的消息不一样是什么意思呢？\r\n\r\n其实很容易理解，假设现在有个topicA存在BrokerA和BrokerB上，那么topicA在BrokerA和BrokerB默认都会有4个队列。\r\n\r\n前面在说发消息的时候需要选择一个队列进行消息的发送，假设第一次选择了BrokerA上的队列发送消息，那么此时这条消息就存在BrokerA上，假设第二次选择了BrokerB上的队列发送消息，那么那么此时这条消息就存在BrokerB上，所以说BrokerA和BrokerB存的消息是不一样的。\r\n\r\n那么为什么同一个Broker组内的Broker存储的消息是一样的呢？其实比较容易猜到，就是为了保证Broker的高可用，这样就算Broker组中的某个Broker挂了，这个Broker组依然可以对外提供服务。\r\n\r\n那么如何实现同Broker组的Broker存的消息数据相同的呢？这就不得不提到Broker的高可用模式。\r\n\r\nRocketMQ提供了两种Broker的高可用模式\r\n\r\n-   主从同步模式\r\n-   Dledger模式\r\n\r\n#### 主从同步模式\r\n\r\n在主从同步模式下，在启动的时候需要在配置文件中指定BrokerId，在同一个Broker组中，BrokerId为0的是主节点（master），其余为从节点(slave)。\r\n\r\n当生产者将消息写入到主节点是，主节点会将消息内容同步到从节点机器上，这样一旦主节点宕机，从节点机器依然可以提供服务。\r\n\r\n主从同步主要同步两部分数据\r\n\r\n-   topic等数据\r\n-   消息\r\n\r\ntopic等数据是从节点每隔10s钟主动去主节点拉取，然后更新本身缓存的数据。\r\n\r\n消息是主节点主动推送到从节点的。当主节点收到消息之后，会将消息通过两者之间建立的网络连接发送出去，从节点接收到消息之后，写到CommitLog即可。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b8e9daf47754ffc853f56437f421d9b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n从节点有两种方式知道主节点所在服务器的地址，第一种就是在配置文件指定；第二种就是从节点在注册到NameServer的时候会返回主节点的地址。\r\n\r\n主从同步模式有一个比较严重的问题就是如果集群中的主节点挂了，这时需要人为进行干预，手动进行重启或者切换操作，而非集群自己从从节点中选择一个节点升级为主节点。\r\n\r\n为了解决上述的问题，所以RocketMQ在4.5.0就引入了Dledger模式。\r\n\r\n#### Dledger模式\r\n\r\n在Dledger模式下的集群会基于Raft协议选出一个节点作为leader节点，当leader节点挂了后，会从follower中自动选出一个节点升级成为leader节点。所以Dledger模式解决了主从模式下无法自动选择主节点的问题。\r\n\r\n在Dledger集群中，leader节点负责写入消息，当消息写入leader节点之后，leader会将消息同步到follower节点，当集群中过半数(节点数/2 +1)节点都成功写入了消息，这条消息才算真正写成功。\r\n\r\n至于选举的细节，这里就不多说了，有兴趣的可以自行谷歌，还是挺有意思的。\r\n\r\n## 消息消费\r\n\r\n终于，在生产者成功发送消息到Broker，Broker在成功存储消息之后，消费者要消费消息了。\r\n\r\n消费者在启动的时候会从NameSrever拉取消费者订阅的topic的路由信息，这样就知道订阅的topic有哪些queue，以及queue所在Broker的地址信息。\r\n\r\n为什么消费者需要知道topic对应的哪些queue呢？\r\n\r\n其实主要是因为消费者在消费消息的时候是以队列为消费单元的，消费者需要告诉Broker拉取的是哪个队列的消息，至于如何拉到消息的，后面再说。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61211d43c1044eb8f6eb6b5dd0f87da~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### 消费的两种模式\r\n\r\n前面说过，消费者是有个消费者组的概念，在启动消费者的时候会指定该消费者属于哪个消费者组。\r\n\r\n```java\r\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\\\"sanyouConsumer\\\");\r\n```\r\n\r\n一个消费者组中可以有多个消费者，不同消费者组之间消费消息是互不干扰的。\r\n\r\n在同一个消费者组中，消息消费有两种模式。\r\n\r\n-   集群模式\r\n-   广播模式\r\n\r\n##### 集群模式\r\n\r\n同一条消息只能被同一个消费组下的一个消费者消费，也就是说，同一条消息在同一个消费者组底下只会被消费一次，这就叫集群消费。\r\n\r\n集群消费的实现就是将队列按照一定的算法分配给消费者，默认是按照平均分配的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73e26bb3216549058852131a7f254c8a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如图所示，将每个队列分配只分配给同一个消费者组中的一个消费者，这样消息就只会被一个消费者消费，从而实现了集群消费的效果。\r\n\r\nRocketMQ默认是集群消费的模式。\r\n\r\n##### 广播模式\r\n\r\n广播模式就是同一条消息可以被同一个消费者组下的所有消费者消费。\r\n\r\n其实实现也很简单，就是将所有队列分配给每个消费者，这样每个消费者都能读取topic底下所有的队列的数据，就实现了广播模式。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff8ecbcc48b4ecda19bbc6b431eb937~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果你想使用广播模式，只需要在代码中指定即可。\r\n\r\n```java\r\nconsumer.setMessageModel(MessageModel.BROADCASTING);\r\n```\r\n\r\n#### ConsumeQueue\r\n\r\n上一节我们提到消费者是从队列中拉取消息的，但是这里不经就有一个疑问，那就是消息明明都存在CommitLog文件中的，那么是如何去队列中拉的呢？难道是去遍历所有的文件，找到对应队列的消息进行消费么？\r\n\r\n答案是否定的，因为这种每次都遍历数据的效率会很低，所以为了解决这种问题，引入了ConsumeQueue的这个概念，而消费实际是从ConsumeQueue中拉取数据的。\r\n\r\n用户在创建topic的时候，Broker会为topic创建队列，并且每个队列其实会有一个编号queueId，每个队列都会对应一个ConsumeQueue，比如说一个topic在某个Broker上有4个队列，那么就有4个ConsumeQueue。\r\n\r\n前面说过，消息在发送的时候，会根据一定的算法选择一个队列，之后再发送消息的时候会携带选择队列的queueId，这样Broker就知道消息属于哪个队列的了。当消息被存到CommitLog之后，其实还会往这条消息所在的队列的ConsumeQueue插一条数据。\r\n\r\nConsumeQueue也是由多个文件组成，每个文件默认是存30万条数据。\r\n\r\n插入ConsumeQueue中的每条数据由20个字节组成，包含3部分信息，消息在CommitLog的起始位置（8个字节），消息在CommitLog存储的长度（8个字节），还有就是tag的hashCode（4个字节）。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9930fcce31a04674a7b09d4b2ee747b4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以当消费者从Broker拉取消息的时候，会告诉Broker拉取哪个队列（queueId）的消息、这个队列的哪个位置的消息（queueOffset）。\r\n\r\nqueueOffset就是指上图中ConsumeQueue一条数据的编号，单调递增的。\r\n\r\nBroker在接受到消息的时候，找个指定队列的ConsumeQueue，由于每条数据固定是20个字节，所以可以轻易地计算出queueOffset对应的那条数据在哪个文件的哪个位置上，然后读出20个字节，从这20个字节中在解析出消息在CommitLog的起始位置和存储的长度，之后再到CommitLog中去查找，这样就找到了消息，然后在进行一些处理操作返回给消费者。\r\n\r\n到这，我们就清楚的知道消费者是如何从队列中拉取消息的了，其实就是先从这个队列对应的ConsumeQueue中找到消息所在CommmitLog中的位置，然后再从CommmitLog中读取消息的。\r\n\r\n#### RocketMQ如何实现消息的顺序性\r\n\r\n这里插入一个比较常见的一个面试，那么如何保证保证消息的顺序性。\r\n\r\n其实要想保证消息的顺序只要保证以下三点即可\r\n\r\n-   生产者将需要保证顺序的消息发送到同一个队列\r\n-   消息队列在存储消息的时候按照顺序存储\r\n-   消费者按照顺序消费消息\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2107d1b563948f5a5f91d3f00c2dedb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第一点如何保证生产者将消息发送到同一个队列？\r\n\r\n上文提到过RocketMQ生产者在发送消息的时候需要选择一个队列，并且选择算法是可以自定义的，这样我们只需要在根据业务需要，自定义队列选择算法，将顺序消息都指定到同一个队列，在发送消息的时候指定该算法，这样就实现了生产者发送消息的顺序性。\r\n\r\n第二点，RocketMQ在存消息的时候，是按照顺序保存消息在ConsumeQueue中的位置的，由于消费消息的时候是先从ConsumeQueue查找消息的位置，这样也就保证了消息存储的顺序性。\r\n\r\n第三点消费者按照顺序消费消息，这个RocketMQ已经实现了，只需要在消费消息的时候指定按照顺序消息消费即可，如下面所示，注册消息的监听器的时候使用MessageListenerOrderly这个接口的实现。\r\n\r\n```java\r\nconsumer.registerMessageListener(new MessageListenerOrderly() {\r\n    @Override\r\n    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\r\n        //按照顺序消费消息记录\r\n        return null;\r\n    }\r\n});\r\n```\r\n\r\n## 消息清理\r\n\r\n由于消息是存磁盘的，但是磁盘空间是有限的，所以对于磁盘上的消息是需要清理的。\r\n\r\n当出现以下几种情况下时就会触发消息清理：\r\n\r\n-   手动执行删除\r\n-   默认每天凌晨4点会自动清理过期的文件\r\n-   当磁盘空间占用率默认达到75%之后，会自动清理过期文件\r\n-   当磁盘空间占用率默认达到85%之后，无论这个文件是否过期，都会被清理掉\r\n\r\n上述过期的文件是指文件最后一次修改的时间超过72小时(默认情况下)，当然如果你的老板非常有钱，服务器的磁盘空间非常大，可以将这个过期时间修改的更长一点。\r\n\r\n有的小伙伴肯定会有疑问，如果消息没有被消息，那么会被清理么？\r\n\r\n答案是会被清理的，因为清理消息是直接删除CommitLog文件，所以只要达到上面的条件就会直接删除CommitLog文件，无论文件内的消息是否被消费过。\r\n\r\n当消息被清理完之后，消息也就结束了它精彩的一生。\r\n\r\n## 消息的一生总结\r\n\r\n为了更好地理解本文，这里再来总结一下RokcetMQ消息一生的各个环节。\r\n\r\n##### 消息发送\r\n\r\n-   生产者产生消息\r\n-   生产者在发送消息之前会拉取topic的路由信息\r\n-   根据队列选择算法，从topic众多的队列中选择一个队列\r\n-   跟队列所在的Broker机器建立网络连接，将消息发送到Broker上\r\n\r\n##### 消息存储\r\n\r\n-   Broker接收到生产者的消息将消息存到CommitLog中\r\n-   在CosumeQueue中存储这条消息在CommitLog中的位置\r\n\r\n由于CommitLog和CosumeQueue都涉及到磁盘文件的读写操作，为了提高读写效率，RokcetMQ使用到了零拷贝技术，其实就是调用了一下Java提供的api。。\r\n\r\n##### 高可用\r\n\r\n如果是集群模式，那么消息会被同步到从节点，从节点会将消息存到自己的CommitLog文件中。这样就算主节点挂了，从节点仍然可以对外提供访问。\r\n\r\n##### 消息消费\r\n\r\n-   消费者会拉取订阅的Topic的路由信息，根据集群消费或者广播消费的模式来选择需要拉取消息的队列\r\n-   与队列所在的机器建立连接，向Broker发送拉取消息的请求\r\n-   Broker在接收到请求知道，找到队列对应的ConsumeQueue，然后计算出拉取消息的位置，再解析出消息在CommitLog中的位置\r\n-   根据解析出的位置，从CommitLog中读出消息的内容返回给消费者\r\n\r\n##### 消息清理\r\n\r\n由于消息是存在磁盘的，而磁盘的空间是有限的，所以RocketMQ会根据一些条件去清理CommitLog文件。\r\n\r\n## 最后\r\n\r\n最后，如果有对RocketMQ源码感兴趣的小伙伴可以从如下地址中拉取RocketMQ源码，里面我已经对RocketMQ一些核心组件的源码进行了注释。\r\n\r\n> ##### https://github.com/sanyou3/rocketmq.git\r\n\r\n**往期热门文章推荐**\r\n\r\n[写出漂亮代码的45个小技巧](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247492024&idx=1&sn=b7b9684fec7ec1788fd18188e9811a7b&chksm=cfdab270f8ad3b6665caffff821f95c0bd70b65386f96ef07f4fd2fc1f9f8aeda767ab78a66c&scene=21#wechat_redirect)\r\n\r\n[项目中引进这玩意，排查日志又快又准！](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247492883&idx=1&sn=39934e717fb24a27705a05f3454c0d9f&chksm=cfdab6dbf8ad3fcd705b9f568dc07be8ea2e55643d94f050f3534e803fef4b367e61ac7bd70d&scene=21#wechat_redirect)  \r\n\r\n\r\n[两万字盘点那些被玩烂了的设计模式](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247492497&idx=1&sn=31882a4693f0e09a419073b58ddf431e&chksm=cfdab059f8ad394f8fcafed1d96825a7393e491f4d287a0e0ab81e42e974ea87f3f54d973864&scene=21#wechat_redirect)  \r\n\r\n\r\n[RocketMQ保姆级教程](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247490508&idx=1&sn=4b7d12025bc9a090c9781cffed29e94d&chksm=cfd94804f8aec1123f1e6431b54e010c066647fa709bc41580e3deb0ba38851bf18a9f20214e&scene=21#wechat_redirect)\r\n\r\n[三万字盘点Spring/Boot的那些常用扩展点](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247489480&idx=1&sn=55e2f9cedb449c9e7615c2818b04eb46&chksm=cfd94400f8aecd1653557c05885c037cf932fc7596850ba7386a5dd85ad741f728093f8aa070&scene=21#wechat_redirect)\r\n\r\n[@Async注解的坑，小心](http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&mid=2247487761&idx=1&sn=efcecf89099e55f7a89579283edc27be&chksm=cfd942d9f8aecbcf188d12c5560c75a3e7ce2d064177d9665a1e2f8453f1f68cffac79871ee4&scene=21#wechat_redirect)"
    }
]