[
    {
        "article_id": "7189447528436203580",
        "snapshot": "",
        "title": "Flutter 耗时监控 | 路由名为空原因分析",
        "preview": "获取Route 名的需求开发中很常见，它可以作为一个标志更好区分业务维度定位问题，但在实际开发过程中很容易忽略细节导致Route.settings.name为空的问题，本文将从根上分析其中原因和细节。",
        "author": "听蝉",
        "view_count": 654,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/f8fe58173454dbbb09a919f421e3c08d~300x300.image",
        "category": "Android",
        "content": "\r\n\r\n## 前言\r\n\r\n最近群里遇到获取Route名为空的问题，当时没在意。。。\r\n\r\n<p align=center><img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050a5d9640ef4707a45920454590b383~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"Untitled.png\\\"  /></p>\r\n\r\n直到自己在监控页面启动耗时，需要确定当前页面是哪个从而方便标记它加载的耗时时，遇到同样 route.settings.name 为空问题，模拟场景如下：\r\n\r\n1. 在 main.dart 页面中点击 + 按钮跳转到 TestPage2 页面。\r\n2. MaterialApp 中设置路由守卫并在路由守卫中打印 route 名。\r\n\r\n\r\n![Untitled 1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2a56cde0c9f4cbea764543a042cb156~tplv-k3u1fbpfcp-watermark.image?)\r\nmain.dart\r\n\r\n\r\n![Untitled 2.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b497a7ed21c447fabe7360e3317f927~tplv-k3u1fbpfcp-watermark.image?)\r\nlaunch_observer.dart\r\n\r\n![Untitled 3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490625e121384b87bea6154e7a1930af~tplv-k3u1fbpfcp-watermark.image?)\r\nTestPage2.dart\r\n\r\n路由守卫中打印结果如下：\r\n\r\n![Untitled 4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/172a8742b7dc48d2a939d31df53aceac~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看出\r\n\r\n- 应用启动进入 main 打印是正确的，之前没有页面，进入时候打印 route = /\r\n- 进入 TestPage2 时，previewousRoute 的 name = / 正确，但是当前 route 的 settings.name 却为 null ，这就比较奇怪了。\r\n\r\n我试着复现文章开头的例子，代码如下：\r\n\r\n1. main.dart 不变，点击 + 跳转到 TestPage2\r\n2. 在 TestPage2 中获取路由参数和路由名字\r\n<p align=left><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2313dfbfdc3463b953fb0900c2f8fe8~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"Untitled 5.png\\\"  /></p>\r\n结果发现：name 的值仍然为 null;\r\n\r\n<p align=center><img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dae7543a3394aed9e43b95494e03cfd~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"Untitled 6.png\\\" width=\\\"50%\\\" /></p>\r\n\r\n## 原因解析\r\n\r\nMaterialPageRoute 继承关系\r\n\r\n\r\n![Untitled 7.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57f982f83b234188b468a64e9c4929c5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n最终我们要得到的 name 其实是 Route 内部的 RouteSettings 对象的 name。\r\n\r\n\r\n![Untitled 8.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ca90b0022942448829502c6a03a2b7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n而通过继承关系追溯，最终 Route 中的 RouteSettings② 由 MaterialPageRoute① 传过来。\r\n\r\n\r\n![Untitled 9.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0341da5c704ec79ce04e8221ee5b8f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![Untitled 10.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e235fdc9ab41f4a8f599a81860fef4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 解决办法\r\n\r\n很简单，在跳转页面之前给 MaterialPageRoute 设置 settings 属性。\r\n\r\n\r\n![Untitled 11.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6049a74413b945a2b0aac9429dbd659e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样就可以接受到 name 和传递过去参数了，如图：\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/840adc5b7f7246daa3d8e63a03f41b40~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"Untitled 12.png\\\" width=\\\"50%\\\" /></p>\r\n\r\n## 能不能自动设置 RouteSettings\r\n\r\n答案： 拿不到。\r\n\r\n### 思路一\r\n\r\n有这个想法是因为涉及到老代码的迁移，很多老代码不想一个个改加 Settings，偷个懒。而且平时用的时候大部分情况下都不会带 settings 属性。\r\n\r\n当然跟我有同样想法的人也有 [flutter - How to get the Widget Class name from the builder object in MaterialPageRoute - Stack Overflow](https://stackoverflow.com/questions/58659819/how-to-get-the-widget-class-name-from-the-builder-object-in-materialpageroute \\\"flutter - How to get the Widget Class name from the builder object in MaterialPageRoute - Stack Overflow\\\")\r\n\r\n\r\n![Untitled.jpeg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab8946ae02214cf28f72aaee81443e38~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n尝试如下：\r\n\r\n\r\n![Untitled 13.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad53d4642cb47b293926543c04cd651~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> PS: 哪位大佬有更好解决自动添加 RouteSetting 属性办法希望不吝赐教，多谢。\r\n\r\n### 思路二\r\n\r\n群里大佬指出可以尝试换个思路: **aop buildpage**。这里找到个帖子是这种思路，没验证各位大大可自行辨别，哈哈。\r\n\r\n[Flutter aspectd（五）全局监控 flutter 生命周期](https://juejin.cn/post/6989156477911072805 \\\"Flutter aspectd（五）全局监控flutter生命周期\\\")\r\n\r\n**核心点**\r\n\r\n> 当我们要打开一个新的 flutter 页面会执行 Navigator.pushNamed(context, RouteHelper.firstPage),最终会执行 navigator.dart 中的 handlePush 方法，hook 该方法，从该方法中可以得到我们要启动页面的 Route,以及当前的页面 Route。\r\n\r\n\r\n![Untitled 14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cc65be8175541caa977c62430fc44d7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 总结\r\n\r\n1. Route.settings.name 无法获取原因是 push/pushNamed 时 MaterialPageRoute 没设置 RouteSettings 属性。\r\n2. 如果老项目有埋点等需求需要监控页面名，建议老老实实给每个 MaterialPageRoute 加 RouteSettings 属性比较稳妥。\r\n3. 最最推荐的做法是通过 APT 方式模块化路由功能，这样应用中所有 MaterialPageRoute 生成过程就可以收拢，生成代码时将 RouteSettings 属性添加上即可。\r\n\r\n> 如果觉得文章对你有帮助，点赞、收藏、关注、评论，一键四连支持，你的支持就是我创作最大的动力。\r\n>\r\n> ❤️ 本文原创**[听蝉](https://juejin.cn/user/272334612863431/posts \\\"听蝉\\\")** 公众号：**码里特别有禅** 欢迎关注原创技术文章第一时间推送 ❤️\r\n\r\n> PS: 文中所有源码获取方式：公众号后台回复 “route”\r\n\r\n## 参考链接\r\n[flutter - How to get the Widget Class name from the builder object in MaterialPageRoute - Stack Overflow](https://stackoverflow.com/questions/58659819/how-to-get-the-widget-class-name-from-the-builder-object-in-materialpageroute)  \r\n[Flutter aspectd（五）全局监控flutter生命周期 - 掘金](https://juejin.cn/post/6989156477911072805)"
    },
    {
        "article_id": "7153986552287690760",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d269a4937bf34f32a5bc56d8b01562cd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2023 届秋招回顾，寒气逼人。。。",
        "preview": "最近几天朋友圈被一篇文章刷屏了，是一位参与了 2023 届秋招的同学分享的秋招回顾总结。 都说今年的秋招难，寒气弥漫，那我们一起来看看这位同学是如何准备秋招、如何应对焦虑，最终拿到 offer 的吧！",
        "author": "程序员追风",
        "view_count": 38174,
        "collect_count": 255,
        "comment_count": 70,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/ba74cb9d376f8f84e5cf942c321d9b86~300x300.image",
        "category": "后端",
        "content": "最近几天朋友圈被一篇文章刷屏了，是一位参与了 2023 届秋招的同学分享的秋招回顾总结。\r\n\r\n都说今年的秋招难，寒气弥漫，那我们一起来看看这位同学是如何准备秋招、如何应对焦虑，最终拿到 offer 的吧！\r\n\r\n以下是他的分享：\r\n\r\n> 原文链接：https://www.cnblogs.com/yuanchuziwen/p/16770895.html\r\n> \r\n> 作者：OliQ\r\n\r\n# 自我介绍\r\n\r\n我来自杭州的一所双非一本学校，是一名普通的本科生，专业【软件工程】。\r\n\r\n## 初学编程\r\n\r\n事实上，我从高中毕业起就开始思考未来的工作了，一开始网上都是 Python 相关的新闻，因此从高中毕业的暑假就开始学 Python，当时在新华书店，捧着一本入门书天天看；\r\n\r\n但是看了并没有什么用，除了大一的时候吹牛皮，啥都没学到。\r\n\r\n然后自 2020 年初(大一寒假) 疫情爆发，学校线上授课；课程中有【面向对象语言】的学习，自此开始正式的跟着视频学习 Java 了。\r\n\r\n## 第一次实习\r\n\r\n2021年暑假(大二暑假)，我的绩点排名在学校保研线边缘徘徊，但又不愿去刷那些水课的绩点，因此决定考研或者工作，期间比较迷茫。\r\n\r\n当时在网上得到一位大数据方向前辈的指点，他说了一句话：“早，就是优势。”\r\n\r\n因此，我决定先去实习，当时在杭州人工智能小镇找了家公司实习。\r\n\r\n虽说是实习，但其实基本每天上班啥也不干，主管也没分配任务，就是一直在看书，期间看完了周志明老师的 JVM，以及几本讲并发编程的书。\r\n\r\n## 第二次实习\r\n\r\n大三上时，眼看着 Java 越来越卷，自己开始学习了大数据相关的组件，像 Hadoop、HBase、Flume 等等组件，一直学到了实时计算之前。\r\n\r\n大三下时，我明白自己是一个心态非常不稳定的人，考研对我来说，最后几个月会非常的难熬，并且考研失败的风险也让我望而却步，因此下定决心本科就业！\r\n\r\n寒假的时候跟着视频完成了【谷粒商城】那个项目，之后立刻着手准备找实习。\r\n\r\n也就是在这第二段实习过程中(2022上半年)，我真正的学到了一些实际的开发技巧。\r\n\r\n实习期间，看完了几本深入讲中间件 ZK、Redis、Spring源码 和 代码重构的书。\r\n\r\n本次实习，让我受益良多，由衷感谢我的 mentor（导师）和主管！\r\n\r\n# 秋招情况\r\n\r\n我从 6 月底开始复习准备，因为准备得比较晚，所以基本没参加提前批。\r\n\r\n正式批总共投递了近 150 家公司，笔试了 30 家，面试了 15 个公司，除了海康威视，其他基本都意向或排序了。\r\n\r\n大致情况如下：\r\n\r\n-   offer：兴业数金\r\n-   意向：猿辅导，Aloudata\r\n-   排序 / 审批：华为，网易雷火，荣耀，招银网络，古茗奶茶，CVTE，以及一众独角兽公司\r\n-   面试挂：海康威视\r\n\r\n## CVTE 提前批面试（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a854792cb6334e9388f4ea7e05520a46~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 大应科技（OC）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb1a384652c48e3a69aac60ef7e1284~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## e签宝 提前批（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072ce7fc5249461b9b9490481fd79cd6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n## 荣耀 Honor（录用决策中）\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b4e84f242d491ba69acdff1f112b76~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 猿辅导（OC）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48c60fe3bf5481cb306b2802087ac1d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 趣链科技（流程中）\r\n\r\n![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d760694d8294b3e95d9dfefb94c6a6f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 海康威视（已挂）\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3c4f95b5bc40c18bb1c43bc412404f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## SMART（已拒）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c99b296eba544729fdb130c330cbc9a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 寒王厂（泡池子）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eaf6481144648e49ca79ff6e4be5562~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n## 网易雷火（排序中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cddc3b08edad48b8b6650037b1732c92~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n## 招银网络（流程中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05f676cd1434d5bbc3949c0826c3889~tplv-k3u1fbpfcp-zoom-1.image)\r\n  \r\n## 古茗奶茶（流程中）\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1872c11bc381495d82b8dfdd4d155510~tplv-k3u1fbpfcp-zoom-1.image) \r\n\r\n# 复习方式\r\n\r\n## 关于焦虑\r\n\r\n我们先要肯定一点，在复习的时候，【焦虑】是一件必然的事情，我们要正视焦虑。\r\n\r\n就拿我自己举例子吧，【双非本科】的学历会把我放到一个最最糟糕的位置。\r\n\r\n自开始复习时，我内心就非常非常的焦虑，胸膛经常会像要爆炸一样的沉闷(真的)...\r\n\r\n而我的缓解方式主要分为两种吧：\r\n\r\n-   运动  \r\n\r\n-   -   背一会八股或者刷一会题之后就去走走\r\n    -   每天晚上去操场跑步\r\n\r\n-   心理慰藉    \r\n-   -   面试前，我会像《三傻大闹宝莱坞》里的阿米尔汗一样，拍着自己的胸口对自己说 “Aal izz well”\r\n    -   给自己想好一个下下策，如果秋招真的找不到工作该怎么办？那至少还有春招，对比明年考研失利的同学，我至少积累了经验！\r\n\r\n## 复习流程\r\n\r\n我的整体复习流程分为三步：\r\n\r\n-   处理基础知识\r\n-   看八股\r\n-   查漏补缺\r\n\r\n### 阶段一：处理基础知识\r\n\r\n对于基础知识部分，我自知《计网》和《操作系统》这两门课学的很差，所以一开始就复习这部分知识。\r\n\r\n当时先把两门课的教材翻了一遍，然后做了一些摘抄，但说实话基本没用。\r\n\r\n这部分知识，我在面试过程中，大概有 50% 的几率会被问到操作系统，但从来没被问到过计网(幸运)。\r\n\r\n之后复习《设计模式》，先跟着一个 csdn 上的博客边看别写，之后找了一个很老的(2003年)博客总结，反复背诵，基本能手写大部分的模式实现了。\r\n\r\n这部分知识，我在面试过程中，要求写过 单例 、三大工厂 和 发布订阅 的实现，问过项目中和 Spring 以及其它中间件中用到的设计模式。\r\n\r\n### 阶段二：看八股\r\n\r\n全面进军 Java 八股文。\r\n\r\n我先看了自己在实习前准备的那些文档，之后网上找了 JavaGuide、JavaKeeper 这两份文档作为补充。\r\n\r\n因为自己之前有过两段的实习经验，因此背过很多次八股。\r\n\r\n但考虑到本次秋招可能会把战线拉得比较长，因此就自己总结了一份脑图。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a235705365f427790a4c8b7c7aa505a~tplv-k3u1fbpfcp-zoom-1.image)  \r\n\r\n### 阶段三：查漏补缺\r\n\r\n经过几轮面试，逐渐察觉到了自己的一些不足，之后针对性的去完善了一下。\r\n\r\n这里随便列举几个点，供其它同学参考：\r\n\r\n-   为什么说进程切换开销比线程大？\r\n-   NIO到底有没有阻塞，NIO到底能不能提高 IO 效率？\r\n-   Redis分布式锁的限制，RedLock的实现？\r\n-   ZK 明明有了有序的指令队列，为什么还要用 zxid来辅助排序？\r\n-   basic paxos 和 multi paxos 的使用？\r\n-   为什么拜占庭将军无解？\r\n-   还有一些业务场景的选择问题。。。\r\n\r\n# 总结\r\n\r\n我一直提醒自己：你是一个双非本科生，这个秋招你如果再不拼命，你就要完蛋了。\r\n\r\n我想，我是幸运的：\r\n\r\n-   我很幸运 在实习的时候，有一个好的 mentor，带我开发了字节码相关的组件，让我的简历不容易挂；\r\n-   我很幸运 在复习的时候，有几位好的朋友，分享经验，加油鼓励，让我没有被焦虑击倒；\r\n-   我很幸运 在面试的时候，有无私的舍友们，能在我需要笔试面试时，把宿舍让给我，让我没有后顾之忧；\r\n\r\n当然，也会有遗憾。每个人心中都有着大厂梦，而今年进大厂确实很难：\r\n\r\n-   我从大一开始就非常渴望进入阿里巴巴，实习的时候五面阿里不得，秋招全部简历挂；\r\n-   百度+度小满，投了 4 个岗位，全部简历挂；\r\n-   字节，一开始担心算法没敢投，之后担心基础知识也没敢投，也很遗憾了；\r\n\r\n人生，有所得就有所失，有所失就有所得。\r\n\r\n最后，想给其他明后年参加秋招的同学一些提醒：\r\n\r\n-   一定要早做准备，早点实习，早点刷算法题，早就是优势；\r\n-   人生无常，意外太多，绝对不要 all in 一家公司；\r\n-   鞋合不合适只有脚知道，自己总结的八股会更适合自己；\r\n-   多刷 力扣 Hot 100，或者 Codetop 热门题，反复刷；\r\n-   选择大于努力；\r\n\r\n在寒气逼人的 2022，我们需要抱团取暖...\r\n\r\n推荐： [2022年Java面试题目收集整理归纳（持续更新）](<https://juejin.cn/post/7135332975440789518>)\r\n"
    },
    {
        "article_id": "7182141348152082489",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6061aa71e24bceace5461dbdb3c728~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022我的个人总结",
        "preview": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 前言 时光如梭，岁月匆匆而过，2022年一转眼就已经到了末尾，今年的环境异常艰难，可是想想自己这一年来的付出，也还是值得做一个复",
        "author": "夕水",
        "view_count": 2132,
        "collect_count": 10,
        "comment_count": 4,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/d8e5f941d4d4257826ba832f47cfd14f~300x300.image",
        "category": "前端",
        "content": "「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n# 前言\r\n\r\n时光如梭，岁月匆匆而过，2022年一转眼就已经到了末尾，今年的环境异常艰难，可是想想自己这一年来的付出，也还是值得做一个复盘总结的，正所谓有得必有失，在这一年我失去了太多，不过却也让我成长了不少，当然这些都是题外话，我主要还是来复盘一下今年我所学习的成果。\r\n\r\n## 文章总结\r\n\r\n今年一共写了12篇文章，加上本次年终总结，一共13篇，数量也并不多，分别如下:\r\n\r\n* [使用React手写一个手风琴组件](https://juejin.cn/post/7120993358683570213)\r\n* [剑指offer2--二维数组中的查找](https://juejin.cn/post/7120997092272635940)\r\n* [手写一个有点意思的电梯小程序](https://juejin.cn/post/7130147855775301646)\r\n* [手写一个有点意思的电梯小程序（React版本）](https://juejin.cn/post/7132036037726961672)\r\n* [剑指offer3-替换空格](https://juejin.cn/post/7133078192172040206)\r\n* [实现《羊了个羊》的小游戏](https://juejin.cn/post/7143933122415951903)\r\n* [50天用vue3完成了50个web项目，我学到了什么?](https://juejin.cn/post/7144929568132956174)\r\n* [手写一个mini版本的React状态管理工具](https://juejin.cn/post/7145439056007004167)\r\n* [实现《羊了个羊-美女版》小游戏（低配版）](https://juejin.cn/post/7151247542221537310)\r\n* [一个有趣的交互效果的实现](https://juejin.cn/post/7163153386911563813)\r\n* [vue3实现一个思否猫连连看小游戏](https://juejin.cn/post/7165747325531324429)\r\n* [原生javascript手写一个丝滑的轮播图](https://juejin.cn/post/7169471068539715598)\r\n\r\n其中尤其是`50天用vue3完成了50个web项目，我学到了什么?`和`实现《羊了个羊》的小游戏`我最为满意，可是却也引起了不少的质疑，不过我觉得无所谓，只要能够让自己学到知识点，同时也帮助他人学到知识点那就足够了。\r\n\r\n其实今年我主要重心放在了React技术栈上，所以我也用React写了不少东西，对于vue框架，尤其是vue3，最主要的输出就是`50天用vue3完成了50个web项目，我学到了什么?`，关于这50个项目其实虽然表面上写的是50天，但实际上我花了不止50天，当然这都不重要了，最重要的是我从这50个项目里面深入去了解了一下less和sass这两门css预处理语言的语法。例如混入mixin,函数，循环，条件判断等，两种预处理语言之间也有很多相同的地方，当然也有不同的地方。比如循环，我们在sass当中会有@for关键字，而在less当中，我们需要写选择器 + when（这种更像是在写递归调用自身）。\r\n\r\n同时对于vue3的核心语法，我也有了一定的认知，至少在实际做vue3的项目当中，我认为我还是没有多大的问题的，这些都是通过实际动手做这50个web项目让我学到的，为了方便我还特意用vue3写了一个关于这50个web项目的网站，地址在[这里](https://eveningwater.github.io/my-web-projects/50-website/index.html)。\r\n\r\n> PS: 如果以上地址访问不到，可以访问[这里](https://www.eveningwater.com/my-web-projects/50-website/index.html)。\r\n\r\n这个网站是我自己设计并实现的，虽然布局看起来有些简单，但是我认为其中的逻辑功能和样式代码还是有点点难度的，在这里我可以总结一下有哪些知识点值得学习:\r\n\r\n* 实现一个clickOutside指令\r\n* 实现一个下拉框组件\r\n* 实现一个图片预加载组件\r\n* 实现classnames工具函数（不是复制的classnames源码，是参考实现的）\r\n* 实现文本超出省略的判断\r\n* 实现回到顶部的功能\r\n* 卡片组件以及图标组件的实现\r\n* less核心语法\r\n\r\n以上是我今年在文章上所做的总结，除此之外我还在github上新增贡献并逐步完善了3个仓库，让我们一起来看看吧。\r\n\r\n## 3个项目\r\n\r\n### 算法\r\n\r\n关于剑指offer算法，我基本上已经将剑指offer的官方算法题刷完了，并且解题思路，我也已经记下来建了一个项目，地址在[这里](https://eveningwater.github.io/to-offer/#/)。\r\n\r\n虽然在工作当中我似乎并没有用到太多算法，可事实上做了一下算法题确实是打开了我的眼界，更何况，我也已经将算法给加到了我所做的项目当中，比如那个用vue3实现连连看的小游戏里面就有这样一个算法。\r\n\r\n```ts\r\nconst findRepeatItem = function (arr: GlobalModule.MaterialData[]) {\r\n    const unique = new Set();\r\n    for (const item of arr) {\r\n        if (unique.has(item.src)) {\r\n            return true;\r\n        }\r\n        unique.add(item.src);\r\n    }  \r\n    return false;\r\n};\r\n```\r\n\r\n这个函数顾名思义，就是从数组当中查找重复项，思路就是利用set数据结构存储每一个数组项，然后当数据里面存在要查找的项的时候，就代表重复了，直接返回即可，这个函数的思路就来源于算法当中。也就是这个算法[数组中重复的数字](https://eveningwater.github.io/to-offer/#/codes/1/findRepeatNumber)的思路二--哈希表解法。\r\n\r\n这只是其中一个小小的应用而已，如果在实际项目当中碰到相应的需求，我或许也会再次回头来翻看这些笔记，已达到巩固并且举一反三的目的，这个项目也就是我今年完善的3个项目之一。\r\n\r\n### js和css代码段\r\n\r\n#### css代码段\r\n\r\n这可能是我今年付出精力最多的一个项目了吧，几乎每天都要贡献一段代码段，不信看下图:\r\n\r\n\r\n![1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2f3983e1bf54b0db4b519cb178d5d55~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n每天学习一段javascript或者是css代码段，不至于让自己忘记css和js基础，而且很多代码段都会用到实际业务当中，比如使用css实现自定义的单选框和复选框。我们以单选框作为示例讲一下实现思路如下:\r\n\r\n##### css实现单选框\r\n\r\n思路就是如下列出的几点，我们就可以创建一个带有状态更改动画的样式单选按钮。\r\n\r\n* 创建一个 .radio-container 并使用 flexbox 为单选按钮创建适当的布局。\r\n* 重置 `<input>` 上的样式并使用它来创建单选按钮的轮廓和背景。\r\n* 使用 ::before 元素创建单选按钮的内圈。\r\n* 使用 transform: scale(1) 和 CSS transition 在状态变化时创建动画效果。\r\n\r\n代码量也不算多，我们来看html和css代码分别如下:\r\n\r\n```html\r\n<div class=\\\"radio-container\\\">\r\n    <input type=\\\"radio\\\" class=\\\"radio-input\\\" id=\\\"male\\\" name=\\\"sex\\\"/>\r\n    <label for=\\\"male\\\" class=\\\"radio\\\">男</label>\r\n    <input type=\\\"radio\\\" class=\\\"radio-input\\\" id=\\\"female\\\" name=\\\"sex\\\"/>\r\n    <label for=\\\"female\\\" class=\\\"radio\\\">女</label>\r\n</div>\r\n```\r\n\r\n```css\r\n.radio-container {\r\n    box-sizing: border-box;\r\n    background-color: #fff;\r\n    color: #545355;\r\n    height: 64px;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-flow: row wrap;\r\n}\r\n.radio-container * {\r\n    box-sizing: border-box;\r\n}\r\n.radio-input {\r\n    appearance: none;\r\n    background-color: #fff;\r\n    width: 16px;\r\n    height: 16px;\r\n    border: 1px solid #cccfdb;\r\n    margin: 0;\r\n    border-radius: 50%;\r\n    display: grid;\r\n    align-items: center;\r\n    justify-content: center;\r\n    transition: all .3s ease-in;\r\n}\r\n.radio-input::before {\r\n    content: \\\"\\\";\r\n    width: 6px;\r\n    height: 6px;\r\n    border-radius: 50%;\r\n    transform: scale(0);\r\n    transition: .3s transform ease-in-out;\r\n    box-shadow: inset 6px 6px #fff;\r\n}\r\n.radio-input:checked {\r\n    background-color: #2396ef;\r\n    border-color: #2396ef;\r\n}\r\n.radio-input:checked::before {\r\n    transform: scale(1);\r\n}\r\n.radio {\r\n    cursor: pointer;\r\n    padding: 6px 8px;\r\n}\r\n.radio:not(:last-child){\r\n    margin-right: 6px;\r\n}\r\n```\r\n\r\n都是常规的布局，其中我们主要利用了label的for属性和input的id属性绑定在一起，然后通过样式将input框给隐藏，修改label的样式去模拟出单选框，从而达到如下的效果:\r\n\r\n\r\n![2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d257ea498f43a586ca86931fc96a7f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n同理，复选框也是这样的思路去实现的,事实上还有很多小技巧，比如隐藏一个元素，我们通常可能会使用display和visibility又或者是opacity属性来达到隐藏，可事实上这三个属性隐藏元素或多或少都会有一定的问题，比如display无法添加过渡效果，而visibility又占用元素本身的空间，opacity只是单纯的设置透明度，元素依然可以被点击等等，而这里我们可以利用clip和定位来达到隐藏元素的目的，从而解决前面三个属性所带来的问题。代码如下:\r\n\r\n```css\r\n.offscreen {\r\n    border: 0;\r\n    clip: rect(0,0,0,0);\r\n    height: 1px;\r\n    margin: -1px;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    position: absolute;\r\n    width: 1px;\r\n}\r\n```\r\n\r\n然后我们给要隐藏的元素添加一个offscreen类名即可达到隐藏元素，这不失为一种隐藏元素的办法，当然还有很多的css代码段值得学习的，例如border实现等高布局,css实现加载中效果,开关组件，高度过渡效果等等示例。\r\n\r\n#### js代码段\r\n\r\n除了css代码段，js代码段也有许多值得学习的知识点，比如冒泡排序算法.\r\n\r\n##### 冒泡排序算法\r\n\r\n我们来看这个算法的实现思路如下:\r\n\r\n* 声明一个变量，swapped，指示在当前迭代期间是否交换了任何值。\r\n* 使用扩展运算符 (...) 克隆原始数组 arr。\r\n* 使用 for 循环遍历克隆数组的元素，在最后一个元素之前终止。\r\n* 使用嵌套的 for 循环遍历 0 和 i 之间的数组段，交换任何相邻的乱序元素并将 swapped 设置为 true。\r\n* 如果在迭代后 swapped 为 false，则不需要更多更改，因此返回克隆的数组。\r\n\r\n代码如下:\r\n\r\n```js\r\nconst bubbleSort = arr => {\r\n    let swapped = false;\r\n    let a = [...arr];\r\n    for(let i = 0;i < a.length;i++){\r\n        swapped = false;\r\n        for(let j = 0;j < a.length - i;j++){\r\n            if(a[j + 1] < a[j]){\r\n                //数组解构的方式\r\n                [a[j],a[j + 1]] = [a[j + 1],a[j]];\r\n                swapped = true;\r\n            }\r\n        }\r\n        if(!swapped) { \r\n            return a;\r\n        }\r\n    }\r\n    return a;\r\n}\r\n```\r\n\r\n再比如数组分块，这个也会用到实际业务当中。\r\n\r\n##### 数组分块\r\n\r\n我们来看实现数组分块的思路如下:\r\n\r\n* 使用 Array.from() 创建一个新数组，该数组适合将要生成的块数。\r\n* 使用 Array.prototype.slice() 将新数组的每个元素映射到长度为 size 的块。\r\n* 如果原始数组不能被平均分割，最终的块将包含剩余的元素。\r\n\r\njs代码如下:\r\n\r\n```js\r\nconst chunk = (arr,size) => Array.from({ length:Math.ceil(arr.length / size)},(v,i) => arr.slice(i* size,i * size + size));   \r\n```\r\n\r\n当然还有更多的css和js代码段，我就不一一举例了，我只是想说明这样每天学习一段代码段让自己学到了很多，更多的代码段请看[网站](https://eveningwater.github.io/code-segment/#/)。\r\n\r\n> 如果访问不了，可访问这个[网站](https://eveningwater.gitee.io/code-segment/#/)。\r\n\r\n### react代码段\r\n\r\n今年还新开了一个项目，记录react的学习代码段，包含基础组件和hook函数两个部分，除此之外，还有在使用antd design组件库的组件基础上额外封装的组件。比如实现一个弹出框组件，一个倒计时组件一个手风琴组件等等，像hooks函数就更多了，比如useTimeout函数,useInterval等等,useBodyScrollLock函数等等。我还是举其中2个示例来说明吧。\r\n\r\n#### 受控的input组件\r\n\r\n主要是样式去美化input组件，同时将input组件的value值和onchange事件暴露出去，在这里我使用的是css in js来美化输入框的，代码如下:\r\n\r\n```tsx\r\nimport styled from '@emotion/styled';\r\nimport React from 'react';\r\nimport type { SyntheticEvent } from 'react';\r\n\r\nconst StyleInput = styled.input`\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  font-variant: tabular-nums;\r\n  list-style: none;\r\n  font-feature-settings: 'tnum';\r\n  position: relative;\r\n  display: inline-block;\r\n  width: 100%;\r\n  min-width: 0;\r\n  padding: 4px 11px;\r\n  color: #000000d9;\r\n  font-size: 14px;\r\n  line-height: 1.5715;\r\n  background-color: #fff;\r\n  background-image: none;\r\n  border: 1px solid #d9d9d9;\r\n  border-radius: 2px;\r\n  transition: all 0.3s;\r\n  &:focus {\r\n    border-color: #40a9ff;\r\n    box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);\r\n    border-right-width: 1px;\r\n    outline: 0;\r\n  }\r\n`;\r\ntype LiteralUnion<T extends U, U> = T & (U & {});\r\ninterface ControlledInputProps {\r\n  type: LiteralUnion<\r\n    | 'button'\r\n    | 'checkbox'\r\n    | 'color'\r\n    | 'date'\r\n    | 'datetime-local'\r\n    | 'email'\r\n    | 'file'\r\n    | 'hidden'\r\n    | 'image'\r\n    | 'month'\r\n    | 'number'\r\n    | 'password'\r\n    | 'radio'\r\n    | 'range'\r\n    | 'reset'\r\n    | 'search'\r\n    | 'submit'\r\n    | 'tel'\r\n    | 'text'\r\n    | 'time'\r\n    | 'url'\r\n    | 'week',\r\n    string\r\n  >;\r\n  value: string;\r\n  onChange(v: string): void;\r\n  placeholder: string;\r\n}\r\nconst ControlledInput = (props: Partial<ControlledInputProps>) => {\r\n  const { value, onChange, ...rest } = props;\r\n  const onChangeHandler = (e: SyntheticEvent) => {\r\n    if (onChange) {\r\n      onChange((e.target as HTMLInputElement).value);\r\n    }\r\n  };\r\n  return (\r\n    <StyleInput value={value} onChange={onChangeHandler} {...rest}></StyleInput>\r\n  );\r\n};\r\n```\r\n\r\n并且每一个组件都有对应的tsx和jsx版本，也有相应的接口，也方便学习如何去实现封装组件，组件的实现个人认为封装的最复杂的是弹出框组件，因为我需要考虑2种方式使用，第一种是通过组件方式使用，第二种则是通过调用方法的方式来使用。\r\n\r\n然后就是我们的hooks函数了，比如我们来看useBodyScrollLock函数的实现。\r\n\r\n#### useBodyScrollLock函数的实现\r\n\r\n在这个函数中，我们通过在useLayoutEffect生命周期钩子函数中获取到body元素，然后给body元素设置一个overflow为hidden的样式，就达到了滚动的锁定，顾名思义这个函数就是用来禁止页面的滚动的。我们来看完整代码如下:\r\n\r\n```ts\r\nimport { useLayoutEffect } from 'react';\r\n\r\nconst useBodyScrollLock = () => {\r\n  useLayoutEffect(() => {\r\n    const container = document.body;\r\n    const originOverflowStyle = window.getComputedStyle(container!).overflow;\r\n    container!.style.overflow = 'hidden';\r\n    return () => {\r\n      container!.style.overflow = originOverflowStyle;\r\n    };\r\n  }, []);\r\n};\r\n\r\nexport default useBodyScrollLock;\r\n```\r\n\r\n当然这只是一个简单的hook函数，很好理解，也还有更复杂的hook函数，比如useCopyToClipboard函数的实现，这里也不需要一一叙述了，想要查看更多实现思路，请看这个[网站](https://eveningwater.github.io/code-segment-react/)。\r\n\r\n> 如果访问不了，请看这个[网站](https://eveningwater.gitee.io/code-segment-react/)\r\n\r\n以上就是我今年的输出了，当然除了这之外，我还在坚持写一部小说，不过这就不需要透露了，哈哈哈，因为我觉得我写的也不怎么样。\r\n\r\n# 最后\r\n\r\n总而言之，我今年的学习成果不算好也不算坏，但是去年立下的flag并没有完成，只能展望于2023年了，感谢阅读到这里，本文就到此为止了，与君共勉。\r\n\r\n"
    },
    {
        "article_id": "7188931167637209146",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/151170c8518e4706bf298f3cb700ee0f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "又是一年，秋风起",
        "preview": "「回顾2022，展望2023，我正在参与2022年终总结征文大赛活动」 就在昨天白天实际上没有工作学习，晚上就没有什么困意，自己躺在床上突然意识到其实96年的我也快接近30了，以前总认为30岁还有好多",
        "author": "austin流川枫",
        "view_count": 1121,
        "collect_count": 10,
        "comment_count": 2,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/506747f630a22c53ba2d01ed0b2e4a1f~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n\r\n![微信图片_20230115165549.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414c03038f114134a69c122b9363c7ef~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n就在昨天白天实际上没有工作学习，晚上就没有什么困意，自己躺在床上突然意识到其实96年的我也快接近30了，以前总认为30岁还有好多年，现在转眼就奔三了，突然间心中危机感油然而生。回顾这一年，可谓是百味杂陈。\r\n\r\n## 一、🤔工作\r\n\r\n**2022从离职到入职再到离职**，在今年的8月份，顶着大家都说互联网市场纷纷裁员的压力，我还是选择了离开了工作了两年的老东家，作为一个95后，更多的是我希望去到更大、更有竞争力的公司从而更好的挖掘自己的所谓的潜能，离职之后我其实当时想着是不急着找下家，可以尝试着边准备边找的心态去投递，然而在简历开始投递之后，不少公司纷纷开始打电话以及开始向上面试了，后面在9月份，我就拿到了新公司的offer，虽说工资涨幅不高，但是其他福利都还好，然后再9月份就入职了，然而种种原因我在今年12月份选择了离职，可以说今年是两次的跳槽了，我告诉自己，可以稍微停一停，不要再盲目努力，有时候前面走得太快了，会身心疲惫。\r\n\r\n## 二、✒重拾写文章习惯\r\n\r\n2022我最大的改变就是重拾写文章的爱好，之前在校期间我就已经有写技术博客的习惯，工作的之后由于时间的问题，我又摆烂了一段时间，在2022年重新回到了掘金，感觉还是很熟悉，同时在掘金发表了接近85篇原创博客，自己也创建了几个专栏，收到了很多IT人的关注，虽然说相比很多厉害的博主来说我可能算不上啥，但是也算是给自己的一个交代，**我相信：那些无数深夜努力的写代码日子在往后一定会以某种方式回馈你的生活。**\r\n\r\n![2022掘金文章数据.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f405b4cfbdf4801bb3b706223c8a70b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 三、生活照\r\n\r\n![微信图片_20230105150840.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de3aa1a7144e43af9c9b159cf2727fff~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我时常会回想读大学的日子，我基本上每天都会花时间去运动，组队篮球、健身、体育场跑步、偶尔跟大学同学骑着自行车在黄埔那边吹吹风，那时候也很忙，我是那种宁愿不上课，也不能不敲代码的人，所以大学我很多时间都是，同学去教室上课，我却逃课在宿舍写代码、做项目（学校的课程懂得都懂，学的都是很简单的）如今出来工作了，很难抽时间出来运动，有时候下班回家吃完饭都很晚了，自然而然运动就少了。当然2022虽然很忙，但是也去了很多不同的城市：长沙、佛山、清远、惠州、湛江，每次去外地旅游，总会有一些意想不到的收获。\r\n\r\n晚上写代码的日子：\r\n\r\n\r\n![微信图片_20230116011737.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d7db704a5fc4601b04a98f6eff93989~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230115165617.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b07a0495ae8b447798b6fb959e6541ab~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116004626.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68414d62718546fc8b1c94d42b9247d2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116005402.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67d9b2f723664f989ace38ac749428fe~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116011301.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5348926007444c6a9d04c5234d2afb51~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116011312.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96dd229b33104a1bb537664347ae11d9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我卑微的书架：\r\n\r\n![微信图片_20230115165631.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092fc8a7bf0545b495fcba324699e1d5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116011743.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a6b21af821467ca1f6a6260a424c3c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n长沙之旅：\r\n\r\n![微信图片_20230116012015.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21f5c61184ba4ae38e0fca893d4fab81~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![微信图片_20230116011750.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc9cf169ccf44f7d8b1ff5b79b51aaa3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n夕阳：\r\n\r\n![微信图片_20230115165643.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b9b34802e3f453694a0dabb7a9f030b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n露营：\r\n\r\n\r\n\r\n![微信图片_20230116011731.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6d47071c8fd4befa3d6ddde457de83a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 四、👨‍🎓2023年个人规划\r\n\r\n> 凡事预则立，不预则废。对于漫长的学习生涯而言，好的计划是成功的一半。\r\n\r\n### 长期规划\r\n\r\n长期规划的实施需要毅力和决心，但是做正确的长期规划还需要高瞻远瞩的眼界、超级敏感的神经和中大奖的运气。对于大部分人来说，长期规划定主要是“定方向”。但遵循如下原则能够减少犯方向性错误的概率：\r\n\r\n- 远离日暮西山的行业。\r\n- 做自己感兴趣的事情。\r\n- 做有积累的事情。\r\n- 一边走一边看，切勿一条道走到黑。\r\n\r\n### 短期规划\r\n\r\n良好的短期规划应该在生活、成长、绩效和晋升之间取得平衡。大部分公司都会制定一个考核周期——少则一个月，多则一年。所以不妨以考核周期作为短期学习规划周期。本质上，规划是一个多目标优化问题，它有一系列的理论方案，这里不一一细说。基于相关理论，我给出一个简单易行的方案：\r\n\r\n- 确定目标优先级。比如：成长、生活、绩效。\r\n- 确定每个目标的下限。从优化理论的角度来看，这被称为约束。比如绩效必须在一般以上，之前已经规划好的旅行不能更改，必须读完《Effective Java》等等。\r\n- 优先为下限目标分配足够的资源。比如，事先规划好的旅行需要10天，这10天就必须预算出去。\r\n- 按照各主目标的顺序依次分配资源。比如，最终分配给学习的时间是10天。\r\n- 在给定的学习预算下，制定学习目标，要激进。然后给出执行方案。比如，学习目标是掌握基本的统计学知识，并成为Java专家。具体方案为：完成《Effective Java》、《Java Performance》、《Design Pattern》、《Head First Statistics》四本书的阅读。\r\n- 对规划中的各学习任务按目标优先级进行排序，并最先启动优先级最高的任务。比如，最高优先级是掌握统计理论，那么就要先看《Head First Statistics》。\r\n\r\n对于该方案，要注意以下几点：\r\n\r\n- 最低目标必须能够轻松达成的目标，否则，从优化理论的角度来讲，该命题无解。比如，类似“半年内完成晋级两次、绩效全部S、从菜鸟成为Java专家”就不太合适作为最低目标。总之，要区分理想和梦想。\r\n- 主要目标规划必须具备一定的挑战性，需要规划出不可能完成的目标。过度规划本质上是一种贪婪算法，目的是目标价值最大化。因为一切皆有变数，如果其他目标能够提前完成，就不妨利用这些时间去完成更多的学习目标。总之，前途必须光明，道路必须坎坷。\r\n- 各目标之间不一定共享资源，规划不一定互有冲突。\r\n\r\n此外，短期规划还可以从如下几个方面进行优化：\r\n\r\n- 学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。比如，本季度规划去做一些数据分析工作，那么不妨把学习目标设置为学习统计知识。\r\n- 要灵活对待规划的目标和具体执行步骤，需要避免“郑人买履”式的笑话。面临新的挑战和变化，规划需要不断地调整。\r\n\r\n### 🕓我的计划表（借鉴了全球公认最佳作息时间表）\r\n\r\n| 时间 | 活动 |\r\n| --- | --- |\r\n| 7:00  | 起床 |\r\n| 7:30  | 洗漱，喝一杯温开水，做做拉伸 |\r\n| 7:30 ~ 7:50 | 早餐时间 |\r\n| 7:50 ~ 8:30 | 看看资讯、blog、技术推文 |\r\n| 9:30 ~ 11:45 | 安排最困难的工作/学习 |\r\n| 11:45 ~ 12:00 | 休息片刻 |\r\n| 12:00 | 午餐时间 |\r\n| 13:00 ~ 14:00 | 午休时间 |\r\n| 14:00 ~ 16:00 | 安排最困难的工作/学习/创意工作 |\r\n| 16:00 | 喝杯咖啡/牛奶 |\r\n| 16:20 ~ 18:00 | 做细致性工作 |\r\n| 18:10 ~ 18:30 | 晚饭时间 |\r\n| 19:30 ~ 20:30 | 运动锻炼 |\r\n| 20:30 ~ 21:30 | 歇会，放松一下，洗澡 |\r\n| 21:50 ~ 11:00 | 看书或者看视频，也可以适当的完成今天未完成的工作 |\r\n| 11:00 ~ 11:40 | 上床，适当看看手机，听听歌 |\r\n| 12:00| 准时睡觉 |\r\n\r\n#### ⏳程序员需要注重效率\r\n\r\n![微信图片_20230115165636.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e639aa662d184ee0ba38e8bae879305c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n经常看到有些同学给自己的绩效评分是100分——满分，原因是在过去一段时间太辛苦了，但最终的绩效却一般般。天道酬勤不错，但是天道更酬巧。工程师们都学过数据结构，不同算法的时间复杂度的差距，仅仅通过更长的工作时间是难以弥补的。为了提升工作学习效率，我们需要注意以下几点：\r\n\r\n-  主要关注效率提升。很多时候，与效率提升所带来的收益相比，延长时间所带来的成果往往不值得一提。\r\n-  要有清晰的结果导向思维。功劳和苦劳不是一回事。\r\n-  做正确的事情，而不仅仅正确地做事情。这是一个被不断提起的话题，但是错误每天都上演。为了在规定的时间内完成一个大项目，总是要有所取舍。如果没有重点，均匀发力，容易事半功倍。如果“南辕北辙”，更是可悲可叹。\r\n\r\n\r\n## 五、🌈收获\r\n\r\n最大的收获就是技术的改变，通过项目的积累和不断的学习、沉淀，自己技术上也有一定程度的提升，我也会经常跟文章底下跟一些留言和评论的人做技术上的探讨和学习，通过不同专栏的技术总结，慢慢形成自己的一套技术体系，在新的一年2023年，我将会继续完善相关的专栏，撰写更好、更值得学习的博文。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f93d5b70f464f63a81fb21a8088f2b8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/429c216f6a604ea1a04950c3262378db~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2023年必定会是更有挑战的一年，做技术的，不能浮躁，需要有一颗耐得住寂寞的心，踏踏实实走好当下的每一步，路虽远，行则将至，事虽难，做则必成，不忘初心。\r\n"
    },
    {
        "article_id": "7187313594093010981",
        "snapshot": "",
        "title": "怎样快速地迁移 MySQL 中的数据？",
        "preview": "我们通常会遇到这样的一个场景，就是需要将一个数据库的数据迁移到一个性能更加强悍的数据库服务器上。这个时候需要我们做的就是快速迁移数据库的数据。 那么，如何才能快速地迁移数据库中的数据呢？今天我们就来聊",
        "author": "Mche",
        "view_count": 3309,
        "collect_count": 29,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/05e2f65a389ede389582cb9d90a3870b~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: juejin\r\nhighlight: a11y-dark\r\n---\r\n我们通常会遇到这样的一个场景，就是需要将一个数据库的数据迁移到一个性能更加强悍的数据库服务器上。这个时候需要我们做的就是快速迁移数据库的数据。\r\n\r\n那么，如何才能快速地迁移数据库中的数据呢？今天我们就来聊一聊这个话题。\r\n\r\n数据库的数据迁移无外乎有两种方式，一种是**物理迁移**，另一种则是**逻辑迁移**。\r\n\r\n首先，我们生成 5 万条测试数据。具体如下：\r\n\r\n```\r\n-- 1. 准备表\r\ncreate table s1(\r\n  id int,\r\n  name varchar(20),\r\n  gender char(6),\r\n  email varchar(50)\r\n);\r\n\r\n-- 2. 创建存储过程，实现批量插入记录\r\ndelimiter $$\r\ncreate procedure auto_insert1()\r\nBEGIN\r\n    declare i int default 1;\r\n    while(i<50000)do\r\n        insert into s1 values(i,'shanhe','male',concat('shanhe',i,'@helloworld'));\r\n        set i=i+1;\r\n        select concat('shanhe',i,'_ok');\r\n    end while;\r\nEND$$\r\ndelimiter ;\r\n\r\n-- 3. 查看存储过程\r\nshow create procedure auto_insert1\\\\G \r\n\r\n-- 4. 调用存储过程\r\ncall auto_insert1()\r\n```\r\n\r\n## []()逻辑迁移\r\n\r\n逻辑迁移的原理是**根据 MySQL 数据库中的数据和表结构转换成 SQL 文件**。采用这一原理常用的迁移工具有 **`mysqldump`**。\r\n\r\n下面我们就来测试一下：\r\n\r\n```\r\n[root@dxd ~]# mysqldump -h172.17.16.2 -uroot -pTest123!  s1 s1 --result-file=/opt/s1.sql\r\n\r\n[root@dxd ~]# ll /opt/\r\n-rw-r--r--  1 root root 2684599 5月  10 00:24 s1.sql\r\n```\r\n\r\n我们可以看到的是，生成了相应的 SQL 。现在我们通过生成的 SQL 迁移到另一个数据库中。\r\n\r\n```\r\nmysql> use s2;\r\nDatabase changed\r\n\r\nmysql> source /opt/s1.sql\r\n```\r\n\r\n通过简单的时间累加计算，大约消耗了 1 秒钟的时间，但是随着数据库递增，迁移的时长也会相应地增加。此时，如果需要迁移的数据表中的数据足够大（假设上千万条），mysqldump 很有可能会将内存撑爆进而导致迁移失败。所以，在迁移这样的数据表的时候，我们可以简单优化一下 mysqldump ，具体如下。\r\n\r\n-   `--add-locks=0`：这个参数表示在迁移数据的时候不加 `LOCK TABLES` s1`.`s1 `WRITE;`，也就是说在导入数据时不锁定数据表。\r\n-   `--single-transaction`：表示的是在导出数据时，不锁定数据表。\r\n-   `--set-gtid-purged=OFF`：表示在导入数据时，不输出 GTID 相关的信息。\r\n\r\n加上这三个参数主要是为了减少所有的操作导致不必要的 IO ，具体如下：\r\n\r\n```\r\n[root@dxd ~]# mysqldump -h172.17.16.2 -uroot -pTest123! --add-locks=0 --single-transaction --set-gtid-purged=OFF s1 s1 --result-file=/opt/s1.sql\r\n```\r\n\r\n通过上面的案例，我们看最终结果，优化的效果微乎其微。所以，这种逻辑优化的方式，在数据量比较大的情况下（百万条以上）不可取。\r\n\r\n## []()文件迁移\r\n\r\n文件迁移顾名思义就是**直接迁移数据库的存储文件**。这种迁移方式相对于逻辑迁移的方式来说，性能上要高出很多，同时也很少会把内存撑爆；`在面对数据量较大的场景下迁移数据，建议使用文件迁移的方式`，具体如下：\r\n\r\n```\r\nmysql> select * from s1 into outfile '/var/lib/mysql-files/1.txt';\r\nQuery OK, 55202 rows affected (0.04 sec)\r\n```\r\n\r\n我们可以看到的是，将 5 万多条数据导出到文件中时，只花了 0.04 秒左右的时间。相比较 mysqldump 来说快了一倍多。\r\n\r\n> 注意：这种方式导出的数据只能导出到 MySQL 数据库的目录中。配置这个目录的参数是 `secure_file_priv`，如果不这样做，数据库会报一个 `ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement` 的错误。\r\n\r\n导出数据之后，我们再将该文件中的数据导入到数据库中，看一下效果，具体如下：\r\n\r\n```\r\nmysql> load data infile '/var/lib/mysql-files/1.txt' into table s3.s1;\r\nQuery OK, 55202 rows affected (0.27 sec)\r\nRecords: 55202  Deleted: 0  Skipped: 0  Warnings: 0\r\n```\r\n\r\n> 注意：into outfile 是不会生成表结构的，因此在导入数据之前，需要手动创建表结构。\r\n\r\n我们可以看出，导入花费的时间总共是`0.27`秒，相比较 mysqldump 而言，也要快两倍多。\r\n\r\n这种方式主要是将每一条数据都以`\\\r\n`换行的方式直接保存在文件之中。\r\n\r\n导入的时候，首先会判断导入的数据表的字段是否与每一行的数据的列数一致，如果一致则一行一行地导入，如果不一致则直接报错。\r\n\r\n这里面有一个问题需要我们注意，如果我们的数据库是主从架构的数据库，这里很可能就会产生一个问题。讲这个问题之前，我们得首先在这里稍微说明一下主从复制的原理。\r\n\r\n主从复制的原理主要是依赖于 `binlog` 日志，`binlog` 日志具体步骤如下：\r\n\r\n-   主库上执行 SQL ，并且把修改的数据保存在 binlog 日志之中；\r\n-   由主库上的 dump 线程转发给从库；\r\n-   由从库中的 IO 线程接收主库发送过来的 binlog 日志；\r\n-   将 binlog 日志数据写入中继日志之中；\r\n-   通过从库上的 SQL 线程从中继日志中重放 binlog 日志，进而达到主从数据一致。\r\n\r\n在这个过程之中，我相信仔细阅读本小册第 15 篇文章的朋友一定有一个疑问，当 binlog 日志的工作模式为 `STATEMENT` 时，在主库上执行上面的 SQL `load data infile '/var/lib/mysql-files/1.txt' into table s3.s1;` 时，就会导致从库无法重复上方 SQL 的结果，这是因为从库中并没有 `/var/lib/mysql-files/1.txt` 这个文件。具体步骤如下：\r\n\r\n1.  主库执行 `load data infile '/var/lib/mysql-files/1.txt' into table s3.s1;`；\r\n1.  binlog 日志的工作模式如果是 `STATEMENT` 时，将在 binlog 中记录上方的 SQL；\r\n1.  然后在从库中重新执行 binlog 中记录上方的 SQL。\r\n\r\n很显然，从库上执行该 SQL 时，会立即报错，这个时候怎么办呢？\r\n\r\n这个时候我需要再介绍上方 SQL 的 load 关键字：\r\n\r\n-   如果增加 local 关键字，则该条 SQL 会在本地寻找 `/var/lib/mysql-files/1.txt`；\r\n-   如果不加 local 关键字，则该条 SQL 会在主库端寻找 `/var/lib/mysql-files/1.txt`。\r\n\r\n所以，在主从架构中，要使用文件迁移的方式迁移数据，不加 local 关键字即可。\r\n\r\n## []()物理迁移\r\n\r\n物理迁移也是迁移文件，所不同是物理迁移一般是直接迁移 MySQL 的数据文件。这种迁移方式性能很好但是操作过程麻烦，容易出错。具体我们来详细解释一下\r\n\r\n首先是非常干脆的迁移方式迁移，就是直接 MySQL 数据库的数据文件打包迁移，下面我们做一个案例：\r\n\r\n```\r\n-- 我们将s1数据库中的所有数据迁移到s4数据库之中\r\n[root@dxd mysql]# pwd\r\n/var/lib/mysql\r\n[root@dxd mysql]# cp -r s1 s4\r\n[root@dxd mysql]# chown -R mysql.mysql s4\r\n\r\n-- 重启数据库\r\n[root@dxd mysql]# systemctl restart mysqld\r\n\r\n-- 查看该表数据\r\nmysql> select count(*) from s1;\r\nERROR 1146 (42S02): Table 's4.s1' doesn't exist\r\n```\r\n\r\n我们可以看到的是查询数据的时候报了一个 `1146` 的错误，这是因为 INnoDB 存储引擎中的数据表是需要在 MySQL 数据库的数据字典中注册的，我们直接将数据文件复制过去的时候并没有在数据字典中注册，换句话说就是在把数据复制过去之后，还需要在数据字典中注册数据库系统才能正常识别。\r\n\r\n下面我们就来介绍一下在数据字典中该如何注册，具体步骤如下。\r\n\r\n> 注：物理迁移数据表数据实际上最主要的就是迁移表空间，因为对于 InnoDB 存储引擎来说，数据是存储在数据表空间中的，也就是`.idb`文件。\r\n\r\n1.  我们在迁移到的数据库中创建与需要迁移的数据表完全相同的数据表。\r\n\r\n    mysql> create database t1;  \r\n    Query OK, 1 row affected (0.01 sec)\r\n\r\n    mysql> use t1;  \r\n    Database changed\r\n\r\n    mysql> CREATE TABLE `s1` (\r\n\r\n    ```\r\n    ->   `id` int(11) DEFAULT NULL,\r\n    ->   `name` varchar(20) DEFAULT NULL,\r\n    ->   `gender` char(6) DEFAULT NULL,\r\n    ->   `email` varchar(50) DEFAULT NULL\r\n    -> ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n    ```\r\n\r\n    Query OK, 0 rows affected (0.04 sec)\r\n\r\n<!---->\r\n\r\n1.  删除新创建的数据表的表空间，这是因为新创建的数据库的表空间没有数据且会跟迁移过来的数据表空间冲突，我们提前删除，具体删除步骤如下：\r\n\r\n    mysql> alter table t1.s1 discard tablespace;  \r\n    Query OK, 0 rows affected (0.01 sec)\r\n\r\n<!---->\r\n\r\n1.  创建一个原有数据表的配置文件，这样做的目的是将原有数据表的一些配置复制过来（注意：这一步会自动将数据表上锁）。\r\n\r\n    mysql> use s1;  \r\n    Database changed\r\n\r\n    mysql> flush table s1 for export;  \r\n    Query OK, 0 rows affected (0.01 sec)\r\n\r\n    # []()查看是否已经创建 .cfg 文件\r\n\r\n    [root@dxd mysql]# pwd  \r\n    /var/lib/mysql  \r\n    [root@dxd mysql]# ll s1/  \r\n    总用量 12312  \r\n    -rw-r——- 1 mysql mysql 65 5月 10 00:26 db.opt  \r\n    -rw-r——- 1 mysql mysql 520 5月 10 15:15 s1.cfg  \r\n    -rw-r——- 1 mysql mysql 8652 5月 10 00:27 s1.frm  \r\n    -rw-r——- 1 mysql mysql 12582912 5月 10 00:27 s1.ibd\r\n\r\n<!---->\r\n\r\n1.  将配置文件和表空间文件迁移至新的数据库。\r\n\r\n    # []()复制文件的方式可以灵活多变\r\n\r\n    [root@dxd mysql]# cp s1/s1.cfg t1/  \r\n    [root@dxd mysql]# cp s1/s1.ibd t1/\r\n\r\n    # []()设置权限，很重要，如果权限不一致会导致数据读取表空间数据失败\r\n\r\n    [root@dxd mysql]# chown -R mysql.mysql t1/\r\n\r\n<!---->\r\n\r\n1.  将原有数据表解锁。\r\n\r\n    mysql> use s1;  \r\n    Database changed\r\n\r\n    mysql> unlock tables;  \r\n    Query OK, 0 rows affected (0.00 sec)\r\n\r\n<!---->\r\n\r\n1.  载入新的表空间。\r\n\r\n    mysql> use t1;\r\n\r\n    mysql> alter table s1 import tablespace;  \r\n    Query OK, 0 rows affected (0.09 sec)\r\n\r\n<!---->\r\n\r\n1.  测试。\r\n\r\n    mysql> select count( *) from s1;  \r\n    +—————+  \r\n    | count(* ) |  \r\n    +—————+  \r\n    | 55202 |  \r\n    +—————+  \r\n    1 row in set (0.03 sec)\r\n\r\n我们看到此时就实现了数据迁移。\r\n\r\n这种数据迁移虽然性能很好，但是过程非常麻烦，很容易出现操作失误的情况。\r\n\r\n## []()总结\r\n\r\n今天，我们介绍了三种数据库迁移的方式，分别是：逻辑迁移、文件迁移和物理迁移。\r\n\r\n逻辑迁移的方式主要是使用 `mysqldump` 命令进行迁移，其原理主要是将数据库中的数据和结构生成 SQL 文件，再导入即可。这种迁移方式主要适用于**数据量比较小且服务器性能较好**的场景下，例如数据连少于 500 万条以下的场景。\r\n\r\n`文件迁移的方式其实也算是逻辑迁移的范畴`，它主要通过命令将数据保存在文件中，然后再导入数据库即可，这种迁移方式是不会迁移表结构的，所以在导入数据之前需要手动创建表结构，其原理跟逻辑迁移的方式相同。\r\n\r\n物理迁移的方式适用于**数据量比较大**的场景，这种场景不易导致服务器因资源占用过多而宕机，但是操作过程麻烦且会锁定原数据表。\r\n\r\n在实际应用过程中，我们通常选择使用 mysqldump 的方式进行数据迁移；如果数据量大，我们首选方式应该是提升服务器的性能，以至于它能够承载处理相应数据量的性能；如果必须迁移，可以考虑使用第三方专业的数据迁移工具。\r\n"
    },
    {
        "article_id": "7189626825566978107",
        "snapshot": "",
        "title": "JavaScript当中的this指向的全解",
        "preview": "全局上下文的this 全局上下文，也就是this在全局作用域下，此时的this相当于window 这是因为给 this 添加属性，就相当于给 window 添加属性，给 window 添加属性，就相当",
        "author": "读书的小蜗牛",
        "view_count": 428,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ba6dedc817ce34d5adda525f030d9912~300x300.image",
        "category": "前端",
        "content": "\r\n> 想必大家在编程当中见过不少的`this`，对`this` 的指向也是非常的头疼,所以在这里我总结了几种常见的情况，希望对各位读者有所帮助😄\r\n\r\n## 全局上下文的this\r\n\r\n  全局上下文，也就是`this`在全局作用域下，此时的`this`相当于`window`\r\n\r\n~~~javascript\r\nconso.log(this)\r\n// 此时在控制台中打印的结果是 window\r\nif (this === window) {\r\n    console.log('yes')\r\n  } else {\r\n    console.log('no')\r\n  }\r\n// 这时候打印的也是符合预期的 yes\r\n~~~\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c81ef5eb86b47038b7f75e4360bfeca~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n> 为了让大家有更深刻的理解，这里再次做一个测试\r\n\r\n~~~javascript\r\nthis.userName = \\\"zhangsan\\\";\r\nwindow.age = 18;\r\n\r\nconsole.log(this.age); // 输出 18\r\nconsole.log(window.userName); // 输出 'zhangsan'\r\n~~~\r\n\r\n 这是因为给 `this` 添加属性，就相当于给 `window` 添加属性，给 `window` 添加属性，就相当于给 `this` 添加属性，也再一次验证了`this`在全局作用域下相当于`window`\r\n\r\n## 全局上下文中的函数\r\n\r\n函数上下文中的 `this` 与 `arguments` 一样，就是函数的`隐式参数`，可以在任意函数中调用，它的`指向不是固定不变的`，取决于函数**处于什么位置、以什么方式调用**\r\n\r\n### 直接调用函数\r\n\r\n```javascript\r\nfunction fn1() {\r\n  console.log(this); \r\n}\r\nfn1();\r\n// 调用的结果会输出 window\r\n// 此时函数的调用相当于 window.fn1();\r\n\r\nfunction fn2() {\r\n  let a = 1;\r\n  console.log(this.a); // 输出 2\r\n}\r\nvar a = 2;\r\nfn2();\r\n// 此时函数的调用相当于 window.fn2();\r\n```\r\n\r\n> **注意**：利用 `var `声明的变量会有`变量提升`\r\n\r\n> **总结**：`函数`当中的`this`指向的是函数的调用者，在全局上下文当中的函数的调用者实际是 `window`。由于是在全局上下文当中的函数，所以调用函数时可以省略 `window`，也就是我们通常所见到的  `函数名 ();`形式的函数调用方式。\r\n\r\n#### 在严格模式下全局上下文中的函数\r\n\r\n```javascript\r\nfunction fn() {\r\n  \\\"use strict\\\"; // 代表开启了严格模式，此时代码的检查会变得非常严格\r\n  console.log(this); // 输出 undefined\r\n}\r\nfn();\r\n```\r\n\r\n## 对象中的函数\r\n\r\n对象当中的函数也称之为对象的`方法`，而`方法的调用者`也就是这个`方法的拥有者`，也就是`对象`\r\n\r\n### 全局上下文中的对象\r\n\r\n```javascript\r\nconst obj = {\r\n  age: 18,\r\n  fn() {\r\n    console.log(\\\"this是：\\\", this); // 输出    this是：obj\r\n    console.log(\\\"this.age是：\\\", this.age); // 输出    this.age是：18\r\n  },\r\n};\r\n\r\nobj.fn();\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51418a24d3434158839106ac7bfef96f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n> 此时对像当中的函数的 this 指的依旧是函数的调用者，也就是 fn(); 的调用者，而对象调用了这个函数 obj.fn();\r\n>\r\n> 所以此时 this === obj\r\n\r\n```javascript\r\nconst obj = {\r\n  age: 18,\r\n  fn() {\r\n    console.log('this是：', this) // 输出 this是：obj\r\n    console.log('this.age是：', this.age) // 输出 this.age是：18\r\n    if (this === obj) {\r\n      console.log('yes')\r\n    } else {\r\n      console.log('no')\r\n    }\r\n  }\r\n}\r\n\r\nobj.fn()\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7df2c3233b1441f49be38bb182a4c793~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n所得结果符合预期。\r\n\r\n### 函数嵌套有函数\r\n\r\n```javascript\r\nconst obj = {\r\n  age: 18,\r\n  fn() {\r\n    return function () {\r\n      console.log(\\\"this是：\\\", this); // 输出 this是：window\r\n      console.log(\\\"this.age是：\\\", this.age); // 输出 this.age是：100\r\n    };\r\n  },\r\n};\r\n\r\nvar age = 100;\r\n\r\nobj.fn()();\r\n```\r\n\r\n其实我们可以这样理解\r\n\r\n```javascript\r\nobj.fn()();\r\n\r\n// 等价于\r\n\r\nconst temp = obj.fn(); // 定义一个临时变量来存储 obj.fn 返回的函数\r\ntemp(); // 执行这个函数\r\n```\r\n\r\n> 其实单独的 `obj.fn();`也不会报错，但是返回的不再是原始类型的数据了，而返回的是一个引用类型的数据 ，在这里返回的其实是一个函数，而`this`是`在返回的函数里`面使用的，那么`this`指向的是返回的函数的调用者。\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d30d96e71b8431e980ee8c269e0d182~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n### 函数嵌套有箭头函数\r\n\r\n> 但是在有时候我们就想在函数嵌套有函数的情况下让`this`所`指向`的就是`obj`，那么可以`使用箭头函数`\r\n```javascript\r\nconst obj = {\r\n  age: 18,\r\n  fn() {\r\n    return () => {\r\n      console.log(\\\"this是：\\\", this); // 输出 this是：obj\r\n      console.log(\\\"this.age是：\\\", this.age); // 输出 this.age是：18\r\n    };\r\n  },\r\n};\r\n\r\nobj.fn()();\r\n```\r\n\r\n对于`普通函数`来说，内部的 `this` 指向函数运行时所在的对象。\r\n\r\n对于`箭头函数`，它不会创建自己的 `this`，它只会**从自己的`作用域链的上一层`继承 this**。\r\n\r\n所以这里 `fn` 中嵌套的匿名箭头函数中的 `this`，指向它作用域链的上一层的 `this`，也就是函数 `fn` 的 `this`，也就是 `obj`。\r\n\r\n## 构造函数\r\n\r\n###  this 指向新建的实例\r\n\r\n```javascript\r\nfunction Person(name) {\r\n  this.name = name;\r\n}\r\nconst p = new Person(\\\"zhangsan\\\");\r\nconsole.log(p.name); // 'zhangsan'\r\n```\r\n\r\n> 这里的`this`指向的是利用`Person `这个构造函数` new` 出来的`实例`，也就是` p` 。\r\n>\r\n> 代码执行后， `this.name = name; `也就意味着 为实例 `p `当中的`name `属性`赋值`为 `zhangsan`\r\n\r\n### 构造函数内的返回值是一个对象\r\n\r\n`示例代码：`\r\n\r\n```javascript\r\nfunction Person(name) {\r\n  this.name = name;\r\n  return {\r\n    name: \\\"syh\\\",\r\n  };\r\n}\r\nconst p = new Person(\\\"zhangsan\\\");\r\nconsole.log(p.name); // 'syh'\r\n```\r\n\r\n这里我们先打印一下 `p` 看看结果\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/180690b8e540403fbdc076fef9862f26~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n到这里，我们先看看 `new Person();`究竟做了什么。\r\n\r\n`第一步:` 创建一个Object对象实例。\r\n`第二步: `将构造函数的执行对象(也就是构造函数当中的所有代码)赋给新生成的这个实例。\r\n`第三步: `执行构造函数中的代码（构造函数当中的代码可能会给实例添加属性或者方法）\r\n`第四步: `将执行的结果返回给新生成的对象实例\r\n\r\n> 就结果而言，只要`new 构造函数();` 就会`自动`的返回一个`已经处理好`的`对象`\r\n\r\n在示例代码当中` Person `这个`构造函数`出现了` return {name: \\\"syh\\\"}; `返回的是一个人为设置的对象，那么就会将那个自动生成的对象给`覆盖`掉，这也就是为什么` p = {name: \\\"syh\\\"};`  而不是  `p = {name: \\\"zhangsan\\\"};` 的原因。所以最后打印的就是 `{name: \\\"syh\\\"} 对象`当中 `name 属性`所对应的`值`，也就是` syh`\r\n\r\n> **简单总结：** 如果构造函数当中有 return 且` return 复杂类型;`(对象也是复杂类型的一种) 则 `new 构造函数(); `返回的是那个手动设置的那个复杂类型。 \r\n\r\n### return 返回的是一个原始值（简单类型）\r\n\r\n```javascript\r\nfunction Person(name) {\r\n  this.name = name;\r\n  return 123;\r\n}\r\nconst p = new Person(\\\"zhangsan\\\");\r\nconsole.log(p.name); // 'zhangsan'\r\n```\r\n\r\n当`return 简单类型; `的时候，`this`依旧指向的是那个自动生成的对象\r\n\r\n## 显式改变函数上下文的 this\r\n\r\n### call()\r\n\r\n`Function.prototype.call()` ,这里出现了`Function.prototype `，那么就意味着只要是函数，那么基本上都可以使用 `call(); `这个方法。`Function `可以简单的理解为所有函数的`父级函数`，`prototype ` 指向`原型对象`，那么连起来就是`Function.prototype.call(); `为`Function`这个函数的原型上挂载一个`call方法`。\r\n\r\n`示例代码：`\r\n\r\n```javascript\r\nfunction fn() {\r\n  console.log(this.name)\r\n}\r\nconst obj = {\r\n  name: 'zhangsan'\r\n}\r\nvar name = '我是 window 下的 name'\r\nfn() // 输出 '我是 window 下的 name'\r\nfn.call(obj) // 指定 this 为 obj，输出 'zhangsan'\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1937b508338f4dc797550ce40d718508~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n\r\n> 调用` fn.call(obj); `改变了原先的`this `指向 ，将`this`指向手动的修改为了 `obj `并且调用了` fn `函数\r\n\r\n### apply()\r\n\r\n`Function.prototype.apply() `那么就意味着只要是函数，那么基本上都可以使用 `apply(); `这个方法。\r\n\r\n按作用效果来说的话，`apply() `方法与 `call()` 方法一样，都会改变函数的`this `指向并调用函数。区别只是只是传参形式不一样，`call` 是传多个参数，`apply` 是只传参数`集合`\r\n\r\n`示例代码：`\r\n\r\n```javascript\r\nfunction add(x, y, z) {\r\n  let result = this.x + this.y + this.z\r\n   console.log(result);\r\n}\r\n\r\nconst obj = {\r\n  x: 1,\r\n  y: 2,\r\n  z: 3\r\n}\r\n\r\nadd.call(obj, 1, 2, 3) // 输出 6\r\nadd.apply(obj, [1, 2, 3]) // 输出 6，只是传参形式不同而已,传入的参数是一个数组，也就是数据的集合\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79b8311f68664a41a363f86379b060d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n### bind()\r\n\r\n`Function.prototype.bind()` 那么就意味着只要是函数，那么基本上都可以使用 `bind(); `这个方法。\r\n\r\n如果函数调用了 bind() 方法，那么就会创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。也就意味着 `函数1.bind() `，这个`函数1`并不会被自动调用。\r\n\r\n```javascript\r\nfunction add(x, y, z) {\r\n  let result = this.x + this.y + this.z\r\n  console.log(result)\r\n}\r\n\r\nconst obj = {\r\n  x: 1,\r\n  y: 2,\r\n  z: 3\r\n}\r\nadd() // undefined 之间相互运算，所得结果是 NaN \r\nconst add1 = add.bind(obj) // bind 会返回一个新的函数\r\nadd1() // 执行新的函数，输出 6\r\n```\r\n\r\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193b7f825f9749449a4c61355a1d29ff~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n"
    },
    {
        "article_id": "7189969269382676540",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c32152a82443e9a786ac6c92103cbb~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【Dubbo3终极特性】「流量治理体系」一文教你如何搭建Dubbo3的控制台服务Dubbo-Admin",
        "preview": "Dubbo Admin Dubbo Admin 是一个控制台，为 Dubbo 集群提供更好可视化服务。Admin 支持 Dubbo3 并很好的兼容 2.7.x、2.6.x 和 2.5.x。 Dubbo",
        "author": "洛神灬殇",
        "view_count": 1362,
        "collect_count": 2,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/a0ada32a139c56817c5f125d7a9cc310~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: smartblue\r\n---\r\n## Dubbo Admin\r\n\r\nDubbo Admin 是一个控制台，为 Dubbo 集群提供更好可视化服务。Admin 支持 Dubbo3 并很好的兼容 2.7.x、2.6.x 和 2.5.x。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65462b6dfc564489a1e8eca2f199aa78~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## Dubbo Admin的部署方式\r\n\r\n接下来我们主要会介绍有四种Dubbo Admin部署到生产环境的方式\r\n\r\n- 基于 Helm 运行 Admin \r\n- 基于 Kubernetes 运行 Admin\r\n- 基于 Docker 运行 Admin\r\n- 基于源码打包运行 Admin\r\n\r\n### 基于 Helm 运行 Admin \r\n\r\n通过 Helm运行Admin有两种方式，它们起到相同的效果，因此可以选择以下任意一种。\r\n\r\n#### 基于 Chart 源文件运行 Admin\r\n\r\n##### 下载 chart 源文件\r\n\r\n克隆 Dubbo Admin仓库源码:\r\n\r\n```\r\n$ git clone https://github.com/apache/dubbo-admin.git\r\n```\r\n\r\n从仓库根目录切换到以下目录 deploy/helm/dubbo-admin\r\n\r\n```\r\n$ cd dubbo-admin/deploy/helm/dubbo-admin\r\n```\r\n\r\n#### 安装 helm chart\r\n\r\n```\r\n$ helm install dubbo-admin .\r\n```\r\n\r\n如果你想定制 Admin 的启动参数，以便让 Admin 连接到真实的生产环境注册中心或配置中心，可以通过以下 `-f helm` 参数指定自定义配置文件：\r\n\r\n##### properties.xml\r\n\r\n```properties\r\nproperties: |\r\n  admin.registry.address=zookeeper://30.221.144.85:2181\r\n  admin.config-center=zookeeper://30.221.144.85:2181\r\n  admin.metadata-report.address=zookeeper://30.221.144.85:2181\r\n```\r\n\r\nzookeeper://30.221.144.85:2181 是可以在 Kubernetes 集群内被访问到的真实地址。\r\n\r\n```properties\r\n$ helm install dubbo-admin -f properties.yaml .\r\n```\r\n\r\nproperties字段指定的内容将会覆盖 Admin 镜像中application.properties 指定的默认配置，除了properties之外，还可以定制 Admin helm chart 定义的其他属性，这里是可供使用的完整参数。\r\n\r\n##### application.properties的配置信息\r\n\r\n```properties\r\nserver.port=38080\r\ndubbo.protocol.port=30880\r\ndubbo.application.qos-port=32222\r\n# centers in dubbo2.7, if you want to add parameters, please add them to the url\r\nadmin.registry.address=zookeeper://127.0.0.1:2181\r\nadmin.config-center=zookeeper://127.0.0.1:2181\r\nadmin.metadata-report.address=zookeeper://127.0.0.1:2181\r\n# nacos config, add parameters to url like username=nacos&password=nacos\r\n#admin.registry.address=nacos://127.0.0.1:8848?group=DEFAULT_GROUP&namespace=public\r\n#admin.config-center=nacos://127.0.0.1:8848?group=dubbo\r\n#admin.metadata-report.address=nacos://127.0.0.1:8848?group=dubbo\r\n#group (Deprecated it is recommended to use URL to add parameters,will be removed in the future)\r\n#admin.registry.group=dubbo\r\n#admin.config-center.group=dubbo\r\n#admin.metadata-report.group=dubbo\r\n#namespace used by nacos. (Deprecated it is recommended to use URL to add parameters,will be removed in the future)\r\n#admin.registry.namespace=public\r\n#admin.config-center.namespace=public\r\n#admin.metadata-report.namespace=public\r\nadmin.root.user.name=root\r\nadmin.root.user.password=root\r\n#session timeout, default is one hour\r\nadmin.check.sessionTimeoutMilli=3600000\r\n# apollo config\r\n# admin.config-center = apollo://localhost:8070?token=e16e5cd903fd0c97a116c873b448544b9d086de9&app.id=test&env=dev&cluster=default&namespace=dubbo\r\n# (Deprecated it is recommended to use URL to add parameters,will be removed in the future)\r\n#admin.apollo.token=e16e5cd903fd0c97a116c873b448544b9d086de9\r\n#admin.apollo.appId=test\r\n#admin.apollo.env=dev\r\n#admin.apollo.cluster=default\r\n#admin.apollo.namespace=dubbo\r\n\r\n#compress\r\nserver.compression.enabled=true\r\nserver.compression.mime-types=text/css,text/javascript,application/javascript\r\nserver.compression.min-response-size=10240\r\n\r\n#token timeout, default is one hour\r\nadmin.check.tokenTimeoutMilli=3600000\r\n#Jwt signingKey\r\nadmin.check.signSecret=86295dd0c4ef69a1036b0b0c15158d77\r\n\r\n#dubbo config\r\ndubbo.application.name=dubbo-admin\r\ndubbo.registry.address=${admin.registry.address}\r\n\r\n# mysql\r\n#spring.datasource.driver-class-name=com.mysql.jdbc.Driver\r\n#spring.datasource.url=jdbc:mysql://localhost:3306/dubbo-admin?characterEncoding=utf8&connectTimeout=1000&socketTimeout=10000&autoReconnect=true\r\n#spring.datasource.username=root\r\n#spring.datasource.password=mysql\r\n\r\n# h2\r\nspring.datasource.url=jdbc:h2:mem:~/dubbo-admin;MODE=MYSQL;\r\nspring.datasource.username=sa\r\nspring.datasource.password=\r\n\r\n# id generate type\r\nmybatis-plus.global-config.db-config.id-type=none\r\n\r\ndubbo.application.logger=slf4j\r\n```\r\n\r\n##### 访问 Admin\r\n\r\nDubbo Admin现在应该已经成功安装，运行以下命令获得访问地址:\r\n\r\n```\r\n$ kubectl --namespace default port-forward service/dubbo-admin 38080:38080\r\n```\r\n\r\n或者，你可以参考执行 helm 安装后给出的提示命令，类似如下:\r\n\r\n```\r\nexport POD_NAME=$(kubectl get pods --namespace default -l \\\"app.kubernetes.io/name=dubbo-admin,app.kubernetes.io/instance=dubbo-admin\\\" -o jsonpath=\\\"{.items[0].metadata.name}\\\")\r\nexport CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath=\\\"{.spec.containers[0].ports[0].containerPort}\\\")\r\necho \\\"Visit http://127.0.0.1:38080 to use your application\\\"\r\nkubectl --namespace default port-forward $POD_NAME 38080:$CONTAINER_PORT\r\n```\r\n\r\n打开浏览器并访问 http://127.0.0.1:38080，默认的 username 和 password 是 root。\r\n\r\n#### 基于 Chart 仓库运行 Admin\r\n\r\n##### 添加 helm chart 仓库 (暂时不可用)\r\n\r\n```\r\n$ helm repo add dubbo-charts https://dubbo.apache.org/dubbo-charts\r\n$ helm repo update\r\n```\r\n\r\n##### 安装 helm chart\r\n\r\n```\r\n$ helm install dubbo-admin dubbo-charts/dubbo-admin\r\n```\r\n\r\n基于 Chart 源文件运行 Admin 中相应环节了解如何定制安装参数\r\n\r\n```\r\n$ helm install dubbo-admin -f properties.yaml dubbo-charts/dubbo-admin\r\n```\r\n\r\n##### 访问 Dubbo Admin\r\n\r\nDubbo Admin 现在应该已经成功安装，运行以下命令获得访问地址:\r\n\r\n```\r\n$ kubectl --namespace default port-forward service/dubbo-admin 38080:38080\r\n```\r\n\r\n打开浏览器并访问 http://127.0.0.1:38080，默认的 username 和 password 是 root\r\n\r\n\r\n### 使用 Kubernetes 运行\r\n\r\n克隆 Dubbo Admin仓库源码:\r\n\r\n```\r\n$ git clone https://github.com/apache/dubbo-admin.git\r\n```\r\n\r\n切换到 deploy/k8s 目录可以看到Admin kubernetes资源文件\r\n\r\n```\r\n$ cd /dubbo-admin/deploy/k8s\r\n```\r\n\r\n#### 部署 Dubbo Admin\r\n\r\n首先，请参照application.properties修改configmap.yml 中的参数配置，只定义要覆盖参数即可，如下图所示。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5987ccfe1bd4611b7de65e7d4205c49~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n```\r\n  application.properties: |\r\n    admin.registry.address=zookeeper://127.0.0.1:2181\r\n    admin.config-center=zookeeper://127.0.0.1:2181\r\n    admin.metadata-report.address=zookeeper://127.0.0.1:2181\r\n```\r\n\r\n- 修改admin.registry.address\r\n- 修改admin.config-center\r\n- 修改admin.metadata-report.address\r\n\r\n执行以下命令：\r\n\r\n```\r\n$ kubectl apply -f ./\r\n```\r\n\r\n#### 访问 Admin\r\n\r\n```\r\n$ kubectl port-forward service dubbo-admin 38080:38080\r\n```\r\n\r\n打开浏览器并访问 http://localhost:38080， 默认 username 和 password 是 root。\r\n\r\n\r\n\r\n#### 使用 Docker 运行\r\n\r\n预先定义的 Admin 镜像托管在： \r\n\r\nhttps://hub.docker.com/repository/docker/apache/dubbo-admin\r\n\r\n可以直接运行镜像来部署 Admin，并通过绑定宿主机上的 application.properties 文件定制镜像默认参数，如注册中心、配置中心地址等。\r\n\r\n```\r\n$ docker run -it --rm -v /the/host/path/containing/properties:/config -p 38080:38080 apache/dubbo-admin\r\n```\r\n将 /the/host/path/containing/properties 替换为宿主机上包含 application.properties 文件的实际路径（必须是一个有效目录的绝对路径）。\r\n\r\n打开浏览器并访问 http://localhost:38080, 默认 username 和 password 是 root\r\n\r\n#### 通过源码打包运行\r\n\r\n下载代码: git clone https://github.com/apache/dubbo-admin.git\r\n\r\n在 dubbo-admin-server/src/main/resources/application.properties中指定注册中心地址\r\n\r\n构建\r\n\r\n```\r\nmvn clean package -Dmaven.test.skip=true\r\n```\r\n\r\n启动\r\n\r\n```\r\nmvn --projects dubbo-admin-server spring-boot:run 或者\r\ncd dubbo-admin-distribution/target; java -jar dubbo-admin-${project.version}.jar\r\n```\r\n访问 http://localhost:38080\r\n\r\n### 核心重点配置\r\n\r\n#### application.properties配置项说明\r\n\r\n##### admin.config-center\r\n\r\n推荐使用，配置中心地址，比如：`admin.config-center=\\\"zookeeper://127.0.0.1:2181\\\"`\r\n需要在配置中心中，配置注册中心和元数据中心地址配置格式如下：\r\n\r\n```\r\nzookeeper：\r\n     path: /dubbo/config/dubbo/dubbo.properties\r\n     content:\r\n        dubbo.registry.address=zookeeper://127.0.0.1:2181\r\n        dubbo.metadata-report.address=zookeeper://127.0.0.1:2181\r\n```\r\n\r\n\r\n##### admin.registry.address\r\n\r\n不推荐使用，老版本的配置中心地址，比如：\r\n\r\n```\r\nadmin.registry.address=\\\"zookeeper://127.0.0.1:2181\\\"\r\n```\r\n\r\n如使用该配置，Dubbo Admin会将其作为注册中心和配置中心使用，元数据中心将无法使用，会影响服务测试等功能。\r\n"
    },
    {
        "article_id": "7189834932955381818",
        "snapshot": "",
        "title": "一次偶然机会发现的MySQL“负优化”",
        "preview": "文章最开始先给大家两条sql，请猜猜他们执行会有什么区别？ 这两条sql看似只是limit的数值不同，但是第一个执行耗时3ms，第二个执行耗时66s，相差2000多倍。",
        "author": "骑牛上青山",
        "view_count": 792,
        "collect_count": 5,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/3618e1e0b47a7c09d390bbd3f9ed7606~300x300.image",
        "category": "后端",
        "content": "文章最开始先给大家两条sql，请猜猜他们执行会有什么区别？\r\n```sql\r\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 1\r\n```\r\n```sql\r\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 2\r\n```\r\n这两条sql看似只是limit的数值不同，但是第一个执行耗时3ms，第二个执行耗时66s，**相差2000多倍**。\r\n\r\n# 故事的起因\r\n今天要讲的这件事和上述的两个sql有关，是数年前遇到的一个关于`MySQL`查询性能的问题。主要是最近刷到了一些关于`MySQL`查询性能的文章，大部分文章中讲到的都只是一些常见的索引失效场合，于是我回想起了当初被那个离奇的“索引失效”支配的恐惧。\r\n\r\n# 场景复现\r\n由于事情已经过去多年，因此我只能凭借记忆在本地的数据库进行模拟。首先创建数据库`school`，数据表`student`：\r\n```sql\r\nCREATE TABLE `student` (\r\n  `id` bigint NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(100) DEFAULT NULL,\r\n  `age` int DEFAULT NULL,\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\r\n  PRIMARY KEY (`id`),\r\n  KEY `student_age_IDX` (`age`) USING BTREE,\r\n  KEY `student_create_time_IDX` (`create_time`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\r\n```\r\n结构简单明了，其中`age`和`create_time`使用`BTREE`构建了索引。\r\n\r\n在使用存储过程往数据库填充了500w条左右的数据后，我们使用如下的sql来进行测试：\r\n```sql\r\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 1\r\n```\r\n结果如下：\r\n\r\n![limit1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f73317b2e2b43fb92cb79b3798d0af5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n之后尝试执行如下sql：\r\n```sql\r\nSELECT * from student s where age < 17 and name ='zhangsan12' and create_time < '2023-01-17 10:23:08' order by age LIMIT 2\r\n```\r\n\r\n![limit2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93959bb4ac642f8a1b32abb5633bbce~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这就是我们开篇提到的那两个sql，性能差距是2000多倍。那么问题来了，为什么limit的值会影响sql性能，并且会差别如此之大？故事要从`MySQL`的优化说起。\r\n\r\n# MySQL的“负优化”\r\n在分析sql性能的时候，我们当然最常用的是`EXPLAIN`，将两个sql分别`EXPLAIN`，结果如下：\r\n\r\n![explain1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfeef218e89241aa9241d5129c8d849f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![explain2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39caf933a95c487f8fd20cb49a40d938~tplv-k3u1fbpfcp-watermark.image?)\r\n可以看到sql执行计划并无二致，那么为什么执行时间却相差这么远呢？\r\n\r\n查找相关文档就可以在`MySQL`的官网找到如下的解释：\r\n> If you combine LIMIT row_count with ORDER BY, MySQL stops sorting as soon as it has found the first row_count rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the LIMIT clause are selected, and most or all of them are sorted, before the first row_count are found. After the initial rows have been found, MySQL does not sort any remainder of the result set.\r\n\r\n大致意思就是`LIMIT`与`ORDER BY`一起使用`MySQL`会在找到`LIMIT`设定的值后立即返回。虽然没有找到具体的原理性的解释，但是从上述的这个描述中我们也能够大致理解这个思路了。\r\n\r\n在`MySQL`中`LIMIT`与`ORDER BY`是特殊的组合，尤其是当`ORDER BY`中的存在`BTREE`索引的情况下。\r\n\r\n普通的查询是根据条件进行筛选，然后在结果集中排序，然后获取`LIMIT`条数的数据，但是在具备上述条件的特殊sql中执行逻辑是这样的，根据`ORDER BY`字段的B+树索引来查找满足条件的数据，直到凑满`LIMIT`设定的数值为止，这就存在一个问题，在结果集中的数据大于`LIMIT`的场景下，这个性能固然是非常棒的，但是如果最后的结果集中的数据小于`LIMIT`，就会存在永远凑不满的情况，所以最终这个`MySQL`的性能优化就会变成全表扫描的“负优化”。\r\n\r\n**根据上述的情况来看的话我们可以大胆猜测，既然是索引导致的优化问题，那么是不是把`age`字段的索引去掉反而会更快？**\r\n\r\n手动执行`DROP INDEX student_age_IDX ON school.student`删除索引，然后执行语句，果然执行速度变成了毫秒级：\r\n\r\n![limit3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324396b512264625b3ce2391378bff1d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n查看执行计划发现在执行时使用了`create_time`的索引，因此其速度也能保持在毫秒级。\r\n\r\n![explain3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a51d4f2147c4f67acbe68615a8ea84f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后我们干脆把`create_time`的索引也去除掉：\r\n\r\n![explain4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/037374f0f4a14f608838f9850574a2d7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![limit4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7d2e3c2e12e4a8d960c348f56f49c02~tplv-k3u1fbpfcp-watermark.image?)\r\n可以看到没有索引的情况下耗时也不过是1秒出头，远远不是66秒。可见在这种情况下`MySQL`的性能优化甚至远远比不上无索引的查询。\r\n\r\n\r\n![kengdie.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ae29326d1474fc5931ad7cd989359f5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 总结\r\n其实出现这个问题的场景也不算十分特殊，但是排查原因相当困难。当初是花了好几天查资料翻文档加上不断实验才找到了问题所在。只能说`MySQL`在解析和执行sql的背后做了很多的优化，但是这部分对于不够熟悉了解的人来说确实是太黑盒，遇到类似的问题排查也很困难。也许这就是程序员成长路上的必经之路吧。"
    },
    {
        "article_id": "7189603007955222583",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcf53e0c3bec45e0aa477c434403bc0d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "『白板推导系列笔记』1.数学基础",
        "preview": "白板推导系列笔记前言。在本文中，对一些0基础的问题进行讲解，但是由于涉及到知识范围太广，难以全部涉及，建议先对线性代数、高数、概率论的部分内容掌握扎实之后再来阅读，会减少一些阅读的障碍。",
        "author": "jjyaoao",
        "view_count": 821,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/7820c500299d7aae3f3ccc299fde757e~300x300.image",
        "category": "人工智能",
        "content": "# 统计学习入门\r\n\r\n> 本系列仅以自己学习过程作为参考，将其学习过的知识与自己的理解用文字的形式记录，希望也能对一同成长的朋友有所帮助，若有错误请各位大佬不吝赐教。\r\n\r\n\r\n![统计学习入门.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94e54b3e46f4affb9589f354d66fe2e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image-20221031101628073.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/295cde1cabec4cca9e7a623fe8d0425c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 前言\r\n\r\n在本文中，对一些0基础的问题进行讲解，但是由于涉及到知识范围太广，难以全部涉及，建议先对线性代数、高数、概率论的部分内容掌握扎实之后再来阅读，会减少一些阅读的障碍\r\n\r\n线性代数部分\r\n\r\n- 至少先去搞懂矩阵、范数、特征向量和特征值等等\r\n\r\n- 推荐资料\r\n- [名校公开课-线性代数-秦静 | 山东大学_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Bp4y1Q7kf/?vd_source=55ffe5143706c86851979f75f0da6acb)\r\n- [-UP主汉语配音-【线性代数的本质】合集-转载于3Blue1Brown官方双语】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ib411t7YR/)\r\n\r\n高数部分\r\n\r\n- 至少搞懂导数/ 微分/ 积分 /梯度 等等，建议都学一下\r\n- [《高等数学》同济版 全程教学视频（宋浩老师）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Eb411u7Fw/)\r\n\r\n概率论\r\n\r\n- 条件概率，期望等等\r\n- [概率论与数理统计全集（统计学）（清楚易懂，看过的都说好！）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1CA411P7bL/)\r\n\r\n若想更加深入学习可以自行去找一些优质资源，打好扎实数理基础。\r\n\r\n## 一、什么是统计学习？\r\n\r\n- **统计学习**是关于计算机基于**数据构建**概率统计**模型**并运用模型**对数据**进行**预测与分析**的一门学科。\r\n- 它的**主要特点**是：\r\n  - 建立在计算机与网络\r\n  - 以数据为研究对象\r\n  - 对数据进行预测与分析\r\n  - 为多学科交叉体系\r\n- 因此统计学习可以称为运用数据及统计方法提高系统性能的机器学习，机器学习的全称往往是指**统计机器学习**\r\n\r\n## 二、分类\r\n\r\n### 基本分类\r\n\r\n统计学习一般包括监督学习、无监督学习、强化学习。有时还会有监督学习和主动学习。\r\n\r\n在这里，我们**以监督学习为例子**，来熟悉统计学习中一些很常见的概念\r\n\r\n请注意，可能概念有点多，大家适当理解就行，不用刻意记忆，用的多了自然会熟的。\r\n\r\n#### 1. 监督学习\r\n\r\n- 监督学习（supervised learning）利用训练数据集学习一个模型，再用模型对测试样本集进行预测，由于过程中需要标注的训练数据集，而标注往往是**人工**进行，所以也可看做是`被人监督的机器学习`。\r\n- 我们将输入变量写作$X$，它对应的每一个取值写作$x$，输出变量定义为$Y$，对应的每一个值看做$y$。每一个具体的**输入变量$x$**我们可以认为是一个**实例（instance）**，每一个**实例**由**特征向量（feature vector）**表示,且所有**特征向量**同处于一个空间，称为**特征空间（feature space）**。\r\n- 另外，由于特征向量具有多个维度（类似于一个实体具有很多不同的属性），因此我们通常将其定义为以下形式：\r\n  - $x=\\\\left(x^{(1)}, x^{(2)}, \\\\cdots, x^{(i)}, \\\\cdots, x^{(n)}\\\\right)^{\\\\mathrm{T}}$\r\n  - 其中：$ x^{(i)}$表示$x$的第 i 个特征，而后文提到的$x_{i}$则为多个输入变量中的一个\r\n- 基本假设：X和Y具有`联合概率分布`\r\n  - 联合概率分布，简单来说就是两个及以上的随机变量组成的关于**随机变量的概率分布**，并且定义在**同一个样本空间**\r\n- `数据集`：我们上文提到监督学习是利用训练数据集学习，并且对测试样本进行预测，要进行预测任务的前提是，需要有对应的真实数据，因此训练数据集由输入输出对组成，通常表示为：\r\n  - $T=\\\\left\\\\{\\\\left(x_{1}, y_{1}\\\\right),\\\\left(x_{2}, y_{2}\\\\right), \\\\cdots,\\\\left(x_{N}, y_{N}\\\\right)\\\\right\\\\}$\r\n- `假设空间`：这里的假设空间和上述特征空间并不一样，需要区别注意。假设空间是指，所有可能的能满足样本输入与输出映射的集合，也就是所有对应关系的总和，当我们确立了一个假设，那么基于该假设的假设空间及其规模大小就可以确定。例如一个苹果有三种颜色，三种脆度和三种大小，那么一共它有三个属性，若我们的假设红色苹果是一个好苹果，那么假设空间的大小就是3，也就是只有三种可能性，若我们给出的假设是一个瓜是不是好瓜，需要结合三种属性同时判断，那么就有4\\\\*4\\\\*4种可能性（例如三种颜色+不是这三种颜色的就是好瓜），也就是假设空间的大小为64。\r\n- `过程`：学习 + 预测\r\n  - 学习：通过训练模型，得到一个条件概率分布$\\\\hat{P}(Y \\\\mid X)$或决策变量$Y=\\\\hat{f}(X) $\r\n    - P（Y | X）是指在满足X的条件下，Y发生的概率，也称为后验概率\r\n  - 预测：$y_{N+1}=a r g \\\\max \\\\hat{P}\\\\left(y \\\\mid x_{N+1}\\\\right)$或$y_{N+1}=f\\\\left(x_{N+1}\\\\right) $给出相应的输出$y_{N+1}$\r\n    - argmax(f(x))是使得 f(x)取得最大值所对应的变量点x(或x的集合)\r\n\r\n**概率模型（probabilistic model）**\r\n\r\n> 条件概率分布模型形式：$P(y|x)$，其中x为输入，y为输出。若在无监督学习中则为$P(z|x)$或$P(x|z)$，其中x是输入，z是输出。\r\n\r\n- **非概率模型（nonprobabilistic model）**\r\n\r\n> 又称确定性模型（deterministic model），取函数形式$y=f(x)$，无监督学习中则为$z=g(x)$\r\n\r\n- 条件概率分布$P(y|x)$和函数$y=f(x)$可以相互转化，前者一般是`生成式`模型，输出某个预测的“概率”，后者一般是`判别式`模型，输出某个预测的“得分”，两者在训练时都是最大化正确预测的概率或得分。\r\n  - 我们现在先使用一下后面会介绍的模型，来简单的引入，看不懂没关系（以下例子参照xSeeker回答）\r\n  - 以朴素贝叶斯二分类为例子，条件概率分布最大化后得到函数是指：\r\n    - $y=f(X)=\\\\arg \\\\max P(Y \\\\mid X)=\\\\arg \\\\max _{k} \\\\frac{P(X \\\\mid y=k) P(y=k)}{P(X)}, k \\\\in\\\\{0,1\\\\}$\r\n  - 以逻辑斯特回归为例，函数归一化后得到条件概率：\r\n    - $\\\\begin{array}{l}f(X)=W X+b \\\\\\\\P(y=1 \\\\mid X)=\\\\text { Sigmoid }(f(X))\\\\end{array}$\r\n  - 这里可能有朋友不懂什么是归一化，简单说就是将已有数据去除量纲，比如一个样本有多个特征，但可能大部分特征数值集中1~10之间，突然有一个特征平均数值比另外这些特征高得多，那么它就会严重的影响结果，对判定起主导作用，为了杜绝这样的情况可以将所以特征都通过一些合适的归一化函数，将其数值规定到0-1之间，使得每个特征对结果影响相对平等。\r\n\r\n- **监督学习**的**任务**就是学习一个模型，并且应用它，**给定输入预测相应输出**\r\n- 一般形式为：\r\n  - 决策函数$Y = f(X)$或条件概率分布$P(Y|X)$\r\n- 统计学习方法也可以分为`生成方法（generative approach）`和`辨别方法（discriminative approach）`，所学到的模型分别是`生成模型（generative model）`和`辨别模型（discriminative model）`\r\n  - 在监督学习中，概率模型是生成模型，非概率模型是辨别模型\r\n- 生成方法关系的是给定了输入X产生输出Y，X与Y之间的关系\r\n  - 特点：还原联合概率分布P（X，Y），辨别方法不能，学习收敛速度往往很快，且样本数量足够大时更能收敛于真实模型。\r\n  - 典型应用模型有朴素贝叶斯模型和隐马尔卡夫模型..会在今后的文章中提到\r\n- 辨别模型则更侧重于给定输入X，应该预测什么样输出Y\r\n  - 直接面对预测的模型，学习准确率往往更高，但因为直接学习的是P（Y|X）或者f（X），可以对数据进行抽象，定义特征并使用特征，因此可以简化学习问题。\r\n  - 典型应用包括K-means，感知机，决策树，逻辑斯谛回归模型，最大熵，支持向量机....同样也会在后面进行讲述\r\n\r\n\r\n\r\n#### 2. 无监督学习\r\n\r\n- 从监督学习过渡过来，我们可以自然想到无监督学习即是采用**无标注数据**来学习预测模型的机器学习。\r\n  - 本质上是**学习**数据中的统计**规律**或潜在结构。\r\n- 学习与预测过程和监督学习类似，数据集通常表示为：\r\n  - $U=\\\\{x_{1},x_{2},...,x_{N}\\\\}$\r\n  - 其中$x_i$，i = 1,2,...,N.\r\n  - 请注意这里每一个x为一个**样本**，不要和上面的$x^{(1)}$混淆\r\n\r\n#### 3. 强化学习\r\n\r\n- 智能系统在与环境的连续互动（通常指的是不断试错）中学习最优行为策略的机器学习问题\r\n\r\n- **本质：学习最优的序贯决策**\r\n\r\n![image-20221005113344046.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ef5ef7b9364bde8ed1016e7a7a072d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 智能系统与环境的互动如上图，具体解释起来就是，每迭代一步，首先智能系统从环境观察到一个状态（state）$s_{t}$与一个奖（reward)$r_{t}$，后采取一个动作（action）$a_{t}$，决定下一步的状态与奖励，大概就是一个动态规划的感觉。设置的**目标**不是短期最大化，而是长期**积累奖励最大化**。强化学习就是不断试错（trial and error）以学习到最优策略的过程。\r\n\r\n- 一个强化学习的经典案例，是马尔可夫链\r\n\r\n  - ![image-20221006142048598.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f6376e2577e486aa91fb6fb636b9087~tplv-k3u1fbpfcp-watermark.image?)\r\n  - ![image-20221006142132896.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4af75e7b004234b52b665dc0d94e10~tplv-k3u1fbpfcp-watermark.image?)\r\n    - 总而言之，学习通常就是从一个价值函数开始，通过搜索找到更加好的价值函数，用其中叠加的奖励来表示是否更好。\r\n\r\n\r\n\r\n  \r\n\r\n#### \\t\\t\\t4. 半监督学习与主动学习\r\n\r\n- 半监督学习（semi-supervised learning）即使用少量标注数据和大量未标记数据，旨在利用未标注数据中信息辅助标注数据，进行监督学习，以较低成本达到较好的学习效果。\r\n- 主动学习（active learning）是指机器主动给出实例让人工来进行标注，目标是找出对学习最有帮助的实例，利用人工来对其特殊标注，从而耗费较少代价达到较好的学习效果。\r\n- 半监督学习和主动学习更接近**监督学习**\r\n\r\n\r\n\r\n\r\n\r\n### 其他分类（部分）\r\n\r\n> 这里为简要介绍，大家快速了解即可。\r\n\r\n#### 按算法分类\r\n\r\n**在线学习（online learning）**\r\n\r\n- 每次接受**一个**样本，进行预测，之后学习模型，并不断重复该操作的机器学习\r\n- 在线学习的学习与预测过程在一个系统中，每次接受一个输入$x_{t}$，用已有模型给出预测$\\\\hat{f}\\\\left(x_{t}\\\\right)$，之后得到的结果即为该输入对应的输出$y_{t}$，我们的学习预测系统使用损失函数计算与理论$f\\\\left(x_{t}\\\\right)$的差异，更新模型不断重复的过程叫做在线学习。\r\n\r\n![image-20221006191358731.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25d9f10d55149f6aec46ebacd3fde08~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n  - 在线学习通常比批量学习更难预测准确率更高的模型，因为迭代过程中可以利用的数据有限。\r\n  - 但当数据规模量很大以至于不可能一次处理所有数据，又或者数据采取的学习方式动态变化就必须得使用在线学习。\r\n  - 下文提及的利用随机梯度下降的感知机学习算法就是在线学习算法。\r\n\r\n---\r\n\r\n**批量学习（batch learning）**\r\n\r\n- 一次接受**所有**数据，学习模型，之后进行预测。\r\n  - 优点\r\n    - 效率高，学习可以并行\r\n    - 消除样本顺序的影响\r\n  - 缺点\r\n    - 需要对内存容量宽裕，满足一次性加载所有训练集的条件，很多时候并不适合实际问题\r\n    - 不适合高维度问题（同样也是内存溢出问题）\r\n\r\n\r\n\r\n#### 按参数数量分类\r\n\r\n> 简而言之，就是看**参数个数是否固定**，参数个数固定的就是参数化模型，反之就是非参数化\r\n\r\n**参数化模型（parametric model）**\r\n\r\n- 假设：模型参数维度**固定**，可以由**有限**维度参数**完全刻画**\r\n- 后续会介绍的感知机、朴素贝叶斯、逻辑斯谛回归...为参数化模型\r\n\r\n---\r\n\r\n**非参数化模型（nonparametric model）**\r\n\r\n- 假设：模型维度**不固定**或者无穷大，随着训练数据量增加**不断增加**\r\n- 后续会介绍的决策树、支持向量机...是为非参数化模型\r\n\r\n#### 按技巧进行分类\r\n\r\n**贝叶斯学习（Bayesian inference）**，是利用贝叶斯定理，计算给定数据条件下模型的条件概率，即后验概率，并运用这个模型进行估计，和对数据进行预测\r\n\r\n- 既然这里提到了贝叶斯定理，那就简单来介绍一下：事件 A 在事件 B 发生的条件下与事件 B 在事件 A 发生的条件下，它们两者的概率并不相同，但是它们两者之间存在一定的相关性，并具有以下公式（称之为“贝叶斯公式”）：\r\n\r\n- $P(A \\\\mid B)=\\\\frac{P(B \\\\mid A) P(A)}{P(B)}$\r\n\r\n  - 其中：\r\n  - P（A）就是在全体数据集的基础上，A事件出现的概率，例如一页书有99个单词，问有多少个how，如果出现3个how，那么P（A）为1/33\r\n  - P（B|A）是条件概率的符号，由于我们求得目标是在B发生的情况下，A发生的概率，那么这个就不能简单的叫做概率了，在统计学里可以用''似然度''来称呼他\r\n  - P（A|B）是指在B发生的的情况下，A发生的概率，计算结果被称为后验概率\r\n\r\n\r\n- 这个公式证明也十分简单，这里可以说一下。\r\n  - P（A，B）代表AB的联合概率分布，那么P（A，B）可以等于P（A|B）\\\\*P（B），也可以等于P（B|A）\\\\*P（A），那么\r\n    - $P（A|B）*P（B）=P（B|A）*P（A）$,即上述公式\r\n\r\n另外，虽然贝叶斯估计和极大似然估计思想上有很大的不同，但是只要假设，先验概率是均匀分布的，取后验概率最大，就能从贝叶斯估计中得到极大似然估计。\r\n\r\n\r\n\r\n![image-20221015153905246.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b80a80f2629d48e2ace01b7a196435b7~tplv-k3u1fbpfcp-watermark.image?)\r\n---\r\n\r\n**核方法（kernel method）**，核方法是一种表示和学习非线性模型的机器学习方法，可以用于监督学习和无监督学习。对一些线性模型，也可以使用，直接的做法是，直接从输入空间（低维）到特征空间（高维）的映射，并在特征空间中进行内积计算，将输入空间的线性不可分问题转化为特征空间的线性可分问题。他的具体技巧可以理解为，并不显示的定义一个一个的映射，而是把这些映射都定义为一个函数，称为核函数（即映射之后的内积），这样可以简化计算以及达到同样效果，节省时间空间。\r\n\r\n\r\n![image-20221015154324778.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29540e8703d14bdaa9830e59ea00f453~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 三、统计学习方法三要素\r\n\r\n- 统计学习方法由三要素构成：\r\n  - $方法=模型+策略+算法$\r\n  - 下面仍然以监督学习进行举例学习三要素，非监督学习，强化学习也同样拥有三要素，可以说，**构建**一种统计学习方法，就是确定**具体**的统计学习三要素\r\n\r\n### 策略\r\n\r\n- 由于策略中的概念在模型中均有体现，因此我们从策略开始学习三要素\r\n- 统计学习需要考虑按照什么样的准则学习或选择最优的模型，这个准则就是策略\r\n\r\n#### 损失函数与风险函数\r\n\r\n- 首先引入损失函数（loss function）与风险函数（cost function）的概念。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。\r\n\r\n- 常用损失\r\n\r\n\r\n![image-20221016113648793.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdaf561f40e0468699796ae71a9d97e5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image-20221016113655897.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c298d83808464b7f939590991c26e5fd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- 一般来讲损失函数值越小，模型越好。由于模型的输入、输出（X，Y）是随机变量，且遵循联合分布P（X，Y），所以我们可以得到损失函数的期望：\r\n\r\n\r\n![image-20221016120359619.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec08a85f25b4ca58dac260d88eda9da~tplv-k3u1fbpfcp-watermark.image?)\r\n- 其实就是把每一次迭代的损失，求平均    \r\n  - 这个期望即是风险函数（risk function）或期望损失（expected loss）\r\n\r\n\r\n- 另外，这个是理想状态下的损失，如果对应到实际的数据集，那么公式变成如下形式\r\n\r\n![image-20221016120901748.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3f7dc532e74d0eb3df0b6c4585dd0b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- Remp就被定义为经验风险（empirical risk）或经验损失（empirical loss）\r\n- 根据大数定律，当N趋于无穷时，经验风险趋近于期望风险，但现实中样本数量有限，常常不能直接这样做，要进行一定的矫正，这里介绍监督学习的两个基本策略：经验风险最小化和结构风险最小化。\r\n\r\n####  基本策略\r\n\r\n- 经验风险最小化（empirical riusk minimization， ERM）\r\n\r\n\r\n![image-20221016122140902.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dbdf0366be14a7cb442004e15aee96b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 其中$\\\\mathcal{F}$是假设空间，下面模型会介绍到。\r\n  - 这个就和经验损失的公式基本类似，他是用于样本足够大的情况，找到能使得损失最小的那一种策略。\r\n  - 但样本容量很**小**的时候，经验风险最小化效果就有待商榷了，可能会产生过拟合（over-fitting）的情况\r\n\r\n---\r\n\r\n\r\n\r\n- 结构风险最小化（structural risk minimization，SRM）\r\n\r\n\r\n![image-20221016122513009.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d01180412c894118add903e2bf8a6d68~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 结构风险最小化是在经验风险最小化的条件下做出的补充，也就是增加一个表示模型复杂度的正则化项（regularizer）或罚项（penalty term）（后续会介绍）\r\n    - 其中：J（f）表示模型复杂度，也称之为泛函，模型越复杂，J（f）就越大，λ>=0，是系数\r\n  - 该策略认为，结构风险最小的模型是最优的模型，所以**求最优**模型就是**求解最优化问题**\r\n\r\n![image-20221016123027832.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fda56ee06704b36b442df8f47410f71~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 模型\r\n\r\n- 在监督学习中，**模型就是**所要学习的**决策函数**或者**条件概率分布**，并且模型的假设空间（hypothesis space）包含所有可能的条件概率分布和决策函数。\r\n  - 假设空间用$\\\\mathcal{F}$表示，假设空间可以定义为决策函数的集合：\r\n    - $\\\\mathcal{F}=\\\\{f \\\\mid Y=f(X)\\\\}$\r\n      - 其中：X和Y是定义在输入空间$\\\\mathcal{X}$和输出空间$\\\\mathcal{Y}$上的变量，此时$\\\\mathcal{F}$通常是参数向量决定的函数族（也就是多个在同一级别的函数）。\r\n  - 假设空间也可以定义为条件概率的集合：\r\n    - $\\\\mathcal{F}=\\\\left\\\\{P \\\\mid P_{\\\\theta}(Y \\\\mid X), \\\\theta \\\\in \\\\mathbf{R}^{n}\\\\right\\\\}$\r\n      - 这个$\\\\theta$就是1,2,3....这些数嘛，属于$\\\\mathbf{R}^{n}$（n维的欧式空间），这个$\\\\mathbf{R}^{n}$也称作参数空间（parameter space）\r\n\r\n#### 模型评估\r\n\r\n- 因为，统计学习的主要**目的**是使学到的模型需要**对未知数据**也能进行良好**预测**，所以说当损失函数给定时，基于损失函数的训练误差（training error）和模型的测试误差（test error）就自然成为学习方法好坏的标准，并且，也要注意训练时的损失函数，**未必**是评估时的损失函数。\r\n- 假设学习到的模型是$Y=\\\\hat{f}(X)$，这里我们在回忆一下，模型其实就是一个能解决问题的数学函数，那么训练误差就是该模型关于训练数据集的平均损失：\r\n  - $R_{\\\\mathrm{emp}}(\\\\hat{f})=\\\\frac{1}{N} \\\\sum_{i=1}^{N} L\\\\left(y_{i}, \\\\hat{f}\\\\left(x_{i}\\\\right)\\\\right)$\r\n    - 其中：$L\\\\left(y_{i}, \\\\hat{f}\\\\left(x_{i}\\\\right)\\\\right)$为损失函数的意思，也就是把模型估计的值和真实值比对，并将其好坏抽象成一个函数算得分。N就是训练样本容量。\r\n\r\n- 测试集误差也是同理：\r\n  - $R_{\\\\mathrm{emp}}(\\\\hat{f})=\\\\frac{1}{N} \\\\sum_{i=1}^{N} L\\\\left(y_{i}, \\\\hat{f}\\\\left(x_{i}\\\\right)\\\\right)$\r\n    - 其中N‘为测试样本容量\r\n\r\n#### 模型选择\r\n\r\n**过拟合（over-fitting）**\r\n\r\n- 如果一昧仅仅追求对训练数据的预测能力，而使得模型过于复杂（参数十分多，十分复杂的函数），那么往往不能很好的完成对未知数据的预测任务，我们举个例子\r\n  - 假设给定一个训练数据集：\r\n    - $T=\\\\left\\\\{\\\\left(x_{1}, y_{1}\\\\right),\\\\left(x_{2}, y_{2}\\\\right), \\\\cdots,\\\\left(x_{N}, y_{N}\\\\right)\\\\right\\\\}$\r\n    - 其中，$x_{i} \\\\in \\\\mathbf{R}$是输入x的观测值，$y_{i} \\\\in \\\\mathbf{R}$是输入y的观测值，i = 1,2，...,N。其实T就是一个散点集合嘛。\r\n  - 现在我们考虑对给定的数据，用函数进行拟合，比如下图中空心原点就是一个数据点，我们采用M次多项式进行拟合。\r\n\r\n![image-20221015164428752.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c013a74afb94683a2e6059242a8070b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 设M次多项式为：\r\n    - $f_{M}(x, w)=w_{0}+w_{1} x+w_{2} x^{2}+\\\\cdots+w_{M} x^{M}=\\\\sum_{j=0}^{M} w_{j} x^{j}$\r\n  - x为单变量输入，w0、w1...是 M + 1 个权重\r\n  - 在这里可以运用策略部分学习到的经验风险最小化策略，将模型与训练数据带入，可得\r\n    - $L(w)=\\\\frac{1}{2} \\\\sum_{i=1}^{N}\\\\left(\\\\sum_{j=0}^{M} w_{j} x_{i}^{j}-y_{i}\\\\right)^{2}$\r\n      - 损失函数为上述提到的平方损失，系数$\\\\frac{1}{2}$仅仅为了方便计算\r\n  - 若要求解可用最小二乘法拟合多项式系数唯一解，有兴趣的同学可以去查阅相关资料，不过我们这里主要是为了解释过拟合的情况\r\n  - 图1.8给出了M=0，M=1，M=3，M=9，即多项式权重的个数与多项式的次数，不难发现，M的值太大或者太小，都会导致拟合曲线与原曲线严重不符合。通常来讲我们模型的项数不能太高，因为有维度诅咒，感兴趣的同学可以去查找**龙格效应**，所以，虽然模型的损失L会根据模型的维度提升（越复杂的模型确实能更好的拟合训练数据），不断减小，但我们往往遵循简单的原则，只要Loss基本达标即可采用该模型，根据经验，回归模型的维度一般要控制到6~7次方以内。在这里，当 **M = 3** 时，多项式曲线对训练数据拟合效果足够好，模型也比较简单，是一个较好的选择。\r\n\r\n![image-20221018215045053.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928806f17ebd4840bee360fbfcd8fa14~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 图1.9描述训练误差和测试误差与复杂度的关系。\r\n  - 为了选择复杂度适当且测试误差最小的学习目的，下面介绍两种常用模型选择方法：正则化与交叉验证\r\n\r\n**正则化（regularization）**\r\n\r\n- 正则化可以来理解为结构风险最小化的实现，一般具有如下形式：\r\n\r\n  - $\\\\min _{f \\\\in \\\\mathcal{F}} \\\\frac{1}{N} \\\\sum_{i=1}^{N} L\\\\left(y_{i}, f\\\\left(x_{i}\\\\right)\\\\right)+\\\\lambda J(f)$\r\n\r\n    - 其中，第一项是经验损失，第二项是正则化项，λ >= 0 为调整两者关系的系数（前面基本策略也有提到）\r\n\r\n  - 正则化项是有不同形式的，在回归问题中，损失函数是平方损失，正则化项可以是参数w的L2范数、L1范数等等。\r\n\r\n    - $L(w)=\\\\frac{1}{N} \\\\sum_{i=1}^{N}\\\\left(f\\\\left(x_{i} ; w\\\\right)-y_{i}\\\\right)^{2}+\\\\frac{\\\\lambda}{2}\\\\|w\\\\|^{2}$\r\n    - $L(w)=\\\\frac{1}{N} \\\\sum_{i=1}^{N}\\\\left(f\\\\left(x_{i} ; w\\\\right)-y_{i}\\\\right)^{2}+\\\\lambda\\\\|w\\\\|_{1}$\r\n\r\n    - 范数：向量的范数可以简单形象的理解为向量的长度，或者向量到零点的距离，或者相应的两个点之间的距离。以后在论文中会常常出现\r\n\r\n    - 常用的向量的范数：\r\n      L1范数:  ||x|| 为x向量各个元素绝对值之和。\r\n      L2范数:  ||x||为x向量各个元素平方和的1/2次方，L2范数又称Euclidean范数或者Frobenius范数\r\n      Lp范数:  ||x||为x向量各个元素绝对值p次方和的1/p次方\r\n\r\n      L∞范数:  ||x||为x向量各个元素绝对值最大那个元素的绝对值，如下:\r\n\r\n      - $\\\\lim _{k \\\\rightarrow \\\\infty}\\\\left(\\\\sum_{i=1}^{n}\\\\left|p_{i}-q_{i}\\\\right|^{k}\\\\right)^{1 / k}$\r\n\r\n  - 这里可能各位朋友又有疑惑了，这么多范数，怎么选呢？\r\n\r\n    - 这可能得具体情况具体分析，例如W是有多个维度的特征向量，那么你认为可能它里面哪一个维度是最重要的，就可以单独用那个维度来使用范数（L1），若p个维度都很有用，那么就可以选择Lp范数\r\n\r\n- L（w）的第一项经验风险较小的模型可能较复杂（多个非0参数），这时第 2 项模型复杂度较大，就可以使得λ增大，从而loss增加，正则化的用途就是**选择经验风险与模型复杂度同时较小的模型**\r\n\r\n---\r\n\r\n**交叉验证（cross validation）**\r\n\r\n- 当模型足够多时，我们只需要将数据简单随机分配成三部分，`训练集（training set）`、`验证集（validation set）`和`测试集（test set）`。训练集用来**训练模型**，验证集用于**筛选模型**，测试集就是**最终对学习方法的评估**，一般来讲，训练集和验证集都是会提供问题和答案，而测试集不会提供答案，就用预测结果作为答案。\r\n- 但是当数据量不够多的时候，为了选择到好的模型，我们可以**将数据重复使用**，就是不断重复同一个数据集，随机切分训练集和测试集，进行迭代，在此基础上反复训练，**重复**就是**交叉验证的本质**\r\n- 1、简单交叉验证\r\n  - 随机将已给数据分为两部分，一部分训练集，一部分测试集（一般7/3开），然后就是正常的\r\n- 2、S折交叉验证\r\n  - 应用最多的是`S折交叉验证（S-fold cross validdation)`，具体方法就是，将数据切分为等大的S个互不相交、大小相同的子集，利用S-1个子集训练数据，1个用来测试，这样的话一共可以训练S次，最终S次测评中平均误差最小的模型即可\r\n- 3、留一交叉验证\r\n  - 核心思想是：每一条数据为一个子集。适合于S = N的情况（S为折数，N为总样本数），往往在数据十分缺乏的时候使用\r\n\r\n### 算法\r\n\r\n- 算法是指学习模型的具体计算方法\r\n- 统计学习有三步\r\n  - ①根据学习策略②从假设空间中选择最优模型③考虑用什么计算方法求解最优模型\r\n- 有时我们利用已有的最优化算法即可，有时需要独自开发最优化算法。\r\n- 下一篇感知机的文章，我们就会提到第一个算法实例：`随机梯度下降法（stochastic gradient descent）`\r\n\r\n## 四、泛化能力\r\n\r\n> `泛化能力（generalization ability）`是指方法学习到**模型对数据的预测能力**\r\n\r\n**泛化误差（generalization error）**\r\n\r\n- 现实中，大多评价泛化能力是通过测试数据集的，但是数据集是有限的，这可能导致结果不可靠，因此，统计学习理论试图从**理论对**学习方法的**泛化能力进行分析**\r\n- 泛化误差其实就是期望损失下加入真实数据的产物（公式基本完全一样，从训练数据更换为了预测数据）\r\n  - $\\\\begin{aligned}\r\n    R_{\\\\exp }(\\\\hat{f}) &=E_{P}[L(Y, \\\\hat{f}(X))] \\\\\\\\\r\n    &=\\\\int_{\\\\mathcal{X} \\\\times \\\\mathcal{Y}} L(y, \\\\hat{f}(x)) P(x, y) \\\\mathrm{d} x \\\\mathrm{~d} y\r\n    \\\\end{aligned}$\r\n- `泛化误差上界（generalization error bound）`\r\n  - 学习方法的泛化**能力分析**往往是**通过**研究泛化误差的**概率上界**进行的，简称泛化误差上界\r\n  - 具体来说就是比较泛化误差上界的大小从而比较泛化能力的优劣\r\n    - 样本容量的函数，当样本容量十分大时，泛化上界趋于0\r\n    - 假设空间容量的函数，容量越大，模型越难学，泛化误差上界就越大。\r\n  \r\n  - 下面从有限集合$\\\\mathcal{F}=\\\\left\\\\{f_{1}, f_{2}, \\\\cdots, f_{d}\\\\right\\\\}$中任意选出函数$f$（F是一个函数集合）分析他的泛化误差上界\r\n  - 对二分类任务而言，每一个函数f的概率至少是$ 1-\\\\delta, 0<\\\\delta<1$，那么，有以下不等式成立：\r\n    - $R(f) \\\\leqslant \\\\hat{R}(f)+\\\\varepsilon(d, N, \\\\delta)$\r\n  \r\n  - 其中：\r\n    - $\\\\varepsilon(d, N, \\\\delta)=\\\\sqrt{\\\\frac{1}{2 N}\\\\left(\\\\log d+\\\\log \\\\frac{1}{\\\\delta}\\\\right)}$\r\n  \r\n  - 这个我认为了解就好，毕竟证明对于初学也过于复杂了，左端R(f)为泛化误差，右端为泛化误差上界。右端第一项是训练误差，训练误差越小，泛化误差会越小。第二项是 N 的单调递减函数，N趋于无穷（样本数量足够多）该项趋于0；同时该项也是$\\\\log d$阶的函数，F包含的函数越多，其值越大。\r\n  \r\n\r\n\r\n\r\n## 五、监督学习应用\r\n\r\n### 分类问题\r\n\r\n- 分类问题包括学习和分类两个过程。学习过程中，利用训练数据（x1，y1),(x2，y2)...(xn,yn)学习分类器；分类过程中利用分类器（模型）对测试集数据($x_{n+1}$,$y_{n+1}$)进行预测,即对$x_{n+1}$进行分类，预测其类别为$y_{n+1}$\r\n\r\n\r\n![image-20221019104158280.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/974c22b150ee4f3ab7009fb8d3235fc3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- 分类器的性能指标一般是分类准确率(accuracy)，其定义是：分类器正确分类的样本数与总样本数之比。\r\n  - 对于二分类问题，常用指标是（precision）与召回率（recall）、通常将关注的类称为正类，其余类为负类，根据在测试数据集上预测的正确与否，将总数记作：\r\n    - TP—将正类预测为正类数（positive）；\r\n    - FN—将正类预测为负类数（negative）；\r\n    - FP—将负类预测为正类数；\r\n    - TN—将负类预测为负类数；\r\n      - T：true；P：positive；F：false；N：Negative。\r\n      - 以0-1问题举例，TP：预测为1，真实值也为1，TN：预测为0，真实值也为0，FP：预测为1，真实为0......\r\n  - 精确率定义为：\r\n    - $P=\\\\frac{\\\\mathrm{TP}}{\\\\mathrm{TP}+\\\\mathrm{FP}}$\r\n    - 即所有预测为 1 的测试集中，预测准确的概率（也就是该样本确实为1）\r\n  - 召回率定义为：\r\n    - $R=\\\\frac{\\\\mathrm{TP}}{\\\\mathrm{TP}+\\\\mathrm{FN}}$\r\n    - 即所有真实为 1 的测试集中，预测也为 1 的概率（预测准确）\r\n  - 还有能代表召回率与精确率的调和均值，叫做$F_{1}$\r\n    - $\\\\frac{2}{F_{1}}=\\\\frac{1}{P}+\\\\frac{1}{R}$  ---->   $F_{1}=\\\\frac{2 \\\\mathrm{TP}}{2 \\\\mathrm{TP}+\\\\mathrm{FP}+\\\\mathrm{FN}}$\r\n    - 与P和R成正比\r\n  - 当精确率和召回率都高时，$F_{1}$也会高。\r\n\r\n### 标注问题\r\n\r\n- 标注问题包括学习和标注两个过程，`标注（tagging）`可以认为是分类问题的推广，又是复杂结构预测问题的简单形式。\r\n- 并且标注问题与分类问题的评价指标相同，常用的也是标注准确率、精确率和召回率\r\n\r\n\r\n![image-20221019105910410.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcf3b73b0ac45529ee4ad93ff8ca6fe~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- 举一个例子方便理解\r\n\r\n\r\n![image-20221019111041530.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f10119c353474f813bf3d5dc03c3a5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n  - 例如我们已经给每一个单词都人工辨别好了他的词性，通过模型训练，预测该句，得到的结果与我们手动的相比较，如果是相同词性，则该单词预测准确，反之则不准确，本质上也可以当成0-1问题\r\n\r\n### 回归问题\r\n\r\n- `回归(regression)`用于预测输入变量（自变量）和输出变量（因变量）之间的关系，回归模型正是表示输入变量到输出变量之间映射的函数。回归也等价于拟合问题，具体可以看模型选择部分的过拟合\r\n\r\n\r\n![image-20221019111706328.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1573f740bf440c8a08865cf6893cb1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- 回归问题按照输入变量个数，可以分为一元回归和多元回归\r\n- 按照输入变量和输出变量之间关系的类型，可以分为线性回归和非线性回归\r\n- 常用的损失函数是平方损失，在此情况下可以用最小二乘法（least squares）求解\r\n\r\n\r\n\r\n## 尾言\r\n\r\n本文为俺第一篇正经的博客，语言组织和表达能力肯定有很多不足之处，可能也会有概念在解释时出现错误，若有大佬看到本篇博客，希望慷慨滴告诉俺有何问题，谢谢大家看到最后，如果可以支持一下，麻烦点个赞吧！\r\n\r\n------\r\n\r\n## 参考资料\r\n\r\n[1] 李航．统计学习方法[M]．第二版.北京: 清华大学出版社, 2019\r\n\r\n[2] [为什么逻辑回归的损失函数叫做交叉熵呢？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/272383714/answer/1702474295)"
    },
    {
        "article_id": "7184800180984610873",
        "snapshot": "",
        "title": "大白话DDD（DDD黑话终结者）",
        "preview": "一、吐槽的话 相信听过DDD的人有很大一部分都不知道这玩意具体是干嘛的，甚至觉得它有那么一些虚无缥缈。原因之一是但凡讲DDD的，都是一堆特别高大上的概念，然后冠之以一堆让人看不懂的解释，。作者曾经在极",
        "author": "李少博",
        "view_count": 9718,
        "collect_count": 99,
        "comment_count": 25,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/db34bbe7afc7ae6136f61dbcc5291920~300x300.image",
        "category": "后端",
        "content": "### 一、吐槽的话\r\n相信听过DDD的人有很大一部分都不知道这玩意具体是干嘛的，甚至觉得它有那么一些虚无缥缈。原因之一是但凡讲DDD的，都是一堆特别高大上的概念，然后冠之以一堆让人看不懂的解释，。作者曾经在极客时间上买了本DDD实战的电子书，被那些概念一路从头灌到尾，灌得作者头昏脑涨，一本电子书那么多文章愣是没有一点点像样的案例，看到最后也 没明白那本电子书的作者究竟想写啥。原因之二是DDD经常出现在互联网黑话中，如果不能稍微了解一下DDD中的名词，我们一般的程序员甚至都不配和那些说这些黑话的人一起共事。\r\n\r\n为了帮助大家更好的理解这种虚无缥缈的概念，也为了更好的减少大家在新词频出的IT行业工作的痛苦，作者尝试用人话来解释下DDD，并且最后会举DDD在不同层面上使用的例子，来帮助大家彻底理解这个所谓的“高大上”的概念。\r\n\r\n### 二、核心概念\r\n\r\n核心的概念还是必须列的，否则你都不知道DDD的名词有多么恶心，但我会用让你能听懂的话来解释。\r\n\r\n#### 1、领域/子域/核心域/支撑域/通用域\r\n###### 领域\r\nDDD中最重要的一个概念，也是黑话中说的最多的，领域指的是特定的业务问题领域，是专门用来确定业务的边界。\r\n###### 子域\r\n有时候一个业务领域可能比较复杂，因此会被分为多个子域，子域分为了如下几种:\r\n\r\n* 核心子域：业务成功的核心竞争力。用人话来说，就是领域中最重要的子域，如果没有它其他的都不成立，比如用户服务这个领域中的用户子域\r\n* 通用子域：不是核心，但被整个业务系统所使用。在领域这个层面中，这里指的是通用能力，比如通用工具，通用的数据字典、枚举这类（感叹DDD简直恨不得无孔不入）。在整个业务系统这个更高层面上，也会有通用域的存在，指的通用的服务（用户服务、权限服务这类公共服务可以作为通用域）。\r\n* 支撑子域：不是核心，不被整个系统使用，完成业务的必要能力。\r\n\r\n#### 2、通用语言/限界上下文\r\n###### 通用语言\r\n指的是一个领域内，同一个名词必须是同一个意思，即统一交流的术语。比如我们在搞用户中心的时候，用户统一指的就是系统用户，而不能用其他名词来表达，目的是提高沟通的效率以及增加设计的可读性\r\n\r\n###### 限界上下文\r\n限界上下文指的是领域的边界，通常来说，在比较高的业务层面上，一个限界上下文之内即一个领域。这里用一张不太好看的图来解释：\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9df1cecd8ae6419e9e89b8d6ce002f08~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n#### 3、事件风暴/头脑风暴/领域事件\r\n\r\n###### 事件风暴\r\n指的是领域内的业务事件，比如用户中心中，新增用户，授权，用户修改密码等业务事件。\r\n\r\n###### 头脑风暴\r\n用最俗的人话解释，就是一堆人坐在一个小会议室中开会，去梳理业务系统都有哪些业务事件。\r\n\r\n###### 领域事件\r\n领域内，子域和子域之间交互的事件，如用户服务中用户和角色交互是为用户分配角色，或者是为角色批量绑定用户，这里的领域事件有两个，一个是“为用户分配角色”,另一个是“为角色批量绑定用户”。\r\n\r\n#### 4、实体/值对象\r\n###### 实体\r\n这里可以理解为有着唯一标识符的东西，比如用户实体。\r\n\r\n###### 值对象\r\n实体的具体化，比如用户实体中的张三和李四。\r\n\r\n实体和值对象可以简单的理解成java中类和对象，只不过这里通常需要对应数据实体。\r\n\r\n#### 5、聚合/聚合根\r\n###### 聚合\r\n实体和实体之间需要共同协作来让业务运转，比如我们的授权就是给用户分配一个角色，这里涉及到了用户和角色两个实体，这个聚合即是用户和角色的关系。\r\n\r\n###### 聚合根\r\n聚合根是聚合的管理者，即一个聚合中必定是有个聚合根的，通常它也是对外的接口。比如说，在给用户分配角色这个事件中涉及两个实体分别是用户和角色，这时候用户就是聚合根。而当这个业务变成给角色批量绑定用户的时候，聚合根就变成了角色。即使没有这样一个名词，我们也会有这样一个标准，让业务按照既定规则来运行，举个上文中的例子，给用户A绑定角色1，用户为聚合根，这样往后去查看用户拥有的角色，也是以用户的唯一标识来查，即访问聚合必须通过聚合根来访问，这个也就是聚合根的作用。\r\n\r\n### 三、用途及案例\r\n目前DDD的应用主要是在战略阶段和战术阶段，这两个名词也是非常的不讲人话，所谓的战略阶段，其实就是前期去规划业务如何拆分服务，服务之间如何交互。战术阶段，就是工程上的应用，用工程化做的比较好的java语言举例子，就是把传统的三层架构变成了四层架构甚至是N层架构而已。\r\n###### 1、微服务的服务领域划分\r\n这是对于DDD在战略阶段做的事情：假如目前我司有个客服系统，内部的客服人员使用这个系统对外上亿的用户提供了形形色色的服务，同时内部人员觉得我们的客服系统也非常好用，老板觉得我们的系统做的非常好，可以拿出去对外售卖以提高公司的利润，那么这时候问题就来了，客服系统需要怎样去改造，才能够支持对外售卖呢？经过激烈的讨论，大致需求如下：\r\n\r\n* 对外售卖的形式有两种，分别是SaaS模式和私有化部署的模式。\r\n* SaaS模式需要新开发较为复杂的基础设施来支持，比如租户管理，用户管理，基于用户购买的权限系统，能够根据购买情况来给予不同租户不同的权限。而私有化的时候，由于客户是打包购买，这时候权限系统就不需要再根据用户购买来判断。\r\n* 数据同步能力，很多公司原本已经有一套员工管理系统，通常是HR系统或者是ERP，这时候客服系统也有一套员工管理，需要把公司人员一个一个录入进去，非常麻烦，因此需要和公司原有的数据来进行同步。\r\n* 老板的野心还比较大，希望造出来的这套基础设施可以为公司其他业务系统赋能，能支持其他业务系统对外售卖\r\n\r\n在经过比较细致的梳理（DDD管这个叫事件风暴/头脑风暴）之后，我们整理出了主要的业务事件，大致如下：\r\n\r\n1、用户可以自行注册租户，也可以由运营在后台为用户开通租户，每个租户内默认有一个超级管理员，租户开通之后默认有系统一个月的试用期，试用期超级管理员即可在管理端进行用户管理，添加子用户，分配一些基本权限，同时子用户可以使用系统的一些基本功能。\r\n\r\n2、高级的功能，比如客服中的机器人功能是属于要花钱买的，试用期不具备此权限，用户必须出钱购买。每次购买之后会生成购买订单，订单对应的商品即为高级功能包。\r\n\r\n3、权限系统需要能够根据租户购买的功能以及用户拥有的角色来鉴权，如果是私有化，由于客户此时购买的是完整系统，所以此时权限系统仅仅根据用户角色来鉴权即可。\r\n\r\n4、基础设施还需要对其他业务系统赋能。\r\n\r\n根据上面的业务流程，我们梳理出了下图中的实体\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de4730507553496a9a310c674ae8e90a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n最后再根据实体和实体之间的交互，划分出了用户中心服务以及计费服务，这两个服务是两个通用能力服务，然后又划分出了基于通用服务的业务层，分别是租户管理端和运营后台以及提供给业务接入的应用中心，架构图如下：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95cb4d0f66f8499c901b3e9d467dc652~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n基础设施层即为我们要做的东西，为业务应用层提供通用的用户权限能力、以及售卖的能力，同时构建开发者中心、租户控制台以及运营后台三个基础设施应用。\r\n\r\n###### 2、工程层面\r\n这个是对于DDD在战术设计阶段的运用，以java项目来举例子，现在的搞微服务的，都是把工程分为了主要的三层，即控制层->逻辑层->数据层，但是到了DDD这里，则是多了一层，变成了控制层->逻辑层->领域能力层->数据层。这里一层一层来解释下：\r\n\r\n| 分层   | 描述 |  \r\n| :------------- | :----------: |\r\n| 控制层       |    对外暴漏的接口层，举个例子，java工程的controller     |\r\n| 逻辑层       |    主要的业务逻辑层     |\r\n| 领域能力层    |    模型层，系统的核心，负责表达业务概念，业务状态信息以及业务规则。即包含了该领域（问题域）所有复杂的业务知识抽象和规则定义。  |\r\n| 数据层       |    操作数据，java中主要是dao层     |\r\n\r\n\r\n### 四、总结\r\n\r\n在解释完了各种概念以及举例子之后，我们对DDD是什么有了个大概的认知，相信也是有非常多的争议。作者搞微服务已经搞了多年，也曾经在梳理业务的时候被DDD的各种黑话毒打过，也使用过DDD搞过工程。经历了这么多这方面的实践之后觉得DDD最大的价值其实还是在梳理业务的时候划分清楚业务领域的边界，其核心思想其实还是高内聚低耦合而已。至于工程方面，现在微服务的粒度已经足够细，完全没必要再多这么一层。这多出来的这一层，多少有种没事找事的感觉。更可笑的是，这个概念本身在对外普及自己的东西的时候，玩足了文字游戏，让大家学的一头雾水。真正好的东西，是能够解决问题，并且能够很容易的让人学明白，而不是一昧的造新词去迷惑人，也希望以后互联网行业多一些实干，少说一些黑话。\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7179953478813351992",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa56c1f52552471a84ff88b94876f85e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "维护8年的前端开源项目长啥样？",
        "preview": "为什么现在主流方案是这个样？——来一起看看8年前的开源项目与思维方式，对比对比现在的主流解决方案来更好的理解",
        "author": "花生Peadar",
        "view_count": 25712,
        "collect_count": 73,
        "comment_count": 26,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/7ebd930e3f1f0a5592a3cb24bc55305b~300x300.image",
        "category": "前端",
        "content": "今天用了下自己的开源小工具 [Pxer](https://github.com/FoXZilla/Pxer) 来下载了些图片，临近年终，简单算算，这个开源项目从 2014年6月 至今已经有了 **8年半** 的历史了，也收获了超过 **900 颗 Star**\r\n\r\n8年半前，那是 jQuery 和 BootStarp 大行其道的时代，前端主流的编程思想也与现在大相庭径\r\n\r\n在这8年半间，我持续更新我的开源项目 [Pxer](https://github.com/FoXZilla/Pxer)，也不断的引入一些新的前端时髦的东西，但是历史包袱大家懂得都懂，不是那么好彻底抛弃的。不过另一方面，我们也可以通过这些“历史包袱”来简单窥探一下前端发展的冰山一角\r\n\r\n所以今天来大家简单读读代码，看看8年前的思维方式，对比对比现在的主流解决方案来更好的理解——**为什么现在的主流方案是这个样？**\r\n\r\n- 项目官网 http://pxer.pea3nut.org/\r\n- Github Repo https://github.com/FoXZilla/Pxer \r\n\r\n# 简单的背景介绍\r\n\r\nPxer 是一个工具，会在 `Pixiv.net` 这个网站额外生成一个 UI 面板来提供一些额外功能。类似于，在B站添加一个按钮让你能够直接下载视频和封面（B站不提供的功能）\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9263d217c92d4478866ab0ea4bb1ccda~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 运行方式\r\n\r\n## 浏览器书签\r\n\r\nPxer 的第一版的发布代码长这样，是在百度贴吧发布的\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c0a9a74dc304c1b8b8105e8028ad369~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n怎么样？是不是看不懂要要怎么用？\r\n\r\n这里就要提到一个浏览器非常有趣的特性了：\r\n\r\n当你存书签时，不仅仅可以存 `http:` 打头的书签，你还可以存 `javascript:` 打头的书签，然后点击书签，你就能运行这段代码了。\r\n\r\n不信你试试存下面的代码为书签，然后点击书签\r\n\r\n```js\r\njavascript: alert('Hello Peanut Pie')\r\n```\r\n\r\n## 油猴 Greasemonkey\r\n\r\n存书签的方式你可能觉得太麻烦了，确实，也有人是这么想的，因此有了“油猴”浏览器扩展（Greasemonkey / Tampermonkey）\r\n\r\n油猴是一个浏览器插件，你可以安装JS脚本进油猴，然后油猴会根据域名，来自动的帮你运行你的 JavaScript 代码\r\n\r\n因此，现在 Pxer 的安装代码大概是长这样的：\r\n\r\n```js\r\n// ==UserScript==\r\n// @name           Pxer\r\n// @include        https://www.pixiv.net*\r\n// ==/UserScript==\r\njavascript: void(function() {\r\n\r\nwindow['PXER_URL'] = 'https://pxer-app.pea3nut.org/';\r\n\r\n// add enter point script in page\r\ndocument.documentElement.appendChild(\r\n    document.createElement('script')\r\n).src = PXER_URL + 'launcher.js?' + (+new Date);\r\n\r\n}());\r\n```\r\n\r\n（完整代码见 https://pxer-app.pea3nut.org/pxer.user.js）\r\n\r\n读一读代码，你就会大概猜到油猴是如何工作的——当用户打开`https://www.pixiv.net*`的网站时，自动运行上面的代码，然后 Pxer 的操作界面就出现了！\r\n\r\n目前油猴也是当前 Pxer 的推荐安装方式，你可以在 Pxer 的官网来找到详细的步骤说明\r\n\r\n- Pxer 安装指南 http://pxer.pea3nut.org/install/install-pxer\r\n\r\n## 浏览器扩展 Extension\r\n\r\n现在有一个更好的实现方式——浏览器扩展。这样能获得更好的性能和权限，但是8年前的浏览器扩展有个致命的问题：\r\n\r\n——各家浏览器的扩展接口大相庭径（而且 Chrome 的扩展商店上架还要钱！）\r\n\r\n这个问题在今天得到了缓解：Mozilla 推出了一个浏览器扩展规范——[WebExtensions](https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions)\r\n\r\n目前 Edge、Firefox 的扩展是完全遵从这个规范的。同时，这个规范也与 Chrome 的扩展接口非常类似，因此你可以基于 WebExtensions 接口来开发扩展，然后非常简单去兼容全部浏览器——但是这在8年前是不可能的！\r\n\r\nPxer 并没有赶上这个好时候，而时至今日的我也没有勇气去开坑，把 Pxer 从油猴的方式迁移到 WebExtensions 的方式\r\n\r\n# 项目打包\r\n\r\n## 依赖次序\r\n\r\n当你的项目大起来，你迫切的需要一个工具来帮助你组织依赖——你也不想有一个几万行JS文件吧？\r\n\r\n核心诉求就是：文件加载的先后次序问题。那么 Pxer 是如何解决的呢？要知道，8年前可没这么好用的 Webpack 给你用。那时 Webpack 刚刚发布 1.0.0 版本不久，用户和中文资料有多少大家懂得都懂\r\n\r\n下面是 2017 年的 Pxer 主 App 目录\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9763da691a544829a43efdb05171f842~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n（https://github.com/FoXZilla/Pxer/tree/5aacbd6becefbf8f9a350cac0f31f149e47fab0b/src/app/class）\r\n\r\n什么？你问文件中间的数字是干嘛的？当然是确定文件加载顺序了~\r\n\r\n简单来说，我写了个脚本，会先自动找数字最小的文件，比如`PxerEvent.-1.class.js`就会被先加载，然后不带数字的默认是0，然后加载`PxerFilter.class.js`，然后是`PxerThread.1.class.js`，以此类推\r\n\r\n## 生产编译\r\n\r\n而编译部分就更加简单粗暴了，直接按次序`Fs.readFileSync`（把文件读到内存）后`Fs.writeFileSync`（把内存内容直接写入成文件）\r\n\r\n```js\r\nvar fileList =[];\r\nfor(let array of PxerUtility.getAllFile(Join(__dirname,'../src/app/class/'))){\r\n    fileList.push(...array);\r\n};\r\nFs.writeFileSync(\r\n    Join(__dirname,'../dist/pxer-core.js'),\r\n    Buffer.concat(fileList.map(path=>Fs.readFileSync(path)))\r\n);\r\n```\r\n\r\n（https://github.com/FoXZilla/Pxer/blob/5aacbd6becefbf8f9a350cac0f31f149e47fab0b/build/build-dist.js#L40）\r\n\r\n然后就可以把这个“生成出来的大文件”丢到生产环境给用户使用了~\r\n\r\n## 开发编译\r\n\r\n但是此时依旧有个问题，我总不能改一行代码然后先打包才能看效果吧？这也太麻烦了？Webpack 还有 dev-server 呢~\r\n\r\nPxer 也有！\r\n\r\n下面是 Pxer 在**开发阶段**的编译后的代码\r\n\r\n```js\r\n// 要加载的文件\r\nconst appClass =[\r\n    [\r\n        \\\"src/app/class/PxerData.-1.js\\\",\r\n        \\\"src/app/class/PxerEvent.-1.class.js\\\"\r\n    ],\r\n    [\r\n        \\\"src/app/class/PxerFilter.class.js\\\",\r\n        \\\"src/app/class/PxerHtmlParser.class.js\\\",\r\n        \\\"src/app/class/PxerPrinter.class.js\\\"\r\n    ],\r\n    [\r\n        \\\"src/app/class/PxerThread.1.class.js\\\"\r\n    ],\r\n    [\r\n        \\\"src/app/class/PxerThreadManager.2.class.js\\\"\r\n    ],\r\n    [\r\n        \\\"src/app/class/PxerApp.3.class.js\\\"\r\n    ]\r\n];\r\n\r\n\r\n// 过程化载入文件\r\nvar Flow = Promise.resolve();\r\n\r\n\r\n// 加载pxer-app\r\n\r\n// 加载无关紧要的资源\r\nFlow = Flow.then(() => execPromise(linkResource, createResource));\r\n// 加载pxer-app class\r\nFlow = Flow.then(() => execPromise(appClass, createScript));\r\n// 加载UI JavaScript\r\nFlow = Flow.then(() => execPromise(viewScripts, createScript));\r\n\r\n```\r\n\r\n\r\n- 生成编译文件的脚本 https://github.com/FoXZilla/Pxer/blob/5aacbd6becefbf8f9a350cac0f31f149e47fab0b/build/support.build.js\r\n- 生成的文件 https://github.com/FoXZilla/Pxer/blob/5aacbd6becefbf8f9a350cac0f31f149e47fab0b/src/app/support.js\r\n\r\n上面的文件是自动生成的，脚本会：\r\n\r\n1. 读取目录里的文件\r\n2. 根据文件中的数字（PxerThreadManager **\\\\.2\\\\.** class.js）排序，分组\r\n3. 拉起一个 Http Server，然后将源文件（未打包之前）加载进浏览器\r\n\r\n这样一来，当我改动磁盘上的文件，不需要重新编译打包，直接刷新浏览器页面就能看到自己的改动了~\r\n\r\n## 对比 Webpack\r\n\r\nPxer 项目在 `build/` 目录有9个文件来承担各种打包编译的工作，这些逻辑全都是我原创的，但是你会发现历史真是惊人的相似——我几乎是实现了一个简易版的 Webpack\r\n\r\n\r\n| 打包步骤 | Webpack 的实现 | 我的实现 |\r\n| --- | --- | --- |\r\n| 确定依赖次序 | require/import 语句 | 文件名中的数字比大小 |\r\n| 生产编译 | 用 loaders 读文件，然后根据配置生成文件 | 按序读取所有文件，合并成一个大文件 |\r\n| 开发编译 | webpack-dev-server | 拉起一个 Http Server，然后编译一个能动态加载代码的文件 |\r\n\r\n当然，Webpack 还有一个非常好用的功能——热加载 Hot Load，可以不刷新浏览器的加载新文件，这个功能 Pxer 的编译系统是没有的\r\n\r\n~~要是我早出生5年...~~\r\n\r\n# 后记\r\n\r\n现在读读8年前自己写的东西——诡异的 Code Style、用读文件的方式来编译打包、用`functionName.prototype['xxx'] = function () {}` 来构建类。一股浓浓的“屎山”味儿扑鼻而来\r\n\r\n但是要知道，这些东西在8年前，可是时髦到不行~！\r\n\r\n## 关于作者与转载\r\n\r\n这里是【花生派】，一只喜欢写东西的程序员。我常常在黑夜中注视着自己的瞳孔，与自己独处，写下一段又一段的文字\r\n\r\n如果你对我感兴趣，可以在这里找到我：\r\n\r\n- 个人资料网站：[`pea3nut.info`](http://pea3nut.info)\r\n- 个人博客：[`pea3nut.blog`](http://pea3nut.blog)\r\n- [知乎：花生PeA](https://www.zhihu.com/people/liu-bo-yuan-75-28)\r\n- [掘金：花生PeA](https://juejin.im/user/58fed8a7a22b9d0065b13e30)\r\n\r\n本文可随意转载，转载时需满足以下要求：\r\n\r\n1. 请保持原文转载，不得做任何改动\r\n1. 转载时请告诉我下。比如说在我的文章下留言，或给我发邮件`626954412#qq.com`均可，能让我知道就ok。**不用**等我回复，打完招呼后直接转就行\r\n1. 不要转载到知乎、掘金，我会自己投\r\n\r\n\r\n"
    },
    {
        "article_id": "7189145163199938597",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/231bde0c828b4933bf48a542c0ab101c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我的 2022：「无」",
        "preview": "【新冠后遗】2022 最后一个月，随着出人意料的政策急转弯，我也不出意外的阳了，经历了大家都经历的各种症状，虽然难受但也能扛住阳康了，这段时间除了不能运动外，感觉还有一个“后遗症”...",
        "author": "等开会",
        "view_count": 841,
        "collect_count": 0,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/882764c566ee6a2eff359bf88518c3fd~300x300.image",
        "category": "代码人生",
        "content": "## 新冠后遗症\r\n2022 最后一个月，随着出人意料的政策急转弯，我也不出意外的阳了，经历了大家都经历的各种症状，虽然难受但也能扛住阳康了，这段时间除了不能运动外，感觉还有一个“后遗症”，就是好像丧失了一些动力和热情，可能是是新冠初愈精力不够，也可能是太久没运动了缺少内啡肽，或是被疫情和各种乱象折腾了这么久乏了，总之就是干啥都有点提不起劲，仿佛进入了“贤者时间”...\r\n\r\n这也是为什么这篇 2022 年终总结拖到 2023 年才写的原因，不过出于这一年的魔幻程度，外加想给自己留下点活过的痕迹，还是“垂死病中惊坐起”来写写吧。\r\n\r\n前段时间看到网友票选 2022 年度汉字，想了想，于我个人而言，这个字大概是「无」。\r\n\r\n## 无常\r\n首先不得不感慨一下 2022 是无常的一年。\r\n\r\n犹记得年初时，互联网打工人们还掀起过一阵反卷风潮，可谁知没过几个月互联网寒冬就来了，各厂纷纷开始降本增效，互联网迎来了“毕业”季，大家讨论的话题也从 wlb 转变为要保住这份工，“寒气”确确实实传给了每一个打工人。不过转念一想公司的内核是“赚钱机器”，在自身运行受到威胁时做出一些调整无可厚非，反而越是能提前预感到威胁，主动做出调整应对的公司越是好的“赚钱机器”，这种能力其实对于我们个人也是非常重要的，比如在要封控前屯点菜，要放开前屯点药🐶\r\n\r\n国内疫情防控政策也是在持续几年的高压后，在年底几乎一夜之间转向，让所有人都猝不及防，让我又一次感叹于到我们的“制度优势”所带来的强执行力，同时也带来了过去一个月的“应阳尽阳”和各种医疗资源的紧缺。不过不管怎么样算总账，（当前）放开肯定比死守封控好，学习和新冠共存也是我们接下来必须上的一课，我们在听了国内各种专家建议后也尽量做好自我教育，多从各种渠道了解一些相关知识，防止病急乱投医。这里也推荐下我前段时间刚看/听到的两个比较好的内容：\r\n- 播客：《凛冬将至，普通人该怎么过疫情这一关？》，小宇宙可听。\r\n- 书籍：《战斗细胞：人体免疫系统奇妙之旅》，微信读书可看。\r\n \r\n今年还有各种黑天鹅事件，东航失事、俄乌战争、佩洛西访台，乌鲁木齐火灾...许多事我已记不太清，但是有人记得，感兴趣的可以看看真·媒体战士睡前编辑部的《2022新闻合订本》，B站（目前）可看。\r\n\r\n这一年很多人不幸被“时代的灰”击中甚至压垮，反观自己这一年无灾无祸其实过得也不算差，突然想起《战斗细胞》中的一句话：健康，不是有，而是无。也许幸福也是如此，不是有，而是无，无忧无虑，无病无灾。\r\n\r\n总之，人生无常，大肠包小肠，我也慢慢学会接受：无常可能才是这个世界的日常。\r\n\r\n## 无知\r\n近两年开始越来越觉得自己无知，所以开始看书求知，今年也断断续续看了几本，上半年看的比较随意，属于没有特定主题的瞎看，当然看完大多也都忘了（看来还是得写读书笔记呀..）\r\n\r\n不得不承认人类的悲欢并不相通，上半年本人所在的广州市并没有什么疫情，虽说面对国内各种封城乱象还是会气愤，但是也只止于气愤，并没有引发太多思考，最多也就看了本郑渊洁的短篇童话《飞马牌汽车》，感叹郑是个预言家，05年写的故事简直就是对今年魔幻故事的预言。\r\n\r\n然而下半年，尤其广州疫情爆发开始“静默管理”之后，虽说没有上海、新疆同胞们经历的那么严重和持久，但是在亲身体验了我们的“制度优势”之后，我开始不由自主的去思考一些我以前不太关注的大话题，从防疫政策到郭嘉体制，再到各种主义和意识形态，企图找到“为什么会是这样？”的答案。\r\n\r\n我高强度地看了几本书，《邓小平时代》、《毛泽东传》（太长了没看完...）、《动物农场》、《可能性的艺术》，看完还是有一些粗浅的收获的（看来带着问题看书才是正确的姿势）：\r\n\r\n- 《邓小平时代》和《毛泽东传》让我知道了过去100多年发生的一些事和背后的决策动因，也大概理解了如今的一些看似魔幻的事情。\r\n- 《动物农场》看完我发现乔治·奥威尔是比郑渊洁还厉害的预言家。\r\n- 《可能性的艺术》则让我更理性的看待威权和民主两种政体，哪一种都不是万能的。\r\n\r\n我也大概明白了为什么“乱世出英雄”，历史的进程和机遇是一方面，另一方面是因为当时的时代环境会迫使那个时代的有识之士去思考那些宏大的命题，去努力做一些改变，因为如果他们不思考不改变，可能就会家破人亡，甚至国破家亡，想到这里我突然觉得“为中华之崛起而读书”可能并不是一个宣传口号。也正如我在魔幻无常的 2022 也开始“被迫”地去思考这些话题，虽然我并不是什么有识之士，更谈不上英雄，不过 2022 确实够乱的...\r\n\r\n总之，了解思考这些话题可能并不能改变外部环境，但是至少能让自己把这世界看得更清楚一点，无知更少一点。\r\n\r\n## 无忌\r\n年中的时候听了期孟岩（有知有行创始人）的播客《张无忌的无限游戏》，突然对无忌这个名字的有了新的理解，无忌即百无禁忌，随心所欲，不给自己设限，玩自己的无限游戏。\r\n\r\n这确实是值得我们追求的状态，想来这一年我也做了一些不给自己设限的事：\r\n\r\n- **个人公众号**：年中时跟着“二舅”治好了自己的精神内耗，搞了个公众号开始瞎写，具体是怎么治好的都写在了:[《都 2202 年了，为什么我还要写公众号？》](https://mp.weixin.qq.com/s/U9siUgaqDKMcLUZ3b_bwTg)，虽然写的不多，但是也算是个记录自己所思所想的好地方，不出意外我应该会持续运营下去，除非平台哪天把我封了🐶\r\n- **健身**：健身其实断断续续已经练了挺多年了，今年新的体验来自于年初时获得的 Apple Watch（感谢组织🙏），给我健身路上带来了新的乐趣，近两年体重和体脂率都有比较明显的下降（两年加起来减了大概三四十斤），之前体检的脂肪肝也消失，精神面貌也好了许多，算是一个比较满意的结果吧，最近因为新冠中招躺平大半个月了，跨到新的一年得把复健提上日程了。\r\n- **飞盘**：得益于公司的各种兴趣协会，今年解锁了新的运动项目飞盘，参加了有六七次活动，除了学习常规的正/反手，传/接盘，还有一些简单的技战术之外，还熟练掌握了各种犯规和崴脚动作🐶，感受了一下所谓的“飞盘精神”，挺有趣的。\r\n- **声乐课**：可能没有人会不喜欢音乐，上半年报名参加了公司音乐协会组织的声乐课，每周在繁忙的工作之余听听/唱唱歌对我来说非常享受，甚至有段时间是我每周最期待的时间，但是从第二节课开始我就发现一个现象，上课的人数成指数级下降，到最后甚至只剩我一个人，一个大团课硬是被我上成了 1v1 私教🐶，当然这种情况肯定慢慢课就上不下去了，所以“私教课”没上几节就取消了，挺可惜的。\r\n- **云南之旅**：今年因为疫情外加我本身也不是一个喜欢到处跑的人，所以基本没怎么出去玩过，也就十一假期去了趟云南，留下了挺多美好的回忆。说起来这次旅行还是我主动策划的，因为那段时间正好想通了旅行的意义是什么，我都写在这里了:[《旅行的意义》](https://mp.weixin.qq.com/s/N9UrV7gTbobRfjPsH69N4A)，有了这篇“自我说服”后，感觉之后每年出一两趟远门，也挺好的。\r\n\r\n还有一些由于主观或客观原因想做却没做的事，街舞 Hiphop 浅尝辄止(其实我更喜欢 popping)，吉他课报了名，陆冲也加了群，虽说要玩无限游戏，但毕竟人的精力是有限的，慢慢来吧...\r\n\r\n总之，感兴趣的事都可以去试试，不要给自己设限，feel alive 的秘密就来自于人生新体验。\r\n\r\n## 三十而立\r\n这个月即将迎来我的三十岁，在再一次感叹时光飞逝，应该珍惜每刻活在当下时，想到三十而立这个词，三十岁了就应该独立、自立、成家立业，仿佛一道分水岭把人生分成了两部分。但是于我个人而言，人生不会因为到了某个年纪而发生突变，三十岁不是一道分水岭，而是一个里程碑，在人生三分之一处“立”下这块里程碑，回头望望，感慨两句，然后继续前行。\r\n\r\n最后顺便许个愿吧：\r\n希望在 2023 年，我能继续保持无知，保持无忌，保持好奇，保持热爱。\r\n也希望在即将到来的 30+，我能获得更多的人生新体验和自由。\r\n\r\n新年快乐，朋友，又是崭新的一年 :)"
    },
    {
        "article_id": "7188878917816549436",
        "snapshot": "",
        "title": "2022年个人总结",
        "preview": "2023年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，又到了一年总结的时候了。 概述 今年过得特别快，很多时候都是忙，各种忙，记得去年12月份中旬开始加班，今年下半年加班成常态",
        "author": "李迟",
        "view_count": 775,
        "collect_count": 0,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6986fd335f7b47c1a2742061aefff4d2~300x300.image",
        "category": "代码人生",
        "content": "2023年的脚步已经来临了。时光荏苒，白驹过隙，日月如梭，岁月不居，时节如流，又到了一年总结的时候了。<!-- more -->\r\n\r\n## 概述\r\n\r\n今年过得特别快，很多时候都是忙，各种忙，记得去年12月份中旬开始加班，今年下半年加班成常态，11月份强度加大，一下子又过一年了。\r\n\r\n### 流水账\r\n\r\n1月份，拿到盖章的工程师证明A4纸，拿到架构师证书，扫描并保存之。还债。 2月份，在南宁过年，1人承担年夜饭任务。买蓝牙板子。月底紧急加班完成一任务。 3月份，研究蓝牙。 4月份，研究蓝牙。大锤发烧，数天方好，花费500余。 5月份，无。 6月份，无。 7月份，带着大锤献血400cc。 8月份，无。 9月份，紧急加班完成一任务。 10月份，新公司挂牌。 11月份，加班。换物业，小区较乱。 12月份，加班。\r\n\r\n## 工作学习\r\n\r\n总体看，今年的工作是比较忙的，上半年没有紧急任务时，重构了一个工程代码，在此期间还搭了一个框架。下半年以来，任务渐渐多了，10月份开始，加班成常态，主要有新的项目在年底赶工完成，二是时不时有其它紧急的事务。\r\n\r\n那个工程在接手之初就看出机制有问题，今年犹甚。其实很久之前就想重构了，无奈工程代码太复杂太绕，分析不出头绪。在领导下任务后，硬是通过`printf`整理流程，于是着手重构。重构后初测正常，但需大量数据验证，因为原工程已上线很久了，目前没有出太问题，因此，新版本也必须保证如此。\r\n\r\n不久，需完成另一个和 web 有关的工程任务，因为时间紧，原来的网页页面仅使用`html`来排列组件，十分不美观，于是趁机使用`bootstrap`重新做了一版，期间也研究了vue，但不擅长，耗时又无提升（内部使用），最终放弃之。\r\n\r\n趁有时间，考虑将网页工具和其它工具合并，在代码工程上还是各自管理多个，但最终形态可以以网页展示，不便展示的页面，不放在导航条上，不显示即不存在。在此期间思考设计写了一个 Golang和C++结合的工具模板，先在网页工具试水，效果不错，后面在多个实际工程中应用了。对于网页工具，前端页面和 Golang 后台，使用最简单的 post 请求，由 Gin 框架接收，手动解析，预处理后，再通过 cgo 调用加载的 so 动态库，路径上虽然复杂，但方便综合各工程模块。那个 so 动态库，从代码角度看，和单独的应用程序完全相同，只是编译命令不同而已（ so 里就包含了 main 函数，只是不会调用而已）。实际上，那个单独的应用程序也有2种形式：单独单次运行形式和终端交互的形式。 ——以上这些，都使用了笔者多年前已有的思路或想法或代码片段。前端网页的 boostrap，很早就接触了；终端交互，是当年做 x86 平台引导程序时弃用的代码；而相同代码不同编译形式，是早就掌握了的。\r\n\r\n后面使用的人多了，提出了不少意见，在一段较长的时间断断续续进行了便捷性的优化，比如在网页输入框根据名称实现模糊查询，一些数据的展示。另外，也进行业务的适配（不同时间，数据不同，所以要处理）。后面在网页工具整合了使用 vuepress 做的内部知识平台。如此一来，就更完善。\r\n\r\n接着又回到了重构的工程，因为要大量数据验证，所以在测试上比较麻烦，测试方案、测试代码完全靠自己。由于不能直接在生产环境测试，只能从日志抽离出所需数据，但日志较大，一天就可能有1GB。为了方便，决定在网页工具中添加测试页面，能解决日志文件，保存为 json 文件；从目录读取 json文件，请求对应的服务器。在此期间，发现很多时候的测试不需要使用到虚拟机 Linux 环境，像请求服务，完成可以在 windows 本地进行。于是修改代码兼容windows和linux系统，因为windows下做测试很方便。网页工具的开发优化，从年头到年尾，基本上都在做，占了较多的时间，从无到有，慢慢作为自己依赖的工具，因此值得花一定的笔墨。\r\n\r\n某次升级服务器应用程序时，发现服务器磁盘满了。这个问题去年反馈过运维，按我的理解应是他们的事，不过许久以来没有变化，于是自己写了一个日志迁移脚本，放到定时任务中，观察半年，还没出过问题。后来发现，一旦做了某些事，这些事就一起在自己身上了。之前是因为自测，所以安装了数据库，后来变成维护服务器了，还帮其它同事部署他们的服务。\r\n\r\n下半年开始一个新项目，涉及云原生、docker、边缘计算等。我负责了其中部分的微服务，因为使用了 docker，于是就用 Golang 开发（实际上不想放弃已有框架，加上C++开发较复杂）。另外还负责了构建docker 镜像，运行部署等。最终的版本，光微服务就有十多个，还有 nginx、redis、mysql，等，我构建了大部分的镜像，最困难的是，程序不是我开发的，但我得保证程序能在容器中正常跑，有些还涉及到内网环境。后来演变成一边开发自己负责的程序，一边帮其它同事部署、查问题。年底准备上线前，发现还少了个服务，领导安排，于是加班2天完成一个版本，紧急部署。后面试运行中不断有问题，因此加班成为常态。参与项目，一方面加深对云原生概念的理解，一方面加强对抗线上问题能力（先前一听到线上问题非常紧张），一方面提高对业务的熟悉度。 有同事已在项目中使用了 k8s ，但掌握的人实在太少了，而且当前的项目是从零开始的，所以不适宜，否则出问题不知从何排查。因此整套微服务使用 docker-compose 部署，先是使用其本身提供的扩容能力，配置是少了，但生成的容器名称可读性不强，影响日志文件的连续性，被排除掉，于是在配置文件中一一指定容器。起初，为了避免容器的IP变化，将微服务部署到同一网络中，通过容器主机名通信，后来发现这一点反而导致 nginx 转发失败（因为升级镜像，IP很大概率变化了），于是改为固定IP。再后来，我负责的微服务耗时较严重，这个web服务接收请求，处理，再返回结果，处理包括调用C++动态库，查 sqlite3 数据库，等。在本地虚拟机测试在60ms~90ms之间，偶尔超过100ms，但在试运行服务器上，经常上100ms，上峰很是关注。于是出动 pprof 分析，几次下来，发现日志模块是常客，经同事提醒，把写日志的同步方式改为异步方式，加上缓存，结果出人意料，在30ms~60ms之间，有时甚至在10ms左右完成请求。后来想着把所有数据都在本地缓存起来，但内存占用近2GB，想到同时有多个副本，虽然服务器内存足够，但还是不敢造次，待后续时机成熟就升级亦可。\r\n\r\n（补记：今年首次有外包的考核结果公示，拿了A+，可能是年底加班多，领导有看到。去年白头发只是数根，现在已经多了好多，大锤都不敢拔了。入职2年半多，拿了2个A+，不知是时运好，还是上天眷顾，还是能力够。但愿发钱时，能对得起白头发，也能应对银行那边6%的房贷利率，虽然高高站岗的人不配有幸福生活，但盼头还是要有的。\r\n\r\n## 个人生活\r\n\r\n年初买了2块蓝牙板子，做了些研究，主要关注点是蓝牙协议和数据传输。后来买了配套的重力感应小板，做了个重力流水灯，给大锤和大妞玩。另外利用板子上的4个LED灯和按键，做了二进制的显示功能，让大锤记录按键的次数和LED的亮灭情况，起初饶有兴趣玩，虽然他不懂是什么。\r\n\r\n文章写作方面，CSDN 有记录的有 30 余篇，如果加上未发表的蓝牙方面文章，和去年持平，排名在300~500名之间。截至目前的很多年，在这方面的坚守，都还是能做到的。 年中参与掘金社区更文活动，主要发表的是之前积累的文章和一些日常技术文章，拿了全勤奖。其中的拖鞋穿到年底坏了；电饭锅寄回老家，但老妈反馈不好用；而积木，则在大锤生日当天送给他。\r\n\r\n去年开始使用 typora ，今年收费了，决定购买。因为对比其它同类工具，还是 typora 顺手好用，不到100块钱，值得付出。\r\n\r\n近年中某晚，和老妈打电话，说刚交话费又欠费了，我登陆APP查看，发现去年6月份被开通了很多种包，甚至包括高考咨询之类的，后来得知，是有人打电话推销，而我妈听不懂普通话，被认为同意开通。当晚打10086，开始我还客气一番，一是了解情况，二是换回原来的套餐，客服反反复复来来回回重复着相同的话术，就是不说解决方案，我就火了，一直追着要具体的方案和具体的时间，但最后也只能说向上级反馈，一天内回复。最终有客服打电话给我妈，还是用流利的普通话，后又换了个客服，操着不流利的白话，总算有个阶段性结果：退还3个月的超额的话费。过了一个多月话费还没有到账，于是再次打电话咨询，过几天，老妈说话费到账了，持续近2个月，总算有个着落。\r\n\r\n年中体检，结果比去年略好，去年有3项警告，今年有2项。就是体重一直减不下去，特别是年底，在家加班，免不了泡面相伴，有一次称量竟然高达140斤，想当年大锤住院那会，我的体重硬是减到了100斤出头。体重管理要作为明年的重点计划执行才行。\r\n\r\n上半年，集中听了B站杨宁老师的多个视频，《美学》重新看了一遍，文学理论方面也看了一遍，杨老师课里讲到的书，后面也买了一些。因为不忙，按时间整理了一些东坡诗词文赋，还看了本王安石传。\r\n\r\n双十一前，罗师傅说某东上书籍半价，于是心血来潮，于是选书，下单，前后花了几百块，主要有《资治通鉴》，前四史，一些诗词，一些历史的书，等。后来开始在周末时到某旧书摊淘书，买了词典和一些自己认识的书，还有一些给小孩的绘本。旧书摊价格便宜，要花时间，幸好离常去的菜市场不远，总体看时间还是划算的。至于发稿，买的新书旧书，有《资治通鉴》、前四史、唐诗宋词元曲、狼图腾、 昆虫记、文化苦旅、文心雕龙（2个版本）、字典、词典（大锤过生日买的4本奥特曼不列出）。\r\n\r\n鉴于我的家庭地位，一般只有深夜才有自己的时间，幸好B站上有大量相关视频，利用通勤时间听，而后抽点时间看文字，就当学习了。对于前四史，先从《史记》下手，其它三史暂时放着。对于字典类，在陪大锤写字时，拿来看一下。\r\n\r\n## 家庭生活\r\n\r\n年初发现燃气公众号无法正常查账单，直到年底才把一年的消费作为月度账单显示，打过几次电话，客服说不支持，建议按一下厨房管道仪表上的红色按钮，便可显示余额。于是月底自己手动抄水表、燃气表，记录物业费等条目，再汇总到 excel 表分析。因为这样，才能搞清楚家里那些必要开支的明细。\r\n\r\n年中开始着手计费提前还款的事，找大妞她妈要了些钱，问父母要了些钱，9月初最终还到银行，一个月能少交点钱给银行，那些钱用在改善伙食上，一个月的收支基本上抹平了。\r\n\r\n某天大妞她妈问我每个月的房贷是多少，我发了截图，就没然后了，记得当时刚搬来时，我说了一下燃气的费用，得到的回复是：不是我管钱，不用跟我说。因此，在家里，我从不说买菜花了多少钱，物业费多少钱，当然，我也从不在家里说“困了”、“累了”这种词。家里东西的小修小补，都是我亲自动手，从不让别人操心，更舍不得花钱请人来。\r\n\r\n年底小区换了物业，结合小区公告、法院文书、网上新闻，才知道一些事由。小区建成之初，物业入住手续就不合法（不知是不是因为物业和开发商在名称上有重叠文字的原因），至今有十多年了，几年前开始打官司，物业成了被告，而上半年，业委会成了被执行人。开头几天看到挂横幅，大意是承诺不涨价，要更好服务小区。至于未来，谁也不好说。\r\n\r\n家务活方面，只要我在家，买菜煮饭洗碗都是一人包干（除了年底发烧那几天），上班时，就负责买菜洗碗拖地，今年大锤帮忙煮了几次饭，有时候，他还是很听话的。厨艺方面，尝试了炸扣肉、芋头，炸猪脚，做炸蛋，大锤大妞评价不错，但他们妈妈说太上火了。\r\n\r\n家里的气氛还是跟以前一样，大锤大妞长大了些，闹了些，大人免不了争吵，因为意见不合，当然也不好多评价什么。同一件事，不同人做，结果是不同的。比如，我是不能买腊肠给小孩吃的，有的人可以。因为还需工作，不可能花很多时间去想去提升吵架水平的。\r\n\r\n## 儿女教育\r\n\r\n不知何时因何故，我就不能单独带大妞外出了，也不能抱她了。我听到大妞被教育时的话，大意是不能让任何男人抱。因此在家我十分注意分寸，凡大妞的事，都让她请示他妈妈，准许方可。\r\n\r\n今年正式开始教大锤拼音和认字。买了拼音卡和本子练习，但没有天天强迫，只是间隔一段想起来了就问一下，如果没有写就得写（当然也会强制写），写的数量也不多。 诗词文方面，除了巩固以前背过的，新加的不多，其中有《岳阳楼记》、《腾王阁序》，这是经过思考后选择的，前者胜在思想，后者朗诵有韵律美，两者的文字，都可以拿来认字。与起初的想法一样，不求数量，不能显摆，就是练童子功。 因为幼儿园要跳绳，于是买了绳子，大锤练了几个晚上就能跳了，从中能明显看出进步，从几个到十几个到几十个。我也有绳子，也跳，但与预期效果不明显。\r\n\r\n大妞进步很多，能自主吃饭，懂得上厕所穿衣服了，偶尔还能读几句三字经，唱几句儿歌，发音虽不准，年纪还小有改进空间。\r\n\r\n哥哥妹妹在家里时不时打闹，抢东西，为此，没少吵架，我又复习了大锤小时至今的劣事。\r\n\r\n大锤慢慢成长了，有些事会主动问，不乏死亡这种话题，有时在厨房问我“爸爸你会不会消失掉”，我从没提过类似的，但有人如此认为，后来教育大锤有些话在家里不能说。当然，单独去玩或睡觉前关起门，还是可以说的。\r\n\r\n明年大锤正式上小学，根据平时表现，还是觉得不懂事，不知道到时候是怎样的情形。尽量教，学得多少，就看他的了。也因为如此，有些事得带着他去做了。\r\n\r\n## 个人事\r\n\r\n**回忆**\r\n\r\n有时候，我会回忆，回忆童年的事，童年听的歌；回忆求学时光；旧事有欢乐有苦难，但回忆时，往往偏向于美好。 我喜欢去那个菜市场，喜欢去旧货市场、旧书摊，那里有市井气息，不时有白话交流，这都让我回想起小时候，老妈带我去赶集的时光。 文学艺术方面，相比于昆曲、黄梅戏，我更喜欢听粤曲，因为小时候听过，是不是同一首无关系，重要的是那个时光。我试过背《长恨歌》，久不能背完。但《琵琶行》很快就会背了，里面有些心境，与乐天竟有一丝相似。而看《浮生六记》，看到沈复一家子在清晨分别时，竟也有些心酸，或许那时我想家了。\r\n\r\n**差距**\r\n\r\n今年很多同事生娃，我跟别人分享新生儿洗澡，护理肚脐，冲奶粉等经验时，结果别人是去月子中心，是1天近1千块钱的那种，出了月子还要请保姆。瞬间觉得人与人差距实在太大了。 有时候，同事周末有问题联系我，以为我能马上查电脑看日志，殊不知那时我在买菜或煮饭，不是所有的家庭都有老人带小孩或有阿姨煮饭，当然，想是一回事，还是要回复并且给出处理时间的。 无意间和一些相同身份的同事聊天，得知正式员工的年终奖比外包的“多好几倍”，这个“好”字，让我不能释怀，特别是下半年常态化无差别化加班。虽然我没能到现场，但也随时待命，也有几次夜晚加班解决了线上问题，那天周日发烧了还得去公司加班。但想到人与人的差距，又只能安慰自己要释怀。\r\n\r\n**大事和小事**\r\n\r\n这一年国内外风云幻变不定，年底可说是重大变化，我一向不太懂国家事，中年以来都是管自己的小事。我朋友圈发的，不外加班、买菜、带小孩玩，等。从不敢用文字指点江山，也听从安排，让打疫苗，打之；让三天一核酸，检之。\r\n\r\n**杂想**\r\n\r\n年初买了棵发财树，慢慢长芽，枝叶渐多，前几天发现有些叶子枯萎了。草木无情，有时飘零，本该如是，人见之有感，亦当如是。 今年是我的本命年，昨天那个在田野玩泥巴的小孩，经过求学、工作、结婚、生子，今天就到了人生的半程了，再有2~3轮，估计差不多行将就木了——以我现在的压力，能不能坚持到那时，还得另说。\r\n\r\n## 展望\r\n\r\n希望明年工作不那么忙，有时间钻研些自己感兴趣的事。 希望明年能多点时间陪小孩，教小孩。 希望早日上岸，摆脱外包工身份——虽然遥遥无期。\r\n\r\n李迟 2023.1.15 周日"
    },
    {
        "article_id": "7151050708094189582",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b3d5a876104c3081fa7e3b8f9f4354~tplv-k3u1fbpfcp-watermark.image?",
        "title": "抛弃moment.js，基于date-fns封装日期相关utils",
        "preview": "本文将简要介绍前端常用日期处理库：官方停止维护的moment.js，无缝代替moment.js的day.js，逐渐流行的date-fns，最后基于date-fns封装常用日期处理的utils",
        "author": "jjjona0215",
        "view_count": 29419,
        "collect_count": 414,
        "comment_count": 44,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6496104ae7cc9d049f4984a8763091e1~300x300.image",
        "category": "前端",
        "content": "> 我正在参加「掘金·启航计划」\r\n## 前言\r\n最近工作内容需要封装时间相关的utils，之前也没有具体研究过这块，所以查看了一些资料补充盲区。\r\n\r\n本文将简要介绍前端常用**日期处理库**：**官方停止维护的moment.js**，**无缝代替moment.js的day.js**，**逐渐流行的date-fns**，最后基于**date-fns**封装常用日期处理的**utils**。\r\n\r\n2022年了，如果项目中有用**moment.js**的可以用**day.js**代替减少体积做优化，新项目可以直接选择**date-fns**。\r\n\r\n> 本文所有的utils均在[github](https://github.com/zxyue25/date-fns-utils.git)实现\r\n\r\n\r\n## 大纲\r\n- 常用日期处理库\r\n    - 官方停止维护的moment.js\r\n    - 无缝代替moment.js的day.js\r\n    - 逐渐流行的date-fns\r\n- 基于date-fns封装utils\r\n\r\n## 一、常用日期处理库\r\n### 1.1 官方停止维护的moment.js\r\n> github：https://github.com/moment/moment\r\n\r\nmoment.js是一个大而全的时间日期库，极大方便了我们在 JavaScript 中计算时间和日期，每周下载量超过 1200 万，已成功用于数百万个项目中。\r\n\r\n但是，作为一个**诞生于2011年**的元老级明星项目，以现在的眼光来看moment.js并非完美无缺，官方总结了两大问题：\r\n\r\n**（1） 可变对象**\\\\\r\nmoment对象是`可变对象（mutable）`，简单点说，任何时间上的加减等计算都改变了其本身。这种设计让代码变得十分不可控，而且很容易带来各种隐蔽且难以调试的 bug。以至于我们在每步修改之前，都要先调用 `.clone` 克隆一次才能放心操作。\r\n\r\n**（2）包体积过大**\\\\\r\n因为Momnet.js`将全部的功能和所有支持的语言都打到一个包里`，包的大小也是到了 **280.9 kB** 这样一个夸张的数字，而且`对于Tree shaking无效`。如果要使用时区相关的功能，包体积更是有 **467.6 kB** 的大小。简单点说，我们可能只需要一个 `.format` 格式化时间的方法，用户就需要加载数百 kB 的库，这是十分不划算的。\r\n\r\n在**2020年9月**，moment.js官方**宣布停止开发，进入维护状态**(如下图)，后续不会再为其增加新功能，并建议新项目不要使用moment.js，推荐使用更现代的库或JavaScript目前的实验性提案`Temporal`。moment团队提供的替代方案包括：`Luxon`、`Day.js`、`date-fns`和`js-Joda`。他们还说，希望未来有一天能够完全不需要JavaScript的日期和时间库，而是使用语言本身的功能。所以他们还推荐了尚处于实验性阶段的`Temporal`。\r\n\r\n所以2022年了，当我们在技术选型的时候，可以果断抛弃moment.js\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/358adee404aa412e8c9c5adaa1f9ce88~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 1.2 无缝代替moment.js的day.js\r\n> github：https://github.com/iamkun/dayjs\r\n\r\nday.js基本用法如下：\r\n```js\r\ndayjs().startOf('month').add(1, 'day').set('year', 2018).format('YYYY-MM-DD HH:mm:ss');\r\n```\r\n**（1）和moment.js相同的API**\\\\\r\n和moment.js相同的API、相同的链式操作。\r\n\r\n**（2）不可变**\\\\\r\n上面提到，可变性是使用momentJs时最大的问题之一。在day.js完全消除了这个问题，它支持不变性。\r\n\r\n**（3）体积小**\\\\\r\nDay.js 虽然仅有 2kb 大小，但是功能一点都没有阉割，包含了时间处理的全部常用方法。\r\n\r\n> 更多可查看day.js作者自己写的推广文章：https://juejin.cn/post/6844903597709197319\r\n\r\n### 1.3 逐渐流行的date-fns\r\n> github：https://github.com/date-fns/date-fns\r\n\r\n**（1）模块化、按需引入**\\\\\r\ndate-fns库包含多个函数，有200多种功能，适用于几乎所有场合。并且是**模块化**的，可以根据需要单独导入这些函数。适用于`webpack`、`Browserify` 或 `Rollup`，还支持 `tree-shaking`。\\\\\r\n例如，如果要计算2个日期之间的差值，只需要导入`formatDistance`和`subDays`函数。\r\n```js\r\nimport { formatDistance, subDays } from ‘date-fns’\r\n\r\nformatDistance(subDays(new Date(), 3), new Date())\r\n```\r\n**（2）不可变**\\\\\r\n上面提到，可变性是使用 momentJs 时最大的问题之一。在date-fns完全消除了这个问题，它支持不变性。\r\n```js\r\nconst startDate = new Date();\r\nconst endDate = add(startDate, {years: 2});\r\nconsole.log(startDate) // 2022-03-13T13:39:07+01:00\r\nconsole.log(endDate)   // 2024-03-13T13:39:07+01:00\r\n```\r\n**（3） 同时支持 Flow 和 TypeScript**\r\n\r\n## 二、基于date-fns封装utils\r\n为什么要封装？一般library都是提供了基础实现\r\n\r\n1、日期这种需要跟业务的**UI规范**结合起来\\\\\r\n比如我们默认的日期格式是`yyyy-MM-dd HH:mm`，而不是`yyyy/MM/dd HH:mm:ss`等\\\\\r\n比如**日期间隔**的默认格式是为`yyyy/MM/dd - yyyy/MM/dd`，而不是`yyyy-MM-dd ～ yyyy-MM-dd`等，提供一个日期间隔的utils，而不是每次自己拼装\\\\\r\n...\\\\\r\n在封装的时候写好默认格式（其实真正考虑多语言场景是不能写死格式的，因为不同国家日期的表达其实是不一样的，后面解决了这个问题，再写文章补充吧），在使用的时候就可以**避免不同的人写出来的格式不一样**\r\n\r\n2、日期涉及到**多语言**\\\\\r\n比如时长：`22小时17分钟1秒`，`22h17m1s`，`22시간17분1초`\\\\\r\n比如多久之前：`5 天前`、` 5 days ago`\\\\\r\n...\\\\\r\ndate-fns提供的多语言不一定能百分百契合，在封装的时候处理好\r\n\r\n### 2.1 getTimestamp\r\n获取当前时间或者某个时间的秒级时间戳\r\n```ts\r\nimport { getUnixTime } from 'date-fns';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 获取当前时间或者某个时间的秒级时间戳；\r\n * 如果入参是毫秒秒级时间戳（13位），则去除最后三位1000返回毫秒级（13位）时间戳；主要场景在前端需要入参拿秒级时间戳给后端作为入参\r\n * @param date - Date | Number\r\n * @returns 返回格式化后的秒级时间戳 - Number\r\n * @example\r\n * ```\r\n * getTimestamp() // 1658320260\r\n * getTimestamp(new Date()) // 1658320260\r\n * getTimestamp(new Date().getTime()) // 1658320260\r\n * getTimestamp(Date.parse(new Date())) // 1658320260\r\n * getTimestamp(1658312707) // 1658312\r\n * getTimestamp(1) // 0\r\n * ```\r\n */\r\n\r\nexport const getTimestamp = (date: number | Date = new Date()): number => getUnixTime(date);\r\n```\r\n\r\n### 2.2 getMilliTimestamp\r\n获取当前时间或者某个时间的毫秒级时间戳\r\n```ts\r\nimport { getTime } from 'date-fns';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 获取当前时间或者某个时间的毫秒级时间戳；\r\n * 如果入参是秒级时间戳（10位），则乘以1000返回毫秒级（13位）时间戳；主要场景在server返回了秒级时间戳，前端先乘以1000转换成日期展示\r\n * TODO：这里传入了其他数字怎么处理？直接返回还是补齐13位返回？date-fns是直接返回，建议直接返回\r\n * @param date - Date | Number\r\n * @returns 返回格式化后的毫秒级时间戳 - Number\r\n * @example\r\n * ```\r\n * getMilliTimestamp() // 1658320372160\r\n * getMilliTimestamp(new Date()) // 1658320372160\r\n * getMilliTimestamp(new Date().getTime()) // 1658320372160\r\n * getMilliTimestamp(Date.parse(new Date())) // 1658320372000\r\n * getMilliTimestamp(1658312707) // 1658312707000\r\n * getMilliTimestamp(1) // 1\r\n * ```\r\n */\r\nexport const getMilliTimestamp = (date?: number | Date): number => {\r\n  if (!date) {\r\n    return getTime(new Date());\r\n  } else {\r\n    if (date instanceof Date) {\r\n      return getTime(date);\r\n    } else {\r\n      if (date.toString().length === 10) {\r\n        return getTime(date * 1000);\r\n      } else {\r\n        return date;\r\n      }\r\n    }\r\n  }\r\n};\r\n```\r\n### 2.3 formatDate\r\n将时间戳转换为指定格式的日期；入参可以是秒级时间戳、毫秒级时间戳；\r\n```ts\r\nimport { format } from 'date-fns';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 将时间戳转换为指定格式的日期；入参可以是秒级时间戳、毫秒级时间戳；\r\n * 如果入参是秒级时间戳（10位），会乘以1000转换；格式默认为'yyyy-MM-dd HH:mm'；\r\n * 主要场景：通常情况下时间戳转换日期不传格式，而是用默认格式；后端返回的时间戳一般是秒级时间戳，如果直接用date-fns需要自己乘1000传入\r\n * @param date - Date | Number\r\n * @param formatStr - String\r\n * @returns 返回格式化后的秒级时间戳 - Number\r\n * @example\r\n * ```\r\n * formatDate(1658320372161) // 2022-07-20 20:32\r\n * format(1658320372, 'yyyy-MM-dd HH:mm') // 1970-01-20 12:38\r\n * formatDate(1658320372) // 2022-07-20 20:32\r\n * formatDate(new Date()) //  2022-07-21 11:28\r\n * formatDate(1658320372000, 'yyyy/MM/dd HH:mm:ss') // 2022/07/20 20:32:52\r\n * ```\r\n */\r\n\r\nexport const formatDate = (date: number | Date, formatStr = 'yyyy-MM-dd HH:mm') => {\r\n  if (typeof date === 'number' && date.toString().length === 10) {\r\n    return format(date * 1000, formatStr);\r\n  } else {\r\n    return format(date, formatStr);\r\n  }\r\n};\r\n```\r\n### 2.4 formatDateRange\r\n将两个时间戳或者Date日期转换为指定格式的日期，并用指定连接符连接；\r\n```ts\r\nimport { formatDate } from './formatDate';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 将两个时间戳或者Date日期转换为指定格式的日期，并用指定连接符连接；\r\n * 入参可以是秒级时间戳、毫秒级时间戳或者Date日期；如果入参是秒级时间戳（10位），会乘以1000转换；\r\n * 格式默认为`${yyyy/MM/dd} - `${yyyy/MM/dd}'；如果想更改格式，可传入第三个参数（日期的格式），第四个参数（连接符的格式）\r\n * @param startDate - Date | Number\r\n * @param endDate - Date | Number\r\n * @param formatStr - String 默认格式'yyyy/MM/dd'\r\n * @param joinStr - String 默认连接符'-'\r\n * @returns 返回格式化后的日期区间字符串\r\n * @example\r\n * ```\r\n * formatDateRange(1658320372161, 1658717927699) // 2022/07/20 - 2022/07/25\r\n * formatDateRange(1658320372, 1658717927) // 2022/07/20 - 2022/07/25\r\n * formatDateRange(1658320372, 1658717927, '', '~') // 2022/07/20 ~ 2022/07/25\r\n * formatDateRange(1658320372, 1658717927, 'yyyy/MM/dd HH:mm', '~') // 2022/07/20 20:32 ~ 2022/07/25 10:58\r\n * ```\r\n */\r\n\r\nexport const formatDateRange = (\r\n  startDate: number | Date,\r\n  endDate: number | Date,\r\n  formatStr = 'yyyy/MM/dd',\r\n  joinStr = '-',\r\n) => `${formatDate(startDate, formatStr || 'yyyy/MM/dd')} ${joinStr} ${formatDate(endDate, formatStr || 'yyyy/MM/dd')}`;\r\n```\r\n\r\n### 2.5 formatDateDistance\r\n获取指定时间距离当前时间或者指定时间多远\r\n```ts\r\nimport { formatDistance } from 'date-fns';\r\n\r\nimport { getMilliTimestamp } from './getMilliTimestamp';\r\nimport { LANGUAGE_DATE_FNS_MAP } from './locale';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 获取指定时间距离当前时间或者指定时间多远；\r\n * @param date - Date | Number\r\n * @param baseDate - Date | Number，默认为当前时间\r\n * @param options - 扩展项，可以配置语言，有两种方式：传入语言类型lang；或者直接传入Locale；\r\n * @returns 返回描述“指定时间距离当前时间或者指定时间多远”的字符串，有多语言处理\r\n * @example\r\n * ```\r\n * formatDateDistance(1658320372161, 1658717927699, { lang: 'zh-CN' }) // 5 天前\r\n * formatDateDistance(1658320372161, 1658717927699, { lang: 'zh-CN', addSuffix: 'false' }) // 5 天\r\n * formatDateDistance(1658320372, 1658717927) // 5 days ago'\r\n * formatDateDistance(new Date('2022-07-12'), new Date('2022-07-17')) // 5 days ago\r\n * formatDateDistance(new Date('2022-07-05'), new Date('2022-07-12')) // 7 days ago\r\n * formatDateDistance(new Date('2022-06-12'), new Date('2022-07-12')) // about 1 month ago\r\n * formatDateDistance(new Date('2021-07-12'), new Date('2022-07-12')) // about 1 year ago\r\n * formatDateDistance(1658320372, 1658717927, { locale: ko }) // 5일 전\r\n * ```\r\n */\r\n\r\ntype OptionType = {\r\n  locale?: Locale;\r\n  addSuffix?: boolean;\r\n  lang?: keyof typeof LANGUAGE_DATE_FNS_MAP;\r\n};\r\n\r\nexport const formatDateDistance = (\r\n  date: Date | number = 0,\r\n  baseDate: Date | number = new Date(),\r\n  options?: OptionType,\r\n): string => {\r\n  const initOptions = {\r\n    addSuffix: options?.addSuffix || true,\r\n    locale: options?.locale || LANGUAGE_DATE_FNS_MAP[options?.lang || 'en'],\r\n    ...options,\r\n  };\r\n  if (\r\n    (typeof date === 'number' && date.toString().length === 10) ||\r\n    (typeof baseDate === 'number' && baseDate.toString().length === 10)\r\n  ) {\r\n    return formatDistance(getMilliTimestamp(date), getMilliTimestamp(baseDate), initOptions);\r\n  }\r\n  return formatDistance(date, baseDate, initOptions);\r\n};\r\n```\r\n\r\n### 2.6 formatDateDuration\r\n将指定秒转为‘H小时M分钟S秒’，H、M、S为0时，默认不展示；如果想更改格式可传入第二个扩展参数options\r\n```ts\r\nimport { formatDuration } from 'date-fns';\r\n\r\nimport { LANGUAGE_DATE_FNS_MAP } from './locale';\r\n\r\n/**\r\n * @author zxyue25\r\n * @desc 将指定秒转为‘H小时M分钟S秒’，H、M、S为0时，默认不展示；如果想更改格式可传入第二个扩展参数options\r\n * @param second - Number，多少秒\r\n * @param options - 扩展项，可以配置语言，有两种方式：传入语言类型lang；或者直接传入Locale；\r\n * @returns 返回描述“H小时M分钟S秒”的字符串，有多语言处理\r\n * @example\r\n * ```\r\n * formatDateDuration(71) // 1minute11seconds\r\n * formatDateDuration(71, { lang: 'zh-CN' }) // 1分钟11秒\r\n * formatDateDuration(3604, { lang: 'zh-CN' }) // 1小时4秒\r\n * formatDateDuration(80221, { lang: 'zh-CN' }) // 22小时17分钟1秒\r\n * formatDateDuration(80221, { locale: ko }) // 22시간17분1초\r\n * formatDateDuration(80221, { lang: 'zh-CN', delimiter: ',' }) // 22小时,17分钟,1秒\r\n * formatDateDuration(80221, { lang: 'zh-CN', format: ['hours', 'minutes'] }) // 22小时17分钟\r\n * formatDateDuration(80220, { lang: 'zh-CN' }) // 22小时17分钟\r\n * formatDateDuration(80220, { lang: 'zh-CN', zero: true }) // 22小时17分钟0秒\r\n * formatDateDuration(880220, { lang: 'zh-CN' }) // 244小时30分钟20秒\r\n * ```\r\n */\r\n\r\ntype OptionType = {\r\n  locale?: Locale;\r\n  zero?: boolean;\r\n  delimiter?: string;\r\n  format?: Array<string>;\r\n  lang?: keyof typeof LANGUAGE_DATE_FNS_MAP;\r\n};\r\n\r\nexport const formatDateDuration = (second: number, options?: OptionType) => {\r\n  const hours = Math.floor(second / 3600);\r\n  const minutes = Math.floor((second % 3600) / 60);\r\n  const seconds = Math.floor(second % 60);\r\n\r\n  return formatDuration(\r\n    {\r\n      hours,\r\n      minutes,\r\n      seconds,\r\n    },\r\n    {\r\n      zero: options?.zero || false,\r\n      locale: options?.locale || LANGUAGE_DATE_FNS_MAP[options?.lang || 'en'],\r\n      ...options,\r\n    },\r\n  ).replace(/ /g, '');\r\n};\r\n```\r\n\r\n## 最后\r\n`日期`处理是前端必定会遇到的问题，本文也只是一部分场景的封装，后续工作中遇到其他utils，也会继续封装在[github](https://github.com/zxyue25/date-fns-utils.git)\r\n\r\n> 且遇到一个不好解决的问题是：**不同国家的日期格式其实是不一样的**，因为工作变动暂时不会关注这部分了，先记下来，后面有机会解决这个问题再写最终的解决方案\r\n\r\n> 发现如果一直等着某件事情干完再干另一件，大概率另一件就不会开始了，所以先干完明确的事情，比如这篇文章\r\n\r\n本文收录专栏【业务总结】旨在**沉淀工作中遇到的问题，总结为最佳实践**，欢迎关注✨\r\n\r\n"
    },
    {
        "article_id": "7189562968059691067",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6327210e684ce0b9a81176814c27af~tplv-k3u1fbpfcp-watermark.image?",
        "title": "「兔了个兔」创意投稿大赛——html+css绘制新春海报",
        "preview": "我正在参加「兔了个兔」创意投稿大赛，详情请看：「兔了个兔」创意投稿大赛 前言 春节将至，今天使用html+css来绘制一张新春海报，具体设计有参考了网上的海报图，最终实现的效果图： 代码放在了码上掘金",
        "author": "格斗家不爱在外太空沉思",
        "view_count": 1998,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/c24f606e2eb7b58b3b94c8e3dd7a255b~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: nico\r\n---\r\n\r\n\r\n我正在参加「兔了个兔」创意投稿大赛，详情请看：[「兔了个兔」创意投稿大赛](https://juejin.cn/post/7185104994801025061 \\\"https://juejin.cn/post/7185104994801025061\\\")\r\n\r\n## 前言\r\n春节将至，今天使用html+css来绘制一张新春海报，具体设计有参考了网上的海报图，最终实现的效果图：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/703719798dde437192e5c13527a48bb5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n代码放在了码上掘金\r\n[jcode](https://code.juejin.cn/pen/7189532121327730744)\r\n\r\n## 使用ps加工图片\r\n\r\n首先解决那只兔子的问题，将网络素材图片导入ps，使用快速魔棒工具将大兔子选中，然后在右击选择取消反转，退格键去掉就得到了大兔子\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/401696affce748e7bb47f7c9667241b7~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"40%\\\" />\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/923b63a4dd21422cb1fbb81daebba6dd~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"40%\\\" />\r\n\r\n再使用裁剪工具裁去多余的部分，最后将图片导出作为使用准备\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0a921c11b864cf89427940ab3ade486~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\" width=\\\"70%\\\" />\r\n\r\n## 绘制组成数字的几何图形\r\n组成数字用到的图形只有**半圆**，**1/4圆**和**直角三角形**\r\n\r\n半圆的绘制使用`border-radius`，border-radius的四个参数分别代表左上，右上，右下，右左，而我们需要绘制的是上半圆，只需设置左上和右上的值，并且值为块的高度就行了\r\n\r\n```\r\n<div class=\\\"semiCircleTop\\\"></div>\r\n\r\n.semiCircleTop{\r\n  width: 152px;\r\n  height: 75px;\r\n  border-radius: 75px 75px 0 0;\r\n  background: pink;\r\n}\r\n```\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e58425b56af441fcb40c96d4a09de548~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n1/4圆也是使用`border-radius`绘制出来，不过1/4圆要宽高相同为正方形，border-radius设置一个对应的值就行了\r\n\r\n```\r\n<div class=\\\"quarterCircleTopLeft\\\"></div>\r\n<div class=\\\"quarterCircleTopRight\\\"></div>\r\n<div class=\\\"quarterCircleBottomRight\\\"></div>\r\n\r\n.quarterCircleTopLeft{\r\n  width: 75px;\r\n  height: 75px;\r\n  border-radius: 75px 0 0 0;\r\n  background: pink;\r\n}\r\n.quarterCircleTopRight{\r\n  width: 75px;\r\n  height: 75px;\r\n  border-radius: 0 75px 0 0;\r\n  background: pink;\r\n\r\n}\r\n.quarterCircleBottomRight{\r\n  width: 75px;\r\n  height: 75px;\r\n  border-radius: 0 0 75px 0;\r\n  background: pink;\r\n}\r\n```\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b44ce3078340158f8dcc6ddcc000ec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n最后就是三角形了，css绘制三角形可以通过三种方法绘制\r\n\r\n第一种是`border`边框属性，宽高为0，设置border的上下左右\r\n\r\n```\r\n<div class=\\\"triangle\\\"></div>\r\n\r\n.triangle{\r\n  width: 0;\r\n  height: 0;\r\n  border-left: 50px solid red;\r\n  border-bottom: 50px solid green;\r\n  border-top: 50px solid yellow;\r\n  border-right: 50px solid pink;\r\n}\r\n```\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8fb900918bb4c3285211770218bd56d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n只需将我们需要的设为同一个颜色，不需要的设为透明色就可以得到一个直角三角形了\r\n\r\n```\r\n<div class=\\\"triangle\\\"></div>\r\n.triangle{\r\n  width: 0;\r\n  height: 0;\r\n  border-left: 50px solid red;\r\n  border-bottom: 50px solid red;\r\n  border-top: 50px solid transparent;\r\n  border-right: 50px solid transparent;\r\n}\r\n```\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af3a8ea98ea4463787920a42949e908b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n第二种是通过线性渐变来绘制，指定两种颜色朝一个角度的渐变效果，颜色还可以设置高度，这样会使元素的一半呈红色\r\n```\r\n.triangle{\r\n  width: 75px;\r\n  height: 75px;\r\n  background-image: linear-gradient(45deg,red 50% , rgba(255,255,255,0) 50%);\r\n}\r\n```\r\n\r\n第三种方法就是`clip-path`，它是最精简和最可具扩展性的，不过要考虑浏览器是否兼容，通过clip-path可以绘制多边形，三角形有三个顶点，三个顶点的内部图案会被保留下来，而外部的则被隐藏掉\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28c2ce649ec24050aa6514562b9253f8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n```\r\n.triangle{\r\n  width: 75px;\r\n  height: 75px;\r\n  clip-path: polygon(0 0, 100% 100%, 0% 100%);\r\n  background: pink;\r\n}\r\n```\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/820a15dce2d0470eb1f7c3c5ac77a58e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但是考虑到三角形我需要用到渐变颜色，前面两种实现不了只好使用clip-path来绘制三角形了\r\n\r\n## 最终\r\n几何图形的背景都换成了渐变颜色，html标签只需要布局好，再添加对应的类名就行了，背景颜色设置为深一点的红色，但是还缺少点磨砂感，body标签在添加一个伪元素，使用background-image导入一张蒙层图片，磨砂感就出来了\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbefc6d660b417795f6886cbf9ee18a~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"1673948336870.png\\\" width=\\\"30%\\\" />\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d72bc73ff14748980a034587cb0cf2~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"1673948380088.png\\\" width=\\\"30%\\\" />\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7188907638694871101",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/319b0d7624d9480d969e93b1428ad98f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "与Go的初次见面 ｜ 青训营笔记",
        "preview": "这是我参与「第五届青训营 」伴学笔记创作活动的第 1 天 本文总共分为：介绍、关键字、数据类型的定义、内置基础类型、array/slice/map、零值",
        "author": "啵啵肠",
        "view_count": 1282,
        "collect_count": 3,
        "comment_count": 4,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0de6e7c19aacf1d70c9fc6bc41710c4d~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: nico\r\n---\r\n**这是我参与「第五届青训营 」伴学笔记创作活动的第 1 天**\r\n\r\n## 前言\r\n\r\n> 记录加入青训营的每一天的日笔记\r\n\r\n本文总共分为：介绍、关键字、数据类型的定义、内置基础类型、array/slice/map、零值\r\n\r\n## Go介绍\r\n\r\nGo 是在设计时考虑了系统编程的通用型编程语言。它是强类型，有垃圾回收机制并原生支持并发编程。Go 程序由一个或多个 package 组成，这样可以高效的管理依赖。\r\n\r\nGo 的语法简洁且有规则，这让自动化工具可以很容易的分析代码，例如：集成开发环境。\r\n\r\n## Go一些规则\r\n\r\nGo之所以会那么简洁，是因为它有一些默认的行为：\r\n\r\n-   大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。\r\n-   大写字母开头的函数也是一样，相当于`class`中的带`public`关键词的公有函数；小写字母开头的就是有`private`关键词的私有函数。\r\n\r\n## 关键字\r\n\r\n-   `var`和`const` 是 Go语言基础里面的变量和常量申明\r\n-   `package`和`import` 用于分包和导入\r\n-   `func` 用于定义函数和方法\r\n-   `return` 用于从函数返回\r\n-   `defer` 用于类似析构函数\r\n-   `go` 用于并发\r\n-   `select` 用于选择不同类型的通讯\r\n-   `interface` 用于定义接口\r\n-   `struct` 用于定义抽象数据类型\r\n-   `break`、`case`、`continue`、`for`、`fallthrough`、`else`、`if`、`switch`、`goto`、`default` 用于流程控制\r\n-   `chan`用于channel通讯\r\n-   `type`用于声明自定义类型\r\n-   `map`用于声明map类型数据\r\n-   `range`用于读取slice、map、channel数据\r\n\r\n## 数据类型的定义\r\n\r\n### 变量\r\n\r\n> Go对于已声明但未使用的变量会在编译阶段报错。\r\n\r\nGo语言里面定义变量有多种方式。使用`var`关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面。\r\n\r\n```\r\n//定义一个名称为“variableName”，类型为\\\"type\\\"的变量\r\nvar variableName type\r\n//定义三个类型都是“type”的变量\r\nvar vname1, vname2, vname3 type\r\n//初始化“variableName”的变量为“value”值，类型是“type”\r\nvar variableName type = value\r\n​\r\n/*\r\n    定义三个类型都是\\\"type\\\"的变量,并且分别初始化为相应的值\r\n    vname1为v1，vname2为v2，vname3为v3\r\n*/\r\nvar vname1, vname2, vname3 type= v1, v2, v3\r\n​\r\n/*\r\n    定义三个变量，它们分别初始化为相应的值\r\n    vname1为v1，vname2为v2，vname3为v3\r\n    然后Go会根据其相应值的类型来初始化它们\r\n*/\r\nvar vname1, vname2, vname3 = v1, v2, v3\r\n​\r\n/*\r\n    定义三个变量，它们分别初始化为相应的值\r\n    vname1为v1，vname2为v2，vname3为v3\r\n    编译器会根据初始化的值自动推导出相应的类型\r\n*/\r\nvname1, vname2, vname3 := v1, v2, v3\r\n​\r\n/*\r\n    :=这个符号直接取代了var和type,这种形式叫做简短声明。\r\n    不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量。\r\n    _（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃\r\n*/\r\n_, b := 34, 35\r\n```\r\n\r\n### 常量\r\n\r\n> Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给`float32`自动缩短为`32bit`，指定给`float64`自动缩短为`64bit`\r\n\r\n所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。\r\n\r\n```\r\nconst constantName = value\r\n//如果需要，也可以明确指定常量的类型：\r\nconst Pi float32 = 3.1415926\r\n//下面是一些常量声明的例子\r\nconst Pi = 3.1415926\r\nconst i = 10000\r\nconst MaxThread = 10\r\nconst prefix = \\\"astaxie_\\\"\r\n```\r\n\r\n## 内置基础类型\r\n\r\n### 布尔类型\r\n\r\n在Go中，布尔值的类型为`bool`，值是`true`或`false`，默认为`false`。\r\n\r\n### 数值类型\r\n\r\n整数类型有无符号和带符号两种。Go同时支持`int`和`uint`，这两种类型的长度相同，但具体长度取决于不同编译器的实现。\r\n\r\nGo里面也有直接定义好位数的类型：`rune`, `int8`, `int16`, `int32`, `int64`和`byte`, `uint8`, `uint16`, `uint32`, `uint64`。其中`rune`是`int32`的别称，`byte`是`uint8`的别称。\r\n\r\n> 需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。\r\n>\r\n> 另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。\r\n>\r\n> 浮点数的类型有`float32`和`float64`两种（没有`float`类型），默认是`float64`。\r\n\r\n### 字符串\r\n\r\nGo中的字符串都是采用`UTF-8`字符集编码。字符串是用一对双引号（`\\\"\\\"`）或反引号（``）括起来定义，它的类型是`string`。\r\n\r\n```\r\n//示例代码\r\nvar frenchHello string  // 声明变量为字符串的一般方法\r\nvar emptyString string = \\\"\\\"  // 声明了一个字符串变量，初始化为空字符串\r\nfunc test() {\r\n    no, yes, maybe := \\\"no\\\", \\\"yes\\\", \\\"maybe\\\"  // 简短声明，同时声明多个变量\r\n    japaneseHello := \\\"Konichiwa\\\"  // 同上\r\n    frenchHello = \\\"Bonjour\\\"  // 常规赋值\r\n}\r\n```\r\n\r\n在Go中字符串是不可变的，但可以通过切片形式进行修改\r\n\r\n```\r\ns := \\\"hello\\\"\r\nc := []byte(s)  // 将字符串 s 转换为 []byte 类型\r\nc[0] = 'c'\r\ns2 := string(c)  // 再转换回 string 类型\r\nfmt.Printf(\\\"%s\\\r\n\\\", s2)\r\n```\r\n\r\n### 错误类型\r\n\r\nGo内置有一个`error`类型，专门用来处理错误信息，Go的`package`里面还专门有一个包`errors`来处理错误\r\n\r\n```\r\nerr := errors.New(\\\"emit macho dwarf: elf header corrupted\\\")\r\nif err != nil {\r\n    fmt.Print(err)\r\n}\r\n```\r\n\r\n### iota枚举\r\n\r\nGo里面有一个关键字`iota`，这个关键字用来声明`enum`的时候采用，它默认开始值是0，const中每增加一行加1\r\n\r\n```\r\npackage main\r\nimport (\r\n    \\\"fmt\\\"\r\n)\r\nconst (\r\n    x = iota // x == 0\r\n    y = iota // y == 1\r\n    z = iota // z == 2\r\n    w        // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用\\\"= iota\\\"\r\n)\r\nconst v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0\r\nconst (\r\n    h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同\r\n)\r\nconst (\r\n    a       = iota //a=0\r\n    b       = \\\"B\\\"\r\n    c       = iota             //c=2\r\n    d, e, f = iota, iota, iota //d=3,e=3,f=3\r\n    g       = iota             //g = 4\r\n)\r\nfunc main() {\r\n    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)\r\n}\r\n```\r\n\r\n## array、slice、map\r\n\r\n### array\r\n\r\n`array`就是数组，它的定义方式如下：\r\n\r\n```\r\nvar arr [n]type\r\n```\r\n\r\n`[n]type`中，`n`表示数组的长度，`type`表示存储元素的类型。对数组的操作和其它语言类似，都是通过`[]`来进行读取或赋值：\r\n\r\n```\r\nvar arr [10]int  // 声明了一个int类型的数组\r\narr[0] = 42      // 数组下标是从0开始的\r\narr[1] = 13      // 赋值操作\r\nfmt.Printf(\\\"The first element is %d\\\r\n\\\", arr[0])  // 获取数据，返回42\r\nfmt.Printf(\\\"The last element is %d\\\r\n\\\", arr[9]) //返回未赋值的最后一个元素，默认返回0\r\n```\r\n\r\n由于长度也是数组类型的一部分，因此`[3]int`与`[4]int`是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。\r\n\r\n数组可以使用另一种`:=`来声明\r\n\r\n```\r\na := [3]int{1, 2, 3} // 声明了一个长度为3的int数组\r\nb := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0\r\nc := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度\r\n```\r\n\r\nGo支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：\r\n\r\n```\r\n// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素\r\ndoubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}\r\n// 上面的声明可以简化，直接忽略内部的类型\r\neasyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}\r\n```\r\n\r\n### slice\r\n\r\n在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫`slice`\r\n\r\n`slice`并不是真正意义上的动态数组，而是一个引用类型。`slice`总是指向一个底层`array`，`slice`的声明也可以像`array`一样，只是不需要长度。\r\n\r\n```\r\n// 和声明array一样，只是少了长度\r\nvar fslice []int\r\n// 接下来可以声明一个slice，并初始化数据\r\nslice := []byte {'a', 'b', 'c', 'd'}\r\n```\r\n\r\n`slice`可以从一个数组或一个已经存在的`slice`中再次声明。`slice`通过`array[i:j]`来获取，其中`i`是数组的开始位置，`j`是结束位置，但不包含`array[j]`，它的长度是`j-i`。\r\n\r\n```\r\n// 声明一个含有10个元素元素类型为byte的数组\r\nvar ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\r\n// 声明两个含有byte的slice\r\nvar a, b []byte\r\n// a指向数组的第3个元素开始，并到第五个元素结束，\r\na = ar[2:5]\r\n//现在a含有的元素: ar[2]、ar[3]和ar[4]\r\n// b是数组ar的另一个slice\r\nb = ar[3:5]\r\n// b的元素是：ar[3]和ar[4]\r\n```\r\n\r\n> `slice`和数组在声明时的区别：\r\n>\r\n> 声明数组时，方括号内写明了数组的长度或使用`...`自动计算长度，而声明`slice`时，方括号内没有任何字符。\r\n\r\n### slice的一些简便操作\r\n\r\n-   `slice`的默认开始位置是0，`ar[:n]`等价于`ar[0:n]`\r\n-   `slice`的第二个序列默认是数组的长度，`ar[n:]`等价于`ar[n:len(ar)]`\r\n-   如果从一个数组里面直接获取`slice`，可以这样`ar[:]`，因为默认第一个序列是0，第二个是数组的长度，即等价于`ar[0:len(ar)]`\r\n\r\n```\r\n// 声明一个数组\r\nvar array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\r\n// 声明两个slice\r\nvar aSlice, bSlice []byte\r\n// 演示一些简便操作\r\naSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c\r\naSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j\r\naSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素\r\n// 从slice中获取slice\r\naSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7\r\nbSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f\r\nbSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f\r\nbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h\r\nbSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g\r\n```\r\n\r\n`slice`是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的`aSlice`和`bSlice`，如果修改了`aSlice`中元素的值，那么`bSlice`相对应的值也会改变。\r\n\r\n从概念上面来说`slice`像一个结构体，这个结构体包含了三个元素：\r\n\r\n-   一个指针，指向数组中`slice`指定的开始位置\r\n-   长度，即`slice`的长度\r\n-   最大长度，也就是`slice`开始位置到数组的最后位置的长度\r\n\r\n#### `slice`有几个有用的内置函数\r\n\r\n-   `len` 获取`slice`的长度\r\n-   `cap` 获取`slice`的最大容量\r\n-   `append` 向`slice`里面追加一个或者多个元素，然后返回一个和`slice`一样类型的`slice`\r\n-   `copy` 函数`copy`从源`slice`的`src`中复制元素到目标`dst`，并且返回复制的元素的个数\r\n\r\n> `append`函数会改变`slice`所引用的数组的内容，从而影响到引用同一数组的其它`slice`。\r\n\r\n但当`slice`中没有剩余空间（即`(cap-len) == 0`）时，此时将动态分配新的数组空间。返回的`slice`数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的`slice`则不受影响。\r\n\r\n### map\r\n\r\n> map`也就是Python中字典的概念，它的格式为`map[keyType]valueType\r\n\r\n`map`的读取和设置也类似`slice`一样，通过`key`来操作，只是`slice`的`index`只能是｀int｀类型，而`map`多了很多类型，可以是`int`，可以是`string`及所有完全定义了`==`与`!=`操作的类型。\r\n\r\n```\r\n// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化\r\nvar numbers map[string]int\r\n// 另一种map的声明方式\r\nnumbers = make(map[string]int)\r\nnumbers[\\\"one\\\"] = 1  //赋值\r\nnumbers[\\\"ten\\\"] = 10 //赋值\r\nnumbers[\\\"three\\\"] = 3\r\nfmt.Println(\\\"第三个数字是: \\\", numbers[\\\"three\\\"]) // 读取数据\r\n// 打印出来如:第三个数字是: 3\r\n```\r\n\r\n这个`map`就像平常看到的表格一样，左边列是`key`，右边列是值\r\n\r\n使用`map`过程中需要注意的几点：\r\n\r\n-   `map`是无序的，每次打印出来的`map`都会不一样，它不能通过`index`获取，而必须通过`key`获取\r\n-   `map`的长度是不固定的，也就是和`slice`一样，也是一种引用类型\r\n-   内置的`len`函数同样适用于`map`，返回`map`拥有的`key`的数量\r\n-   `map`的值可以很方便的修改，通过`numbers[\\\"one\\\"]=11`可以很容易的把key为`one`的字典值改为`11`\r\n-   `map`和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制\r\n\r\n`map`的初始化可以通过`key:val`的方式初始化值，同时`map`内置有判断是否存在`key`的方式\r\n\r\n通过`delete`删除`map`的元素：\r\n\r\n```\r\n// 初始化一个字典\r\nrating := map[string]float32{\\\"C\\\":5, \\\"Go\\\":4.5, \\\"Python\\\":4.5, \\\"C++\\\":2 }\r\n// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true\r\ncsharpRating, ok := rating[\\\"C#\\\"]\r\nif ok {\r\n    fmt.Println(\\\"C# is in the map and its rating is \\\", csharpRating)\r\n} else {\r\n    fmt.Println(\\\"We have no rating associated with C# in the map\\\")\r\n}\r\ndelete(rating, \\\"C\\\")  // 删除key为C的元素\r\n```\r\n\r\n`map`也是一种引用类型，如果两个`map`同时指向一个底层，那么一个改变，另一个也相应的改变：\r\n\r\n```\r\nm := make(map[string]string)\r\nm[\\\"Hello\\\"] = \\\"Bonjour\\\"\r\nm1 := m\r\nm1[\\\"Hello\\\"] = \\\"Salut\\\"  // 现在m[\\\"hello\\\"]的值已经是Salut了\r\n```\r\n\r\n## make、new操作\r\n\r\n`make`用于内建类型（`map`、`slice` 和`channel`）的内存分配。`new`用于各种类型的内存分配。\r\n\r\n内建函数`new`本质上说跟其它语言中的同名函数功能一样：`new(T)`分配了零值填充的`T`类型的内存空间，并且返回其地址，即一个`*T`类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型`T`的零值。有一点非常重要：\r\n\r\n`new`返回指针。\r\n\r\n内建函数`make(T, args)`与`new(T)`有着不同的功能，make只能创建`slice`、`map`和`channel`，并且返回一个有初始值(非零)的`T`类型，而不是`*T`。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个`slice`，是一个包含指向数据（内部`array`）的指针、长度和容量的三项描述符；在这些项目被初始化之前，`slice`为`nil`。对于`slice`、`map`和`channel`来说，`make`初始化了内部的数据结构，填充适当的值。\r\n\r\n`make`返回初始化后的（非零）值。\r\n\r\n## 零值\r\n\r\n关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。\r\n"
    },
    {
        "article_id": "7189599956255129660",
        "snapshot": "",
        "title": "数据分析模型---AARR模型R和RFM模型",
        "preview": "该文章以图文结合的形式向大家介绍了数据分析的两个经典模型---AARRR模型和RFM模型，加上模型的应用场景方便各位读者了解。",
        "author": "佩棋wa",
        "view_count": 562,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0d3a7f1cb5a4634c095388bfc6fddfef~300x300.image",
        "category": "人工智能",
        "content": "# AARRR模型\r\n## AARRR模型概述\r\n\r\n-   AARRR模型是做用户分析的经典模型，呈现漏斗结构;\r\n-   从生命周期的角度，描述用户进入平台需经历的五个环节，获取商业价值;\r\n-   价值不仅源于用户购买行为( 获取营收)，还来自于用户作为推荐者和内容生产者所带来的营收;\r\n\r\n## AARRR分别对应产品生命周期的五个阶段\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2088f9b80c6e4a3da7b2c7639c3a036f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fafab262cbc405692f906c8f33424ce~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 对用户进行分层--用户增长\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/895a899183444164ba0c59082063c6f9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6ae1c1ed29945d79f3f911aa4db2fe1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6afa99580834ef88a24ebb609bf829d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# RFM模型\r\n## RFM模型概述\r\n\r\nRFM模型是通过一个客户的近期购买行为、购买的总体频率以及花了多少钱3个维度来描述该客户价值状况的客户分类模型。\r\n\r\n1.  R:针对“最近活跃日期距离当前统计日期的天数”的衡量分值;\r\n1.  F:针对“充值次数”的衡量分值;\r\n1.  M:针对“充值金额”的衡量分值。\r\n\r\n## 利用RFM打分进行用户分群流程\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8e538e614084816943fffff34c7a132~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 例子\r\n\r\n**项目背景:** 根据用户行为数据进行精细化地运营，一方面资源倾斜到更有价值的人群上，另一方面分层运营节省运营效率加速用户价值提升;\r\n\r\n**项目前提:** 用户生命周期维度粗狂，增加用户价值RFM模型多维度运营体系;\r\n\r\n**评分规则:** 根据最后1次支用距今时间(R)、近1年360天支用次数(F)、180天日均余额(M)进行分析( 按照RFM三要素进行等级划分) ;\r\n\r\n### 人群划分\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd23bcf741174945873b2ba6b8738492~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n$$$$ 总分=R* 权重1+M*权重1+F*权重3 $$$$\r\n\r\n> 权重相加之和为100（即：权重1+权重2+权重3=100）\r\n\r\n-   重要核心保持: [300,+∞)\r\n-   重要发展用户: [250,300)\r\n-   重要挽留用户: [200-250)\r\n-   一般发展用户: [150-200)\r\n-   低价值用户:[0,150)\r\n\r\n**注意: 区间选取及调整原则:用户分布尽量均匀，且尽可能集中于中部区间**\r\n\r\n根据目前RFM的分层( 各维度权重)验证大盘的用户价值等级结论:\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/040cdf8c492b4b10977079c19a92de53~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**结论：**\r\n\r\n-   *重要核心保持用户的长期收入价值高等级用户占比高(深色)，L4等级以上用户占94%;*\r\n-   *重要发展用户腰部价值用户占比较高，L2-L4等级用户占比85%;*\r\n-   *重要挽留用户L0-L2占比53%，L3-L4等级45%；*\r\n-   *一般发展用户L0-L2占比76%， L3-L4等级24%;*\r\n-   *低价值的用中长期收入价值低比例占据较大，L0-L2等级及以下用户占84%; L3-L4占比16%*"
    },
    {
        "article_id": "7189468004723146809",
        "snapshot": "",
        "title": "【青听第1期】Nice 兔 meet u 写码抽奖直播预约开始啦",
        "preview": "1月19日晚19:30，来「青听」直播间，一起来看从抽奖代码开始写起的抽奖活动，在线 code review，体验互联网公司“码味十足”的年会氛围吧🐶",
        "author": "青训营官方账号",
        "view_count": 5160,
        "collect_count": 6,
        "comment_count": 19,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/de432cd6200bc3d3f7d633a3ccd528d8~300x300.image",
        "category": "阅读",
        "content": "或许，你还没有进入过互联网公司工作\r\n\r\n或许，你工作过，但没参加过年会\r\n\r\n或许，你参加过年会，但没有参加过现场写代码抽奖的活动\r\n\r\n**1月19日19:30** 来「青听」直播间，一起来看从抽奖代码开始写起的抽奖活动，在线 code review，体验互联网公司“码味十足”的年会氛围吧🐶\r\n\r\n# 🚀 直播信息\r\n\r\n> 监督月影写抽奖代码，在线 code review\r\n\r\n⏰ **直播时间：** 2023年1月19日（星期四）19:30-20:15\r\n\r\n💁 **邀请嘉宾：** 月影、少壮（掘金插件 & 码上掘金产品负责人）\r\n\r\n🚀 **直播预约地址：** [https://juejin.cn/live/8354609](https://juejin.cn/live/8354609)\r\n\r\n🏠 **参与方式：** 按抽奖规则要求，提前预约并准时观看「青听」直播间，参与直播互动和抽奖\r\n\r\n✅ **面向对象：** 在校大学生\r\n\r\n# ⛳️ 直播流程\r\n\r\n-   技术学习平台推荐 5min\r\n-   程序员的短期 & 长期成长规划 10min\r\n-   在线写代码抽奖 30min\r\n\r\n# 📒 抽奖规则介绍\r\n\r\n> 划重点！！大家必须按以下要求参与直播才能获得中奖资格❤️\r\n\r\n1.  参与抽奖的同学需公开转发直播间链接 or 海报到朋友圈，且转发时间须在中奖时间之前。中奖后，我们将会核验转发截图，不满足转发条件的同学默认放弃中奖资格；\r\n1.  参与写码抽奖的同学必须于2023年1月19日19:00前预约直播（预约时填写的手机号码作为抽奖ID）；\r\n1.  所有参与抽奖的同学观看直播时长必须在20分钟以上（开始观看直播时需登录掘金账号记录观看时长），直播结束后后台记录观看时长小于20分钟的同学将自动取消中奖资格；\r\n1.  写码直播中奖后，中奖同学请于2023年2月3日前联系青训营官方助手填写完整的收件地址；\r\n1.  直播间福利专区中奖的同学需填写完整的收件地址。\r\n\r\n**中奖补充**\r\n\r\n-   奖品发放时间预计在2023年2月10日左右。\r\n-   中奖同学请联系青训营官方助手：微信（liangxz521）or 飞书（梁幸芝）。\r\n\r\n# 🎁 抽奖奖品详情\r\n\r\n> 除了代码抽奖，还有直播间抽奖哦~快来看看你最想拥有的奖品是什么吧～\r\n\r\n| 代码抽奖奖项 | 奖品                  |\r\n| ------ | ------------------- |\r\n| 大展宏兔 | 掘金新年礼盒              |\r\n| 大有前兔 | 掘金季度会员              |\r\n| 前兔似锦 | 掘金 who cares 系列杜邦特包 |\r\n| 兔年大吉 | 掘金 YOYO 抱枕          |\r\n| 兔然暴富 | 掘金马克杯               |\r\n\r\n| 直播间抽奖奖项    | 奖品                |\r\n| ---------- | ----------------- |\r\n| 健康有我       | 无绳跳绳              |\r\n| Warm 兔 You | 保暖套装（羽绒围巾+福袜 * 2） |\r\n\r\n🎁 奖品图片（糟了，是心动啊～）\r\n\r\n| ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a51dd9161b045b39269ae4dd31acd6c~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb34386b4524eadbf4b10f8cca4d27d~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8d96dfb49e4c23a5e6b9e6dc0eae7b~tplv-k3u1fbpfcp-zoom-1.image) |\r\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccccb1dd6c4c44eea8377ccae07fa505~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5572f45239a3459ba50cb092c2eaca93~tplv-k3u1fbpfcp-zoom-1.image) | ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3759108434040c384e832482e0f1324~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n中奖名单公示：https://juejin.cn/post/7190364067205709880/\r\n\r\n希望大家新的一年健康平安，学习进步~"
    },
    {
        "article_id": "7189788011494637623",
        "snapshot": "",
        "title": "对 Pulsar 集群的压测与优化",
        "preview": "这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如： 一键创建一个测试集群。 运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。 模拟压测，输出",
        "author": "crossoverJie",
        "view_count": 801,
        "collect_count": 4,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/4cec00e951d8bb54909fe2cdaa135384~300x300.image",
        "category": "后端",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1f2c0165c0435fbe497abd0c3f242a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n# 前言\r\n这段时间在做 MQ（Pulsar）相关的治理工作，其中一个部分内容关于消息队列的升级，比如：\r\n- 一键创建一个测试集群。\r\n-  运行一批测试用例，覆盖我们线上使用到的功能，并输出测试报告。\r\n- 模拟压测，输出测试结果。\r\n\r\n本质目的就是想直到新版本升级过程中和升级后对现有业务是否存在影响。\r\n\r\n\r\n\r\n一键创建集群和执行测试用例比较简单，利用了 `helm` 和 `k8s client` 的 SDK 把整个流程串起来即可。\r\n\r\n# 压测\r\n其实稍微麻烦一点的是压测，`Pulsar` 官方本身是有提供一个压测工具；只是功能相对比较单一，只能对某批 topic 极限压测，最后输出测试报告。\r\n最后参考了官方的压测流程，加入了一些实时监控数据，方便分析整个压测过程中性能的变化。\r\n\r\n## 客户端 timeout\r\n\r\n随着压测过程中的压力增大，比如压测时间和线程数的提高，客户端会抛出发送消息 timeout 异常。\r\n\r\n```java\r\norg.apache.pulsar.client.api.PulsarClientException$TimeoutException: \r\nThe producer pulsar-test-212-20 can not send message to the topic persistent://my-tenant/my-ns/perf-topic-0 within given timeout : createdAt 82.964 seconds ago, firstSentAt 8.348 seconds ago, lastSentAt 8.348 seconds ago, retryCount 1\r\n```\r\n\r\n而这个异常在生产业务环境的高峰期偶尔也出现过，这会导致业务数据的丢失；所以正好这次被我复现出来后想着分析下产生的原因以及解决办法。\r\n\r\n## 源码分析客户端\r\n\r\n既然是客户端抛出的异常所以就先看从异常点开始看起，其实整个过程和产生的原因并不复杂，如下图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd224338fe04bf9af33f5e1d8e6e61a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n客户端流程：\r\n1. 客户端 producer 发送消息时先将消息发往本地的一个 pending 队列。\r\n2. 待 broker 处理完（写入 bookkeeper) 返回 ACK 时删除该 pending 队列头的消息。\r\n3. 后台启动一个定时任务，定期扫描队列头（头部的消息是最后写入的）的消息是否已经过期（过期时间可配置，默认30s)。\r\n4. 如果已经过期（头部消息过期，说明所有消息都已过期）则遍历队列内的消息依次抛出 `PulsarClientException$TimeoutException` 异常，最后清空该队列。\r\n\r\n服务端 broker 流程：\r\n1. 收到消息后调用 bookkeeper API 写入消息。\r\n2. 写入消息时同时写入回调函数。\r\n3. 写入成功后执行回调函数，这时会记录一条消息的写入延迟，并通知客户端 ACK。\r\n4. 通过 broker metric 指标 `pulsar_broker_publish_latency` 可以获取写入延迟。\r\n\r\n\r\n从以上流程可以看出，如果客户端不做兜底措施则在第四步会出现消息丢失，这类本质上不算是 broker 丢消息，而是客户端认为当时 broker 的处理能力达到上限，考虑到消息的实时性从而丢弃了还未发送的消息。\r\n\r\n# 性能分析\r\n\r\n通过上述分析，特别是 broker 的写入流程得知，整个写入的主要操作便是写入 bookkeeper，所以 bookkeeper 的写入性能便关系到整个集群的写入性能。\r\n\r\n极端情况下，假设不考虑网络的损耗，如果 `bookkeeper` 的写入延迟是 0ms，那整个集群的写入性能几乎就是无上限；所以我们重点看看在压测过程中 `bookkeeper` 的各项指标。\r\n\r\n\r\n## CPU\r\n首先是 CPU：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f40a9a5800554327ba6274324e5e427d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n从图中可以看到压测过程中 CPU 是有明显增高的，所以我们需要找到压测过程中 bookkeeper 的 CPU 大部分损耗在哪里？\r\n\r\n这里不得不吹一波阿里的 arthas 工具，可以非常方便的帮我们生成火焰图。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf1b5f3d4924e43b91b04b61be5516e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n分析火焰图最简单的一个方法便是查看顶部最宽的函数是哪个，它大概率就是性能的瓶颈。\r\n\r\n在这个图中的顶部并没有明显很宽的函数，大家都差不多，所以并没有明显损耗 CPU 的函数。\r\n\r\n此时在借助云厂商的监控得知并没有得到 CPU 的上限（limit 限制为 8核）。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5c324bd638b4215a31d6b7840d12324~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n---\r\n使用 arthas 过程中也有个小坑，在 k8s 环境中有可能应用启动后没有成功在磁盘写入 pid ，导致查询不到 Java 进程。\r\n\r\n```java\r\n$ java -jar arthas-boot.jar\r\n[INFO] arthas-boot version: 3.6.7\r\n[INFO] Can not find java process. Try to pass <pid> in command line.\r\nPlease select an available pid.\r\n```\r\n此时可以直接 `ps` 拿到进程 `ID`，然后在启动的时候直接传入 `pid` 即可。\r\n\r\n```java\r\n$ java -jar arthas-boot.jar 1\r\n```\r\n通常情况下这个 `pid` 是 1。\r\n\r\n## 磁盘\r\n\r\n既然 CPU 没有问题，那就再看看磁盘是不是瓶颈；\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b47bdd37f3402db72146873849a72f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到压测时的 IO 等待时间明显是比日常请求高许多，为了最终确认是否是磁盘的问题，再将磁盘类型换为 SSD 进行测试。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aafbc6a6fa9405695a936ae3a922326~tplv-k3u1fbpfcp-zoom-1.image)\r\n果然即便是压测，SSD磁盘的 IO 也比普通硬盘的正常请求期间延迟更低。\r\n\r\n既然磁盘 IO 延迟降低了，根据前文的分析理论上整个集群的性能应该会有明显的上升，因此对比了升级前后的消息 TPS 写入指标：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf7b7aabbe64a789bd9ea0076f3ec33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n升级后每秒的写入速率由 40k 涨到 80k 左右，几乎是翻了一倍（果然用钱是最快解决问题的方式）；\r\n\r\n> 但即便是这样，极限压测后依然会出现客户端 timeout，这是因为无论怎么提高服务端的处理性能，依然没法做到没有延迟的写入，各个环节都会有损耗。\r\n\r\n# 升级过程中的 timeout\r\n还有一个关键的步骤必须要覆盖：模拟生产现场有着大量的生产者和消费者接入收发消息时进行集群升级，对客户端业务的影响。\r\n\r\n根据官方推荐的升级步骤，流程如下：\r\n\r\n- Upgrade Zookeeper.\r\n- Disable autorecovery.\r\n- Upgrade Bookkeeper.\r\n- Upgrade Broker.\r\n- Upgrade Proxy.\r\n- Enable autorecovery.\r\n\r\n其中最关键的是升级 Broker 和 Proxy，因为这两个是客户端直接交互的组件。\r\n\r\n本质上升级的过程就是优雅停机，然后使用新版本的 docker 启动；所以客户端一定会感知到 Broker 下线后进行重连，如果能快速自动重连那对客户端几乎没有影响。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13c7139552f04dc89c9529caec787524~tplv-k3u1fbpfcp-zoom-1.image)\r\n在我的测试过程中，2000左右的 producer 以 1k 的发送速率进行消息发送，在 30min 内完成所有组件升级，整个过程客户端会自动快速重连，并不会出现异常以及消息丢失。\r\n\r\n而一旦发送频率增加时，在重启 Broker 的过程中便会出现上文提到的 timeout 异常；初步看起来是在默认的 30s 时间内没有重连成功，导致积压的消息已经超时。\r\n\r\n经过分析源码发现关键的步骤如下：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/078f76f4102e47309df0fde74915b468~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n客户端在与 Broker 的长连接状态断开后会自动重连，而重连到具体哪台 Broker 节点是由 `LookUpService` 处理的，它会根据使用的 topic 获取到它的元数据。\r\n> 理论上这个过程如果足够快，对客户端就会越无感。\r\n\r\n在元数据中包含有该 topic 所属的 bundle 所绑定的  Broker 的具体 IP+端口，这样才能重新连接然后发送消息。\r\n\r\n> bundle 是一批 topic 的抽象，用来将一批 topic 与 Broker 绑定。\r\n\r\n而在一个 Broker 停机的时会自动卸载它所有的 bundle，并由负载均衡器自动划分到在线的 Broker 中，交由他们处理。\r\n\r\n这里会有两种情况降低 LookUpSerive 获取元数据的速度：\r\n\r\n因为所有的 Broker 都是 stateful 有状态节点，所以升级时是从新的节点开始升级，假设是`broker-5`，假设升级的那个节点的 bundle 切好被转移 `broker-4`中，客户端此时便会自动重连到 4 这个Broker 中。\r\n\r\n此时客户端正在讲堆积的消息进行重发，而下一个升级的节点正好是 4，那客户端又得等待 bundle 成功 unload 到新的节点，如果恰好是 3 的话那又得套娃了，这样整个消息的重发流程就会被拉长，直到超过等待时间便会超时。\r\n\r\n还有一种情况是 bundle 的数量比较多，导致上面讲到的 unload 时更新元数据到 zookeeper 的时间也会增加。\r\n\r\n\r\n> 所以我在考虑 Broker 在升级过程中时，是否可以将 unload 的 bundle 优先与 `Broker-0`进行绑定，最后全部升级成功后再做一次负载均衡，尽量减少客户端重连的机会。\r\n\r\n# 解决方案\r\n\r\n如果我们想要解决这个 timeout 的异常，也有以下几个方案：\r\n1. 将 bookkeeper 的磁盘换为写入时延更低的 SSD，提高单节点性能。\r\n2. 增加 bookkeeper 节点，不过由于 bookkeeper 是有状态的，水平扩容起来比较麻烦，而且一旦扩容再想缩容也比较困难。\r\n3. 增加客户端写入的超时时间，这个可以配置。\r\n4. 客户端做好兜底措施，捕获异常、记录日志、或者入库都可以，后续进行消息重发。\r\n4. 为 bookkeeper 的写入延迟增加报警。\r\n5. Spring 官方刚出炉的 Pulsar-starter 已经内置了 producer 相关的 metrics，客户端也可以对这个进行监控报警。\r\n\r\n以上最好实现的就是第四步了，效果好成本低，推荐还没有实现的都尽快 `try catch` 起来。\r\n\r\n\r\n整个测试流程耗费了我一两周的时间，也是第一次全方位的对一款中间件进行测试，其中也学到了不少东西；不管是源码还是架构都对 `Pulsar` 有了更深入的理解。\r\n"
    },
    {
        "article_id": "7174065718386753543",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aa022410f98455fafee98e7c230c1e4~tplv-k3u1fbpfcp-watermark.image?",
        "title": "另类年终总结：在煤老板开的软件公司实习是怎样一种体验？",
        "preview": "某个编剧曾经说过：“怀念煤老板，他们从不干预我们创作，除了要求找女演员外，没有别的要求。”，现在的我毕业后正式工作快半年了，手上的活越来越多，负责的事项越来越多越来越杂，偶尔夜深人静走在回家的路上，也",
        "author": "日暮与星辰之间",
        "view_count": 10466,
        "collect_count": 18,
        "comment_count": 58,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f7c730a02295d5704194422bb27f8509~300x300.image",
        "category": "代码人生",
        "content": "某个编剧曾经说过：“怀念煤老板，他们从不干预我们创作，除了要求找女演员外，没有别的要求。”，现在的我毕业后正式工作快半年了，手上的活越来越多，负责的事项越来越多越来越杂，偶尔夜深人静走在回家的路上，也怀念当时在煤老板旗下的软件公司实习时无忧无虑的快乐生活，谨以此文纪念一下当时的时光。\r\n\r\n## 煤老板还会开软件公司？\r\n\r\n是的，煤老板家大业大，除了名下有几座矿之外，还有好多处农场、餐厅、物流等产业，可以说涉足了多个产业。当然最赚钱的主业还是矿业，听坊间传闻说，只要矿一开，钱就是哗哗的流进来。那么这个软件公司主要是做什么的呢，一小部分是给矿业服务的，负责矿山的相关人员使用记录展示每天矿上的相关数据，比如每天运输车辆的流转、每日矿上人力的核算。大部分的主力主要用于实现老板的雄伟理想，通过一个超级APP，搞定衣食住行，具体的业务如下，可以说是相当红火的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933ac790ac3e40ba8037f45249669c2c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 煤老板的软件公司是怎么招聘的\r\n\r\n这么有特色的一家公司，我是如何了解到并加入的呢。这还要从老板如何创立这家公司说起，老板在大学进修MBA的时候，认识了大学里计算机学院的几名优秀学子，然后对他们侃侃而谈自己的理念和对未来的设想，随后老板大笔一挥，我开家公司，咱们一起创业吧，钱我出，你们负责出技术。然后这几个计算机学院的同学，就携带着技术入股成为了这家软件公司的一员。随着老板的设想越来越丰富，最初进去的技术骨干也在不停的招兵买马，当时还是流行在QQ空间转发招聘信息。正是在茫茫动态中，多看了招聘信息一眼，使得该公司深深留在我的印象当中。后来我投递的时候，也是大学同学正在里面实习，于是简历直达主管。\r\n\r\n## 面试都问了些啥\r\n\r\n由于公司还处于初创阶段，所以没有那么复杂的一面二面三面HR面，一上来就是技术主管们来一个3对1面，开头聊聊大家都是校友，甚至可能还是同一个导师下的师兄弟，所以面试相对来说就没有那么难，问一问大学里写过的大作业项目，聊一聊之前实习做的东西，问一问熟悉的八股文，比如数据库事务，Spring等等，最后再关切的问一下实习时间，然后就送客等HR通知了。\r\n\r\n## 工作都需要干啥\r\n\r\n正如第一张图所示，公司的产品分成了几个模块，麻雀虽小，五脏俱全，公司里后端、前端、移动端、测试一应具全。我参与的正是公司智慧餐饮行业线的后端开发，俗称Java CRUD boy。由于公司里一众高薪招揽过来的开发，整体采用的开发理念还是很先进的。会使用sprint开发流程，每周一个迭代，就是发版上线还是不够devops，需要每周五技术leader自己启动各个脚本进行发版，将最新的代码启动到阿里云服务机器上。 虽然用户的体量不是很大，但是仍然包含Spring Cloud分布式框架、分库分表、Redis分布式锁、Elastic Search搜索框架、DTS消息传输复制框架等“高新科技”。每周伊始，会先进行需求评审，评估一下开发需要的工作量，随后就根据事先制定的节奏进行有条不紊的开发、测试、验收、上线。虽然工作难度不高，但是我在这家公司第一次亲身参与了产品迭代的全流程，为以后的实习、找工作都添加了一些工作经验。\r\n\r\n  \r\n\r\n\r\n因为是实习嘛，所以基本上都是踩点上班、准时下班。不过偶尔也存在老板一拍脑袋，说我们要两周造一个电子商城的情况，那个时候可真是加班加点，披星戴月带月的把项目的简易版本给完成、上线了。但是比较遗憾的是，后面也没有能大范围投入使用。\r\n\r\n  \r\n\r\n\r\n比如下面的自助借伞机，就是前司的一项业务，多少也是帮助了一些同学免于淋雨。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508d09f3d86c4eb095b0c2d5e018de25~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 画重点，福利究竟有多好\r\n\r\n首先公司的办公地点位于南京市中心，与新街口德基隔基相望。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db54ea0a112047059e37b20dbf3ccfc3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n\r\n每天发价值88元的内部币，用于在楼下老板开的餐厅里点餐，工作套餐有荤有素有汤有水果，可以说是非常的上流了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec830e25f38c4db28b4cd04b8586a9f7~tplv-k3u1fbpfcp-zoom-1.image)![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3427552fa9f04234b4bbc969c9c67a74~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果不想吃工作套餐，还可以一起聚众点餐，一流的淮扬菜式，可以说非常爽了。 听说在点餐系统刚上线还没有内部币时，点餐是通过白名单的方式，不用付钱随便点。可惜我来晚了，没有体验到这么个好时候。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7136a05ae514074ad337985a82ceb7e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n工作也标配imac一整套，虽然不好带走移动办公，但是用起来依然逼格满满。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16a4954ac33c4132a86ed71e404c996c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n熟悉的健身房福利当然少不了，而且还有波光粼粼的大泳池，后悔没有利用当时的机会多去几次学会游泳了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/927cebce450a43f292ea8523611cdbb6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n除了这些基础福利之外，老板给的薪资比肩BAT大厂，甚至可能比他们还高一丢丢，在南京可以生活的相当滋润了。\r\n\r\n## 既然说的这么好，那么为啥没有留下来呢。\r\n\r\n唯一的问题当然是因为公司本身尚未盈利，所有这一切都依赖老板一个人的激情投入，假如老板这边出了啥问题，那整个公司也就将皮之不存，毛将焉附了。用软件领域的话来说，就是整个系统存在单点故障。所以尽管当时的各种福利很好，也选择离开找个更大的厂子先进去锻炼锻炼。\r\n\r\n最后希望前老板矿上的生意越来越好，哪天我在外面卷不动了，还能收留我一下。\r\n\r\n> 我是日暮与星辰之间，创作不易，求关注，求点赞，求收藏，技术路漫漫，欢迎和我交流。\r\n\r\n我的其他文章⬇️\r\n\r\n[从Offer收割机到延毕到失业再到大厂996，二零二二我的兵荒马乱 - 掘金](https://juejin.cn/post/7175408432374579255)\r\n\r\n[第一次值守双十一，居然没有任何意外发生？！ - 掘金](https://juejin.cn/post/7167370134980395039)\r\n\r\n[大厂996三个月，我曾迷失了生活的意义，努力找回中 - 掘金](https://juejin.cn/post/7159960105759277070)\r\n\r\n[阿里实习三个月，我学会了面试时讲好自己的项目，欢迎提问 - 掘金](https://juejin.cn/post/7154551709103521799)\r\n\r\n[迟到的苏州微软实习历险记 - 掘金](https://juejin.cn/post/7153938601036742664)\r\n\r\n[什么时候要用到本地缓存，比Redis还要快？怎么用？ - 掘金](https://juejin.cn/post/7146946847465013278)\r\n\r\n[把数据库里的未付款订单改成已付款，会发生什么 - 掘金](https://juejin.cn/post/7144378128914186270)\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」"
    },
    {
        "article_id": "7184971142321406007",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b035b59845149c3ba053a4908906335~tplv-k3u1fbpfcp-watermark.image?",
        "title": "HelloGitHub 最受欢迎的开源项目 Top10（2022年）",
        "preview": "再见 2022，你好 2023！ HelloGitHub 也随着 2023 年的到来，更新到了第 81 期 开始迈向第 7 个年头啦。 在过去的 2022 年，我们一共发布了 12 期月刊、分享了 5",
        "author": "HelloGitHub",
        "view_count": 10265,
        "collect_count": 55,
        "comment_count": 4,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/28/169c31b06dcd6e90~tplv-t2oaga2asx-image.image",
        "category": "开发工具",
        "content": "再见 2022，你好 2023！\r\n\r\nHelloGitHub 也随着 2023 年的到来，更新到了[第 81 期](https://mp.weixin.qq.com/s/OaqWhEIaM2S5t-TnunpWmA) 开始迈向第 7 个年头啦。\r\n\r\n在过去的 2022 年，我们一共发布了 12 期月刊、分享了 502 个开源项目，HelloGitHub 能够分享这么多有趣、好玩的开源项目，离不开开源爱好者的推荐、项目作者的自荐以及团队成员的贡献。在 2022 年发布过的众多开源项目中，你最喜欢哪个开源项目呢？哪些开源项目让你印象深刻？\r\n\r\n下面就让我们一起来看看 2022 年[《HelloGitHub 月刊》](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzA5MzYyNzQ0MQ==&scene=1&album_id=1331197538447310849&count=3&scene=21#wechat_redirect)最受欢迎的 10 个开源项目，为了尽量涵盖较多的类别，就从 C++、Python、Java、JavaScript、Go、C#、C、Rust、CSS 每个类别挑选一个组成了 **Top10 开源项目**。排名并不重要，重要是的是不能让你错过这些好玩的开源项目。\r\n\r\n话不多说，开始今年的 HelloGitHub 年度盘点！\r\n\r\n## 1、《金庸群侠传》C++ 复刻版\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96bcbdb5ef3b40a0a52ef2f8d80e986a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：1.9K｜**编程语言**：C++\r\n\r\n这是一款基于 SDL2 开发的 2D 游戏，作为《金庸群侠传》C++ 复刻版，它的资源大部分来自《金庸群侠传》DOS 版本，复刻版除了经典的回合制战斗系统，还在加入了受《黑帝斯》启发的即时战斗系统。或许大佬们的重温经典，就是用自己擅长的编程语言把游戏重新实现一遍吧。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64ea2ace62bb4c2a9a1b0e52c7a046dc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/scarsty/kys-cpp\r\n\r\n\r\n## 2、异步的 Python 聊天机器人框架\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0275005234ce401e82dbe9f06e0ac442~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：3.2K｜**编程语言**：Python\r\n\r\n它是基于 Python 的异步特性构建的聊天机器人框架，可以轻松处理大量的消息。还提供了命令行脚手架，仅用几条命令就可以完成项目搭建。支持多种 IM 平台，有效地帮助开发人员快速构建聊天机器人、消息通知等项目。该项目代码质量高、社区活跃，它上得了生产环境，下能搞定一次性脚本。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7e8e1ea18d45638ba6515462eaf894~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/nonebot/nonebot2\r\n\r\n\r\n## 3、JVM 沙箱容器\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d26ff71585a45eda84426c7c7e696bf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：5.5K｜**编程语言**：Java\r\n\r\n这是一种 JVM 的非侵入式运行期 AOP 解决方案。简单地说就是如果线上 Java 服务出现故障，需要加一条日志定位问题，通过该项目就可以在不重启服务的情况下，完成增加日志的操作。它还支持线上故障模拟、请求录制和结果回放等功能。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ede4831c949f49e1b379bd6049859708~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/alibaba/jvm-sandbox\r\n\r\n\r\n## 4、称手的 JSON 可视化工具\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffdf3f9d7d44406aa53452533ea4eaa9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：20.6K｜**编程语言**：TypeScript\r\n\r\n一款改变你查看 JSON 数据习惯的工具，它不是简单地格式化 JSON 数据，而是将其数据转化成节点，通过类似脑图的形式展示。支持放大/缩小、展开/收缩、搜索节点、导出图片等操作，你还可以通过部署服务，将它变成免费的在线服务。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b974959948e14575997e3ca59127f237~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/AykutSarac/jsoncrack.com\r\n\r\n\r\n## 5、极简的订阅工具\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b6124d9b49453e937e5c8cd8867bb0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：4.4K｜**编程语言**：Go\r\n\r\n一个极简主义的 feed 阅读器，它的“简”是由内而外，内部代码部分不使用 Web 框架和 ORM 仅采用 Go+PostgreSQL+JS 实现，界面朴实无华、功能精简实用，支持快速自建、源管理、自动获取内容、快捷键、用户系统等，这一切不多不少刚刚好。Go 初学者可以通过阅读不依赖任何框架、“纯粹”的 Go 代码，看清 Web 开发的原理。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e45186cb709e4073bac4e5a6d164b51e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/miniflux/v2\r\n\r\n\r\n## 6、强大的媒体库管理工具\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f31e942de2d94906bb75c7943ca484ee~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：19.2K｜**编程语言**：C#\r\n\r\n一款完全免费、支持中文、安装简单、跨平台、功能齐全的媒体库管理系统。它能把原本躺在文件夹里的视频文件，变成包含封面、描述、评分、演员表等信息的“影碟”，让视频整整齐齐、赏心悦目，还支持视频续播、订阅更新、多端可看，让你可以远离广告优雅地追剧。要说缺点的话，我感觉就是得花时间折腾一番才能感受到它的魅力。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1c9c484a6f424bad4f206f050a9be5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/jellyfin/jellyfin\r\n\r\n## 7、好玩的 GB 游戏制作工具\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/510a475a350942f4af14ae5155c37a36~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：6.7K｜**编程语言**：C\r\n\r\n这是一款可视化开发游戏的工具，可用于快速构建复古冒险游戏。通过该项目可以实现仅仅拖拽的方式，就能制作出复古风格的 Game Boy 游戏，不会编程也可以开发游戏。还支持导出 ROM 或发布成在线游戏，适用于 macOS、Linux 和 Windows 操作系统。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c39d3137f84931acc5a33363edda4d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/chrismaltby/gb-studio\r\n\r\n\r\n## 8、Markdown 电子书构建工具\r\n\r\n**Star 数**：11.6K｜**编程语言**：Rust\r\n\r\n该项目是 Rust 官方开源的制作 Markdown 电子书工具，功能上类似 Gitbook。它可以将 Markdown 文件制作成在线书籍，支持代码高亮、可集成搜索、多主题等功能，简单易用非常适合创建教程、API 文档、开源书籍等。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a18b68f8b334c32bfec16d08703f246~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/rust-lang/mdBook\r\n\r\n\r\n## 9、按钮样式集合\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aff6c76100f446bd88ab26113a5772c4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：2.6K｜**编程语言**：CSS\r\n\r\n该项目提供了 100 种不同样式按钮的 CSS 源码，不仅如此还支持在线查看效果以及调试。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45d4e4598bcc4a6e8bae7a41b63941ef~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/ui-buttons/core\r\n\r\n\r\n## 10、大学计算机没有的一课\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0cb54979b3441ca952590e1db831627~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**Star 数**：3.3K｜**编程语言**：Other\r\n\r\n大学里的计算机课程往往只专注于讲授数据结构、操作系统这些知识，对于编程开发中常用的工具则留给学生自行学习。在 MIT 这个课程中，你可以了解和掌握命令行(shell)、文本编辑器(Vim)、版本控制系统(Git)等强大的工具，越早接触越能更加熟练地使用它们，有助于未来的职业生涯。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eca656e4e45b446a921756149cab74d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 地址：https://github.com/missing-semester/missing-semester\r\n> \r\n> 中文：https://missing-semester-cn.github.io/\r\n\r\n\r\n## 最后\r\n\r\nHelloGitHub 的年度 Top10 榜单，并不是简单地根据项目访问数拉个表单就完事儿了。\r\n\r\n为了让更多人在 HelloGitHub 找到喜欢的开源项目，不管擅长什么编程语言、职业是学生还是程序员。我多花了几倍的时间，从多个主流分类中挑选出几个较为受欢迎的几个开源项目，然后根据大家的评价、留言、访问比等数据层层筛选，最终每个分类只留一个开源项目，反复多次才制作出这个榜单。\r\n\r\nHelloGitHub 一直秉承着分享 GitHub 上有趣、入门级的开源项目，我们做的一切都是为了：\r\n\r\n**让你找到喜欢的开源项目，爱上开源参与开源。**\r\n\r\n一切美好风景都在路上，希望你和开源最美的那张合影上有 HelloGitHub。\r\n\r\n由于篇幅有限，还有很多优秀的项目没能入选，你可以在往期的[《HelloGitHub 月刊》](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzA5MzYyNzQ0MQ==&scene=1&album_id=1331197538447310849&count=3&scene=21#wechat_redirect)中找到它们。\r\n\r\n以上就是本文的所有内容，如果您觉得这篇文章写得还不错，就请给我点一个**赞**，您的支持就是我更新的动力。我们下期见～"
    },
    {
        "article_id": "7189133830681264188",
        "snapshot": "",
        "title": "2022年终感悟-时光债务",
        "preview": "回顾2022，展望2023，过去虽然一路坎坷，但是我们依然需要一路往前，绝不退缩，因为我们退无可退。",
        "author": "思想觉悟",
        "view_count": 835,
        "collect_count": 0,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/7cf27144faf34e0f3b22e122bde08ac7~300x300.image",
        "category": "代码人生",
        "content": "\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\r\n\r\n# 前言 \r\n\r\n首先说明一下，这可以算是我2022年的总结感悟，或许会有些许的负能量，介意的小伙伴建议直接关闭阅读。\r\n\r\n其实不是很想写年终总结，因为总感觉转眼间一年又过去，自己还是一事无成，除了打工还是打工，甚至如果倒霉遇上了`降本增效（也就是裁员）`，那么打工都变成了一中奢侈，也没什么可写的。后来想想无论过得如何，\r\n这都终将过去，成为自己生活中不可磨灭的一段过往，很应该被记录下来。\r\n\r\n# 这恶心的疫情  \r\n\r\n感觉这一年的疫情比以往的两年都让人寒心，幸运的是总有在2022的年末迎来了疫情防控的转折变化。都说疫情是一面照妖镜，照出百态人生。 面对疫情，有的人借机发“guo难财”；有的人默默付出竭尽所能；有的人在防控中感到崩溃，无处呐喊。或许这就是人生吧，\r\n在灾难面前，所有的人都会将人性表现得淋漓尽致。\r\n\r\n身处广州，在疫情放开的黎明之前，经历了一波一个多月的封控，天天捅喉咙，做核酸几乎成了比吃饭还重要的任务。从最初的保住个绿码退一步变成保住黄码也行，然后再退到红码就红码吧，别阳了就好，就这样一步步退到无路可退，最终还是阳了。真的是那样，困难不会因为\r\n你的退却让步而不降临到你的头上，有的时候面对困难迎难而上才是最好的解决方法。\r\n\r\n在疫情封控最严重的时候，社区都叮嘱说红码人员不能出门，会有相关工作人员上门服务，可这恶心的疫情传播速度远远超出了防控的速度，最后我所在社区也让红码的人可以出门做核酸了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479aa4b71743401ba7828347751c6b09~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n随着年末的防控措施放开，又来了全民屯药抢药，全民分`羊`。记得刚放开返工两天我就发烧不舒服了，那时候已经买不到药和抗原检测了，靠着以前留下的布洛芬和感冒药扛了过去康复了，因为没有做过抗原检测，\r\n所以至今为止我都不确定自己是否已经羊过了，只是所有的症状都与羊的人吻合。\r\n\r\n自己阳康后最担心的依然是在老家的老婆和孩子，一再祈祷老家尽量不要那么`全民分羊`，想着老家这个n线的小县城，最快的高峰也得元旦左右吧，然而事实恨恨得打了我的脸，大概是在12月20号左右，老婆和孩子就高烧不断了，后面请了六天的事假，加上元旦的三天假期回老家照顾他们。\r\n\r\n因为孩子还小，刚上幼儿园，又是易感高危人群，所以很令人担心，发烧到39度多的时候带他去医院，排了一个下午的队最终的结果是医院也没有布洛芬混悬液了，只能开一点点（注意是一点点）其他的退烧给我带回家。所以后面某些人说下面这句话的时候，我是不信的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6026f095308415483a75bbe3abc88f6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n想了很多办法也没有弄到小孩子专用的布洛芬混悬液，最终在某个公益互助平台上弄到了一瓶小孩专用的布洛芬混悬液。至于怎么弄到的，我只能说天下没有免费的午餐，某公益平台的出发点是好的，\r\n但是工具能发挥出什么样的作用，在于使用工具的是什么样的人。是的huang牛无处不在。。。\r\n\r\n现在家人已康复，希望后续不要再感染，但愿这疫情永远消去。。。\r\n\r\n# 所谓的降本增效  \r\n\r\n裁员依然是今年的住旋律啊，好像从19年开始裁员的风波就没断过，只是每年的说法不一样而已，都快被资本家们玩出花来了，还是记得19年的时候裁员是怎么说的吗？\r\n\r\n> 华为：放弃平庸员工。  \r\n百度：鼓励狼性，淘汰小资。  \r\n蔚来：局部优化，提高运营效率。  \r\n科大讯飞：提前吃饭的员工需要被优化。  \r\n京东：淘汰掉因身体原因不能拼搏的员工。  \r\n马云：未来每年将会向社会输出1000名在阿里工作10年以上的人才\r\n\r\n今年的说法是降本增效，年年说法不一样，实际上的行动结果都一样，就是裁员。。。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170373b286df460da51998bbc123bae8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n# 技术输出  \r\n\r\n这一年依然坚持原创，估计写了有40+原创博文吧，虽然质量不咋的，但是数量还算过得去吧。但是我都是佛系更新，也不参加各种更文活动，因此没什么周边奖品(估计参加了也没有)。\r\n\r\n年初的时候写过一篇flag: \r\n\r\n[新的一年打工人再出发](https://mp.weixin.qq.com/s/6Kw95Uv8HJWDq0SweGoVzQ)\r\n\r\n里面有提到过2022年里自己下午的输出文章方向大概有以下几个：\r\n\r\n+ C++进阶巩固\r\n+ JNI编程入门\r\n+ 音视频挖坑指南\r\n+ OpenGL ES入门\r\n\r\n目前依然没有全部完成，新的一年继续吧。\r\n\r\n下面是一些2022年博文集合，感兴趣的小伙伴可以一起学习：\r\n\r\n[《FFMpeg系列学习》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2MDkzMTExMQ==&action=getalbum&album_id=2357000653161562114#wechat_redirect)\r\n\r\n[《Opengl系列学习》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2MDkzMTExMQ==&action=getalbum&album_id=2547163144436023297#wechat_redirect)\r\n\r\n[《C++系列学习》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2MDkzMTExMQ==&action=getalbum&album_id=1799160741871058947#wechat_redirect)\r\n\r\n[《NDK系NDK列学习》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2MDkzMTExMQ==&action=getalbum&album_id=2346213106646974464#wechat_redirect)\r\n\r\n[《Android Camera应用开发》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI2MDkzMTExMQ==&action=getalbum&album_id=2536895401975578625#wechat_redirect)\r\n\r\n# 奔跑的生活 \r\n\r\n都说三十而立，2023我就要33了还没立。我的老家在粤西的一个小县城，工作在广州，所以经常周末就老家和工作地两头跑。一般是周五下班坐大巴回家，大概是半夜一两点到家，然后周日下午三四点坐大巴返回广州准备新的一周打工生活，大部分情况下是一个月回两次这样子。\r\n\r\n2022年的9月份儿子终于上幼儿园了，听老师反馈说他几乎是班上最捣蛋最令人开心的一个孩子，说实在的，其实自己内心最希望的还是他能健康成长，开心快乐。\r\n\r\n由于他不怎么喜欢吃饭，所以比较瘦小，经常生病啥的，估计他也是班上请假最多的了吧，希望新的一年孩子们都能健康成长，有个好的体质吧。\r\n\r\n# 未来 \r\n\r\n结了婚，有了妻子，然后有了孩子，你父母也老了，你如何护他们周全？如果给他们想要的生活？未来会怎么样，我真的不知道，我经常在想我这一生估计也就这样了，至少目前来看我是没有看到可以导致生活质量发生好的质变的的希望。。。\r\n\r\n作为一名大龄普通程序员，偶尔也会焦虑，特别是在不断的`降本增效`的大环境之下以及贩卖焦虑的人群推动下，这种焦虑越发强烈。所以程序员的最终归宿是啥？买课程？开滴滴？送外卖？反正我渠道太少，信息太差，也想不到好的出路。\r\n\r\n一开始我们的梦想都是很伟大的，犹如`为天地立心，为生民立命，为往圣继绝学，为万世开太平。` 后来渐渐的我的梦想成了脱贫，解决温饱，问题处在哪里了呢？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd90ab4e4157420ba8ed6b13f81cdb33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这能怪谁呢？如其不争呗。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7855a9891b74e699f000b61e6378bb9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n或许对于我来说不是缺少目标，缺少驱动力，而是缺少执行力吧，比如大学时浪费的时光，单身没成家前所浪费的时光等。如今回头看这些时光才是人成长最快的时段，却被我白白地浪费掉了。\r\n面对这些浪费掉的时光，后续如果想要继续追赶，务必要付出多于先前几倍甚至几十倍的努力，仅仅是为了偿还哪些自己不努力奋斗所欠下的时光债务。。。\r\n\r\n既然这样，哪能怎么办？落子无悔，自己选择的路跪着也要走完，如果在前进的过程中发现自己选择的路错了，那么及时止损，亡羊补牢为时未晚。种一棵树最好的时机是十年前，其次是现在，\r\n错了就错了，及时调整方向，重新整装待发吧。\r\n\r\n引用笔者很有感触的两句话作为结尾吧。\r\n\r\n一句是罗翔老师说的：  \r\n> 要么努力到出类拔萃，要么懒惰得乐知天命，最怕你见识打开了，可努力又跟不上，股子里清高至极，性格上软弱无比\r\n\r\n一句是《山月记》中的摘录：  \r\n> 我深怕自己本非美玉，故而不敢加以刻苦琢磨，却又半信自己是块美玉，故又不肯庸庸碌碌，与瓦砾为伍。\r\n> 于是我渐渐地脱离凡尘，疏远世人，结果便是一任愤懑与羞恨饲育着内心那怯弱的自尊心。其实，任何人都是驯兽师，而那野兽，无非就是个人的性情而已。\r\n"
    },
    {
        "article_id": "7189806951650295868",
        "snapshot": "",
        "title": "RPC框架泛化调用原理及转转的实践",
        "preview": "泛化调用实现方式及原理，各种实现方案的优缺点，并分享了泛化调用在转转的实践。有助于RPC框架使用方理解泛化调用，更好地使用泛化调用；对于有自研RPC框架需求的开发者在选择泛化调用实现方案上有一定参考",
        "author": "转转技术团队",
        "view_count": 895,
        "collect_count": 4,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/5569c2276ef448736bde1221ea5fc846~300x300.image",
        "category": "后端",
        "content": "RPC框架泛化调用功能在网关、接口测试等场景下有着广泛的需求，本文给各位读者介绍一下主流的泛化调用实现方式及原理，比较各种实现方案的优缺点，并分享泛化调用在转转的实践。一方面有助于RPC框架使用方理解泛化调用，更好地使用泛化调用；另一方面对于有自研RPC框架需求的开发者在选择泛化调用实现方案上有一定参考意义。\r\n\r\n## 1 普通RPC调用\r\n基于动态代理技术，RPC框架客户端做到了调用RPC方法与调用本地方法相同的体验。一般情况下服务端定义服务接口，并将接口打包到二方jar包发布。服务端在服务进程中实现该接口，而调用方在进程中根据该接口创建动态代理进行调用，与调用本地方法体验一致。\r\n\r\n例如有接口`HelloService`，被打包在`demo-service-interfaces.jar`包中。\r\n```java\r\npublic interface HelloService {\r\n    String hello(String name);\r\n}\r\n```\r\n服务端依赖`demo-service-interfaces.jar`，创建`HelloServiceImpl`实现该接口。\r\n```java\r\npublic class HelloServiceImpl implements HelloService {\r\n    @Override\r\n    public String hello(String name) {\r\n        return \\\"hello, \\\" + name;\r\n    }\r\n}\r\n```\r\n客户端同样依赖`demo-service-interface.jar`，创建`HelloService`的代理类，以下为代码示例，实际上创建代理类，发送接口、参数，接收返回结果等操作都是封装在框架内的。\r\n```java\r\nHelloService helloService = (HelloService)Proxy.newProxyInstance(this.getClass().getClassLoader(), HelloService.class, (InvocationHandler) (proxy, method, args) -> {\r\n    //都是封装在框架内的\r\n    //获取方法、参数类型\r\n    String methodName = method.getName();\r\n    Class<?>[] parameterTypes = method.getParameterTypes();\r\n    //发送方法、参数类型和实参到服务端并返回结果\r\n    return request(methodName, parameterTypes, args);\r\n});\r\nString result = helloService.hello(\\\"jack\\\");\r\nSystem.out.println(result);\r\n```\r\n## 2 网关、接口测试等场景下的需求\r\n由上文可以看到普通的RPC调用需要将接口类（参数和返回值如果是POJO类型同样需要一起打包）打到一个jar包中，被服务方和调用方共同依赖。这种方式在多大数业务场景中是适用的，且更加方便，因为所依赖的接口jar包是可枚举的。\r\n\r\n但是在一些特殊的场景下依赖接口jar包变得很不方便，比如网关、接口测试平台等。例如使用http网关代理私有协议RPC请求，如果在网关中依赖接口jar包，那么在新增方法或者接口时网关需要重新编译上线。而接口测试平台需要对全公司所有的RPC接口进行测试，将全公司所有的接口jar包添加到测试平台的依赖中显然是不可行的。\r\n\r\n在这些场景下就诞生了对泛化调用的需求。\r\n\r\n## 3 泛化调用\r\n**泛化调用就是在不依赖服务方接口jar包的情况下进行调用，包括对调用方法的泛化、参数的泛化和返回值的泛化**。\r\n```\r\npublic interface GenericService {\r\n    Object $genericInvoke(String methodName, String[] parameterTypes, Object[] args);\r\n}\r\n```\r\n在没有接口类依赖的情况下，`parameterTypes`需要通过字符串指定，而`args`和返回值如果是`jdk`内置类型的话与普通调用无异，而如果是`POJO`类型的话则需要寻找一种通用的表示方法。\r\n\r\n下普通RPC调用的序列化与反序列化原理，如下图所示，实际上序列化框架在将`POJO`序列化成字节数组之前需要解析`POJO`的类结构生成序列化中间体，当然序列化中间体并非一定能在序列化框架中找到对应的类，有时候这个中间体是虚拟的。\r\n\r\n![普通RPC调用序列化原理](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ece71f8f649b4c559be6ddaed3db1e7b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 3.1 基于Java Bean的泛化调用\r\n\r\n基于`Java Bean`的泛化调用是通过统一的`Java Bean`描述符（`JavaBeanDescriptor`）来描述`POJO`对象，它工作在序列化层之上，例如`dubbo`支持该种类型的泛化调用，在使用泛化调用时，直接传递`JavaBeanDescriptor`对象作为参数，基本原理如下图所示。\r\n\r\n![Java Bean泛化调用](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae5d0c748f0b46dabf7699f669d19a16~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n该泛化调用的实现通用性比较强，与底层序列化无关，但是复杂度较高，需要RPC框架处理`POJO`和`JavaBeanDescriptor`之间的转换。\r\n\r\n### 3.2 基于序列化中间体的泛化调用\r\n支持基于序列化中间体的泛化调用的RPC框架典型的如`sofa-rpc`，使用了`sofa-hessian`序列化框架，`sofa-hessian`是在`hessian`序列化框架基础上进行二次开发的，抽象出了序列化中间体，如`GenericObject`、`GenericMap`、`GenericArray`等。\r\n\r\n转转RPC框架在支持泛化调用时也参考了`sofa-hessian`的实现，对`hessian`序列化框架进行二次开发，并且有所改进。\r\n\r\n![基于序列化中间体的泛化调用](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36273218910d45f2b88cc1ed925a3d02~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而`json`序列化天然具备序列化中间体，即`JsonObject`或者`json String`，在使用`json`序列化时调用方可以直接将`Json Object`或者`json String`作为参数代替`POJO`进行调用。转转RPC框架也支持基于`json`序列化的泛化调用。\r\n\r\n`dubbo`除了支持基于`Java Bean`的泛化调用，还支持`json-protobuf`泛化调用，也就是说调用方可以使用`json`描述`protobuf`对象，在反序列化时可以将`json`反序列为`protobuf`对象再转换成`POJO`，而这些功能本身是序列化框架所提供，不需要RPC框架做额外的开发支持。\r\n\r\n基于序列化中间体的泛化调用与基于`Java Bean`的泛化调用相比，实现较为简单，有些序列化框架本身原生就支持，或者对序列化框架做简单的二次开发即可实现，缺点是与序列化框架耦合。\r\n\r\n## 4 泛化调用在转转的实践\r\n目前泛化调用在转转公司应用最广泛的领域就是接口测试，我们提供了统一的测试API平台。通过该平台可以使用http + json的方式实现对任意服务、任意节点、任意方法的调用，而测试API平台不需要依赖任何服务的接口jar包。并且API平台也没有依赖RPC框架jar包，因为转转RPC框架实现了在同一个端口上同时兼容私有的二进制协议及公有的http协议，也就是说可以使用http请求来发起RPC调用。\r\n\r\n![泛化调用在转转的应用](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dea7a22634844adab7bf719fb5b737ae~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n同时还支持获取任意服务、任意节点、任意方法参数及返回值的`JsonSchema`,如下代码所示。\r\n```json\r\n{\r\n    \\\"msg\\\": \\\"success\\\",\r\n    \\\"data\\\": {\r\n        \\\"schema\\\": {\r\n            \\\"returnValue\\\": {\r\n                \\\"type\\\": \\\"array\\\",\r\n                \\\"items\\\": {\r\n                    \\\"type\\\": \\\"object\\\",\r\n                    \\\"id\\\": \\\"urn:jsonschema:com:bj58:zhuanzhuan:arch:user:atomic:entity:User\\\",\r\n                    \\\"properties\\\": {\r\n                        \\\"id\\\": {\r\n                            \\\"type\\\": \\\"string\\\"\r\n                        },\r\n                        \\\"userName\\\": {\r\n                            \\\"type\\\": \\\"string\\\"\r\n                        },\r\n                        \\\"userNamePinyin\\\": {\r\n                            \\\"type\\\": \\\"string\\\"\r\n                        },\r\n                        \\\"mock\\\": {\r\n                            \\\"type\\\": \\\"boolean\\\"\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \\\"parameters\\\": {\r\n                \\\"pageNum\\\": {\r\n                    \\\"type\\\": \\\"integer\\\"\r\n                },\r\n                \\\"pageSize\\\": {\r\n                    \\\"type\\\": \\\"integer\\\"\r\n                }\r\n            }\r\n        }\r\n    },\r\n    \\\"code\\\": 0\r\n}\r\n```\r\n未来转转的网关也将基于泛化调用进行开发。\r\n\r\n## 5 总结\r\nRPC框架的泛化调用在网关、测试平台等领域应用广泛，目前主流的泛化调用实现有基于`Java Bean`规范的泛化调用和基于序列化中间体的泛化调用，它们的优缺点分别如下：\r\n- **基于`Java Bean`的泛化调用**：优点是与序列化无关；缺点是RPC框架需要实现`JavaBeanDescriptor`向`POJO`的转换功能，较为复杂。\r\n- **基于序列化中间体的泛化调用**：优点是RPC框架实现简单，序列化框架原生支持或者仅需少量改造；缺点是与特定的序列化框架耦合。\r\n\r\n在开发RPC框架时，具体选择哪种泛化调用实现方式，还需要结合实际情况做出选择。\r\n\r\n---\r\n>关于作者\r\n\r\n王建新，转转架构部服务治理负责人，主要负责服务治理、RPC框架、分布式调用跟踪、监控系统等。爱技术、爱学习，欢迎联系交流。\r\n> 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。\r\n> 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~"
    },
    {
        "article_id": "7189231349759705143",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5d8930d2f143b5b8f510b128f461e3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "方法论：在不是太懂源码的情况下，我是怎么定位源码问题的？",
        "preview": "本篇文章讲解介绍我最近遇到的一个真实例子，在不是太懂源码的情况下，通过自己的一些经验、调试技巧，去定位问题",
        "author": "candyTong",
        "view_count": 1645,
        "collect_count": 11,
        "comment_count": 2,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/33a18c832ad717525f8abda8b4b03a52~300x300.image",
        "category": "前端",
        "content": "在日常开发中，我们多多少少会遇到些问题，有时候是自己的写法有错误，这时候可能就要先检查一遍，看看文档，看看是哪里的问题。\r\n\r\n但有时候也有可能是框架/工具的源码错误，虽然一般这种情况很少发生，因为一般框架/工具都会做了比较多的单元测试，经过开源社区的验证，出错的概率比较少，但也不一定所有情况都能测试到。\r\n\r\n那么，**如果真的认为是源码的 Bug，我们该怎么去定位呢？**\r\n\r\n> 本篇文章讲解介绍我最近遇到的一个真实例子，并通过自己的一些经验、调试技巧，去定位问题\r\n\r\n\r\n\r\n# 发现问题\r\n\r\n在我的某个项目中，当我使用 `pnpm i --fix-lockfile` 时，一定会报如下错误：\r\n\r\n![image-20230115212059866](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5600c9c4dc46f2bedeb9fae238cf57~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n运行 `pnpm i` 的时候，不会报错，只有运行  `pnpm i --fix-lockfile` 会报错。**在一些业务场景下，我们偏向于使用   `pnpm i --fix-lockfile`**，当然我也可以改为用 `pnpm i`，那故事就结束了，全剧终hhh。\r\n\r\n\r\n\r\n当然我还是稍微努力了一下下，准备提个 issue 看看。\r\n\r\n**既然要提 issue，那就得首先觉得它是  pnpm 自身的问题，不是我写的代码有问题**。我个人主要是有以下原因：\r\n\r\n+ 我就是安装个依赖，这能有什么错哦。。。而且它 `pnpm i` 是能安装的\r\n+  `--fix-lockfile` 这个选项，肯定比仅仅使用 `pnpm i` 的场景少，那在极端场景下，**可能 `pnpm` 的单元测试没覆盖到**，有问题也是正常的\r\n+ 我是学过英文的，错误信息很明显就说，`vite@4.0.4_@types+node@17.0.45` 这个**版本解析不出来**，个人感觉应该是要解析成 vite 4.0.4，我 package.json 也是这么写的，pnpm 自己加的其他东西，那肯定不关我的事情呀。而且 pnpm 的 lock 文件也是用 `vite@4.0.4_@types+node@17.0.45`，那是你的问题没错了\r\n+ 错误信息中出现 `@vitejs/plugin-basic-ssl`，有可能是这个包不行，但 `pnpm i` 既然能正常安装，就证明人家本身没问题，是 pnpm 的问题。\r\n\r\n\r\n\r\n因此，我提了个 [issue](https://github.com/pnpm/pnpm/issues/5878)，就贴了个截图，然后写 `pnpm i --fix-lockfile` 安装失败，是解析版本失败了，还贴了 pnpm 的锁文件。\r\n\r\n我觉得我已经写得很明白了，这么一个 package 的版本解析错误问题，作者应该一看就懂。。。了吧\r\n\r\n结果不出所料，作者也看不懂，**让我提供一个最小的复现 Demo**。\r\n\r\n\r\n\r\n这里补充一个知识点，**一般提 issue 的时候，都要带上最小的复现 Demo**，不然人家作者也没办法复现你的问题。\r\n\r\n但是鸭，很多时候，开发者可能遇到问题了，却提供不出来，主要有以下原因：\r\n\r\n+ **项目非常大，不知道哪里有问题**，因此不知道怎么做一个最小复现的 Demo\r\n+ 是公司的项目，**不能将代码提供出去**\r\n\r\n我是两个原因都有，因此不是我不想提供 Demo，而是我也搞不出来。。。因此想碰碰运气，说不定作者一看就知道呢hhh，结果不出所料，还是得提供 Demo。\r\n\r\n**很多人提供不了最小复现 Demo，开源库作者也没办法知道问题**，然后问题就不了了之。\r\n\r\n因此，很多人也只能走到这一步，然后故事就结束了。\r\n\r\n\r\n\r\n但其实不是完全不可能提供一个 Demo，看要不要再努力一下下。**这时候人和人的差别就会显现出来了**。\r\n\r\n+ 有的人可能觉得换一种方式就行了\r\n+ 有的人可能觉得没多大影响，不折腾了\r\n+ 有的人可能觉得，我就是要搞出来。\r\n\r\n\r\n\r\n当我第一次遇到这个问题的时候，我也是抱着，算了不管了\r\n\r\n后来再遇上，真烦，不如提个 issue 碰碰运气吧\r\n\r\n再后来多遇上几次，实在不想忍了，晚上调试一下看看，就花一个晚上，不行拉倒\r\n\r\n\r\n\r\n因此才有了接下来的一些努力。\r\n\r\n> 有时候，你离开源贡献，就只有一念之差。只是，有些人选择放弃，有的人选择再努力一下。\r\n\r\n\r\n\r\n# 调试代码\r\n\r\n光有决心还是没有的，得实际行动。\r\n\r\n但一个巨大的问题摆在面前，**pnpm 的代码我也没看过鸭，调个啥玩意**？？？\r\n\r\n因此，第一个问题，是怎么把 pnpm 源码跑起来调试呢？\r\n\r\n\r\n\r\n## pnpm 源码调试\r\n\r\n之前看了**神光大佬的[调试小册](https://s.juejin.cn/ds/kQuyLjd/)**，学到了很多调试相关的知识，感兴趣的可以学习一下\r\n\r\n一般情况下，**如何知道一个开源仓库要怎么进行调试**呢？\r\n\r\n1. 看仓库的 [CONTRIBUTING.md](https://github.com/pnpm/pnpm/blob/main/CONTRIBUTING.md) 文档，按道理比较常见的开源仓库都会有\r\n2. 找别人总结过调试文章\r\n\r\n\r\n\r\n我随便在掘金，找了一遍[文章](https://juejin.cn/post/7075584391522713613)，毕竟**能调试，能打断点就行**。因此如何调试的问题就解决了。\r\n\r\n这里总结一下：\r\n\r\n+ pnpm i 先安装 pnpm 源码的依赖\r\n+ pnpm run compile，执行源码所有包的构建（pnpm 是 monorepo 仓库）\r\n+ 用 node 执行 pnpm 的入口脚本\r\n\r\n下图是我在 webstorm 的调试配置，`qf-tds-vue-plugins` 是我的项目文件夹，下面配置的意思是，我要在这个文件夹运行以下命令（因为是在项目目录安装依赖）：\r\n\r\n```shell\r\n# 实际上 pnpm i，也是运行全局安装的 pnpm 目录下的 bin/pnpm.cjs\r\nnode /candy/app/pnpm/pnpm/bin/pnpm.cjs i --fix-lockfile\r\n```\r\n\r\n![image-20230115220835421](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/923ed5b899154c4ea314b09495ef00af~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n找个地方打个断点，代码能停住（停不住可能是根本没运行这行代码，换个别的），就代表这一步已经成功了\r\n\r\n\r\n\r\n## 定位问题\r\n\r\n> 这一步才是最核心、但又最麻烦的步骤\r\n\r\n**如何在茫茫源码中定位问题？**下面是我的一些个人经验：\r\n\r\n**从错误信息出发，找到报错的代码**\r\n\r\n![image-20230115212059866](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0692353d588f4a5aafef1511743784b5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们**全局搜索关键字**：`isn't supported by any available resolver`，找到是哪一行报错的，找到之后，打个断点。\r\n\r\n![image-20230115222616976](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a54f14a9e9b4079b689635ed5103381~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这就找到了报错源头了。因为 `resolution` 不为真值，所以报错了，那我们的问题就变成了，为什么  `resolution` 不为真值。**这就将很大很抽象的问题，转化成了一个更小更明确的问题**\r\n\r\n`resolution` 是由 `resolveFromNpm` 返回的，那我们就修改一下断点位置\r\n\r\n这里有一个小经验，**断点位置要改到哪里比较好？**有两种方式：\r\n\r\n+ 找到 `resolveFromNpm` 的函数源码实现，在函数实现里面打断点\r\n+ 直接在  `resolveFromNpm` 函数调用的位置打断点。\r\n\r\n我个人**更偏向与在调用的位置打断点**，因为更方便。可以看上图的例子，`resolveFromNpm` 是另一个函数返回的，如果你想要找到它的实现，还得进去 `createNpmResolver` 函数里面找，说不定里面函数比较复杂，就比较麻烦，需要找到 `resolveFromNpm` 函数真正的内部实现，才能打断点 。\r\n\r\n如果是在调用位置打断点，就会在 `resolveFromNpm` 函数调用前停住，此时，我们按进入函数，就能直接找到源码了\r\n\r\n![image-20230115223833870](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f291b9fc744ae98a4c863e0a930c36~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n因此断点会改到这里，但我们运行后会发现，每个 package 都会在这里暂停，一个项目这么多包，不行啊。\r\n\r\n这时候就要用到**条件断点**，**如何设置条件断点呢？可以先观察一下一些变量的值**\r\n\r\n![image-20230115224039257](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b174713ff3c4460a5515ad23299a222~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到 `wantedDependency.pref` 的值为 `4.0.4_@types+node@17.0.45`，那就用这个了。断点的条件就设置为\r\n\r\n```\r\nwantedDependency.pref === '4.0.4_@types+node@17.0.45'\r\n```\r\n\r\n这就能在出错前将代码定住了，然后我们进入函数\r\n\r\n![image-20230115223644290](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c5876c4ca54ad2aaff8aec89bec6a9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n进入 `resolveFromNpm` 调试，然后发现 `spec` 为 null，所以函数 return null 了，因此又可以将**问题转化**：为什么 `spec` 会使 null？\r\n\r\n那就要排查 `parsePref` 函数了，还是用上述的思路，打断点，进入函数，\r\n\r\n同样的，按照上述思路就是 `parsePref` 函数的问题了，这里就不重复了。\r\n\r\n最后发现，是 `wantedDependency.pref` 这个属性，应该为 `4.0.4`，才能使后面的代码不报错，而不是 `4.0.4_@types+node@17.0.45` \r\n\r\n\r\n\r\n那接下来的问题就转化成了： `wantedDependency.pref` 为什么不为 `4.0.4`？我们**需要找到 `wantedDependency.pref` 被赋值的地方**\r\n\r\n\r\n\r\n下面又是一些经验：\r\n\r\n+ 全局搜索 `.pref =`，是为了所有出 `wantedDependency.pref = xxx` 的这些代码\r\n+ 全局搜索 ` pref:`（注意前面有空格），这个是为了搜索 `{ pref: xxx }` 的代码\r\n\r\n\r\n\r\n不过很可惜，在 pnpm 中都搜不到太多有用的信息，那就只能通过调试找了。接下来该怎么办呢？\r\n\r\n![image-20230115225040250](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9b3ee1112a14339a06165d2d2908f05~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们可以**利用函数的调用栈**，逐级往上找，调试方法跟之前一样，目标是，找到 `wantedDependency.pref` 被赋值的地方。\r\n\r\n> 有较多调试经验的开发者，也可以不逐级网上找，如果觉得肯定不会在当前函数层级被赋值，可以直接跳到更深的函数调用层级中\r\n\r\n最终，我找到了整个 wantedDependency 初始化的地方：`resolveDependency` 函数。\r\n\r\n这里我直接回顾一下整个错误的相关信息：\r\n\r\n1. `@vitejs/plugin-basic-ssl` 在安装 vite 的时候，遇到了版本解析错误，`4.0.4_@types+node@17.0.45`\r\n2. 在 `resolveDependency` 函数中，会解析 `@vitejs/plugin-basic-ssl` 的 package.json。直接注意的是，它的 **package.json 没有 dependencies 字段**\r\n3. pkg 对象根据 package.json 生成，这一句代码中，**由于 `pkg.dependencies` 不存在，因此会导致使用了锁文件的 `dependencies` 字段**，这是不应该的，导致取了锁文件的 vite 版本号`4.0.4_@types+node@17.0.45` 。\r\n\r\n![image-20230115230449621](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819b02af0f29459ebfd13c52c93c8733~tplv-k3u1fbpfcp-zoom-1.image)既然知道了这个，我们就知道了这个错误出现的场景：\r\n\r\n1. **装了多个 Vite**，有的 Vite 版本号是 `4.0.4`，有的是 `4.0.4_@types+node@17.0.45` ，出现多个 Vite 的原因，是因为 `peerDependencies`，感兴趣可以查看官网的[说明文档](https://pnpm.io/how-peers-are-resolved)\r\n2. `@vitejs/plugin-basic-ssl`  的 **`dependencies` 字段不存在**（不是为空，是不存在）\r\n\r\n\r\n\r\n只有同时满足以上条件才会报错，因此很多非 monorepo 仓库，都不会有这个问题，因为它们只装了一个 Vite。\r\n\r\n当我知道了以上信息之后，我就可以提供一个最小的可复现 Demo 了\r\n\r\n\r\n\r\n不过，我觉得既然都看到这里了，**不如尝试一下自己修复**。\r\n\r\n直觉告诉我，只要加一点代码就行了，判断 `pkg.dependencies`是否为空，为空就设置为 `{}`\r\n\r\n```javascript\r\nif (!pkg.dependencies) {\r\n    pkg.dependencies = {}\r\n}\r\n```\r\n\r\n然后我把出错原因写到了 issue 中，顺便提了个 pull request 给开源作者，然后被告知需要补一下单元测试（这也的确是正常且稳妥的做法），至于后续单元测试怎么补，就不是本文该关心的问题了，以后有机会再聊。\r\n\r\n\r\n\r\n# 总结\r\n\r\n本文用我个人的例子，从发现问题，到调试代码，一步步地深入，直到最终找到问题。里面用到了很多调试相关的技巧，**这些技巧可以帮助我们，即使在不熟悉源码的情况下，也能深入源码进行定位问题**\r\n\r\n这些技巧主要包括以下这些：\r\n\r\n+ **全局搜索查找关键词/错误信息**，找到相关的源码\r\n+ **转化问题**，将大的抽象问题，变小变具体\r\n+ **在合理的位置打断点**\r\n+ 巧用**条件断点**，巧妙的设置断点条件\r\n+ 利用**函数调用栈**\r\n\r\n当然，仅仅有技巧也不行，你需要有**解决问题的决心**。那么，当你遇到问题时，你是选择避开它，还是选择解决它呢？\r\n\r\n如果这篇文章对您有所帮助，**可以点赞加收藏**👍，您的鼓励是我创作路上的最大的动力。也可以关注我的公众号订阅后续的文章：**[Candy 的修仙秘籍](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28e3ed86c0584e78b42b35dd4776e780~tplv-k3u1fbpfcp-zoom-1.image)**（点击可跳转）\r\n\r\n"
    },
    {
        "article_id": "7189833406602018877",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548375aab3244c6281484708ef3fe034~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Calcite SQL 解析、语法扩展、元数据验证原理与实战（上）",
        "preview": "本文第一部分介绍如何基于 Calcite 实现一个简单的 SQL 解析器并扩展其语法，并将外部数据库的 SQL 语法转换成 Calcite 内部的解析体系。第二部分将介绍 SQL 验证的流程和如何验证",
        "author": "Aloudata技术团队",
        "view_count": 1074,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6fff9323cf98de8b0d55ae8cb762e483~300x300.image",
        "category": "后端",
        "content": "## **引言**\r\n\r\n  \r\n\r\n\r\nApache Calcite 是一个动态数据管理框架，其中包含了许多组件，例如 SQL 解析器、SQL 验证器、SQL 优化器、SQL 生成器等。因为 Calcite 的体系结构并不支持数据的存储和处理，**所以 Calcite 天然具备了在多种计算引擎和存储格式之间作为“中介者”的能力。** 前文《一条 SQL 的查询优化之旅》提到，SQL 的查询是从 SQL 解析和 SQL 验证开始的，所以本文将围绕这两个话题展开。\r\n\r\n### **目标和收益**\r\n\r\n  \r\n\r\n\r\n本文第一部分介绍**如何基于 Calcite 实现一个简单的 SQL 解析器并扩展其语法，** 并将外部数据库的 SQL 语法转换成 Calcite 内部的解析体系。第二部分将**介绍 SQL 验证的流程和如何验证扩展的 SQL，如自定义函数等。**\r\n\r\n  \r\n\r\n\r\n## **一、基于 Calcite 实现一个自定义 SQL 解析器**\r\n\r\n  \r\n\r\n\r\n### **1.1 Calcite SQL 解析器介绍**\r\n\r\n  \r\n\r\n\r\nCalcite 默认使用 JavaCC 生成 SQL 解析器，可以很方便的将其替换为 Antlr 作为代码生成器 。JavaCC 全称 Java Compiler Compiler，是一个开源的 Java 程序解析器生成器，生成的语法分析器采用递归下降语法解析，简称 LL(K)。主要通过一些模版文件生成语法解析程序（例如根据 .jj 文件或者 .jjt 等文件生产代码）。\r\n\r\nCalcite 的解析体系是将 SQL 解析成抽象语法树， Calcite 中使用 SqlNode 这种数据结构表示语法树上的每个节点，例如 \\\"select 1 + 1 = 2\\\" 会将其拆分为多个 SqlNode。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcd6034ef9774973bf69cefb2ab1ffe9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n\r\n**SqlNode 有几个重要的封装子类，SqlLiteral、SqlIdentifier 和 SqlCall。** SqlLiteral：封装常量，也叫字面量。SqlIdentifier：SQL 标识符，例如表名、字段名等。SqlCall：表示一种操作，SqlSelect、SqlAlter、SqlDDL 等都继承 SqlCall。\r\n\r\n### **1.2 实现一个简单自定义 SQL Parser**\r\n\r\n  \r\n\r\n\r\nCalcite 提供了一个默认的 SQL 语法解析器，默认支持的语法可以查看此文档：[https://calcite.apache.org/docs/reference.html](https://link.zhihu.com/?target=https%3A//calcite.apache.org/docs/reference.html)，除了默认语法外，Calcite 还提供了其他 SQL 语法的兼容，例如 STRICT_92、STRICT_99、STRICT_2003、MYSQL_5、ORACLE_12 等，这部分可参考 Calcite 源码 SqlConformanceEnum 类。\r\n\r\n**如果 Calcite 解析器并不能满足我们的需求，需要扩展语法操作怎么办呢？**\r\n\r\n第一种方法是直接修改 Calcite 源码，添加我们需要的语法实现。但这种方式显然对 Calcite 的侵入性太强，并不是最优的办法。\r\n\r\n第二种方法是采用模版引擎来扩展 SQL 语法，相比第一种侵入性更小，达到了解耦的目的。\r\n\r\nCalcite 支持使用 FreeMarker 模版引擎扩展语法，下图是 Calcite 源码中通过模版引擎扩展 SQL 语法的相关目录结构。\r\n\r\n  \r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7b3d07c122f4b6fa05d6065b290b2aa~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  \r\n\r\n\r\n其中，templates 文件夹下的 Parser.jj 作为模版，includes 目录下是扩展语法文件，config.fmpp 作为整体的配置，包含定义解析器类名、导入扩展语法文件和自定义关键字等。\r\n\r\n**所以我们实现自定义 SQL Parser 的步骤为：**\r\n\r\n-   获取 Calcite 源码中的 Parser.jj 文件，将此文件作为模版用于后续扩展。\r\n-   编写自定义 SQL 扩展语法文件和配置文件。\r\n-   使用 JavaCC 编译。\r\n\r\n  \r\n\r\n\r\n### **1.2.1 获取 Calcite 源码中的 Parser.jj 文件**\r\n\r\n  \r\n\r\n\r\n使用 Maven 插件 maven-dependency-plugin 直接从 Calcite 源码包中进行拷贝，将 Parser.jj 文件拷贝到项目构建目录下。\r\n\r\n```\r\n<plugin>\r\n    <groupId>org.apache.maven.plugins</groupId>\r\n    <artifactId>maven-dependency-plugin</artifactId>\r\n    <executions>\r\n        <execution>\r\n            <id>unpack-parser-template</id>\r\n            <phase>initialize</phase>\r\n            <goals>\r\n                <goal>unpack</goal>\r\n            </goals>\r\n            <configuration>\r\n                <artifactItems>\r\n                    <artifactItem>\r\n                        <groupId>org.apache.calcite</groupId>\r\n                        <artifactId>calcite-core</artifactId>\r\n                        <version>1.31.0</version>\r\n                        <type>jar</type>\r\n                        <overWrite>true</overWrite>\r\n                        <outputDirectory>${project.build.directory}/</outputDirectory>\r\n                        <includes>**/Parser.jj</includes>\r\n                    </artifactItem>\r\n                </artifactItems>\r\n                <skip>false</skip>\r\n            </configuration>\r\n        </execution>\r\n    </executions>\r\n</plugin>\r\n```\r\n\r\n  \r\n\r\n\r\n可以使用 mvn initialize 进行命令测试，**如果成功我们会在 target 目录下找到拷贝的语法模版文件。**\r\n\r\n### **1.2.2 自定义 SQL 语法**\r\n\r\n  \r\n\r\n\r\n我们可以仿照 Calcite 在代码目录中**创建 codegen 目录结构，新建一个 .ftl 文件，** 下面以 Trino 的 CREATE MATERIALIZED VIEW 为例，演示如何在 Calcite 中新增这个语法：\r\n\r\n```\r\n/*为了演示方便 SQL语法有所简化*/\r\nCREATE MATERIALIZED VIEW\r\n[ IF NOT EXISTS ] view_name\r\nAS query\r\n```\r\n\r\n**第一步，新增一种 SqlCall，** 新建一个类继承 SqlCall，实现构造方法并重写 unparse()，unparse()方式是 SqlNode 的解析器，负责将 SqlNode 转换为 Sql。getOperator() 方法返回当前 SqlNode 的操作符类型，所有的操作符类型可以在 org.apache.calcite.sql.SqlKind 中找到，CREATE MATERIALIZED VIEW 显然是一种扩展的 DDL，应该返回 SqlKind.OTHER_DDL，getOperandList() 返回操作符列表，这里我们可以返回物化视图的名字和 AS 后面的语句，用于自定义 DDL 的校验。\r\n\r\n```\r\npublic class CreateMaterializedView\r\n        extends SqlCall\r\n{\r\n    public static final SqlSpecialOperator CREATE_MATERIALIZED_VIEW = new SqlSpecialOperator(\\\"CREATE_MATERIALIZED_VIEW\\\", SqlKind.OTHER_DDL);\r\n    SqlIdentifier viewName;\r\n    boolean existenceCheck;\r\n    SqlSelect query;\r\n\r\n    public CreateMaterializedView(SqlParserPos pos, SqlIdentifier viewName, boolean existenceCheck, SqlSelect query)\r\n{\r\n        super(pos);\r\n        this.viewName = viewName;\r\n        this.existenceCheck = existenceCheck;\r\n        this.query = query;\r\n    }\r\n\r\n    @Override\r\n    public SqlOperator getOperator()\r\n{\r\n        return CREATE_MATERIALIZED_VIEW;\r\n    }\r\n\r\n    @Override\r\n    public List<SqlNode> getOperandList()\r\n{\r\n        List<SqlNode> operands = new ArrayList<>();\r\n        operands.add(viewName);\r\n        operands.add(SqlLiteral.createBoolean(existenceCheck, SqlParserPos.ZERO));\r\n        operands.add(query);\r\n        return operands;\r\n    }\r\n\r\n    @Override\r\n    public void unparse(SqlWriter writer, int leftPrec, int rightPrec)\r\n{\r\n        writer.keyword(\\\"CREATE MATERIALIZED VIEW\\\");\r\n        if (existenceCheck) {\r\n            writer.keyword(\\\"IF NOT EXISTS\\\");\r\n        }\r\n        viewName.unparse(writer, leftPrec, rightPrec);\r\n        writer.keyword(\\\"AS\\\");\r\n        query.unparse(writer, leftPrec, rightPrec);\r\n    }\r\n}\r\n```\r\n\r\n**第二步，编写语法文件，** 在 codegen/includes 目录下新建 parserImpls.ftl 文件。语法文件内容如下：\r\n\r\n```\r\nSqlNode SqlCreateMaterializedView() :\r\n{\r\n    SqlParserPos pos;\r\n    SqlIdentifier viewName;\r\n    boolean existenceCheck = false;\r\n    SqlSelect query;\r\n}\r\n{\r\n    <CREATE> { pos = getPos(); }\r\n    <MATERIALIZED> <VIEW>\r\n    <#-- [] 代表里面的元素可能出现 -->\r\n        [ <IF> <NOT> <EXISTS> { existenceCheck = true; } ]\r\n    <#-- CompoundIdentifier() 为 Calcite 内置函数，\r\n    可以解析类似 catalog.schema.tableName 这样的全路径表示形式 -->\r\n    viewName = CompoundIdentifier()\r\n    <AS>\r\n    <#-- SqlSelect() 为 Calcite 内置函数，解析一个 select sql -->\r\n    query = SqlSelect()\r\n    {\r\n        return new CreateMaterializedView(pos, viewName, existenceCheck, query);\r\n    }\r\n}\r\n```\r\n\r\n  \r\n\r\n\r\n**第三步，配置 config.fmpp 文件，** 在 codegen 目录下新建 config.fmpp 文件。定义解析器的包名和类型，声明新增的关键字和解析方法等。\r\n\r\n```\r\ndata: {\r\n  parser: {\r\n    package: \\\"com.aloudata.demo.parser.impl\\\",\r\n    class: \\\"DemoSqlParserImpl\\\",\r\n\r\n    imports: [\r\n        \\\"com.aloudata.tardis.parser.CreateMaterializedView.CreateType\\\"\r\n    ]\r\n\r\n    keywords: [\r\n        \\\"IF\\\",\r\n        \\\"MATERIALIZED\\\"\r\n    ]\r\n\r\n    statementParserMethods: [\r\n        \\\"SqlCreateMaterializedView()\\\"\r\n    ]\r\n\r\n    implementationFiles: [\r\n        \\\"parserImpls.ftl\\\"\r\n    ]\r\n  }\r\n}\r\n\r\nfreemarkerLinks: {\r\n  includes: includes/\r\n}\r\n```\r\n\r\n  \r\n\r\n\r\npackage 和 class 就是 JavaCC 生成的解析器的类名和包路径。imports 中需要导入语法文件中使用到的 Java 类，keywords 关键字只需包含 Calcite 原生不存在的即可，statementParserMethods 应包含解析的入口方法，implementationFiles 中为自定义语法文件名，freemarkerLinks.includes 为自定义语法文件相对路径。\r\n\r\n### **1.2.3 JavaCC 编译**\r\n\r\n  \r\n\r\n\r\n使用 FreeMarker 模版插件**根据 config.fmpp 生成 parser.jj 文件**，最后使用 JavaCC 编译插件生成最终的解析器代码。\r\n\r\n-   **配置 FreeMarker 插件**\r\n\r\nMaven 配置中 <cfgFile> 表示 config.fmpp 文件路径。<outputDirectory> 表示输出路径。<templateDirectory> 表示从 Calcite 拷贝的模版文件路径。配置好后**可以使用 mvn generate-resources 命令测试是否生成了新的 parser.jj 文件。**\r\n\r\n```\r\n<plugin>\r\n      <groupId>com.googlecode.fmpp-maven-plugin</groupId>\r\n      <artifactId>fmpp-maven-plugin</artifactId>\r\n      <version>1.0</version>\r\n      <configuration>\r\n          <cfgFile>src/main/codegen/config.fmpp</cfgFile>\r\n          <outputDirectory>target/generated-sources/fmpp<outputDirectory>\r\n          <templateDirectory>${project.build.directory}/codegen/templates</templateDirectory>\r\n      </configuration>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.freemarker</groupId>\r\n            <artifactId>freemarker</artifactId>\r\n            <version>2.3.28</version>\r\n        </dependency>\r\n    </dependencies>\r\n    <executions>\r\n        <execution>\r\n            <id>generate-fmpp-sources</id>\r\n            <phase>generate-sources</phase>\r\n            <goals>\r\n                <goal>generate</goal>\r\n            </goals>\r\n        </execution>\r\n    </executions>\r\n</plugin>\r\n```\r\n\r\n  \r\n\r\n\r\n-   **配置 JavaCC 插件**\r\n\r\n```\r\n<plugin> <!-- generate the parser (Parser.jj is itself generated wit fmpp above) -->\r\n    <groupId>org.codehaus.mojo</groupId>\r\n    <artifactId>javacc-maven-plugin</artifactId>\r\n    <version>2.6</version>\r\n    <executions>\r\n        <execution>\r\n            <id>javacc</id>\r\n            <phase>generate-sources</phase>\r\n            <goals><goal>javacc</goal></goals>\r\n            <configuration>\r\n                <sourceDirectory>${project.build.directory}/generated-sources/fmpp</sourceDirectory>\r\n                <includes>\r\n                    <include>**/*.jj</include>\r\n                </includes>\r\n                <lookAhead>1</lookAhead>\r\n                <isStatic>false</isStatic>\r\n                <outputDirectory>${project.build.directory}/generated-sources/javacc</outputDirectory>\r\n            </configuration>\r\n        </execution>\r\n    </executions>\r\n</plugin>\r\n```\r\n\r\n  \r\n\r\n\r\n<sourceDirectory> 为 FreeMarker 生成的模版文件路径。后续再次执行 mvn generate-resources 命令，**在 <outputDirectory> 标签配置的路径下会生成解析器相关的类。** 至此，整个自定义解析器就基本完成了。\r\n\r\n-   **测试**  \r\n\r\n\r\n**我们可以写一段简单的测试代码：**\r\n\r\n```\r\n@Test\r\n    public void test() throws SqlParseException {\r\n        String sql = \\\"CREATE MATERIALIZED VIEW IF NOT EXISTS \\\"test\\\".\\\"demo\\\".\\\"materializationName\\\" AS SELECT * FROM \\\"system\\\"\\\";\r\n\r\n        SqlParser.Config myConfig = SqlParser.config()\r\n                .withQuoting(Quoting.DOUBLE_QUOTE)\r\n                .withQuotedCasing(Casing.UNCHANGED)\r\n                .withParserFactory(DemoSqlParserImpl.FACTORY);\r\n        SqlParser parser = SqlParser.create(sql, myConfig);\r\n        SqlNode sqlNode = parser.parseQuery();\r\n        assertTrue(sqlNode instanceof CreateMaterializedView);\r\n        System.out.println(sqlNode);\r\n    }\r\n```\r\n\r\n  \r\n\r\n\r\n**输出：**\r\n\r\n![]()\r\n\r\n  \r\n\r\n\r\n### **1.3 原理**\r\n\r\n  \r\n\r\n\r\n上文介绍时提到，**JavaCC 生成的语法分析器采用递归下降（自顶向下）语法解析**，简称 LL(K)，第一个 L 代表从左到右扫描输入，第二个 L 代表每次都进行最左推导，K 表示每次向右探索 K 个终结符。JavaCC 默认生成 LL(1) 的解析器。\r\n\r\nJavaCC 中的词法分析器会将语句拆分成一系列的子单元，在 JavaCC 中称为 token，语法分析器会拿着这个 token 串以 LL(1) 的方式进行匹配，看是否符合定义的语法结构。描述起来比较抽象，下面举个例子：\r\n\r\n例如 Total = price + tax; 这个语句，JavaCC 会将整条语句拆分成以下5个 token。\r\n\r\n  \r\n\r\n\r\n![]()\r\n\r\n  \r\n\r\n\r\n### **1.3.1 自顶向下 LL(1) 分析基本流程**\r\n\r\n  \r\n\r\n\r\n上下文无关文法是 LL(1) 的充要条件，上下文无关文法的形式定义比较晦涩（可以参考[https://baike.baidu.com/item/](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/)上下文无关文法/2001908），可以简单理解为 A 可以直接推到出 aB （A → aB）是一个上下文无关文法，u A b 推导出 aB （u A b → aB）当 A 的前一个是 u，下一个是 b 的时候才能应用次规则，这样就是上下文有关文法。现在有一种语法：\r\n\r\n```\r\nS –> AB\r\nA –> aA | ε   // ε 代表一个空字符\r\nB –> b |\r\n```\r\n\r\n  \r\n\r\n\r\n上面每一行，形如“A –> aA | ε”的式子称为产生式。产生式左边的符号称为“**非终结符**”，这个符号既可以出现在产生式的左边也可以出现在产生式的右边，位于产生式右边的 'a' 称为“**终结符**”，它意味着无法再产生新的符号，终结符只能出现在产生式右边。同时，上述产生式中有一个特别的非终结符 'S'，这种语法的所有句子都以它为起点产生，这个符号被称为“**起始符号（startsymbol）** ”。\r\n\r\n例如，要分析的句子为 aaab，我们把解析过程和中间句子整理成以下表格：首先从起始符号 S 开始展开到最终语句 aaab，要匹配 aaab 中左边第一个字符 a，S 只能推导为 AB，**所以用 AB 替换 S。**\r\n\r\n| 中间句子 | 要匹配的语句 | 产生式    |\r\n| ---- | ------ | ------ |\r\n| S    | a aab  | S → AB |\r\n| AB   | a aab  |        |\r\n\r\n  \r\n\r\n\r\n由于 A 是非终结符，下面要展开 A，A 有两种产生式 A → aA, A → ε，和要匹配的语句进行比较发现 A → aA 可以匹配第一个字符 a，以此类推前三个 'a' 都可以以这种方式匹配。展开过程如下：\r\n\r\n| 中间句子  | 要匹配的语句 | 产生式    |\r\n| ----- | ------ | ------ |\r\n| S     | a aab  | S → AB |\r\n| AB    | a aab  | A → aA |\r\n| aAB   | a a ab | A → aA |\r\n| aaAB  | aa a b | A → aA |\r\n| aaaAB | aaa b  |        |\r\n\r\n  \r\n\r\n\r\n最后一个 a 匹配结束后，发现只能应用产生式 A -> ε，否则就无法得到 aaab，应用此产生式后得到：\r\n\r\n| 中间句子  | 要匹配的语句 | 产生式    |\r\n| ----- | ------ | ------ |\r\n| S     | a aab  | S → AB |\r\n| AB    | a aab  | A → aA |\r\n| aAB   | a a ab | A → aA |\r\n| aaAB  | aa a b | A → aA |\r\n| aaaAB | aaa b  | A → ε  |\r\n| aaaB  | aaa b  | B →    |\r\n\r\n  \r\n\r\n\r\n最后按照上面的原则尝试展开非终结符 B，最终得到 aaab，**整个语句推导成功。**\r\n\r\n| 中间句子  | 要匹配的语句 | 产生式    |\r\n| ----- | ------ | ------ |\r\n| S     | a aab  | S → AB |\r\n| AB    | a aab  | S → aA |\r\n| aAB   | a a ab | S → aA |\r\n| aaAB  | aa a b | S → aA |\r\n| aaaAB | aaa b  | S → ε  |\r\n| aaaB  | aaa b  | B → b  |\r\n| aaab  | aaab   | ACCEPT |\r\n\r\n  \r\n\r\n\r\n这是一个非常简单的语句推导过程，LL(1) 还会有其他更多的复杂情况与约束，感兴趣可以参考此书的第九章和第十章（[http://pandolia.net/tinyc](https://link.zhihu.com/?target=http%3A//pandolia.net/tinyc)）\r\n\r\n### **1.3.2 LL(1) 的优缺点**\r\n\r\n  \r\n\r\n\r\nLL(1) 分析法的优点是构造方法较简单，且分析速度非常快，每读到第一个符号就可以预测出整个产生式。缺点则是对语法的限制太强，它要求同一个非终结符的不同产生式的首字符集合之间互不相交，否则我们就无法唯一确定一种语法。\r\n\r\n不过，在 JavaCC 编译插件中或语法文件中**可以使用 lookAhead 配置解析时向前探测的 token 数量，也就是修改 LL(K) 中的 K 值，来解决一些语法冲突问题。**\r\n\r\n-   **JavaCC 插件中配置**\r\n\r\n```\r\n<configuration>\r\n  <lookAhead>2</lookAhead>\r\n</configuration>\r\n```\r\n\r\n  \r\n\r\n\r\n-   **词法中使用 lookAhead**  \r\n\r\n\r\n```\r\nSqlNode SqlCreateMaterializedView() :\r\n{\r\n    ...\r\n}\r\n{\r\n    LOOKAHEAD(2)\r\n    ...\r\n}\r\n```\r\n\r\n  \r\n\r\n\r\n### **1.3.3 扩展**\r\n\r\n  \r\n\r\n\r\n与 LL 分析法对应的还有 LR 分析法，**和 LL 正好相反，LR 是从最终表达式向上折叠，直到跟产生式无法再匹配为止。** LR 分析法相比于 LL 来说在普适性方面占有绝对的优势，因为 LR 文法能够支持更多上下文无关文法，并且不需要考虑消除左递归的问题。\r\n\r\n-   **左递归问题**\r\n\r\n左递归：是指形如 A -> A u 这样的规则。\r\n\r\nLL(1) 的分析法无法解决“左递归”问题，这是 LL 解析器的局限，因为一个含左递归的语法（如：A -> Aa | c）中，**必然存在相交的现象。** Antlr4 中的 ALL 解析器解决了左递归问题，但是对于间接左递归仍然无能为力。并且在自顶向下分析法中，左递归的出现对性能的影响极大，因为出现左递归就意味着需要对匹配串进行回溯，而回溯分析一般都非常慢，**所以应该尽量避免这种语法的出现。**\r\n\r\n## **总结**\r\n\r\n  \r\n\r\n\r\n本文介绍了 Calcite SQL 解析模块以及语法扩展的方式，并对 LL(k) 分析法做了简单阐述，以 LL(1) 为例探究了整个分析过程。**下一篇，我们将介绍Calcite SQL 的验证流程与原理，一起探究如何在 SQL 验证阶段进行语法的扩展。**\r\n\r\n钱可以带来快乐，玩技术也可以！最后，如果你对**数据虚拟化、Calcite 原理技术、湖仓平台、SQL 优化器感兴趣的话，欢迎关注“Aloudata技术团队”公众号。**\r\n\r\n  \r\n\r\n\r\n    \r\n  \r\n\r\n\r\n✎ **本文作者/** 淳译，Aloudata OLAP 引擎开发工程师，参与 Aloudata AIR Engine 的多个核心模块开发，目前负责 Aloudata 数据虚拟化引擎的 SQL 层、元数据和多源异构引擎集成等相关工作。"
    },
    {
        "article_id": "7187956951211311141",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb2f0648bbcf48f2a1087cd69adc708e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "读书笔记｜择一城以定财富，择一行以定发展",
        "preview": "题记 “最近个人财政吃紧，想着病急乱投医”，看看理财区有什么好的书籍，然后就用两天时间读完了这本——《钱从哪里来》。",
        "author": "宇宙之一粟",
        "view_count": 2368,
        "collect_count": 3,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/baa731b9560ab7c0d3f2aac5f0a08e56~300x300.image",
        "category": "阅读",
        "content": "## 题记\r\n\r\n“最近个人财政吃紧，想着病急乱投医”，看看理财区有什么好的书籍，然后就用两天时间读完了这本——《钱从哪里来》。\r\n\r\n作者：香帅，本名唐涯，知名金融学者，香帅数字金融工作室创始人，“香帅的金融江湖”公众号创始人，著有畅销书《钱从哪里来：中国家庭的财富方案》、《金钱永不眠：资本世界的暗流涌动》。\r\n\r\n\r\n![wx-cover-235-1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb8e2720917643a4b582f1eae7b0bf13~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n说实话，被这本书吸引是由于这本的名字，其中每一个词都刺激着我的神经：**钱、家庭、财富。**\r\n\r\n钱，谁能不爱？“有钱能使鬼推磨”、“无米寸步难行”类似的句子都在告诉我们它的重要性，那么怎么从来都没人告诉我们：钱怎么来呢？\r\n\r\n家庭，谁都有之甚至需要靠之。人之于这个社会，脱离了家庭，又怎能轻松长大？襁褓中的我们需要的营养、孩童时需要的教育（背后多少家庭争抢的学区房）、甚至是结婚前需要的彩礼新房......\r\n\r\n财富，人人向往之。大家都追逐着财富独立、财富自由，无时不想着在这个时代成为那个生活中的佼佼者。\r\n\r\n书中就提出来这样一个思考：**一个普通家庭该如何积累财富，钱从哪里来？**\r\n\r\n读尽全文，虽然没有读到我想象中的结果，但有了如下的笔记和思考。或许有误，恐贻笑大方，请大家指正。\r\n\r\n## 时代背景之下：工业型往服务型的转化\r\n\r\n中国社会自 1978 年以来最大的一次社会结构变迁：人口集聚方式、经济增长模式、行业发展规律和消费行\r\n\r\n为逻辑都在重构过程中。自然，财富的底层逻辑也会发生巨大改变。改革之后中国高速发展的两种力量：“城镇化”和“全球化下的工业化”。其中，全球化是动因，工业化是主导，城镇化则是工业化的载体。\r\n\r\n出生于 90 年代，只有到过年走亲访友才能感受到家乡的大家从外地回来的热闹。而我的两个舅舅也都是本地的工厂职工，每次去他们那都是过年还有排班要去厂里，小的时候也有一次跟着去体验了一下。在我们那个地方，似乎那个时候“进厂”是一种潮流，不愿意读书可能就会跟着大人选择进厂，外地的工厂也多。那个时候，大部分都选择“进厂打工”，对他们的所见所闻充满好奇。\r\n\r\n2012 年之后，工业的就业人数到了巅峰，之后出现拐点，意味着工业社会的结束，之后人和资本都会离开工业，流向服务业，完成一个结构性的转型。\r\n\r\n这之后，我看到了社会上的话题“年轻人情愿送外卖，不愿意进厂”、“年轻人想要当网红”......\r\n\r\n无谓责怪年轻人是没有意义的，仔细思考这背后的时代背景：工业化兴起的时代，工厂多，选择进工厂能赚钱；第三产业来了，进入服务型社会的现在，近几年我们都可以看到，服务业型的岗位大火，更多人选择：做主播、送快递、美甲美容师...\r\n\r\n一方面我们吐槽大厂对外卖骑手的压榨，但另一方面不得不承认这都是实打实的就业机会。不应该是提供更多的服务业的就业机会吗？为什么还要责怪年轻人不愿意进厂呢？\r\n\r\n放眼未来，服务化继续升级，传统制造业会往高端制造业发展。大量的机会也来与此，更多的岗位会出现，我们不是自己做选择，而是**时代的洪流将我们推向这些领域**。\r\n\r\n## 择一城以定财富\r\n\r\n工业时期，我们选择那些城镇化、工厂多的城市。一家工厂不好做，随时能找到下一家。不经要问，**如此时代背景之下，我们如何选择城市？**\r\n\r\n罗伯特·弗罗斯特说：“一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。”\r\n\r\n关于城市的选择，没有绝对的正确与否。但是我们不可否认的是一线城市的家庭年收入往往是独一档的，不说别的，一线城市的房产价值有目共睹。其次，外来人口流入的也都是一线城市或者省会城市，说明这些都是服务业的肥土，同样是洗剪吹，大城市的 tony 老师是老家的 3-5 倍（高级的甚至更大），美容机构也在这些城市更多。\r\n\r\n对于我们程序员来说，年轻时还有机会选择城市，还算幸运。即使一开始选择了一座自己不喜欢的城市，也可以再选择，前几年我的室友先后待过上海、北京、长沙，如今在杭州。但就 2022 年的情形看来，形势不像往年般简单。当然，能力强的除外，情形再不好大佬总有地方施展拳脚、经济再不好总有富豪能买下豪宅。\r\n\r\n作者说：“城市决定着你财富的上限，也决定着你财富的下限。”想想，也的确如此，一开始能选择大城市，还有机会回到自己生活安逸的小城里，但是一开始选择了小城市，小城的经济形势也就局限在那。想想前二十年的大工厂为什么在省会（城市转型后迁去周边城市），也就能明白前十年的大厂也都诞生于大城市了。\r\n\r\n北上广相信梦想，回家发展非退却。**择一城以定财富，可逐浪大江奔流之向，可心安大江福泽之所。**\r\n\r\n## 择一行以定发展\r\n\r\n快速变化的时代，众多迷茫的年轻人 **，该如何选择职业？** 书中将职业分为两种类型，我这里总结一下概念：\r\n\r\n-   **“滚雪球”** 型职业：雪球越滚越大、雪崩的能量无比巨大。此类职业随着工作年限增加，能力越来越突出\r\n-   **“推石头”** 型职业：西西弗斯一次又一次将巨石推上山顶，年复一年。此类职业做着重复性的工作、可替代性强\r\n\r\n在现代社会，人力资本的积累最重要的来源就是职业。职业选择不仅决定一个人职业生涯的长度和高度，更决定了其财富水平甚至家庭财富的代际传承。\r\n\r\n折旧率是个很有趣的名词。从“生理性人力资本”的角度 看，我们都面临着岁月的折旧一一可乐终将换成枸杞养生茶，从一天睡 4 个小时依然神采奕奕变成一天睡 7 个小时还精神不济，记忆力、爆发力都在下滑，到五六十岁时面临着自然退休。随着时间流逝，这种折旧的速度越来越快，幅度越来越大，最后残值越来越小。所以，职场上的年龄歧视本质上是对生理性折旧的自然反应。\r\n\r\n但“技能型人力资本”不一样。比如，一个人知识、技能 的累积速度超过更新的速度，这类人力资本不但不会随岁月产生折旧耗损——人力资本生理性折旧率很低，反而可能增值。这就是医生、律师、教师这些职业会“**越老越吃香**”的原因。\r\n\r\n所以，对抗人力资本生理性折旧的最好方法就是加大技能型人力资本的积累。这种可以减少人力资本折旧的职业，就是我们要寻找的“**滚雪球型**”职业。\r\n\r\n而像在收费站收费那种重复性的“可编码型”工作(有明确的任务目标、有海量数据储备、工作内容程序化的工作)，几乎没有人力资本增长的空间，人力资本折旧的速度极快，30 多岁就可能折得不剩什么残值了。\r\n\r\n**滚雪球型职业**，一定是使人力资本增速加快、折旧减慢的职业。而我们要找到的就是此类职业，那么如何找到呢？\r\n\r\n现代社会的人类普遍的 3 个特点：怕死、爱美、孤独。因此催生的行业也是最热、最能赚钱的行业：\r\n\r\n-   医疗：医生、护士、健身教练、营养师...\r\n-   美容：美甲师、美容师、造型师...\r\n-   害怕孤独：心理咨询师、养宠物、宠物医生...\r\n\r\n世界从来不是只有一种颜色。每一颗种子都应该找到属于自己的土壤。职业也不是非得追逐热门、选择适合自己的才是最好：\r\n\r\n-   如果你是学霸（要求学历），可以选择做去金融、医生；\r\n-   如果你热爱健身、社交能力强，极度自律、可以选择做健身教练；\r\n-   如果你是个爱美细心的小姑娘，可以选择做美甲师、美容师、服装设计。\r\n-   如果你像李佳琦一样口才出众、热爱美妆，而且具有面白唇红这些禀赋，美妆直播、网红经济也是可选的道路。\r\n\r\n人无法选择先天的禀赋，就像一颗种子不能选择自己的基因和种属一样。但人可以选择城市，犹如蒲公英可以选择落地的土壤——同样的种子，在肥沃的土壤、温润的季候风中结出的果实和在贫瘠的土地上结出的果实是不一样的。\r\n\r\n## 总结：钱从哪里来\r\n\r\n最后，作者说，**财富只是一个结果，背后是一连串关于人和资金的正确决策：职业方向、城市选择、资产配置。**\r\n\r\n实际生活中，钱从哪里来？\r\n\r\n1.  劳动所得，俗称的“人生钱”：打一份工，得一份钱。\r\n\r\n劳动性收入取决于城市选择、职业选择。职业是人力资本积累的平台，会决定个人收入的增长曲线和周期长度，而城市是行业和职业的载体，选择城市，就选择了自己的人力资本孵化器。\r\n\r\n2.  资本性收入，俗称的“钱生钱”：房产、金融产品。\r\n\r\n残酷的事实是人人并非都能成为股神，你我皆是韭菜。\r\n\r\n最后希望看完本文有兴趣的读者，去看看原书，或者阅读以下的推荐文章。觉得文章有用的话，不妨点个关注和收藏，这将是我创作的动力。谢谢！\r\n\r\n推荐阅读：\r\n\r\n-   [唐涯，《钱从哪里来》](https://book.douban.com/subject/34925762/)\r\n-   笔记侠公众号：[2020年，钱从哪里来？](https://mp.weixin.qq.com/s/uIce30aX6zhYMs9ZRiVrZw)"
    },
    {
        "article_id": "7189818918033162277",
        "snapshot": "",
        "title": "Android OpenCV (一) 基础API 清晰度亮度识别",
        "preview": "背景   工作中遇到业务诉求是通过OpenCV对图片进行一些判断操作和优化，这里是看了部分不错的文章，希望总结一个自己的学习过程，温故而知新，有不对的地方可以评论区指出，小白学习海涵。 基础知识 Ma",
        "author": "小肥羊冲冲冲Android",
        "view_count": 449,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/89e140290d0a1d40960fe59e416d06b3~300x300.image",
        "category": "Android",
        "content": "## 背景\r\n&emsp;&emsp;工作中遇到业务诉求是通过OpenCV对图片进行一些判断操作和优化，这里是看了部分不错的文章，希望总结一个自己的学习过程，温故而知新，有不对的地方可以评论区指出，小白学习海涵。\r\n\r\n## 基础知识\r\n\r\nMat在OpenCV中是非常重要的存在，后续各个API都是在Mat的基础上去做文章，Mat 是Matrix（矩阵）的缩写 \r\n\r\n```c++\r\n...\r\ninline\r\nMat::Mat(int _rows, int _cols, int _type)\r\n    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),\r\n      datalimit(0), allocator(0), u(0), size(&rows), step(0)\r\n{\r\n    create(_rows, _cols, _type);\r\n}\r\n\r\ninline\r\nvoid Mat::create(int _rows, int _cols, int _type)\r\n{\r\n    _type &= TYPE_MASK;\r\n    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )\r\n        return;\r\n    int sz[] = {_rows, _cols};\r\n    create(2, sz, _type);\r\n}\r\n\r\n...\r\n\r\n```\r\n**Mat中其实保存着关于图片的图像信息，包括像素、宽、高、类型大小深度等属性。**\r\n\r\n## 主要Api - 加载图片\r\n&emsp;&emsp;由于我这里使用的集团的二方库，读者大佬可以直接在github搜索 OpenCV对应版本，在gradle中添加依赖即可，由于本人是使用的Java代码通过jni调用底层C++代码，大部分api其实是互通的（网上Python教程居多，这也是我想把这个过程总结下来的原因）\r\n\r\n### imread \r\n&emsp;&emsp;该方法主要是获取图片的Mat信息的 默认通道为BGR（Blue, Green, Red），可以有很多flags供我们选择以此达到不同的效果。\r\n```\r\npublic static Mat imread(String filename, int flags) {\r\n       return new Mat(imread_0(filename, flags));\r\n}\r\n\r\n// 调用例子\r\neg:\r\nMat bgr = Imgcodecs.imread(filePath, Imgcodecs.IMREAD_UNCHANGED);\r\nImgproc.cvtColor(bgr, srcMat, Imgproc.COLOR_BGR2RGB);\r\n\r\n//Imgcodecs flags 常用参数含义\r\npublic static final int IMREAD_UNCHANGED = -1;  // 无改动\r\npublic static final int IMREAD_GRAYSCALE = 0;  // 单通道灰色\r\npublic static final int IMREAD_COLOR = 1;  //三通道BGR图像\r\n\r\n```\r\n\r\n### Utils.bitmapToMat\r\n&emsp;&emsp;通过Utils.bitmapToMat方法获取Mat对象。\r\n```\r\n\r\nBitmap bitmap = BitmapFactory.decodeResource(res, R.drawable.icon);\r\nMat mat = Mat()\r\n// bitmap : 支持ARGB_8888和RGB_565两种格式\r\n// mat : 类型为CV_8UC4，通道顺序为RGBA\r\nUtils.bitmapToMat(bitmap, mat);\r\n```\r\n\r\n## 主要API - 写入图片\r\n&emsp;&emsp; 我们可以通过 imwrite方法将Mat对象保存至指定文件\r\n\r\n```java\r\nFile file = new File(Environment.getExternalStorageDirectory().getPath() + File.separator + \\\"${System.currentTimeMillis()}.jpg\\\");\r\n if (!file.exists()) {\r\n        file.createNewFile();\r\n }\r\n// 文件路径  ,  待输出mat对象\r\nImgcodecs.imwrite(file.getPath(), srcMat);\r\n```\r\n## 端侧常用分析方法\r\n### 亮度检测\r\n&emsp;&emsp;计算图片在灰度图上的均值和方差，当存在亮度异常时，均值会偏离均值点(可以取0-255中间值 128)，方差也会偏小；通过计算灰度图的均值和方差，就可评估图像是否存在过曝光或曝光不足。\r\n```\r\n//亮度检测\r\nprivate static float brightness(Mat grayImage) {\r\n        float a = 0;\r\n        int Hist[] = new int[256];\r\n        for (int i = 0; i < 256; i++) {\r\n            Hist[i] = 0;\r\n        }\r\n        for (int i = 0; i < grayImage.rows(); i++) {\r\n            for (int j = 0; j < grayImage.cols(); j++) {\r\n                //在计算过程中，考虑128为亮度均值点\r\n                a += (float) (grayImage.get(i, j)[0] - 128);\r\n                int x = (int) grayImage.get(i, j)[0];\r\n                Hist[x]++;\r\n            }\r\n        }\r\n        float da = a / (float) (grayImage.rows() * grayImage.cols());\r\n        float D = Math.abs(da);\r\n        float Ma = 0;\r\n        for (int i = 0; i < 256; i++) {\r\n            Ma += Math.abs(i - 128 - da) * Hist[i];\r\n        }\r\n        Ma /= (float) ((grayImage.rows() * grayImage.cols()));\r\n        float M = Math.abs(Ma);\r\n        float K = D / M;\r\n        float cast = K;\r\n        if (cast >= 1) {\r\n            if (da > 0) {\r\n                Log.e(\\\"ymc\\\", \\\"过亮\\\");\r\n            } else {\r\n                Log.e(\\\"ymc\\\", \\\"过暗\\\");\r\n            }\r\n        } else {\r\n            Log.e(\\\"ymc\\\", \\\"亮度：正常\\\");\r\n        }\r\n        return cast;\r\n    }\r\n```\r\n\r\n### 清晰度检测\r\n&emsp;&emsp;利用拉普拉斯算子计算图片的二阶导数，反映图片的边缘信息，同样事物的图片，清晰度高的，相对应的经过拉普拉斯算子滤波后的图片的方差也就越大。\r\n```\r\n//清晰度\r\nprivate static double clarity(Mat grayImage) {\r\n        Mat laplacianDstImage = new Mat();\r\n        Imgproc.Laplacian(grayImage, laplacianDstImage, CvType.CV_64F);\r\n        MatOfDouble median = new MatOfDouble();\r\n        MatOfDouble std = new MatOfDouble();\r\n        Core.meanStdDev(laplacianDstImage, median, std);\r\n        double clarity = Math.pow(std.get(0, 0)[0], 2);\r\n        //后续可根据业务设置阈值\r\n        Log.e(\\\"ymc\\\", \\\"清晰度：\\\" + clarity);\r\n        laplacianDstImage.release();\r\n        return clarity;\r\n    }\r\n```\r\n\r\n## 最后\r\n&emsp;&emsp;2022年接触了很多新东西，在工作中也看到了很多大佬的闪光点，后续还会有更深入的OpenCV使用案例博文，图片分析方面还是菜鸟，这篇文章也看了很多Python大佬的文章，正所谓三人行必有我师，继续学习。\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7189866353514577979",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6278988946f467bb0d0d354b6e8b6df~tplv-k3u1fbpfcp-watermark.image?",
        "title": "win32com操作word 第三集：Range精讲(一)",
        "preview": "这是本节课要讲的接口，它是Document的方法，但其本身也是一个独立的接口，方法和属性共计183个。Range这个接口简直是word接口中的劳模。它表示资源选中或插入点",
        "author": "一灯编程",
        "view_count": 1385,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/9adac953f3e3ffa398491d321a76c445~300x300.image",
        "category": "后端",
        "content": ">本课程《win32com操作word API精讲&项目实战》，本公众号以文字分享为主，B站与视频号则发布视频分享，ID均为：一灯编程\r\n\r\n本集开始，将会深入`Document`接口。打开或创建一个文档都会产生一个`Document`对象，它代表文档本身，所以绝大部分文档的操作都会依赖该接口，它的属性和方法共计`374`个！说不上很多，但它大部分的接口和属性都是一个个独立接口封装而成的。\r\n\r\n但不必担忧，官方的文档中显示，有一部分接口是用于客户端级编程的，我们只需要学习部分接口足以满足各种类型的文档级开发需求了。\r\n\r\n## Range是什么\r\n这是本节课要讲的接口，它是Document的方法，但其本身也是一个独立的接口，方法和属性共计183个。`Range`这个接口简直是word接口中的劳模。它表示资源选中或插入点，可以理解为一个看不见的鼠标，但它比鼠标的作用强大多了。官方也提供了`Selection`接口，这是正儿八经的鼠标，它能和鼠标交互，个人认为`Selection`适合用在`客户端级开发`的场景，`文档级开发`的场景还是`Range`好用。\r\n\r\n\r\n## Range的作用\r\n操作文档中的资源，如选中一段文字，在实操中，得先鼠标选中文字。在word编程中，使用`Range`就能实现资源的选中，`Selection`是`单例模式`，`Range`可不是，最近的一个`Range`实例不会覆盖前面的实例，每个实例都是独立存在的。\r\n\r\n## Range声明范围的三种形式\r\n\r\n\r\n```python\r\nfrom win32com.client import Dispatch\r\n\r\nclient = Dispatch('word.Application')\r\nclient.Visible = 1\r\n\r\n# 创建一个文档 返回一个Document对象 操作文档就必须要操作Document\r\ndoc = client.Documents.Add()\r\n```\r\n此时，客户端上已经创建了一个新文档，为了方便演示，先在文档中粘贴一段新闻：\r\n>总部大楼内唯一对外开放的部分，是著名的火器博物馆。它共有15个展室，收藏着3000件曾经叱咤美国各个历史时期的著名枪械和部分外国名枪。其中，“前总统收藏专区”更是显示出这一协会与美国政界的紧密联系。在美国历史上，有九位总统曾是该协会的会员，分别是：格兰特、西奥多·罗斯福、塔夫脱、艾森豪威尔、肯尼迪、尼克松、里根、老布什。还有一位，就是上任总统特朗普。要让这么多总统站台，背后往来的金钱可不是小数目。数据显示，美国全国步枪协会在2016年总统选举中捐出的竞选资金高达5440万美元，其中，他们为特朗普砸下了3000万美元。\r\n\r\n#### 使用Range声明文档全选\r\n```python\r\nrng1 = doc.Range()\r\n```\r\n没什么可讲的，真的太简单了，如果你刚接触Python不久且无其他编程语言基础，只需要记住，`Range`接口返回一个`Range`对象，表示当前被选中的内容，仅此。\r\n\r\n#### 使用Range声明选择某范围资源\r\n\r\n>用法 Range(Start: int, End: int) -> Range\r\n\r\n`Start`和`End`表示字符，表示选择了从`Start`开始，截至`End`的范围。\r\n\r\n```python\r\nrng2 = doc.Range(0,10)\r\n```\r\n\r\n#### 使用Range声明一个无内容的范围：插入点\r\n\r\n```python\r\nrng3 = doc.Range(20,20)\r\n```\r\n当起始位置和结束位置一样时，`Range`中就无内容了，它是一个点，这种插入点通常用来往插入点写入内容。这样做很方便，不必担心因为误操作而导致范围中的内容被替换。\r\n\r\n## Range.Text属性\r\n`Text`属性内部有`__setter__`，可以使用该属性来获取或设置范围中的内容。打印`Range`实例时，会返回一个`<COMObject Range>`，看不到实例细节，此时可以使用`Text`属性查看范围中的文本。\r\n\r\n使用Text属性获取范围中的内容\r\n\r\n```python\r\nrng2 = doc.Range(0,4)\r\nprint(rng2.Text)\r\n>>>\r\n'总部大楼'\r\n```\r\n\r\n## Range.Start & Range.End 属性\r\n两个属性分别可以获取或设置范围的起始位置和结束位置，在实操中，有时候`Range`的范围并不是通过`Range(Start, End)`这种方式来声明的，而是某种方式，比如使用`Document.Paragraphs(1)`获得文章第一段，而某些操作只能在`Range`对象下才能操作，那么可以使用，`Document.Paragraphs(1).Range`将第一段的`段落对象`转换成了`Range`对象，此时就可以通过`Range.End`来获得范围的结束位置啦。\r\n\r\n\r\n当然，这两个属性也是实现了`__setter__`方法的，意味着可以通过为属性赋值来改变`Range`的范围。\r\n\r\n## 更改Range的范围\r\n\r\n在word编程中，更改`Range`范围是常规操作，上面的`Start`和`End`属性可以实现，但复杂的需求和编程环境是不允许我们来`数数有几个字符`的，这不现实。所以，微软官方提供了非常丰富的接口来实现`Range`范围的更改，比如，下面要讲的`MoveStart`和`MoveEnd`方法。\r\n\r\n## MoveStart & MoveEnd方法\r\n\r\n1、MoveStart(Unit=1, Count=1)\r\n\r\n该方法可以改变范围的起始位置，可以扩大范围也可以减少范围，参数说明：\r\n\r\n- Unit：\r\n按什么单位移动，`1`表示字符，`3`表示句子，`4`表示段落，\r\n- Count：\r\n执行一次要移动多少个Unit，正数表示往前移动（文档结束的方向），负数表示往后移动（文档开头的方向）\r\n\r\n2、MoveEnd(Unit=1, Count=1)\r\n\r\n参数和`MoveStart`一模一样。\r\n\r\n>演示\r\n\r\n```python\r\nrng3 = doc.Range(0,4)\r\nrng3.MoveStart(Unit=4, Count=1)\r\nprint(rng3.Start, rng2.End)\r\n# 移动后打印起始位置和结束位置\r\n>>>\r\n(262, 262)\r\n```\r\n\r\n明明只移动了起始位置，但为何结束位置从原来的4也变成了262字符位置了呢？请看下方说明：\r\n>说明\r\n无论是MoveStart还是MoveEnd，如果一方的位置超越了另一方，两个点就会重叠并形成插入点，最后一起移动到目标位置，不可能会出现结束位置小于起始位置这种匪夷所思的情况。\r\n\r\n这种玩法就很妙，意味着，我们不需要在意到底要`数到第几个字符`就可以轻松获得一个`Range`的范围。\r\n\r\n## 使用Range写入文本\r\n\r\n#### Range.Text重新赋值实现插入\r\n前面所示，可以使用Range.Text属性重新赋值，这很简单，就演示个伪代码吧。\r\n```python\r\n# 伪代码\r\n# 在0,0的位置声明一个插入点\r\nrng1 = doc.Range(0,0)\r\n# 使用Text属性插入内容\r\nrng1.Text = '一灯编程'\r\n```\r\n\r\n>注意：\r\n除非你想替换范围中的内容，否则不要轻易使用有内容的范围来执行`doc.Range(0,10).Text = '插入的内容'`语句。\r\n\r\n#### InsertBefore和InsertAfter方法插入\r\n\r\nInsertBefore：在范围的起始位置插入内容\r\n\r\nInsertAfter：在范围的结束位置插入内容\r\n\r\n这两个方法是为`有内容的范围`量身订造的，我想，千言万语不如一张图来得直接（懒）。\r\n\r\n\r\n![Snipaste_2023-01-18_12-03-13.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/969bdb1cc19e402d94dbc86b1948265e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n>注意：两个方法会扩大原来的范围\r\n\r\n## 插入段落标记\r\n\r\n另起一段是word编辑中常用的功能，使用回车即可实现，在word编程中，有三个方法可以实现的。\r\n\r\n#### InertParagraph\r\n\r\n使用段落标记`\\\\r`替换原来范围中的内容，并形成新段落。\r\n\r\n```python\r\nrng4 = doc.Range(20,20)\r\nrng4.InsertParagraph()\r\n```\r\n该方法适用于插入点，因为它会使用自动执行以下代码：\r\n```python\r\nrng4.Text = '\\\\r'\r\n```\r\n意味着，`\\\\r`会替换原来范围中的内容，除非有这个必要。执行这个方法后，从字符`21`开始，后面的内容都会另起一段。\r\n\r\n#### InsertParagraphBefore\r\n在范围起始位置插入一个段落标记`\\\\r`，意思是在原来内容的基础上，在起始位置插入一个`\\\\r`，那么当前范围会形成一个新段落，假如原来的内容为`一灯编程`，执行该方法后，内容为`\\\\r一灯编程`。\r\n```python\r\nrng5 = doc.Range(4,8)\r\nrng5.InsertParagraphBefore()\r\nprint(rng5.Text)\r\n>>>\r\n\\\"\\\\r一灯编程\\\"\r\n```\r\n\r\n#### InsertParagraphAfter\r\n和InsertParagraphBefore相反，它会在结束位置插入`\\\\r`，作用完全一样，不作演示。\r\n\r\n\r\n## 最后\r\n`Document`需要讲的内容很多，仅`Range`接口就能讲很多集。学习不能急，但也不能懒，代码敲起来，没有学不会的内容。\r\n\r\n好啦，我们下节课接着讲`Range`。"
    },
    {
        "article_id": "7189555395298328632",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9abe43a2f9224b34b0aa86ea964d43cc~tplv-k3u1fbpfcp-watermark.image?",
        "title": "搭建「Linux」内核调试环境",
        "preview": "学习内核 IO 模型的顺序IO、IO多路复用的 epoll 实现等知识点，不亲自去debug一下内核是真的非常晦涩难懂，所以这篇文章主要是记录一下如何使用qemu加gdb的方式去搭建Linux开发环境",
        "author": "用户1781525626194",
        "view_count": 893,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p6-passport.byteacctimg.com/img/mosaic-legacy/3795/3044413937~300x300.image",
        "category": "后端",
        "content": "## 前言\r\n\r\n学习内核 IO 模型的顺序IO、IO多路复用的 epoll 实现等知识点，不亲自去 debug 一下内核是真的非常晦涩难懂，所以这篇文章主要是记录一下如何使用 qemu 加 gdb 的方式去搭建 linux 内核的调试环境。\r\n主要使用得到的东西有：\r\n\r\n| Name | Description | Url | Note |\r\n| --- | --- | --- | --- |\r\n| Linxu kernel Source Code | Linux 内核的源码 | [http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel](http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel) | 国内能快速访问 |\r\n| Ubnutu | Ubnutu 的 iso 镜像文件 | [http://mirrors.aliyun.com/ubuntu-releases/14.04/ubuntu-14.04.6-desktop-amd64.iso](http://mirrors.aliyun.com/ubuntu-releases/14.04/ubuntu-14.04.6-desktop-amd64.iso) |  |\r\n| Vmware Fusion | 启动 Ubnutu 系统，构建 Linux 内核的编译环境 | [https://www.vmware.com/cn/products/fusion/fusion-evaluation.html](https://www.vmware.com/cn/products/fusion/fusion-evaluation.html) |  |\r\n| qemu | 虚拟器，用于运行 Linux 内核 | 看下文 |  |\r\n| busybox | 用于制作 Linux 内核启动所需的 initrd | 开下文 |  |\r\n| gdb | 一个强大的程序调试工具，用于调试 qemu 运行的 Linux 内核 | 看下文 |  |\r\n\r\n\r\n## 流程\r\n首先需要用 vmware fusion 启动 ubnutu ，网络模式选择`WI-FI`（不过好像选择其他模式也可以）\r\n**注意，硬盘容量最好给到 200 G，最少 100 G，我已经遇到只分配了 20 G 的硬盘，编译完内核以后根文件系统只剩下几十M容量后，登录上 ubnutu 后桌面除了鼠标能动后啥都没有的问题了！**\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0fdcf574dab47b5bc0a3dc22605ccbd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 1. 在 ubnutu 中下载编译 linux 内核\r\n\r\n```bash\r\n# 1. vmware 启动 ubnutu ，硬盘建议分配到 100 GB 空间\r\n# 否则后期如果出现了根目录磁盘容量不够的情况，\r\n# 会出现登录上 ubnutu 系统后，桌面只有鼠标能动的坑\r\n\r\n# 2. 登录 ubnutu 系统\r\n\r\n# 3. 设置 root 密码\r\nsudo passwd\r\n\r\n# 4. 切换 root 用户\r\nsu root\r\n\r\n# 5. 安装 vim、openssh-server\r\n# 安装 openssh 后，可以宿主机用 ssh 连接到 vmware 内的 ubnutu，会方便一点 \r\napt-get install vim openssh-server -y\r\n\r\n# 6. 启动 openssh-server\r\n/etc/init.d/ssh start\r\n\r\n# 7. 接下来可以切换到宿主机外用 ssh 连接到 ubnutu 了\r\n\r\n# 8. 下载解压 linux 内核\r\ncd /root\r\nwget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/linux-5.0.1.tar.gz\r\ntar zxf linux-5.0.1.tar.gz\r\n\r\n# 9. 进入 linux 内核源码目录\r\ncd linux-5.0.1\r\n\r\n# 10. 安装编译工具\r\napt install build-essential flex bison libssl-dev libelf-dev libncurses-dev -y\r\n\r\n# 11. 设置调试的编译菜单。\r\nexport ARCH=x86\r\nmake x86_64_defconfig\r\nmake menuconfig、\r\n# 下面选项如果没有选上的，选上（点击空格键），然后 save 保存设置，退出 exit。\r\n##################################################################\r\nGeneral setup  --->\r\n    [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support\r\n\r\nDevice Drivers  --->\r\n    [*] Block devices  --->\r\n        <*> RAM block device support\r\n            (65536) Default RAM disk size (kbytes)\r\n\r\nProcessor type and features  --->\r\n    [*] Randomize the address of the kernel image (KASLR)\r\n    \r\nKernel hacking  --->\r\n    Compile-time checks and compiler options  ---> \r\n        [*] Compile the kernel with debug info\r\n            [*] Provide GDB scripts for kernel debugging\r\n\r\nDevice Drivers --> \r\n    Network device support --> \r\n        <*> Universal TUN/TAP device driver support\r\n\r\n[*] Networking support --> \r\n        Networking options --> \r\n            <*> 802.1d Ethernet Bridging\r\n##################################################################\r\n\r\n# 12. 编译 linux 内核\r\n# -j4 是启动 4 个线程进行编译，加快编译速度\r\nmake -j4\r\n```\r\n\r\n### 2. 使用 busybox 制作 initrd\r\n\r\ninitrd 是 linux 内核启动过程中所需的临时根文件系统，包含了内核初始化过程中所需的设备驱动等。\r\n\r\n```bash\r\ncd /root\r\n\r\n# 下载解压 busybox 源码\r\nwget https://busybox.net/downloads/busybox-1.30.0.tar.bz2 --no-check-certificate\r\ntar xvf busybox-1.30.0.tar.bz2\r\n\r\n# 设置静态编译，这样 busybox 在运行时就不需要动态链接其他 ELF 文件\r\n# Busybox Settings  --->\r\n#      Build Options  --->\r\n#            [*] Build BusyBox as a static binary (no shared libs)\r\nmake menuconfig\r\n\r\n# 编译 busybox，会在源码目录下生成 _install 目录，即 linux 系统的根目录\r\nmake && make install\r\n\r\ncd _install\r\n\r\n# 创建软连接 init 指向 bin/busybox，内核启动到最后会执行 init 进程\r\nln -sf bin/busybox init\r\nmkdir -p {sys,proc,dev,etc/init.d}\r\n\r\n# 启动脚本，相当于 rc.local\r\ntouch etc/init.d/rcS \r\nchmod 755 etc/init.d/rcS\r\n# etc/init.d/rcS内容见下方\r\nvi etc/init.d/rcS\r\n\r\ntouch etc/fstab\r\n # etc/fstab内容见下方\r\nvi etc/fstab\r\n\r\n# 这里的 pigz 可以多线程压缩，需要安装 pigz，或者使用 gzip 替代。\r\nsudo apt install pigz\r\nfind . -print0 | cpio --null -ov --format=newc | pigz -9 > /root/initrd-busybox.img\r\n```\r\n\r\n文件 etc/init.d/rcS 的内容\r\n\r\n```bash\r\n#!/bin/sh\r\n# RC Script for Tiny Core Linux\r\n# (c) Robert Shingledecker 2004-2012\r\n\r\n# Mount /proc.\r\n[ -f /proc/cmdline ] || /bin/mount /proc\r\n\r\n# Remount rootfs rw.\r\n/bin/mount -o remount,rw /\r\n\r\n# Mount system devices from /etc/fstab.\r\n/bin/mount -a\r\n\r\n\r\nclear\r\n```\r\n\r\n文件 etc/fstab 的内容\r\n\r\n```bash\r\nsysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0\r\nproc /proc proc rw,nosuid,nodev,noexec,relatime 0 0\r\nudev /dev devtmpfs rw,nosuid,noexec,relatime,mode=755 0 0\r\n```\r\n\r\n### 3. 安装 qemu\r\n\r\n```bash\r\n# 安装 qemu 模拟器，以及相关组件。 \r\napt install qemu libc6-dev-i386 -y\r\n```\r\n\r\n### 4. 源码安装 gdb\r\n\r\ngdb 是一个强大的通过交互式命令行调试指定程序的工具，在这里可以用于调试通过 qemu 运行的 linux 内核（qemu 自身支持 gdb 调试）。ubnutu 有自带 gdb，但是会有无法调试 qemu 下的 linux 内核的坑，所以需要下载 gdb 的源码并且修改其源码后重新编译。\r\n\r\n```bash\r\n# 删除 gdb\r\ngdb -v | grep gdb\r\napt remove gdb -y\r\n\r\n# 下载解压 gdb\r\ncd /root\r\n#wget https://mirror.bjtu.edu.cn/gnu/gdb/gdb-8.3.tar.xz\r\nwget http://ftp.gnu.org/gnu/gdb/gdb-8.3.tar.gz\r\ntar zxf gdb-8.3.tar.gz\r\n\r\n# 修改 gdb/remote.c 代码。\r\n# 看下方\r\ncd gdb-8.3\r\nvim gdb/remote.c\r\n\r\n./configure\r\nmake -j4\r\ncp gdb/gdb /usr/bin/\r\n```\r\n\r\n1. 修改 gdb/remote.c 的代码\r\n\r\n```c\r\n/* Further sanity checks, with knowledge of the architecture.  */\r\n// if (buf_len > 2 * rsa->sizeof_g_packet)\r\n//   error (_(\\\"Remote 'g' packet reply is too long (expected %ld bytes, got %d \\\"\r\n//      \\\"bytes): %s\\\"),\r\n//    rsa->sizeof_g_packet, buf_len / 2,\r\n//    rs->buf.data ());\r\n\r\nif (buf_len > 2 * rsa->sizeof_g_packet) {\r\n    rsa->sizeof_g_packet = buf_len;\r\n    for (i = 0; i < gdbarch_num_regs(gdbarch); i++) {\r\n        if (rsa->regs[i].pnum == -1)\r\n            continue;\r\n        if (rsa->regs[i].offset >= rsa->sizeof_g_packet)\r\n            rsa->regs[i].in_g_packet = 0;\r\n        else\r\n            rsa->regs[i].in_g_packet = 1;\r\n    }\r\n}\r\n```\r\n\r\n### 5. qemu 启动 linux 内核\r\n\r\n```bash\r\ncd /root\r\n\r\nqemu-system-x86_64 -kernel ./linux-5.0.1/arch/x86/boot/bzImage -initrd ./initrd-busybox.img -append nokaslr -S -s\r\n```\r\n\r\n解释一下，`-kernel` 参数指定的就是 linux 内核，`-initrd` 指定的是 linux 内核启动过程中所需的临时根文件系统，由 boot loader 加载到内存中。\r\n`-s`的是`-gdb tcp::1234`的别名，即在 1234 端口开启 gdb server 以调试 linux 内核。`-S` 是可以 debug linux 内核的启动阶段，温馨提示：可以 debug 内核是如何处理 initrd 的，若不加`-S`参数，则直接就到控制台去了。\r\n\r\n```\r\n-s  Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234.\r\n\r\n-S  Do not start CPU at startup (you must type 'c' in the monitor).\r\n```\r\n\r\n上面的命令是一定要在 vmware fusion 启动的 ubnutu 中才可以顺利执行，否则会报错\r\nCould not initialize SDL(No available video device) - exiting\r\n看起来是因为必须用到显示设备驱动之类的gui问题，加上`--curses`就可以解决。\r\n\r\n### 6. 使用 GDB 调试内核\r\n\r\n```bash\r\ncd /root\r\n# 读取编译出来的 linux 内核 ELF 文件\r\ngdb linux-5.0.1/vmlinux\r\n\r\n# ... 进入到 gdb 到交互式命令行\r\n\r\n# 连接到本地 qemu 启动的 linux 内核\r\n# 对应 qemu 启动命令的 -s 参数\r\ntarget remote :1234\r\n\r\n# 即可开始调试 Linux 内核\r\n```\r\n### \r\n### 7. 配置 qemu 网络（可选）\r\n\r\n此时用 qemu 启动的 Linux 内核是不具备网络功能的，这里将基于 tun/tap 和 bridge 来实现 qemu 的网络功能，关于 tun/tap 和 bridge 的详情会另开一篇文章来写（因为我也还没完全搞清楚），下面开始配置 qemu 网络。\r\n我们上面使用 vmware 启动的 ubnutu 宿主机默认是支持 tun/tap 驱动的，是作为 ubnutu 的默认模块编译到了内核中的，/dev/net/tun 是 tun/tap 的字符设备，是用户态和内核态之间网络数据收发的桥梁（这一块涉及 tun/tap 的原理相关），即使因为未知的原因  lsmod 并未显示内核已经加载了 tun/tap 模块。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935522dbd3e34cfa92d5794d4cf7a320~tplv-k3u1fbpfcp-zoom-1.image)\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f29a8a11b0452bb56f1101de369172~tplv-k3u1fbpfcp-zoom-1.image)\r\n（所以，我假设你的宿主机是支持 tun/tap 的，如果不支持，可能需要重新编译你的宿主机的内核了）\r\n**第一步，在宿主机安装相关软件。**\r\n```bash\r\n# 虚拟网桥工具\r\napt-get install bridge-utils\r\n\r\n# UML（User-mode linux）工具\r\napt-get install uml-utilities\r\n```\r\n**第二步，修改宿主机的 /etc/network/interfaces 文件，增加下面的内容。**\r\n```bash\r\n# vim /etc/network/interfaces 文件\r\n\r\n# 增加名为 br0 的虚拟网桥，通过 dhcp 获取 ip 地址\r\nauto br0\r\niface br0 inet dhcp\r\n\r\n# 我这台主机的真实物理网卡的 nf 名为 eth0（一般都是叫 eth0 ）\r\nbridge_ports eth0\r\nbridge_fd 9\r\nbridge_hello 2\r\nbridge_maxage 12\r\nbridge_stp off\r\n\r\n# 增加名为 tap0 的虚拟网卡\r\nauto tap0\r\niface tap0 inet manual\r\npre-up tunctl -t tap0 -u root\r\npre-up ifconfig tap0 0.0.0.0 promisc up\r\n\r\n# 把 eth0 和 tap0 通过虚拟网桥连接起来\r\npost-up brctl addif br0 tap0\r\n```\r\n**第三步，重启宿主机以刷新网络**。\r\n然后输入 `ifconfig` 命令，应该可以看到真实物理网卡 eth0、本地回环 lo、虚拟网桥 br0、虚拟网卡 tap0，并且通过 `brctl showstp br0` 可以看到 eth0 和 tap0 都加入了虚拟网桥 br0 中。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b271be7dc2c4e328dc8bd8cc5255503~tplv-k3u1fbpfcp-zoom-1.image)\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7744555f75a54198a56c2ab281bf9135~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**第四步，在 qemu 的启动命令追加网络相关参数即可。**\r\n```bash\r\n# -net tap 表示使用 tun/tap 类型的网络，还有一种是 user-stack 类型\r\n# script 是指定内核启动时，用于配置网络的脚本绝对路径\r\n# downscript 时指定内核关闭时，用于注销网络相关配置的脚本绝地路径\r\n-net nic -net tap,ifname=tap0,script=no,downscript=no\r\n\r\n# 可调试 linux 内核启动过程的完整命令\r\nqemu-system-x86_64 -kernel ./linux-5.0.1/arch/x86/boot/bzImage -initrd ./initrd-busybox.img -append nokaslr -S -s -net nic -net tap,ifname=tap0,script=no,downscript=no\r\n\r\n# 不可调试 linux 内核启动过程的完整命令\r\nqemu-system-x86_64 -kernel ./linux-5.0.1/arch/x86/boot/bzImage -initrd ./initrd-busybox.img -append nokaslr -s -net nic -net tap,ifname=tap0,script=no,downscript=no\r\n```\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc818afe5faa4b38b533a3585bfdf9b7~tplv-k3u1fbpfcp-zoom-1.image)\r\n后来发现还没完，网络发现还是无法用，还有第五步，在 qemu 启动的内核里还得进行一些配置。\r\n`ifconfig` 会看到此时空无一物，linux 不是说没有消息就是好消息嘛，`ls /sys/class/net` 可以看到是有 eth0 和 lo 的，那问题就简单了。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab7f3848a1349da8d4da9ddc0620c5b~tplv-k3u1fbpfcp-zoom-1.image)\r\nping 一下宿主机发现报错了，仔细看上面 `ifconfig` 的输出，eth0 是没有 ip 地址的，应该是编译内核的时候，没有勾选 dhcp 相关选项，自己配置一下就好了。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4573f1b0e630492989f7bf8c00452f27~tplv-k3u1fbpfcp-zoom-1.image)\r\n使用 udhcpc 命令可以获取到可用的 ip 地址。\r\n**第五步，在 qemu 启动的客户机里，开启 eth0 以及配置其 ip 地址。**\r\n```bash\r\n# 开启 eth0 网络接口\r\nifconfig eth0 up\r\n# 顺便把本地回环也开一下\r\nifconfig lo up\r\n\r\n# ping 一下宿主机，发现不通\r\n# 仔细看 ifconfig 的输出，eth0 是没有 ip 地址的，\r\n# 应该是编译内核的时候，没有勾选 dhcp 相关选项，\r\n# 自己配置一下就好了，\r\n# 使用 udhcpc 命令可以获取到可用的 ip 地址\r\nudhcpc\r\n\r\n# 加上 udhcpc 获取到的 ip 地址即可，192.168.105 需要替换为你自己获取到的 ip 地址\r\nifconfig eth0 192.168.105 \r\n```\r\nqemu 客户机和 ubnutu 宿主机之间的网络是通的，但是，你试一下，ping 百度的 ip 地址（因为现在 qemu 客户机还没有配置好 dns 协议），是不通的。\r\n\r\n**第六步，在 qemu 客户机增加路由到所在局域网网关的路由项。**\r\n首先，通过宿主机查看网关的 ip 地址\r\n```bash\r\nroot@elvis:~# route -n\r\nKernel IP routing table\r\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\r\n0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 br0\r\n169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 br0\r\n192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 br0\r\n```\r\n可以看到，宿主机上最后所有不是发往局域网的网络包都是路由到 192.168.1.1 这个网关上的，\r\n所在 qemu 客户机也需要增加上这条路由。\r\n```bash\r\n     / # route -n\r\n     Kernel IP routing table\r\n     Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\r\n     192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0\r\n     / #\r\n     / # ip route add 0.0.0.0/0 via 192.168.1.1 dev eth0\r\n     / # route -n\r\n     Kernel IP routing table\r\n     Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\r\n     0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0\r\n     192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0\r\n     / #\r\n```\r\n接着，试一下 ping 百度的 ip，ok。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75f1622195584630ad4bff8f0bd6301f~tplv-k3u1fbpfcp-zoom-1.image)\r\n至此，你已经有了一台拥有网络功能的可以 debug 内核的 Linux 机器了！\r\n\r\n## 命令汇总\r\n完整的 qemu 启动过程\r\n```bash\r\nkernel_path=./linux-5.0.1/arch/x86/boot/bzImage\r\ninitrd_path=./initrd-busybox.img\r\nqemu-system-x86_64 -kernel ${kernel_path} -initrd ${initrd_path} -append nokaslr -s -net nic -net tap,ifname=tap0,script=no,downscript=no --curses\r\n```\r\nqemu 启动后，配置网络的过程\r\n```bash\r\n# 启动 eth0 网卡\r\nifconfig eth0 up\r\n# 通过 dhcp 协议获取 ip 地址\r\nudhcpc \r\n# 给 eth0 网卡配置ip地址\r\nifconfig eth0 ${获取到的 ip 地址}\r\n# 添加网关路由，注意你需要到宿主机上确认 192.168.1.1 是不是你宿主机所在局域网的网关 ip 地址\r\nip route add 0.0.0.0/0 via 192.168.1.1 dev eth0\r\n# 测试一下 tcp 能否到百度，因为没有配置 dns，所以直接用 ip\r\nping 14.215.177.39\r\n```\r\n## 补习\r\n### 主机上电到 Linux 内核的启动过程 \r\n\r\n1.  POST (Power On And Self Test) : 主机开机上电自检\r\n主板上有一块CMOS芯片，上面刻录了一段程序称之为 BIOS (Basic Input/Output System) 基本输入输出系统，BIOS 会对主机的核心设备如CPU、键盘、存储设备如硬盘进行检查和初始化。\r\n2.  MBR (Master Boot Record) : 主启动记录\r\nPOST 结束后，BIOS 程序会让用户指定启动顺序，即从主机上的哪一块存储设备中获取 MBR，MBR 中存储了存储设备的分区信息以及 Boot Loader 引导程序。 \r\n3.  Boot Loader：引导程序\r\n引导程序负责从存储设备中读取操作系统内核到内存中，把主机的控制权转交给操作系统内核。以 qemu 启动内核的命令举例，`-kernel` 参数指定的即操作系统内核的可执行程序。 目前主流的引导程序有 GRUB ，引导程序也可以视作是一个小型的操作系统，也具有操作硬盘和内存的能力，可以把内核从硬盘加载到内存中。\r\n4.  initrd/initramfs: 初始化RAM磁盘 / 初始化RAM文件系统\r\n引导程序启动的内核仅仅是内核核心而已... 它不包含各种驱动模块（包括硬盘控制器的驱动）。所以内核被引导以后其实无法完成对 root 的挂载... 无法挂载文件系统便不能读取并载入内核驱动模块，没有驱动支持就不能管理硬盘（完成对文件系统的挂载）...\r\n所以这些如硬盘驱动等核心部件需要通过 initrd/initramfs 来提供，否则，就需要把所有可能出现在主机上的硬盘的驱动全都预先的编译到内核中（这显然是一个不可能完成的任务）。\r\ninitrd/initramfs 可以通过由 boot loader 加载到内存中，并且把其内存起始&结束地址传递给 linux 内核，也可以把 initrd/initramfs 编译到 linux 内核的 ELF 文件中。\r\nintird 和 initramfs 本质是一个东西，initrd 是在内存中模拟一个磁盘设备，inintramfs 是在内存中模拟一个文件系统，initramfs 基于 tmpfs，由 linux 的 virtual memory 管理，而 initrd 模拟的是硬盘，和 kernel 间隔着一层 virtual memory。 \r\n\r\n### tun/tap 虚拟网络设备\r\n下图是 qemu 使用 tun/tap 进行联网的原理，了解一下即可，我暂时也未深入研究。\r\n![tuntap_qemu.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a37c906a822456f9a649e0d473180a0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 参考\r\n\r\n[搭建 Linux 内核网络调试环境（vscode + gdb + qemu）](https://zhuanlan.zhihu.com/p/445453676)\r\n\r\n[Linux内核Ramdisk(initrd)机制](https://blog.csdn.net/xiehaihit/article/details/91959216)\r\n\r\n[initrd和initramfs的区别是什么](https://www.zhihu.com/question/22045825/answer/796011861)\r\n\r\n[qemu网络配置官方文档](https://wiki.qemu.org/Documentation/Networking)\r\n\r\n[网络虚拟化之tun/tap](https://www.toutiao.com/i7057844752796025383/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1644248324&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=202202072338440101381901660D3EC23D&share_token=18a183d4-d326-4c41-8635-fe308afe9fd4&group_id=7057844752796025383&wid=1644249444512)\r\n\r\n"
    },
    {
        "article_id": "7155401532303753229",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d56b83ec95c4eab99e7d3e5653da25c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "不用防抖和节流，用更底层的方式解决JS的重复请求",
        "preview": "`once-init` 为解决异步函数问题而生。它从 `Promise` 的定义出发，用 `Promise` 的基础功能彻底地阻止了异步请求浪费的发生。",
        "author": "Xmo",
        "view_count": 33358,
        "collect_count": 511,
        "comment_count": 80,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/31d0d33e0430811c66aa9e5fe9aed7b6~300x300.image",
        "category": "前端",
        "content": "> 欢迎转载，评论，然后注明来源和github地址即可。\r\n\r\n> 如果你认为本文或本工具对你有帮助，请点赞收藏或给项目star，这对我真的很重要。ヾ(•ω•`)o\r\n\r\n[项目 github 地址](https://github.com/darkXmo/once-init)\r\n\r\n你或许在项目中遇到过这样的情况。\r\n\r\n1. 成员A成员B都用得上一个后端接口api，但它们互相不知道对方什么时候请求这个接口，因此导致一打开页面，同一个接口竟然重复请求了多次。\r\n2. 由于用户手抖，又因为成员忘记做请求的loading防误触处理，导致一个接口被用于疯狂请求，最终数据乱套，页面不可用。\r\n3. SPA单页面应用，多个页面甚至是多个组件可能有同样的数据请求，完全可以共享的数据却不得不重复请求，影响页面加载效率。\r\n4. 想要用节流或者防抖解决上面的问题，但是后端返回数据的时间浮动太大，导致不知道应该设置多长的时间。\r\n\r\n这些请求浪费，实际上都有调用异步函数（`async function`）的参与的；因此，它们虽不是`async function`的问题，但却可以利用`async function`的特点来解决。\r\n\r\n`async function`本质上是一个`Promise`。因此只要利用好`Promise`的特性，就能解决这些问题。\r\n\r\n`once-init` 正是为解决这些问题而生。它从 `Promise` 的定义出发，用 `Promise` 的基础功能彻底地阻止了异步请求浪费的发生。\r\n\r\n我用它做了两件事：\r\n\r\n1. 缓存请求的返回值；\r\n2. **缓存Promise请求本身**；\r\n\r\n## 原理\r\n\r\n`once-init` 的核心思想是缓存和执行队列；\r\n\r\n### 缓存返回值\r\n\r\n实现缓存返回值并不困难，只要写一个单例模式就好了。下面是一个缓存的单例模式的简单示例；\r\n\r\n```typescript\r\nclass OnceInit {\r\n    cache = undefined;\r\n    func;\r\n    \r\n    constructor(asyncFunc) {\r\n        this.func = asyncFunc;\r\n    }\r\n\r\n    async init() {\r\n        if (typeof this.cache !== 'undefined') {\r\n            return this.cache;\r\n        } else {\r\n            const res = await this.func();\r\n            this.cache = res;\r\n            return res;\r\n        }\r\n    }\r\n}\r\n\r\n// 使用\r\nconst oiFoo = new OnceInit(someAsyncFunc);\r\nawait oiFoo.init();\r\n```\r\n\r\n1. 如果缓存已经有值，返回缓存的值；\r\n2. 如果缓存没有值，执行异步函数；执行完毕后，更新缓存；\r\n\r\n这是一个简易的解决方案，它大概能解决10%的异步函数相关的问题，因为在第一次执行`Promise`完成之后，就不会再进行请求，也就不会产生浪费了；\r\n\r\n**但是**，它没有解决多个`Promise`同时发生的情况。\r\n\r\n假设开发人员同一时间多次调用`init`，如果第一次调用的`Promise`还没有完成，`cache`也还没有初始化，就会导致同一时间的所有调用依旧创建新的`Promise`。\r\n\r\n甚至有可能因为多次请求，不断的变化`cache`，你甚至没有办法确定最后`cache`的值是不是你最后一次请求的返回值。\r\n\r\n如果要解决这个问题，就需要利用`Promise`的特性，**同一时间，同一个async function，只允许同一个Promise处在pending状态**。\r\n\r\n### 缓存 Promise \r\n\r\n1. 如果`Promise`正在执行，就不创建新的`Promise`；直接返回正在执行的`Promise`的返回值；\r\n2. 如果没有`Promise`正在执行，就创建并缓存新的`Promise`；\r\n    1. `Promise`执行结束之后，删除缓存的`Promise`；\r\n\r\n```typescript\r\nclass OnceInit {\r\n    cache = undefined;\r\n    func;\r\n    promise = undefined;\r\n    constructor(asyncFunc) {\r\n        this.func = asyncFunc;\r\n    }\r\n\r\n    async init() {\r\n        if (typeof this.cache !== 'undefined') {\r\n            return this.cache;\r\n        } else {\r\n            if (this.promise) {\r\n                return await this.promise;\r\n            } else {\r\n                const promise = this.func();\r\n                promise.finally(() => {\r\n                    this.promise = undefined;\r\n                })\r\n                this.promise = promise;\r\n                const res = await promise;\r\n                this.cache = res;\r\n                return res;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n通过这种方式，就能避免`promise`同一时间重复执行。这也是`once-init`这个库的核心思想。\r\n\r\n当然这个简单实现还有很多问题需要解决。\r\n\r\n1. 如果想要刷新缓存，或者不想用缓存怎么办？（原理见这篇文章-[不缓存返回值，只防止 Promise 的重复请求应该怎么做？](https://juejin.cn/post/7156119444215824398)）\r\n2. 如果`asyncFunc`需要参数怎么办；\r\n3. 怎样提供`Typescript`支持；\r\n\r\n不过这些问题 `once-init` 都已经解决了。如果你读过我的上一篇文章[https://juejin.cn/post/7046667393405304868](https://juejin.cn/post/7046667393405304868)，就知道我在年初就写了一个库封装这个想法。\r\n\r\n很多伙伴都对我的实现提出了可靠的建议，为我修正改进项目帮助很大。经过这一段时间的打磨，并在实际生产环境中试用了一段时间后，现在终于推出了它的`v1.0.0`正式版本了。\r\n\r\n---\r\n\r\n# once-init\r\n\r\n<p align=\\\"center\\\">\r\n  <a href=\\\"https://github.com/darkXmo/once-init/blob/main/LICENSE\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e56261c13cef470f94490fd8e3b13aac~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"license\\\"></a>\r\n  <a href=\\\"https://www.npmjs.com/package/once-init\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fc436ebf7974fc7a3258e0dc557eaff~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"npm version\\\"></a>\r\n  <a href=\\\"https://circleci.com/gh/darkXmo/once-init\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed61bbefb2b54fb09f815a8168e40044~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"circleci\\\"></a>\r\n  <a href=\\\"https://app.codecov.io/gh/darkXmo/once-init\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21cb4f104ec5417fa1732aee841110be~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"test-coverage\\\"></a>\r\n  <a href=\\\"https://packagephobia.now.sh/result?p=once-init\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946314dc50364d969447b928e175b03a~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"gzip size\\\"></a>\r\n  <a target=\\\"_blank\\\" rel=\\\"noopener noreferrer nofollow\\\" href=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723189b7713546c89485ad964ac2613c~tplv-k3u1fbpfcp-zoom-1.image\\\" data-turbo-frame=\\\"\\\"><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7fe2858194e475698c43261cc182e37~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"badge\\\" data-canonical-src=\\\"https://badgen.net/badge/TypeScript/strict%20%F0%9F%92%AA/blue\\\" style=\\\"max-width: 100%;\\\"></a>\r\n</p>\r\n\r\n<strong style=\\\"text-align: center;\\\">🗼 Makes asynchronous function execution manageable.</strong>\r\n\r\n封装可控的 `async function`。\r\n\r\n> 你可以让同一个 `async function` 不会在同一时间内被执行两次，以防止发出重复的请求。\r\n\r\n> 你可以让第二次执行 `async function` ，直接返回第一次执行的结果，而不是重复执行函数。\r\n\r\n> 解决大量的相同请求的问题。\r\n\r\n> 详细且精确的 `Typescript` 检查。\r\n\r\n## 安装\r\n\r\n```bash\r\nnpm install once-init\r\n```\r\n\r\n## 简介\r\n\r\n`once-init` 的核心思想是缓存和执行队列；\r\n\r\n## 使用\r\n\r\n```typescript\r\n// 0. 引入once-init\r\nimport oi from \\\"once-init\\\";\r\n\r\n// 1. 创建一个异步函数\r\nasync function foo() {\r\n  // do something, for example, request backend data.\r\n  const res = await axios.get(\\\"xxx.com\\\");\r\n  return res;\r\n}\r\n\r\n// 2. 用once-init封装这个异步函数\r\nconst oiFoo = oi(foo);\r\n\r\n// 3. 执行封装后的函数\r\noiFoo.init();\r\n```\r\n\r\n### 用例\r\n\r\n> 一个结合axios的简单示例\r\n\r\n```typescript\r\nimport oi from \\\"once-init\\\";\r\naxios.get = oi(axios.get).refresh;\r\n```\r\n\r\n只用一行，就能在调用`axios.get`的时候就能阻止同一时间的重复请求了。\r\n\r\n#### 不用 `once-init`\r\n\r\n```typescript\r\n// 我们假设 axios.get(\\\"xxx.com\\\") 返回的值是一个递增的数字，即第1次请求，会返回1，第2次请求会返回2，第n次请求会返回n。\r\nawait foo(); // 返回 1\r\nawait foo(); // 返回 2\r\nawait foo(); // 返回 3\r\n```\r\n\r\n#### 使用 `once-init`\r\n\r\n```typescript\r\n// once-init 会将重复执行重定向到第一次执行的结果上；（第一次执行后会缓存执行结果，类似单例模式）\r\nawait oiFoo.init(); // 返回 1\r\nawait oiFoo.init(); // 返回 1\r\nawait oiFoo.init(); // 返回 1\r\n```\r\n\r\n这意味着无论重复执行 `oiFoo.init` 多少次，`foo` 都只会执行第一次，返回第一次执行的结果；（就像缓存一样）\r\n\r\n```typescript\r\nawait Promise.all([oiFoo.init(), oiFoo.init(), oiFoo.init()]); // 返回 [1, 1, 1]\r\nawait Promise.all([oiFoo.init(), oiFoo.init(), oiFoo.init()]); // 返回 [1, 1, 1]\r\n```\r\n\r\n```typescript\r\n// 通常，如果你只会使用到init，你可以直接把 oiFoo 定义成 init 函数\r\nconst oiFoo = oi(foo).init;\r\n\r\nawait oiFoo();\r\n```\r\n\r\n如果你不使用缓存，只是希望防止同一时间发出重复请求，你可以使用`refresh`：\r\n\r\n```typescript\r\n// refresh和init在同一时间执行多次，都会阻止重复执行，多余的async function会返回第一次的结果；\r\nawait Promise.all([oiFoo.refresh(), oiFoo.refresh(), oiFoo.refresh()]); // 返回 [1, 1, 1]\r\n// 但refresh如果当前没有其它重复的async function在执行，会刷新结果，并同时刷新缓存（影响到下一次init的返回）；\r\nawait Promise.all([oiFoo.refresh(), oiFoo.refresh(), oiFoo.refresh()]); // 返回 [2, 2, 2]\r\nawait oiFoo.init(); // 返回 2\r\n```\r\n\r\n> `once-init` 会区分参数，如果传入的异步函数有参，那么传入不同的参数将被视为两个不同的异步函数，不会共享缓存和执行队列；（使用`lodash.isEqual`判断参数是否相等）\r\n\r\n下面这个复杂用例将会给你提供灵感：\r\n\r\n```typescript\r\n// 假设 xxx.com/+ 会返回正数， xxx.com/- 会返回负数，两者有独立的缓存，且绝对值都递增\r\nasync function foo(op: \\\"+\\\" | \\\"-\\\") {\r\n  const res = await axios.get(`xxx.com/${op}`);\r\n  return res;\r\n}\r\n\r\nconst oiFoo = oi(foo);\r\nawait oiFoo.init(\\\"-\\\"); // 返回 -1\r\nawait oiFoo.refresh(\\\"-\\\"); // 返回 -2\r\nawait oiFoo.refresh(\\\"-\\\"); // 返回 -3\r\n\r\nawait oiFoo.refresh(\\\"+\\\"); // 返回 1\r\nawait oiFoo.init(\\\"-\\\"); // 返回 -3\r\n```\r\n\r\n更多问题和api请到[项目 github 地址](https://github.com/darkXmo/once-init)中查看，如果有任何问题，也请在下面评论留言或到github提交issue(热烈欢迎到github提交issue捏)。"
    },
    {
        "article_id": "7189099607728521272",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe65c99a3c54fbfa4110115f9ff1188~tplv-k3u1fbpfcp-watermark.image?",
        "title": "ChatGPT的一些好玩用途，有些你绝对想不到！",
        "preview": "去年12月ChatGPT发布，全世界再次掀起了一波AI狂潮。很多技术社区、技术爱好者，都在不断摸索这个AI“接口”无穷无尽的可能性，我去年也写过一篇让ChatGPT写一些python代码的文章，再进一",
        "author": "也鱼小编程",
        "view_count": 1228,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/f46acbcd1dfa12559a7917ef9509da03~300x300.image",
        "category": "人工智能",
        "content": "去年12月ChatGPT发布，全世界再次掀起了一波AI狂潮。很多技术社区、技术爱好者，都在不断摸索这个AI“接口”无穷无尽的可能性，我去年也写过一篇让ChatGPT写一些python代码的文章，再进一步的探索后，又有了不少新的发现，特别是当看到人工智能已经无缝地嵌入到日常生活中后，简直忍不住马上要与大家分享！最近有传闻，ChatGPT将要商业化，现在且玩且珍惜吧。\r\n# 1. 写小说\r\n国外某网友在社区里写到：““哇，这东西太不可思议了！ 我无语了。 我真的问了我能想到的第一件事，结合了我的三个爱好：写作、悬疑小说和爵士乐。“ 然后，他对ChatGPT的要求是：“为一部悬疑小说写一段情节，其中一名失魂落魄的凶杀案侦探追捕一名高智商连环杀手，后者专门猎sha弹奏爵士乐Autumn Leaves的音乐家”。\r\n\r\n然后他分享了ChatGPT的回复：\r\n>“侦探詹姆斯汤普森是凶杀案部门经验丰富的老手，但最近他一直感到筋疲力尽和沮丧。 他最近的案件是一名年轻的爵士钢琴家被谋杀，被发现在他的家中被残忍杀害，这只会加深他的绝望感……（提供更多）“\r\n# 2. 向演讲嘉宾进行提问\r\n比如你组织一个活动，邀请了演讲嘉宾，我们经常会发生比如没有人提问的尴尬场面，这个时候一般就需要组织者也就是你代为问一些问题，这个时候就可以请ChatGPT来为你提问。\r\n\r\n例如，会议主题是关于“水资源短缺问题”。 演讲者是水资源管理方面的专家。 接下来就可以要求ChatGPT：“关于海水淡化及其影响，我应该问专家哪些问题？”\r\n\r\nChatGPT 回复了……\r\n>“海水淡化目前在世界范围内是如何使用的，在哪些类型的地点最有效？“\\\\\r\n”使用海水淡化提供淡水的潜在优势和劣势是什么？“\\\\f\r\n”海水淡化技术的一些主要挑战和局限性是什么？如何解决这些问题？“\r\n# 3. 创建游戏\r\n这个没有实际尝试过，不过看到了以下这条新闻：\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a0674357154433b088524529bccefe~tplv-k3u1fbpfcp-watermark.image?)\r\n# 4. 约会顾问\r\n当被问到，“怎么在社交软件里给爱慕的异性发第一条带有一点情调的信息“，虽然回答有点怪怪，但ChatGPT表现的主动超乎我们想象：\r\n\r\n>“你隔着屏幕引起了我的注意。 我忍不住打招呼，看看我们之间是否有火花。“ \\\\\r\n>“你的个人资料照片很棒。 我一直在想你[Feature]以及我多么想更好地了解你。”\\\\\r\n>“我通常不是迈得出第一步的人，但我不得不给你发消息。 你令人难以置信 [有吸引力的品质]，我迫不及待地想和你聊天。”\\\\\r\n>“你好呀！ 我看到了你的个人资料，我不想说谎，我有点害羞。 你是如此 [有吸引力的品质]，我感觉有点追星了。”\r\n\r\n# 5. 减轻孤独感和焦虑\r\n我们都发现 ChatGPT 在一对一对话方面表现出色。有AI社区网友对ChatGPT说：“我现在真的很伤心和孤独。”\r\n\r\n得到的回答鼓舞人心：\r\n\r\n>“得知您感到悲伤和孤独，我很难过。 有时感到沮丧是很自然的，但重要的是要记住你并不孤单。 有很多人关心你，想帮助你。 与某人谈论您的感受可能会有所帮助，无论是密友、家人还是心理健康专家。有时候，仅仅向别人表达你的想法和情绪就可以帮助减轻你的悲伤和孤独。 照顾好自己并做一些让自己开心的事情也很重要，例如与所爱的人共度时光、追求爱好或锻炼身体。 这些东西可以帮助改善你的情绪，让你感觉与他人的联系更紧密。 请记住，你是坚强的，有能力的，你可以度过这段艰难的时期。\r\n\r\n另一位网友说：我认为 ChatGPT 可以用于心理治疗，所以我请它来教我写日记来帮助我应对焦虑：\r\n\r\n于是他得到了ChatGPT专业的答复：\r\n>写下此刻让你焦虑的事情。\r\n描述一个让你感到焦虑的情况，以及你是如何应对的。\r\n反思你的想法和信念是如何导致你的焦虑的。\r\n写一封信给你的焦虑，表达你的感受和担忧\r\n想象自己在一个平静祥和的地方，并详细描述。\r\n（随后还有更多内容）\r\n# 6. 给东西命名\r\n我：帮我想出一种新饮料的名字。 它有日本杜松子酒、汤力水、酸橙、胡椒粉和葡萄柚。\r\n\r\nChatGPT：\r\n>“樱花日出”怎么样？ 这个名字结合了日本杜松子酒和葡萄柚和酸橙的柑橘味，“日出”这个词暗示着一天的新鲜和充满活力的开始。 或者，您可以选择“胡椒葡萄柚杜松子酒”之类的东西来强调胡椒和葡萄柚的独特风味组合。\r\n# 7. 实时翻译\r\n你可以在手机上使用 ChatGPT，因此它是一个完美的翻译工具。 比如说你在意大利旅行，你需要帮助：\r\n\r\n我：将以下内容翻译成意大利语 - “我的车快没油了，你能告诉我最近的加油站在哪里吗？”\r\n\r\nChatGPT：\r\n\r\n>“La mia auto sta per esaurire il carburante, mi puoi dire dove si trova la stazione di servizio più vicina？”\r\n# 8. 健身顾问\r\n我：我希望能够在 3 个月内跑完 5 公里。 为我制定一个能够实现这一目标的跑步计划吧？\r\n\r\nChatGPT：\r\n\r\n>这是一个可以帮助你在3个月内跑完5公里的跑步计划：从每天步行 15-20 分钟开始，以增强您的耐力并让您的身体习惯定期锻炼。步行一周后，开始将短距离慢跑纳入您的日常活动。 从一次慢跑 1-2 分钟开始，中间休息一下。 逐渐增加慢跑的时间并减少步行的时间。一旦您可以不停地慢跑 10 分钟，就可以开始增加跑步距离。 目标是不停地跑 1 公里，然后逐渐增加距离。除了常规跑步之外，将力量训练和伸展运动纳入您的日常活动中，以改善您的整体健康状况并降低受伤风险。（更多细节...）\r\n# 9. 为教师提供课程计划\r\nAI社区一位教师：今天早上我在想谁拥有世界上最困难的工作。 教师。学生太多，时间不够。 如果他们可以将课程计划内容交付给 ChatGPT 会怎么样？ 我试了一下，这就是它提供的：\r\n\r\n>课程名称：人工智能的历史和影响\r\n目标：学生将了解人工智能的历史和发展，并能够识别和讨论人工智能对社会的潜在积极和消极影响。\\\\\r\n\\\\\r\n材料：\\\\\r\n\\\\*AI 历史上重大事件的时间表\\\\\r\n\\\\*人工智能技术与应用实例\\\\\r\n\\\\\r\n课程大纲：\\\\\r\n\\\\*引入人工智能的话题，并说明它是指开发能够模拟人类智能和行为的计算机系统和算法。\\\\\r\n\\\\*显示 AI 历史上重大事件的时间表，并讨论该领域的关键里程碑和发展。\\\\\r\n\\\\*展示人工智能技术和应用的例子，并解释它们如何应用于各个行业和领域。\\\\\r\n\\\\*讨论人工智能对社会的潜在正面和负面影响，包括它提高生产力、效率和安全性的潜力，以及它带来新挑战和担忧的潜力，例如工作岗位流失和道德问题。（后面还有更多细节）\r\n# 10. 推荐活动嘉宾\r\n我：谁是我的 Web3 营销讲座的理想嘉宾？\r\n\r\nChatGPT：\r\n>您的 Web3 营销讲座的理想嘉宾可能包括 Web3 营销领域的行业专家、影响者和思想领袖。 这些可能包括活跃在 Web3 营销领域的数字营销人员、内容创建者、企业主、企业家和技术专家。 您还可以邀请与 Web3 相关的初创公司和组织的代表作为您讲座的嘉宾。\r\n\r\n我：你能给我举个例子吗？\r\n\r\nChatGPT：\r\n>您的 Web3 营销播客的一些理想嘉宾示例可能包括：Tim Berner-Lee-万维网的发明者，Chris Dixon/Andreessen Horowitz-普通合伙人，Vitalik Buterin-以太坊创始人，ConsenSys 创始人 Joe Lubin，苏珊·福勒-《告密者》的作者（省略更多建议...）\r\n# 11. 帮助商家处理其社交媒体上的评论和留言\r\n一位商家用户想到请ChatGPT代替她回复她餐厅消费者的评论。\r\n\r\n消费者好评：“我非常喜欢这个地方。 我们经常出去吃饭，这个地方名列前茅。 完美的菜品，出色的员工和一切的时机都很棒！ 非常感谢 xxx餐厅- 来自yyy的客人，谢谢！”\r\n\r\nChatGPT 回复：\r\n>非常感谢您的好评和花时间写评论。 我们很高兴听到您在我们的餐厅有如此美好的体验。 我们很高兴您享受您的用餐和 xxx 提供的服务。 很高兴为来自yyy的客人提供服务，我们感谢您的支持。 我们期待着很快再次欢迎您回来。 再次感谢您的正面评价。\r\n\r\n消费者中评：“食物一般，风景不错，仅此而已”\r\nChatGPT：\r\n>感谢您的评论。 如果您的用餐体验没有达到您的期望，我们深表歉意。 我们努力为所有客户提供最优质的食品和服务，我们会在不断改进的同时考虑您的反馈。 感谢您让我们知道您的体验。\r\n# 12. 家具设计\r\n我看到过有人通过和ChatGPT的对话，最终设计出一个小型的桌子：\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e79d00d2fe894ff985cc8b72246f5dd4~tplv-k3u1fbpfcp-watermark.image?)\r\n# 13. 协助回答专业采访\r\n针对即将面临的话题采访“销售行业的未来”，有人向ChatGPT要求给予一些可能的问答建议。\r\n\r\nChatGPT回应：\r\n>“\r\n当然，以下是您在面试中可能会被问到的关于销售行业未来的一些潜在问题，以及如何回答这些问题的建议：\\\\\r\n**您认为技术在未来几年将如何影响销售行业？**\r\n在未来几年，技术可能会对销售行业产生重大影响。 技术可能影响销售行业的一些潜在方式包括越来越多地使用自动化和人工智能来处理日常任务，以及数据分析和客户关系管理工具的重要性越来越高。 此外，电子商务和在线销售渠道的兴起可能会继续重塑销售格局。\\\\\r\n**您认为销售人员的角色在未来会发生怎样的变化？**\r\n将来，销售人员的角色可能会随着不断变化的客户需求和期望而发生变化。 销售人员需要在他们的方法中更有知识和咨询，并且需要能够帮助客户驾驭复杂的产品和服务。 此外，数据分析和客户关系管理工具的重要性日益增加，这可能要求销售人员对技术有更深入的了解，并能够在工作中有效地使用它。\\\\\r\n**您认为未来销售专业人员最重要的技能是什么？**\r\n未来，销售专业人员将需要多种技能才能取得成功。 除了强大的沟通和人际交往能力外，销售专业人员还需要对他们销售的产品和服务有高度的了解，并能够有效地使用数据分析和客户关系管理工具。 此外，适应不断变化的客户需求的能力以及不断学习和了解行业趋势的能力对于销售行业的成功至关重要。\r\n“\r\n# 14. 礼物的建议\r\n有国外网友向ChatGPT咨询圣诞节送给老婆什么礼物：\r\n网友：“为一位热爱老鹰乐队的中年女性推荐一份 200 美元以下的礼物。”\r\n\r\nChatGPT：\r\n>对于喜爱老鹰乐队的中年女性来说，一个潜在的礼物创意是一张他们经典专辑之一的黑胶唱片，例如“Hotel California”或“The Long Run”。 近年来，黑胶唱片重新流行起来，许多音乐爱好者都喜欢在黑胶唱片上聆听音乐的独特声音和体验。您还可以考虑将黑胶唱片与高品质唱片播放器搭配使用，以获得完整的礼品包装。 这类礼物很可能会受到老鹰乐队的歌迷的青睐，而黑胶唱片和电唱机的组合很可能在您 200 美元的预算之内。\r\n# 15. 解释一些复杂的概念\r\n我输入：请把我当成10岁小孩那样，向我解释量子物理\r\n\r\nChatGPT：\r\n>量子物理学是研究微小粒子（如原子和亚原子粒子）行为方式的科学分支。 这些粒子是如此之小，以至于它们并不总是遵循与我们每天都能看到和触摸到的事物相同的规则。比如有时候他们可以同时在两个地方，或者即使相隔很远也可以成为朋友。 这听起来可能很奇怪，但这是科学家从研究这些微小粒子中学到的东西。 量子物理学帮助我们了解世界在非常小的尺度上是如何运作的，它还可以帮助我们创造新技术，比如比我们今天拥有的计算机快得多的计算机。\r\n# 16. 起文章标题\r\n 我叫ChatGPT为本文写一个强有力的标题（虽然我没有采纳...），介绍 ChatGPT 的 16 种创造性和娱乐性用途”\r\n\r\nChatGPT：\r\n>以下是文章的一些潜在标题，其中介绍了 ChatGPT 的 16 种创造性和娱乐性用途：\\\\\r\n“使用 ChatGPT 的 16 种有趣且富有创意的方式：从游戏到解谜”\\\\\r\n“使用 ChatGPT 进行娱乐和创意的终极指南”\\\\\r\n“使用 ChatGPT 的 16 个理由：它如何增强您的游戏能力、故事能力或者其他能力”\\\\\r\n“ChatGPT 的 16 种娱乐用途，你从来不知道这是可能的”\\\\\r\n“通过 ChatGPT 释放您的想象力：16 种创造性的和有趣的使用方式”\r\n# 总结\r\n这篇文章还远远没有覆盖ChatGPT的很多使用场景，比如编曲、撰写研究论文等都已经开展起来，希望通过此文可以激发你的灵感，更重要的是，加入到使用者队伍中来，体验这个将深刻改变需要行业的AI。我本人也会持续关注和使用，欢迎交流！"
    },
    {
        "article_id": "7188897810287165495",
        "snapshot": "",
        "title": "为什么NumPy这么快",
        "preview": "本文从NumPy的数据结构和算法实现上，探讨了其高性能的原理，并简单介绍了部分API，希望能吸引你学习它的兴趣",
        "author": "游戏不存在",
        "view_count": 1111,
        "collect_count": 4,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/da09b92a1a828d9329dff192c3ec1cb5~300x300.image",
        "category": "人工智能",
        "content": "NumPy是使用 Python 进行科学计算的基础包，是Python数据科学基础中的基础。它具有下面六大特点:\r\n\r\n1. 强大的 N 维数组。NumPy 向量化、索引和广播概念快速且通用，是当今数组计算的实际标准。\r\n2. 数值计算工具。NumPy 提供全面的数学函数、随机数生成器、线性代数例程、傅里叶变换等。\r\n3. 可互操作。NumPy 支持广泛的硬件和计算平台，与分布式、GPU 和稀疏数组库配合良好。\r\n4. 高性能。NumPy 的核心是经过良好优化的 C 代码。享受 Python 的灵活性和编译代码的速度。\r\n5. 使用方便。NumPy 的高级语法使任何背景或经验水平的程序员都可以轻松访问并提高效率。\r\n6. 开源。NumPy在自由BSD 许可下分发，由充满活力、响应迅速且多样化的社区在 GitHub 上公开开发和维护。\r\n\r\n以上来自NumPy的官网，个人觉得NumPy主要具有下面二个特点，我们一起来了解它:\r\n1. 高性能\r\n2. API简单易用\r\n\r\n\r\n## 高性能的NumPy\r\n\r\n高性能是科学计算的首要需求，大量数据，大量的循环，快字当先，毕竟谁也不希望跑一个模型好几天。我们先看一个简单的例子: 使用Python的列表推导式输出长度1000的数组，每个元素是自然数的平方, 代码如下:\r\n```\r\nL = range(1000)\r\n%timeit [i**2 for i in L]\r\n```\r\n这是使用NumPy的方式:\r\n```\r\na = np.arange(1000)\r\n%timeit a**2\r\n```\r\n\r\n测试结果中两者的耗时如下表:\r\n\r\n循环测试|耗时\r\n---|---\r\n列表推导式循环|437 µs ± 1.38 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\r\nnumpy循环| 1.97 µs ± 19.3 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\r\n\r\n可以看到测试结果NumPy比列表推导式快了几百倍。\r\n\r\n为什么NumPy这么快呢？首要原因在于NumPy的核心是经过良好优化的C代码，具有编译代码的速度。其次在于NumPy的数据结构设计和算法，这一点是很多文章都没有介绍的，这是我想重点介绍的内容。\r\n\r\nNumPy提供的最重要的数据结构是一个称为NumPy数组的强大对象，它有下面两个特点:\r\n\r\n1. 数组长度固定\r\n2. 仅支持同类型数据元素\r\n\r\n我们知道Python的list，是动态的并且可以存放任意类型的元素, 比如:\r\n```\r\n>>> a = [\\\"a\\\", 9, 9.0, True]\r\n>>> a.append(\\\"b\\\")\r\n>>> a\r\n['a', 9, 9.0, True, 'b']\r\n```\r\na数组包含了4个元素，数据类型各不相同，我们还可以使用append方法往a中添加元素。实际数组有长度(length)和容量(capacity)两个概念，我这里借用一下go-slice的图示意一下:\r\n\r\n![容量和长度](https://miro.medium.com/max/640/1*p3wNR1_4I6dmqdI7han4vA.webp)\r\n* 长度表示当前数组内元素个数\r\n* 容量表示当前数组最多可以存储多少个元素，超过了则需要重新申请内存区域\r\n* 一般扩容申请都会翻倍。比如上图是6个方格，已经使用了4个，再添加3个，这时候会直接再申请6个，而不是3个。\r\n\r\n所以我们可以设想一下，使用列表推导式的时候，经过多次的内存申请，效率就低了下来。而NumPy数组是长度固定的，一次申请到位，自然效率会高不少。\r\n\r\n如果大家做过协议处理，一定理解定长和不定长协议。定长协议中，每个协议长度相同，计算起来非常快捷，直接当前位置+固定长度就可以获取下一个协议位置；而不定长协议，还需要解析当前协议长度，判断当前协议的长度，才可以得知下一个协议的位置。\r\n\r\n我们把数组在内存中的存储相信成协议的字节流，这就一致了。NumPy仅支持同类型的数据元素，就是定长协议的解析，效率很高。\r\n```\r\n# 定长\r\n+---+---+---+---+---+---+\r\n|   |   |   |   |   |   |\r\n+---+---+---+---+---+---+\r\n\r\n# 不定长\r\n+--+----+------+--+-----+\r\n|  |    |      |  |     |\r\n+--+----+------+--+-----+\r\n```\r\n* 字符图不好理解的话，大家可以把定长元素想象为高铁车厢，不定长元素想象成汽车，那么春运的铁路运输和公路运输效率就一目了然\r\n\r\n需要注意，NumPy中数组也可以放不同 *Python类型* 元素，但是它们都会(长度)向上对齐到 *NumPy数据类型* ，下面的U32就是NumPy的数据类型:\r\n```\r\nnp.array([\\\"a\\\", 9, 9.0])\r\narray(['a', '9', '9.0'], dtype='<U32')\r\n```\r\n\r\nNumPy支持矩阵运算，这也是NumPy高性能原因所在。\r\n\r\n我们先复习一下矩阵的哈达玛积(Hadamard product)，使用符号A⊙B表示：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76c757238014416286c4e862ac7253ee~tplv-k3u1fbpfcp-zoom-1.image)\r\n* 两个矩阵对应位置的元素逐一相乘\r\n\r\n那么a**2的运算使用矩阵的方式就是这样:\r\n```\r\n+-----------+     +-----------+     +--------------+\r\n|1,2,3,...,n|  ⊙  |1,2,3,...,n|  =  |1,4,9,...,N*N |\r\n+-----------+     +-----------+     +--------------+\r\n```\r\n* 这里二维变成一维，计算法则是一样的\r\n\r\n使用矩阵后就可以进行并发处理了，这和大数据中的map-reduce模型类似。我们可以这样理解它，普通的列表推导式:\r\n```\r\nL = range(1000)\r\nfor i in L:\r\n    i**2        \r\n```\r\n需要经历1000次循环，并且只能够在CPU的单核上逐次执行。根据矩阵运算公式，对应A\\\\_i位置的元素，只需要和B\\\\_i位置的元素相乘，和其它的999个数都无关，那么我们可以将整个大的运算拆分成1000个小运算，分到多个CPU核上并发执行，计算出每个位置元素后，再汇总即可。\r\n\r\n所以NumPy采用良好的数据结构+高效的算法，性能自然上去了。\r\n\r\n## 简单易用的NumPy\r\n\r\n如果仅关注性能那么Fortran, matlab, R语言也足够了，或者直接使用C语言。Python语言足够简洁和灵活，使用它包装的API简单易用，又使NumPy的开发效率带来很大提升。我们可以通过下面几个小的例子来了解NumPy的这个特点。\r\n\r\n首先是NumPy的数组切片非常强大，如图:\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b1b41925aa14bb08faf8456c130e530~tplv-k3u1fbpfcp-zoom-1.image)\r\n* 红色切片取第0行的，第3-第4个元素(左闭右开)\r\n* 绿色切片取第4行和第4列后面的元素\r\n* 蓝色切片取第3列\r\n* 紫色切片按照2的步进取元素\r\n\r\n然后是NumPy支持数学运算:\r\n```\r\n>>> import numpy as np\r\n>>> a = np.arange(5)\r\n>>> a\r\narray([0, 1, 2, 3, 4])\r\n>>> np.sin(a)\r\narray([ 0.        ,  0.84147098,  0.90929743,  0.14112001, -0.7568025 ])\r\n```\r\n同样的计算，我们在python中大概这样实现:\r\n```\r\nimport math\r\n>>> import math\r\n>>> items = [0, 1, 2, 3, 4]\r\n>>> list(map(lambda x: math.sin(x), items))\r\n[0.0, 0.8414709848078965, 0.9092974268256817, 0.1411200080598672, -0.7568024953079282]\r\n```\r\n对比可见，NumPy包装的API更便捷。\r\n\r\n最后NumPy还提供了很多统计函数， 比如:\r\n```\r\n>>> x = np.array([1, 2, 3, 4])\r\n>>> np.sum(x)\r\n10\r\n>>> x.sum()\r\n10\r\n>>> x.max()\r\n4\r\n>>> x.min()\r\n1\r\n>>> x.mean()\r\n2.5\r\n```\r\n* `np.sum(x)` 和 `x.sum()` 是API的两种写法，我们更常使用后面的方法\r\n\r\n更多的API使用，可以阅读参考链接中的用户指南和参考手册\r\n\r\n## 小结\r\n\r\nNumPy由于高性能和简单易用，是Python进行科学计算的基石。本文从NumPy的数据结构和算法实现上，探讨了其高性能的原理，并简单介绍了部分API，希望能吸引你学习它的兴趣。\r\n\r\n## 参考链接\r\n\r\n* https://www.numpy.org.cn/user/\r\n* https://www.numpy.org.cn/about/\r\n"
    },
    {
        "article_id": "7189420175416885309",
        "snapshot": "",
        "title": "初探 Babel 插件开发",
        "preview": "Babel api 介绍 之前介绍了 babel 的编译流程和 AST，我们就大概知道了 babel 做了什么。但是还需要了解下 babel 的 api，然后通过这些 api 来操作 AST，完成代码",
        "author": "WhaleFE",
        "view_count": 1918,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/7ba4cfbe328e8f6e5248947fc6b1a2c7~300x300.image",
        "category": "前端",
        "content": "> 本篇文章分享来自小伙伴「huanxing」的一次学习总结分享，希望跟社区的同学一起探讨。\r\n\r\n## Babel api 介绍\r\n\r\n之前介绍了 babel 的编译流程和 AST，我们就大概知道了 babel 做了什么。但是还需要了解下 babel 的 api，然后通过这些 api 来操作 AST，完成代码的转换。\r\n\r\n我们知道 babel 的编译流程分为三步：parse、transform、generate，每一步都暴露了一些 api 出来。\r\n\r\n- parse 阶段有@babel/parser，功能是把源码转成 AST\r\n- transform 阶段有 @babel/traverse，可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 @babel/types 了，当需要批量创建 AST 的时候可以使用 @babel/template 来简化 AST 创建逻辑。\r\n- generate 阶段会把 AST 打印为目标代码字符串，同时生成 sourcemap，需要 @babel/generator 包，中途遇到错误想打印代码位置的时候，可以使用 @babel/code-frame 包\r\n- babel 的整体功能通过 @babel/core 提供，基于上面的包完成 babel 整体的编译流程，并应用 plugin 和 preset。\r\n\r\n这些包的 api 都可以在[文档](https://babel.docschina.org/docs/en/babel-parser/)里查看。\r\n### @babel/parser\r\nbabel parser 默认只能 parse js 代码，jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。\r\n\r\n它提供了有两个 api：parse 和 parseExpression。两者都是把源码转成 AST，不过 parse 返回的 AST 根节点是 File（整个 AST），parseExpression 返回的 AST 根节点是是 Expression（表达式的 AST），粒度不同。\r\n```javascript\r\nfunction parse(input: string, options?: ParserOptions): File\r\nfunction parseExpression(input: string, options?: ParserOptions): Expression\r\n```\r\n```javascript\r\nrequire('@babel/parser').parse(source, {\r\n\r\nsourceType: 'module',\r\n\r\nplugins: ['jsx', 'flow', 'classProperties', 'decorator', 'decorators-legacy'],\r\n\r\n});\r\n```\r\nplugins： 指定jsx、typescript、flow 等插件来解析对应的语法。\r\n\r\nsourceType： module、script、unambiguous 3个取值，module 是解析 es module 语法。通常一般默认unambiguous，可以根据内容是否有 import 和 export 来自动设置 module 还是 script。\r\n### @babel/traverse\r\nparse 出的 AST 由 @babel/traverse 来遍历和修改，babel traverse 包提供了 traverse 方法\r\n```javascript\r\nrequire(\\\"@babel/traverse\\\").default(parent, opts)\r\n```\r\n常用的就前面两个参数，parent 指定要遍历的 AST 节点，opts 指定 visitor 函数。babel 会在遍历 parent 对应的 AST 时调用相应的 visitor 函数。\r\n\r\nvisitor 是指定对什么 AST 做什么处理的函数，babel 会在遍历到对应的 AST 时回调它们。而且可以指定刚开始遍历（enter）和遍历结束后（exit）两个阶段的回调函数，\r\n```javascript\r\nrequire(\\\"@babel/traverse\\\").default(ast, {\r\n  /** - 1.进入节点时调用（一般不用） */\r\n  enter(path) {\r\n    console.log('__enter__');\r\n  },\r\n  /** - 2.离开节点时调用（一般不用） */\r\n  exit(path) {\r\n    console.log('__exit__');\r\n  },\r\n  /** - 3.当遍历到指定节点类型时调用，比如这里是：FunctionDeclaration（函数声明）（建议方案） */\r\n  FunctionDeclaration(path) {\r\n    console.log('__FunctionDeclaration__');\r\n  },\r\n  /** - 4.你可以单独监听某个节点类型的进入或者离开 */\r\n  FunctionDeclaration: {\r\n    enter(path) {\r\n      console.log('__FunctionDeclaration_enter_');\r\n    },\r\n    exit(path) {\r\n      console.log('__FunctionDeclaration_exit_');\r\n    },\r\n  },\r\n  /** - 5.当遍历到 FunctionDeclaration|ReturnStatement 节点时调用（这种方式会覆盖前面几种方式） */\r\n  ['FunctionDeclaration|ReturnStatement'](path) {\r\n    console.log('__FunctionDeclaration|ReturnStatement');\r\n  },\r\n});\r\n```\r\n具体的类型有哪些可以在[babel-types 的类型定义](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Fblob%2Fmain%2Fpackages%2Fbabel-types%2Fsrc%2Fast-types%2Fgenerated%2Findex.ts%23L2059)中查。\r\n#### path\r\n每个 visitor 都有 path 和 state 的参数，path 记录了 AST 在遍历过程中的路径。\r\n\r\n我们可以通过 path 对象表示节点之间的关联关系。通过这个对象提供的属性方法，我们可以操作 AST 语法树。\r\n```javascript\r\n// 属性\r\npath.state // Babel 插件信息，可通过 state.opts 获取传入的 Options；\r\npath.node // 当前遍历到的 node 节点，可通过它访问节点上的属性，对于 Ast 节点；\r\npath.parent // 父级 node，无法进行替换；\r\npath.parentPath // 父级 path，可进行替换；\r\npath.scope // 作用域相关，可用于变量重命名，变量绑定关系检测等；\r\npath.key // 获取路径所在容器的索引\r\npath.listKey // 获取容器的 key\r\npath.container // 获取路径的容器（包含所有同级节点的数组）\r\npath.inList // 判断路径是否有同级节点\r\n\r\n// 方法\r\npath.toString() // 当前路径所对应的源代码；\r\npath.isXXX // XXX为节点类型，可以判断是否符合节点类型。比如我们需要判断路径是否为 StringLiteral 类型 → path.isStringLiteral；\r\npath.get(key) // 获取子节点 path，例如：path.get('body.0') 可以理解为 path.node.body[0]这样的形式，让我们更加方便的拿到子路径，但是注意仅路径可以这样操作，访问属性是不允许的！\r\npath.set(key) // 设置子节点 path;\r\npath.remove() // 删除 path;\r\npath.replaceWith() // 用AST节点替换该节点，如：path.replaceWith({ type: 'NumericLiteral', value: 3 })，创建节点可以使用 @babel/types，如果是多路径则使用 relaceWithMultiple([AST...]);\r\npath.replaceWidthSourceString() // 用字符串替换源码\r\npath.find((path) => path.isObjectExpression()) // 向下搜寻节点\r\npath.findParent() // 向父节点搜寻节点\r\npath.getSibling()、path.getNextSibling()、path.getPrevSibling() // 获取兄弟路径；\r\npath.getFunctionParent() // 向上获取最近的 Function 类型节点；\r\npath.getStatementParent() // 向上获取最近的 Statement 类型节点；\r\npath.insertBefore() // 在之前插入兄弟节点\r\npath.insertAfter() // 在之后插入兄弟节点\r\npath.pushContainer() // 将AST push到节点属性里面\r\npath.traverse() // 递归的形式消除全局状态（官网 >> 例子已经不错了）\r\npath.stop() // 停止遍历\r\npath.skip() // 不往下遍历，跳过该节点\r\n\r\n```\r\n#### state\r\n第二个参数 state 则是遍历过程中在不同节点之间传递数据的机制，插件会通过 state 传递 options 和 file 信息，我们也可以通过 state 存储一些遍历过程中的共享数据。\r\n### @babel/types\r\n遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型，这时候就需要 @babel/types 包。\r\n\r\n举例来说，如果要创建IfStatement就可以调用\r\n```javascript\r\nt.ifStatement(test, consequent, alternate); \r\n```\r\n而判断节点是否是 IfStatement 就可以调用 isIfStatement 或者 assertIfStatement\r\n```javascript\r\nt.isIfStatement(node, opts); t.assertIfStatement(node, opts); \r\n```\r\nopts 可以指定一些属性是什么值，增加更多限制条件，做更精确的判断。\r\n```javascript\r\nt.isIdentifier(node, { name: \\\"paths\\\" }) \r\n```\r\nisXxx 和 assertXxx 看起来很像，但是功能不大一样：isXxx 会返回 boolean，而 assertXxx 则会在类型不一致时抛异常\r\n### @babel/generator\r\n当我们对AST进行遍历操作之后，就可以通过 @babel/generator 将 AST 生成目标代码了，具体使用如下：\r\n```javascript\r\nconst generator = require('@babel/generator');\r\n\r\n// ...\r\n\r\n// → 将AST输出为目标代码\r\nconst code = generator.default(ast).code;\r\nconsole.log(code);\r\n\r\n```\r\n### @babel/template\r\n通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 @babel/template 包来批量创建。\r\n如： \r\n```javascript\r\nconst ast = template(code, [opts])(args);\r\nconst ast = template.ast(code, [opts]); // 返回的是整个 AST\r\nconst ast = template.program(code, [opts]); // 返回的是 Program 根节点。\r\nconst ast = template.expression(code, [opts]); // 返回创建的 expression 的 AST。\r\nconst ast = template.statements(code, [opts]) // 返回创建的 statems 数组的 AST。\r\n```\r\n模版也支持占位符，可以在模版里设置一些占位符，调用时再传入这些占位符参数对应的 AST 节点。\r\n```javascript\r\nconst fn = template(`console.log(NAME)`);\r\n// const fn = template(`console.log(%%NAME%%)`);\r\n\r\nconst ast = fn({\r\n  NAME: t.stringLiteral(\\\"guang\\\"),\r\n});\r\n```\r\n加不加 %% 都行，当占位符和其他变量名冲突时可以加上。\r\n### @babel/core\r\n@babel/core 包基于前面的包完成整个编译流程，从源码到目标代码，生成 sourcemap，其语法形式如下：\r\n```javascript\r\n// → 同步方法\r\ntransformSync(code, options); // => { code, map, ast }\r\ntransformFileSync(filename, options); // => { code, map, ast }\r\ntransformFromAstSync(parsedAst, sourceCode, options); // => { code, map, ast }\r\n// → 异步方法\r\ntransformAsync('code();', options).then((result) => {});\r\ntransformFileAsync('filename.js', options).then((result) => {});\r\ntransformFromAstAsync(parsedAst, sourceCode, options).then((result) => {});\r\n\r\n```\r\n## 插件开发实践\r\n知道了 babel 的编译流程、AST、api 之后，我们已经可以做一些有趣的事情了。比如我们在开发的时候经常会使用 console 来调试代码，为了让打印信息更清晰，我们可以在 console.log 等 api 中插入文件名和行列号的参数，方便定位到代码。如：\r\n```javascript\r\nconsole.log(1); -> console.log('文件名（行号，列号）：', 1);\r\n```\r\n我们可以先看下 console.log(1) 的 AST 结构\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d98530a8e40843b28f9aacdb786f5b83~tplv-k3u1fbpfcp-zoom-1.image)\r\n函数调用表达式的 AST 是 CallExpression。\r\n\r\n那我们要做的是在遍历 AST 的时候对 console.log、console.info 等 api 自动插入一些参数，也就是要通过 visitor 指定对 CallExpression 的 AST 做一些修改。\r\n\r\nCallExrpession 节点有两个属性，callee 和 arguments，分别对应调用的函数名和参数， 所以我们要判断当 callee 是 console.xx 时，在 arguments 的数组中插入一个 AST 节点。如：\r\n```javascript\r\nconst parser = require('@babel/parser');\r\nconst generate = require('@babel/generator').default;\r\nconst traverse = require('@babel/traverse').default;\r\nconst t = require('@babel/types')\r\nconst path = require(\\\"path\\\")\r\n\r\n/**\r\n * 给console插入行列序号\r\n */\r\nconst sourceCode = `function func() {\r\n    console.info(2);\r\n}`\r\n\r\nconst ast = parser.parse(sourceCode, {\r\n    sourceType: 'unambiguous'\r\n})\r\nconst stringCode = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`)\r\nconst fileName = path.basename(__dirname)\r\ntraverse(ast, {\r\n    CallExpression(path, state){\r\n        if(t.isMemberExpression(path.node.callee) && path.node.callee.object.name === 'console' && ['log', 'info', 'error', 'debug'].includes(path.node.callee.property.name)) {\r\n            const {line, column} = path.node.loc.start \r\n            path.node.arguments.unshift(t.stringLiteral(`${fileName}: (${line},${column})`))\r\n        }\r\n    }\r\n})\r\n\r\nconst {code} = generate(ast)\r\n\r\nconsole.log(code)\r\n// 输出结果为：\r\n// function func() {\r\n//   console.info(\\\"fileName: (2,4)\\\", 2);\r\n// }\r\n\r\n```\r\n虽然结果是符合预期的，但是我们可以发现 if 的判断条件过于复杂，我们可以优化一下。可以通过path.toString() 把 callee 的 AST 转换成代码字符串再进行判断，如：\r\n```javascript\r\ntraverse(ast, {\r\n    CallExpression(path, state){\r\n        if (stringCode.includes(path.get('callee').toString())) {\r\n            const {line, column} = path.node.loc.start \r\n            path.node.arguments.unshift(t.stringLiteral(`${fileName}: (${line},${column})`))\r\n        }\r\n    }\r\n})\r\n\r\n```\r\n如果我们想在 console 之前打印行列号，如：\r\n```javascript\r\nconsole.log(1);\r\n\r\n// 转换成\r\nconsole.log('文件名（行号，列号）：');\r\nconsole.log(1);\r\n```\r\n基本逻辑是差不多的，不过这里需要插入 AST，会用到 path.insertBefore 的 api。而且要跳过新的节点的处理，就需要在节点上加一个标记，如果有这个标记的就跳过。如：\r\n```javascript\r\nconst parser = require('@babel/parser');\r\nconst generate = require('@babel/generator').default;\r\nconst traverse = require('@babel/traverse').default;\r\nconst t = require('@babel/types')\r\nconst template = require(\\\"@babel/template\\\").default;\r\nconst path = require(\\\"path\\\")\r\n\r\n/**\r\n * 给console插入行列序号\r\n */\r\nconst sourceCode = `function func() {\r\n    console.info(2);\r\n}`\r\n\r\nconst ast = parser.parse(sourceCode, {\r\n    sourceType: 'unambiguous'\r\n})\r\nconst stringCode = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`)\r\nconst fileName = path.basename(__dirname)\r\ntraverse(ast, {\r\n    CallExpression(path, state){\r\n        if (path.node.isNew) {\r\n            return\r\n        }\r\n        if (stringCode.includes(path.get('callee').toString())) {\r\n            const {line, column} = path.node.loc.start \r\n            const newAst = template.expression(`console.log(\\\"${fileName}: (${line},${column}\\\")`)()\r\n            newAst.isNew = true\r\n            path.insertBefore(newAst)\r\n        }\r\n    }\r\n})\r\n\r\nconst {code} = generate(ast)\r\n\r\nconsole.log(code)\r\n\r\n// 输出结果\r\n// function func() {\r\n//   console.log(\\\"babel-1: (2,4\\\")\r\n//   console.info(2);\r\n// }\r\n\r\n```\r\n## 封装成 Babel 插件\r\nbabel 插件的形式就是函数返回一个对象，对象有 visitor 属性。\r\n\r\n函数的第一个参数可以拿到 types、template 等常用包的 api，这样我们就不需要单独引入这些包了。\r\n而且作为插件用的时候，并不需要自己调用 parse、traverse、generate，这些都是通用流程，babel 会做，我们只需要提供一个 visitor 函数，在这个函数内完成转换功能就行了。\r\n\r\n函数的第二个参数 state 中可以拿到插件的配置信息 options 等，比如 filename 就可以通过 state.filename 来取。\r\n```javascript\r\nconst stringCode = ['log', 'info', 'error', 'debug'].map(item => `console.${item}`)\r\n\r\nmodule.exports = function({types, template}) {\r\n    return {\r\n        name: 'parameters-insert-plugin',\r\n        visitor: {\r\n            CallExpression(path, state) {\r\n                if (path.node.isNew) {\r\n                    return;\r\n                }\r\n\r\n                if (stringCode.includes(path.get('callee').toString())) {\r\n                    const {line, column} = path.node.loc.start \r\n                    const newAst = template.expression(`console.log(\\\"${state.filename}: (${line},${column}\\\")`)()\r\n                    newAst.isNew = true\r\n                    path.insertBefore(newAst)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n然后通过 @babel/core 的 transformSync 方法来编译代码，并引入上面的插件：\r\n```javascript\r\nconst { transformFileSync } = require('@babel/core');\r\nconst insertParametersPlugin = require('./plugin/parameters-insert-plugin');\r\nconst path = require('path');\r\n\r\nconst { code } = transformFileSync(path.join(__dirname, './sourceCode.js'), {\r\n    plugins: [insertParametersPlugin],\r\n    parserOpts: {\r\n        sourceType: 'unambiguous'    \r\n    }\r\n});\r\n\r\nconsole.log(code);\r\n```\r\n这样我们就成功的把前面调用 parse、traverse、generate 的代码改造成了 babel 插件的形式。\r\n\r\n## 参考\r\n1. [https://juejin.cn/post/6992134202430849061#heading-6](https://juejin.cn/post/6992134202430849061#heading-6)\r\n2. [https://blog.csdn.net/lunahaijiao/article/details/121312776](https://blog.csdn.net/lunahaijiao/article/details/121312776)\r\n\r\n"
    },
    {
        "article_id": "7189808861388210235",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a899da639064603963c264eb322e030~tplv-k3u1fbpfcp-watermark.image?",
        "title": "MySQL性能优化浅析及线上案例",
        "preview": "业务发展初期，数据库中量一般都不高，也不太容易出一些性能问题或者出的问题也不大，但是当数据库的量级达到一定规模之后，如果缺失有效的预警、监控、处理等手",
        "author": "京东云开发者",
        "view_count": 834,
        "collect_count": 5,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/b9a366997037d998063135bd56302b85~300x300.image",
        "category": "后端",
        "content": "### 作者：京东健康 孟飞\r\n\r\n### **1、 数据库性能优化的意义**\r\n\r\n业务发展初期，数据库中量一般都不高，也不太容易出一些性能问题或者出的问题也不大，但是当数据库的量级达到一定规模之后，如果缺失有效的预警、监控、处理等手段则会对用户的使用体验造成影响，严重的则会直接导致订单、金额直接受损，因而就需要时刻关注数据库的性能问题。\r\n\r\n### **2、 性能优化的几个常见措施**\r\n\r\n数据库性能优化的常见手段有很多，比如添加索引、分库分表、优化连接池等，具体如下：\r\n\r\n| **序号** | **类型** | **措施**  | **说明**                                                                                                                                                                     |\r\n| ------ | ------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| 1      | 物理级别   | 提升硬件性能  | 将数据库安装到更高配置的服务器上会有立竿见影的效果，例如提高CPU配置、增加内存容量、采用固态硬盘等手段，在经费允许的范围可以尝试。                                                                                                         |\r\n| 2      | 应用级别   | 连接池参数优化 | 我们大部分的应用都是使用连接池来托管数据库的连接，但是大部分都是默认的配置，因而配置好超时时长、连接池容量等参数就显得尤为重要。 1、 如果链接长时间被占用，新的请求无法获取到新的连接，就会影响到业务。 2、 如果连接数设置的过小，那么即使硬件资源没问题，也无法发挥其功效。之前公司做过一些压测，但就是死活不达标，最后发现是由于连接数太小。 |\r\n| 3      | 单表级别   | 合理运用索引  | 如果数据量较大，但是又没有合适的索引，就会拖垮整个性能，但是索引是把双刃剑，并不是说索引越多越好，而是要根据业务的需要进行适当的添加和使用。 缺失索引、重复索引、冗余索引、失控索引这几类情况其实都是对系统很大的危害。                                                               |\r\n| 4      | 库表级别   | 分库分表    | 当数据量较大的时候，只使用索引就意义不大了，需要做好分库分表的操作，合理的利用好分区键，例如按照用户ID、订单ID、日期等维度进行分区，可以减少扫描范围。                                                                                              |\r\n| 5      | 监控级别   | 加强运维    | 针对线上的一些系统还需要进一步的加强监控，比如订阅一些慢SQL日志，找到比较糟糕的一些SQL，也可以利用业务内一些通用的工具，例如druid组件等。                                                                                                 |\r\n\r\n\r\n### **3、 MySQL底层架构**\r\n\r\n首先了解一下数据的底层架构，也有助于我们做更好优化。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a4dd564a9a84fb8a2d1cb293e926860~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**一次查询请求的执行过程**\r\n\r\n我们重点关注第二部分和第三部分，第二部分其实就是Server层，这层主要就是负责查询优化，制定出一些执行计划，然后调用存储引擎给我们提供的各种底层基础API，最终将数据返回给客户端。\r\n\r\n### **4、MySQL索引构建过程**\r\n\r\n目前比较常用的是InnoDB存储引擎，本文讨论也是基于InnoDB引擎。我们一直说的加索引，那到底什么是索引、索引又是如何形成的呢、索引又如何应用呢？这个话题其实很大也很小，说大是因为他底层确实很复杂，说小是因为在大部分场景下程序员只需要添加索引就好，不太需要了解太底层原理，但是如果了解不透彻就会引发线上问题，因而本文平衡了大家的理解成本和知识深度，有一定底层原理介绍，但是又不会太过深入导致难以理解。\r\n\r\n首先来做个实验：\r\n\r\n创建一个表，目前是只有一个主键索引\r\n\r\nCREATE TABLE `t1`(\r\n\r\na int NOT NULL,\r\n\r\nb int DEFAULT NULL,\r\n\r\nc int DEFAULT NULL,\r\n\r\nd int DEFAULT NULL,\r\n\r\ne varchar(20) DEFAULT NULL,\r\n\r\nPRIMARYKEY(a)\r\n\r\n)ENGINE=InnoDB\r\n\r\n插入一些数据：\r\n\r\ninsert into test.t1 values(4,3,1,1,'d');\r\n\r\ninsert into test.t1 values(1,1,1,1,'a');\r\n\r\ninsert into test.t1 values(8,8,8,8,'h');\r\n\r\ninsert into test.t1 values(2,2,2,2,'b');\r\n\r\ninsert into test.t1 values(5,2,3,5,'e');\r\n\r\ninsert into test.t1 values(3,3,2,2,'c');\r\n\r\ninsert into test.t1 values(7,4,5,5,'g');\r\n\r\ninsert into test.t1 values(6,6,4,4,'f');\r\n\r\nMYSQL从磁盘读取数据到内存是按照一页读取的，一页默认是16K，而一页的格式大概如下。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b1aa8e06ed441f9c04ccd40ecc5b5f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n每一页都包括了这么几个内容，首先是页头、其次是页目录、还有用户数据区域。\r\n\r\n1）刚才插入的几条数据就是放到这个用户数据区域的，这个是按照主键依次递增的单向链表。\r\n\r\n2）页目录这个是用来指向具体的用户数据区域，因为当用户数据区域的数据变多的时候也就会形成分组，而页目录就会指向不同的分组，利用二分查找可以快速的定位数据。\r\n\r\n**当数据量变多的时候，那么这一页就装不下这么多数据，就要分裂页，而每页之间都会双向链接，最终形成一个双向链表。**\r\n\r\n页内的单向链表是为了查找快捷，而页间的双向链表是为了在做范围查询的时候提效，下图为示意图，其中其二页和第三页是复制的第一页，并不真实。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b710524ed60349fcb5d9cf4c266e10d1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而如果数据还继续累加，光这几个页也不够了，那就逐步的形成了一棵树，也就是说索引B-Tree是随着数据的积累逐步构建出来的。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/756523f39bce4c7485b2b2076086f6f6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最下边的一层叫做叶子节点，上边的叫做内节点，而叶子节点中存储的是全量数据，这样的树就是**聚簇索引**。一直有同学的理解是说索引是单独一份而数据是一份，其实MySQL中有一个原则就是**数据即索引、索引即数据**，真实的数据本身就是存储在聚簇索引中的，所谓的**回表就是回的聚簇索引**。\r\n\r\n但是我们也不一定每次都按照主键来执行SQL语句，大部分情况下都是按照一些业务字段来，那就会形成别的索引树，例如，如果按照b,c,d来创建的索引就会长这样。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f02776d587f4715916c1c1b54b9dfa7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n推荐1个网站，可以可视化的查看一些算法原型：\r\n\r\n目录：\r\n\r\n<https://www.cs.usfca.edu/~galles/visualization/Algorithms.html>\r\n\r\nB+树\r\n\r\n<https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>\r\n\r\n而在MySQL官网上介绍的索引的叶子节点是双向链表。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af55d7b31c344508a7ca6c10e34a9a2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**关于索引结构的小结：**\r\n\r\n对于B-Tree而言，叶子节点是没有链接的，而B+Tree索引是单向链表，但是MySQL在B+Tree的基础之上加以改进，形成了双向链表，双向的好处是在处理> <，between and等'范围查询'语法时可以得心应手。\r\n\r\n### **5、MySQL索引的一些使用规范**\r\n\r\n1、 只为用于搜索、排序或分组的列创建索引。\r\n\r\n重点关注where语句后边的情况\r\n\r\n2、 当列中不重复值的个数在总记录条数中的占比很大时，才为列建立索引。\r\n\r\n例如手机号、用户ID、班级等，但是比如一张全校学生表，每条记录是一名学生，where语句是查询所有’某学校‘的学生，那么其实也不会提高性能。\r\n\r\n3、 索引列的类型尽量小。\r\n\r\n无论是主键还是索引列都尽量选择小的，如果很大则会占据很大的索引空间。\r\n\r\n4、 可以只为索引列前缀创建索引，减少索引占用的存储空间。\r\n\r\nalter table single_table add index idx_key1(key1(10))\r\n\r\n5、 尽量使用覆盖索引进行查询，以避免回表操作带来的性能损耗。\r\n\r\nselect key1 from single_table order by key1\r\n\r\n6、 为了尽可能的少的让聚簇索引发生页面分裂的情况，建议让主键自增。\r\n\r\n7、 定位并删除表中的冗余和重复索引。\r\n\r\n冗余索引：\r\n\r\n单列索引：（字段1）\r\n\r\n联合索引：（字段1 字段2）\r\n\r\n重复索引：\r\n\r\n在一个字段上添加了普通索引、唯一索引、主键等多个索引\r\n\r\n### **6、 执行计划**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1edbcf6aef6e49888ee740b1eb947e65~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其中常用的是：\r\n\r\npossible_keys: 可能用到的索引\r\n\r\nkey: 实际使用的索引\r\n\r\nrows：预估的需要读取的记录条数\r\n\r\n### **7、 线上案例**\r\n\r\n**案例1：**\r\n\r\n在建设互联网医院系统中，问诊单表当时量级23万左右，其中有一个business_id字符串字段，这个字段用来记录外部订单的ID，并且在该字段上也加了索引，但是'根据该ID查询详情'的SQL语句却总是时好时坏，性能不稳定，快则10ms，慢则2秒左右，SQL大体如下：\r\n\r\n**select 字段1、字段2、字段3 from nethp_diag where business_Id = ?**\r\n\r\n因为business_id是记录第三方系统的订单ID，为了兼容不同的第三方系统，因而设计成了**字符串类型**，但如果传入的是一个数字类型是无法使用索引的，因为MySQL只能将**字符串转数字，而不能将数字转字符串**，由于外部的ID有的是数字有的是字符串，因而导致索引一会可以走到，一会走不到，最终导致了性能的不稳定。\r\n\r\n**案例2：**\r\n\r\n在某次大促的当天，突然接到DBA运维的报警，说数据库突然流量激增，CPU也打到100%了，影响了部分线上功能和体验，遇到这种情况当时大部分人都比较紧张，下图为当时的数据库流量情况：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae3efe430a94bbb959d4a93777320b0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01368ee64d0442aa48afe1ec55613dc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n相关SQL语句：\r\n\r\n<!--统计医患下过去24小时内开的电子病历总数-->\r\n\r\n<select id=\\\"getCountByDPAndTime\\\" resultType=\\\"integer\\\">\r\n\r\nselect count(1)\r\n\r\nfrom jdhe_medical_record\r\n\r\nwhere status = 1 and is_test = #{isTest,jdbcType=INTEGER} and electric_medical_record_status in (2,3)\r\n\r\n**<if test=\\\"patientId != null\\\">**\r\n\r\nand patient_id = #{patientId,jdbcType=BIGINT}\r\n\r\n**</if>**\r\n\r\n**<if test=\\\"doctorPin != null\\\">**\r\n\r\nand doctor_pin = #{doctorPin,jdbcType=VARCHAR}\r\n\r\n**</if>**\r\n\r\nand created >#{dateStart,jdbcType=TIMESTAMP};\r\n\r\n</select>\r\n\r\n**当时的索引情况**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/062fd30e18ad4a01973faa9104acd23d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**当时的执行计划**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e83bd8d6f6b846e4bedd9a5bc8404a33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其实在patientId和doctor_pin两个字段上是有索引的，但是由于线上情况的改变，导致test判断没有进入，这样的通用查询导致这两个字段没有设置上，进而导致了数据库扫描的量激增，对数据库产生了很大压力。\r\n\r\n**案例3：**\r\n\r\n2020年某日上午收到数据库CPU异常报警，对线上有一定的影响，后续检查数据库CPU情况如下，从7点51分开始，CPU从8%瞬间达到99.92%，丝毫没有给程序员留任何情面。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4b1071bee544b0bb1007d338428d78~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当时的SQL语句：\r\n\r\nselect rx_id, rx_create_time from nethp_rx_info where rx_status = 5 and status = 1 and rx_product_type = 0 and (parent_rx_id = 0 or parent_rx_id is null) and business_type != 7 and vender_id = 8888 order by rx_create_time asc limit 1;\r\n\r\n当时的索引情况:\r\n\r\nPRIMARY KEY (`id`), UNIQUE KEY `uniq_rx_id` (`rx_id`), KEY `idx_diag_id` (`diag_id`), KEY `idx_doctor_pin` (`doctor_pin`) USING BTREE, KEY `idx_rx_storeId` (`store_id`), KEY `idx_parent_rx_id` (`parent_rx_id`) USING BTREE, KEY `idx_rx_status` (`rx_status`) USING BTREE, KEY `idx_doctor_status_type` (`doctor_pin`, `rx_status`, `rx_type`), KEY `idx_business_store` (`business_type`, `store_id`), KEY `idx_doctor_pin_patientid` (`patient_id`, `doctor_pin`) USING BTREE, KEY `idx_rx_create_time` (`rx_create_time`)\r\n\r\n当时这张表量级2000多万，而当这条慢SQL执行较少的时候，数据库的CPU也就下来了，恢复到了49.91%，基本可以恢复线上业务，从而表象就是线上间歇性的一会可以开方一会不可以，这条SQL当时总共执行了230次，当时的CPU情况也是忽高忽低，伴随这条SQL语句的执行情况，从而最终证明CPU的飙升是由于这条慢SQL。当线上业务逻辑复杂的时候，你很难第一时间知道到底是由于那条SQL引起的，这个就需要对业务非常熟悉，对SQL很熟悉，否则就会白白浪费大量的排查时间。\r\n\r\n最后的排查结果：\r\n\r\n在头天晚上的时候**添加了一条索引rx_create_time**，当时没事，但是第二天却出了事故。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2129b6a7c02740c5ad2214d1138f2573~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n加索引前后走的索引不同，一个是走的rx_status（处方审核状态）单列索引，一个是走的rx_create_time(处方提交事件)单列索引，这个就要回到业务，因为处方状态是个枚举，且枚举范围不到10个，也就说线上29,000,000的数据量也就是被分成了不到10份，rx_status=5的值是其中一份，因而通过这个索引就可以命中很多行，这是业务规则，再套用MySQL的特性，主要是以下几条：\r\n\r\n**1、没加新索引rx_create_time的时候**，由于order by后边没有索引，就看where条件中是否有合适的索引，查询选择器选定rx_status这个单列索引，而rx_status=5这个条件下限制的数据行在索引中是连续，即使需要的rx_id不在索引中，再回主键聚簇索引也来得及，由于order by后边没有索引，所以走磁盘级别的排序filesort，高峰积压的时候处方就1万到2万，跑到了100ms,白天低谷的时候几百单也就20ms。\r\n\r\n**2、新加索引之后，就分两种情况：**\r\n\r\n2.1、加索引是在晚上，当前命中的行数比较少，由于当天晚上的时候待审核的处方确实很少，也就是rx_status=5的确实很少，查询优化器感觉反正没多少行，排序不重要，因而就还是选择rx_status索引。\r\n\r\n2.2、第二天白天，待审核的处方数量很多了（rx_status=5的数据量多了），当时可以命中几万数据，如果当前命中的行数比较多，查询优化器就开始算成本，感觉排序的成本会更高，那就优先保排序吧，所以就选择rx_create_time这个字段，但是这个索引树上没有别的索引字段的信息，没办法，几乎每条数据都要回表，进而引发了灾难。\r\n\r\n### **8、 推荐用书**\r\n\r\n这本书以一种诙谐幽默的风格写了MySQL的一些运行机制，非常适合阅读，理解成本大幅降低。\r\n\r\n<https://item.jd.com/13009316.html>\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb64a4208ce9482aaca8ac1c79f4315c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n<https://item.jd.com/10066181997303.html>\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f62e344c49ce432e9efc69df15da8ac4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### **9、一些感悟**\r\n\r\n关于数据库的性能优化其实是一个很复杂的大课题，很难通过一篇帖子讲的很全面和深刻，这也就是为什么我的标题是‘浅析’，程序员的成长一定是要付出代价和成本，因为只有真的在一线切身体会到当时的紧张和压力，对于一件事情才能印象深刻，但反之也不能太过于强调代价，如果可以通过一些别人的分享就可以规避一些自己业务的问题和错误的代价也是好的。"
    },
    {
        "article_id": "7189452431929901117",
        "snapshot": "",
        "title": "马蜂窝如何利用 APISIX 网关实现微服务架构升级",
        "preview": ">作者：董红帅，马蜂窝微服务体系建设以及基础服务能力建设专家。 马蜂窝作为旅行社交平台，是数据驱动的新型旅行电商。基于十余年的内容积累，马蜂窝通过 AI 技术与大数据算法，将个性化旅行信息与来自全",
        "author": "Apache_APISIX_中文社区",
        "view_count": 385,
        "collect_count": 0,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/2d5c38573d11d655e44117c2b9f2c0dd~300x300.image",
        "category": "后端",
        "content": ">作者：董红帅，马蜂窝微服务体系建设以及基础服务能力建设专家。\r\n\r\n马蜂窝作为旅行社交平台，是数据驱动的新型旅行电商。基于十余年的内容积累，马蜂窝通过 AI 技术与大数据算法，将个性化旅行信息与来自全球各地的旅游产品供应商实现连接，为用户提供与众不同的旅行体验。\r\n\r\n随着业务的发展，马蜂窝架构也在跟随技术步伐进行更迭，开始基于 Kubernetes 进行更多的延展。在这个技术背景下，需要针对云服务开启新一轮的架构更新，比如：微服务场景建设新的蜂效平台及周边设施来支持迭代和流量泳道的能力，在多 Kubernetes 集群场景引入 Karmada 实现多集群管理，在微服务网关领域将 Istio + Envoy 的架构替换为 Apache APISIX 与 Envoy 共存的微服务网关模式。\r\n\r\n## 微服务 1.0 模式现状\r\n\r\n目前马蜂窝内部的微服务架构经历了两次迭代，本文中将针对原有架构的第一次调整定义为 1.0 版本。在进行微服务 1.0 架构的搭建之前，我们从发布系统能力、Kubernetes 容器、服务发现和微服务网关等角度进行了一些考量与目标对齐。比如 Kubernetes 的广泛应用，需要开始考虑基于容器做多语言支持，在 CI/CD 环节实现全面容器化，并支持多 Kubernetes 集群等。\r\n\r\n在进行第一次迭代之前，内部架构的微服务网关使用的是 NGINX Ingress，但它其实是存在问题的。比如配置变更基于 NGINX reload，会造成业务有损；同时在应用范围内仅支持单 Kubernetes 集群，场景受限；内置资源过于简单，大量匹配规则依赖 Annotations，配置繁杂不友好，尤其是对外部服务发现能力支持很弱。\r\n\r\n因此在进行微服务 1.0 迭代落地的过程中，为了满足一些业务需求，我们进行了如下动作（选取部分操作列举）：\r\n\r\n* 在 Kubernetes 容器内，基于 macvlan 改造容器网络，IDC 机房网络与云厂商网络互通（容器互通的通信基础）；借助网关或容器直连实现服务互访，不再使用 Kubernetes Service。\r\n* 基于 Kubernetes 容器场景部署；基于 Consul 物理机虚拟机部署。\r\n* 增加统一服务发现能力，基于 Kubernetes、Consul 建设统一的发现中心 — Atlas；同时基于 Atlas 扩展微服务网关、Java 生态、监控体系等。\r\n* 在微服务网关的选择上，基于 Istio + Envoy 架构进行构建。对 Istio 中 Pilot 进行二次开发，对接 Atlas 发现中心，由于 Atlas 数据来源于多套 Kubernetes 和 Consul，进而将实例发现与 Kubernetes 集群解耦，间接做到网关对接多 Kubernetes 集群的能力，实现整个网关动态感知识别的变化。\r\n\r\n![蜂效 1.0 微服务网关架构](https://static.apiseven.com/uploads/2023/01/17/jydzEiWC_image%20%2837%29.png)\r\n\r\n### 痛点梳理\r\n\r\n在微服务 1.0 的这套架构中，实践下来还是存在一些痛点。\r\n\r\n首先是在发布系统能力方面，微服务 1.0 中的发布系统，仅仅是一个发布系统，无法有效融合项目需求的管理（发布也是度量的一环）；同时这套发布系统基于 PHP 构建，无法很好地支持自动化滚动部署、多版本滚动部署容量变更等较为复杂的部署场景；当多人对同一个项目开发，或一个需求关联多个项目时，缺少机制让流量在同一个迭代中自动串联（流量泳道）。同时对多 Kubernetes 集群管理并不方便，当 Kubernetes 下线时需要业务侧参与，给业务线带来了时间成本等。\r\n\r\n其次就是微服务网关架构层面。前文也提到了 1.0 架构下网关是基于 Istio+Envoy 对 Pilot 做了二次开发，主要是对接 Atlas 发现中心。随着业务的应用数量越来越多，访问规则也越来越多，这就导致我们线上的网关生效延迟也越来越高。在流量巅峰状态下，大概有 15 秒左右的延迟。这个延迟主要来自于 CRD 资源，几乎全都在相同的 namespace 下，同时上下线时会触发全量更新导致延迟较高。\r\n\r\n而在早期的使用过程中，Envoy 在数据全量推送过程中还会出现链接中断的状况，造成 `503` 问题的产生。除此之外，Envoy 还存在使用内存持续增长导致 OOM 的情况，当网关出现问题时，对 Envoy 和 Pilot 进行排错的成本较高。当使用一些高阶配置时，需要借助 Envoy Filter 实现，其上手门槛较高，对于想简单实现熔断、限流、Auth 鉴权等功能而言，成本较高。\r\n\r\n除此之外，两个社区（Istio 和 Envoy）的发展速度很快，这也导致我们的架构比较难跟进上游社区的发展。\r\n\r\n## 基于 APISIX 的微服务 2.0 模式\r\n\r\n### 新平台与新架构\r\n\r\n面对 1.0 架构下存在的痛点与问题，内部对于这套微服务架构进行了再次迭代，来到了 2.0 时代。2.0 架构场景下，我们新增了一套发布平台——蜂效平台。\r\n\r\n蜂效平台重点突出了以下能力：\r\n\r\n* 融合了需求管理，支持了迭代部署能力，使得发布系统可以增益度量。\r\n* 将容器部署和机器部署（物理机部署）在产品能力上进行了统一。\r\n* 增强了精细化的流量管理能力、回滚能力（回滚策略：批次、实例数、间隔等）\r\n* 与 Java 生态融合共建，支持了流量泳道能力，环境流量隔离。\r\n* 网关基于 APISIX 进行重构，解决 Envoy OOM 及规则生效延迟较高的同时，通过 APISIX 产品化能力降低了问题排错成本，降低了扩展和配置网关的上手门槛。\r\n\r\n在蜂效平台产品侧中，我们将需求管理与迭代部署关联结合，并且为了支持了多种迭代流水线模式。在流量管理方面，我们借助 Atlas Instance 模型中的 env 属性以及扩展属性，实现了流量泳道能力。基于流量泳道模型，在上层产品侧构建迭代流量环境调用链路隔离。\r\n\r\n![规划蜂效 2.0 ](https://static.apiseven.com/uploads/2023/01/17/FmMR3bfp_image%20%2838%29.png)\r\n\r\n在周边生态建设方面，Java SDK 侧做到了应用在迭代环境中可以实现隔离的链路调用，网关侧也进行了类似的操作。只是网关侧作为整个流量的入口，我们是通过 Cookie 的规则，也就 Cookie 的方式进行配置的。基线环境的流量只能到达基线环境的版本中，迭代环境的流量就会转发到迭代的版本上去。\r\n\r\n![v1 与 v2 版本的流量分配](https://static.apiseven.com/uploads/2023/01/17/QCn1I0Gh_%E6%B5%81%E7%A8%8B%E5%9B%BE%20%283%29%20%281%29.jpg)\r\n\r\n同时在部署层的 Kubernetes 多集群管理层面，我们则借助 Karmada 实现了一个多 Kubernetes 集群的管理。在整个架构中（如下图所示），底层的能力主要是由 Kubernetes 多集群和流量网关 Envoy 与 APISIX、发现中心 Atlas、日志服务与监控服务等组成。\r\n\r\n而蜂效平台在整个架构中主要是进行配置管理、构建部署、扩缩容和上下线等等，同时包含任务流的模块。最上方则是应用市场的一些能力，比如迭代能力和插件能力等。\r\n\r\n![蜂效平台 2.0 架构图](https://static.apiseven.com/uploads/2023/01/17/luSFWibx_%E6%B5%81%E7%A8%8B%E5%9B%BE%20%284%29.jpg)\r\n\r\n整体来说，我们基于应用中心和服务打造出了 2.0 新架构。这套新架构在 Kubernetes 集群发生变更时，可通过 PropagationPolicy、OveridePolicy 等策略，实现 Deployment 等在 Kubernetes 集群级别的资源分发，减少集群变更时业务参与的成本，减轻了业务研发侧的一些压力。\r\n\r\n### 网关选型\r\n\r\n在 2.0 模式的架构中，流量网关我们提到了两个网关产品，即 Envoy 与 APISIX。Envoy 作为之前 1.0 版本的选择，我们并没有完全放弃，在 2.0 中我们也因为一些需求和产品期望，开始考虑新的网关产品进行替代，比如：\r\n\r\n* 访问规则变化时，网关的生效速度需要控制在毫秒级（生效慢，会导致网关生效速度不一，在使用了 CDN 场景下可能导致业务资源长时间 404）。\r\n* 可在现有场景中，完全替换 Istio+Envoy 架构；同时支持 HTTP、gRPC，并兼容现有路由策略。\r\n* 需要降低问题的排查成本，最好有产品化支持（如 Dashboard）。\r\n* 产品足够稳定，社区活跃，功能强（对限流等场景支持）。\r\n* 不需要二次开发即可支持公司现有架构的替换。\r\n* 在替换 Istio+Envoy 架构过程中，需要保持双架构可用（Istio、Envoy 与新网关并存），如果新架构有问题可快速回退至原来方案。\r\n\r\n在调研了一些关键网关产品的模型之后，我们最终将方案锁定在了 Apache APISIX。APISIX 的架构也分为控制面和数据面，同时还附带 Dashboard 产品。在功能使用上，APISIX 提供了丰富的插件，比如限流、熔断、日志安全和监控等等。我们可以通过 APISIX 的 Admin API 提供的接口，去完整操作 APISIX 的所有能力，比如 Upstream、Consumer 还有各种插件等。对我们而言，APISIX 还有一个特别有优势的点，就是 APISIX 在升级时，能够做到对低版本的 API 进行统一的兼容。\r\n\r\n![APISIX 架构](https://static.apiseven.com/uploads/2023/01/17/RxOc4qk7_image%20%2840%29.png)\r\n\r\n除此之外，我们认为 APISIX 还有以下几个优势：\r\n\r\n* APISIX 基于 Openresty 的性能很好，相比 Envoy 来说，性能损耗很少。在经过我们测试之后，在 QPS 的表现上，APISIX 损耗 3%，而 Envoy 损耗 16%；在时延表现上，APISIX 平均转发耗时 2ms，而 Envoy 耗时 7ms。数据的体现，已经展示了 APISIX 在性能上的卓越优势。\r\n* APISIX 还附有 Dashboard 支持，对于路由匹配异常等场景可快速判断是否为规则配置错误。\r\n* 作为开源产品，APISIX 的社区更为活跃。在产品的功能上，在限流、鉴权、监控等方面相比 Envoy 成本更低，支持性更好。\r\n* APISIX 相比 Envoy 内存占用很低，但在配置的动态变更上相比 Envoy 要弱（Envoy 几乎大部分配置可动态下发），但也足够满足需求。\r\n\r\n因此，在调研与测试之后，我们在微服务 2.0 的架构下增添了 Apache APISIX 作为流量网关加入。由于网关是整个微服务流量的核心，如果从一套旧架构切换到一套新的架构，其实成本是比较高的。所以我们希望微服务的网关规则变化能够对新旧两套网关（Envoy 与 APISIX）同时生效，也就是一套配置可以适用于两种架构，因此我们在 2.0 架构中，针对这些变动做了一些调整。\r\n\r\n### 落地方案与实践问题\r\n\r\n首先考虑到成本问题，对原本的 Istio 架构保持不变，并未进行改造。同时在网关架构中，引入了新开发的关键组件—— **istio-apisix-translator**。\r\n\r\nistio-apisix-translator 主要是去对接 Atlas 发现中心以及 Istio 的 CRD 数据。作为数据同步服务，实时将 VirtualService、DestinationRule 等规则变化转换为 APISIX 路由规则，将 Atlas Instance 数据实时转换为 APISIX Upstream 规则等。简单来说，就是通过这样一个服务组件，实现了对 Atlas 以及 Istio CRD 的数据支持。\r\n\r\n借助这种架构，我们就实现了对两种网关的完整支持，如下图所示。\r\n\r\n![蜂效 2.0 微服务网关架构](https://static.apiseven.com/uploads/2023/01/17/Ai05UtVk_image%20%2841%29.png)\r\n\r\n网关架构的核心部分则是图中最下方的 APISIX，上层的 istio-apisix-translator 则充当类似 Istio 架构中的 Pilot 角色，将 Instance 与 CR 数据整合后，借由 APISIX Admin API 推送至 APISIX 中，实例则是对接到内部业务的 Atlas 发现中心。因此，无论是访问规则发生变化还是 Atlas 的数据源发生变化，都可以将这份数据变化转换成 APISIX 的数据推到 APISIX 中。目前全链路都是基于 Watch 机制保证数据变化的实时处理，因此在实际应用场景下，基本可以达到数据变化的毫秒级生效。\r\n\r\n**当然，在使用 APISIX 的过程中，我们也遇到了几处问题。但均已解决并将结果同步给了社区进行反馈。**\r\n\r\n第一个问题就是在 APISIX 使用证书对接 etcd 时，如果 APISIX 节点较多，可能会导致 APISIX Admin API 接口响应非常慢。这个问题的原因是因为目前 etcd 存在一个关于 HTTP/2 的 BUG。如果通过 HTTPS 操作 etcd（HTTP 不受影响），HTTP/2 的连接数上限为 Golang 默认的 250 个。而 APISIX 的控制面和 Istio 架构的控制面有区别，APISIX 节点是直连 etcd，当 APISIX 数据面节点数较多时，一旦所有 APISIX 节点与 etcd 连接数超过这个上限，则 APISIX 的接口响应会非常的慢。\r\n\r\n为了解决这个问题，我们也在 etcd 和 APISIX 的社区均进行了反馈，后续也通过升级版本（etcd 3.4 升级到 3.4.20 及以上，etcd 3.5 升级到 3.5.5 及以上）解决了这个问题。同时我们也已将这个结果同步到了 APISIX 社区官网 Q&A 文档中，方便后续用户遇到同样问题时，可以有所参考。\r\n\r\n第二个问题就是在使用 APISIX 的过程中会遇到性能抖动的问题。\r\n\r\n首先是会出现 `499` 响应抖动，这个问题主要出现在连续两次以上过快的 post 请求（也不止 post）的场景下。这种情况是 NGINX 认定为不安全的连接，则主动断开了客户端的连接。为了处理这个问题，只需将 `proxy_ignore_client_abort` 的配置调整为 on 即可。\r\n\r\n除此之外，当 APISIX Admin API 接口请求密集时，也会出现 APISIX 数据面少部分响应超时的状况。这个主要是因为 istio-apisix-translator 在重启时，会将 Atlas、Istio CR 数据聚合，全量同步至 APISIX 中，大量请求引发 APISIX 数据变更，APISIX 数据面密集的同步变更导致小部分响应超时。为此，我们引入协程池和令牌桶限流，减少 APISIX 数据密集变更的场景来应对此问题。\r\n\r\n## 总结与发展\r\n\r\n马蜂窝当前是基于 Kubernetes 容器部署以及基于 Consul 的机器部署场景，自建 Atlas 服务发现中心，同时，在 Java 生态、微服务网关，微服务体系的流量泳道，以及监控体系做对接和适配。\r\n\r\n在微服务网关前期，是基于 Istio 1.5.10 对 Pilot 二次开发，也在网关侧支持非容器部署场景。目前阶段则是保持了 Istio+Envoy 架构与 APISIX 架构同时支持，通过引入外部服务组件，让 APISIX 也复用 Istio CRD 资源。\r\n\r\n从网关发展视角来看，未来我们也会跟随网关的一些趋势。比如现在很多产品都开始支持 Gateway API，像 APISIX Ingress、Traefik、Contour 等；同时网关的动态化配置也是未来非常明显的趋势，对于运维或者基础研发的同学来说，在后续考虑网关架构的选型和迭代时，也可以更多关注网关动态配置的方面。\r\n\r\n \r\n\r\n"
    },
    {
        "article_id": "7189824161542307900",
        "snapshot": "",
        "title": "Elasticsearch：以更简单的方式编写具有逻辑条件的 Elasticsearch 查询 - query_string",
        "preview": "当涉及到诸如 NOT、AND 和 OR 之类的布尔运算时，我们通常使用带有 must、should、must_not 子句的布尔查询。 是的，bool 查询非常强大，可用于执行所有类型的高级搜索。 但",
        "author": "Elasticsearch",
        "view_count": 781,
        "collect_count": 1,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3298f2149155cd4fce1f6942122778a3~300x300.image",
        "category": "后端",
        "content": "当涉及到诸如 NOT、AND 和 OR 之类的布尔运算时，我们通常使用带有 must、should、must_not 子句的布尔查询。 是的，bool 查询非常强大，可用于执行所有类型的高级搜索。 但是，对于具有基本 NOT、AND 和 OR 条件的简单搜索，使用 bool 查询有点矫枉过正，因为你需要编写大量样板代码。 这是 query_string 查询适合的地方，因为它具有更简单的语法。针对 query_string，在我的另外一篇文章 “[Elasticsearch: query_string 查询](https://elasticstack.blog.csdn.net/article/details/103291944 \\\"Elasticsearch: query_string 查询\\\")” 有详细介绍。\r\n\r\n准备数据\r\n====\r\n\r\n如果你还没有准备好你的数据，请阅读我之前的文章 “[Elasticsearch：通过例子快速入门](https://elasticstack.blog.csdn.net/article/details/128714977 \\\"Elasticsearch：通过例子快速入门\\\")”。我们通过文章里介绍的方法把索引  laptops-demo 建立起来。这里不再累述了。\r\n\r\nNOT operation\r\n-------------\r\n\r\n让我们找出 brand 不是 HP 的笔记本电脑。 配合 bool 查询，代码如下：\r\n\r\n```\r\n\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"bool\\\": {\r\n5.        \\\"must_not\\\": [\r\n6.          {\r\n7.            \\\"match\\\": {\r\n8.              \\\"brand\\\": \\\"hp\\\"\r\n9.            }\r\n10.          }\r\n11.        ]\r\n12.      }\r\n13.    }\r\n14.  }\r\n\r\n\r\n```\r\n\r\n如你所见，我们需要使用 bool/must_not 样板代码（以及大量括号）来编写具有简单 NOT 条件的查询。 使用 query_string 查询，语法更简单、更灵活。 以下所有将起作用并给出相同的结果：\r\n\r\n```\r\n`\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"query_string\\\": {\r\n5.        \\\"default_field\\\": \\\"brand\\\",\r\n6.        \\\"query\\\": \\\"NOT hp\\\"\r\n7.      }\r\n8.    }\r\n9.  }\r\n\r\n11.  GET laptops-demo/_search\r\n12.  {\r\n13.    \\\"query\\\": {\r\n14.      \\\"query_string\\\": {\r\n15.        \\\"default_field\\\": \\\"brand\\\",\r\n16.        \\\"query\\\": \\\"!hp\\\"\r\n17.      }\r\n18.    }\r\n19.  }\r\n\r\n21.  GET laptops-demo/_search\r\n22.  {\r\n23.    \\\"query\\\": {\r\n24.      \\\"query_string\\\": {\r\n25.        \\\"query\\\": \\\"brand:(NOT hp)\\\"\r\n26.      }\r\n27.    }\r\n28.  }\r\n\r\n30.  GET laptops-demo/_search\r\n31.  {\r\n32.    \\\"query\\\": {\r\n33.      \\\"query_string\\\": {\r\n34.        \\\"query\\\": \\\"brand:(!hp)\\\"\r\n35.      }\r\n36.    }\r\n37.  }\r\n\r\n`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)\r\n```\r\n\r\n*   要搜索的字段可以使用 [default_field](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-top-level-params \\\"default_field\\\") 或 [fields](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-top-level-params \\\"fields\\\") 参数指定，或直接在查询中指定。 当在查询中指定时，它后面应该跟一个冒号，布尔条件应该放在括号中。\r\n*   使用 query_string 以更简单的方式指定布尔条件。 例如，你可以使用 NOT 或感叹号 ! 指定 NOT 条件。 当存在 AND 或 OR 条件时，它会更加突出。\r\n\r\nAND operation\r\n-------------\r\n\r\n让我们找到 brand 为 HP 且名称中包含 EliteBook 的笔记本电脑：\r\n\r\n```\r\n`\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"bool\\\": {\r\n5.        \\\"must\\\": [\r\n6.          {\r\n7.            \\\"match\\\": {\r\n8.              \\\"brand\\\": \\\"hp\\\"\r\n9.            }\r\n10.          },\r\n11.          {\r\n12.            \\\"match\\\": {\r\n13.              \\\"name\\\": \\\"elitebook\\\"\r\n14.            }\r\n15.          }\r\n16.        ]\r\n17.      }\r\n18.    }\r\n19.  }\r\n\r\n`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)\r\n```\r\n\r\n嗯，这里有点失控了，因为你需要非常小心嵌套查询，不要错过任何方括号或大括号。 同样，使用 query_string 更简单：\r\n\r\n```\r\n\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"query_string\\\": {\r\n5.        \\\"query\\\": \\\"brand: hp AND name: elitebook\\\"\r\n6.      }\r\n7.    }\r\n8.  }\r\n\r\n\r\n```\r\n\r\n哇，这简单多了，不是吗？ 没有样板代码和带有令人眼花缭乱的括号的疯狂嵌套。\r\n\r\n请注意，当使用 query_string 时，如果查询具有逻辑条件，则需要将查询放在括号中。 例如，我们只列出 brand 为 HP 但不是 EliteBook 的笔记本电脑：\r\n\r\n```\r\n\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"query_string\\\": {\r\n5.        \\\"query\\\": \\\"brand: hp AND name: (NOT elitebook)\\\"\r\n6.      }\r\n7.    }\r\n8.  }\r\n\r\n\r\n```\r\n\r\n它非常简单易读。 如果使用 bool 查询，则需要同时使用 must 和 must_not 子句，这会变得更加复杂：\r\n\r\n```\r\n`\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"bool\\\": {\r\n5.        \\\"must\\\": [\r\n6.          {\r\n7.            \\\"match\\\": {\r\n8.              \\\"brand\\\": \\\"hp\\\"\r\n9.            }\r\n10.          }\r\n11.        ],\r\n12.        \\\"must_not\\\": [\r\n13.          {\r\n14.            \\\"match\\\": {\r\n15.              \\\"name\\\": \\\"elitebook\\\"\r\n16.            }\r\n17.          }\r\n18.        ]\r\n19.      }\r\n20.    }\r\n21.  }\r\n\r\n`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)\r\n```\r\n\r\nOR operation\r\n------------\r\n\r\n为了完整起见，让我们检查 OR 条件并找到 brand 为 Dell 或 name 中有 EliteBook 的笔记本电脑（仅供演示 😃）。 对于 bool 查询，你需要使用 should 子句：\r\n\r\n```\r\n`\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"bool\\\": {\r\n5.        \\\"should\\\": [\r\n6.          {\r\n7.            \\\"match\\\": {\r\n8.              \\\"brand\\\": \\\"dell\\\"\r\n9.            }\r\n10.          },\r\n11.          {\r\n12.            \\\"match\\\": {\r\n13.              \\\"name\\\": \\\"elitebook\\\"\r\n14.            }\r\n15.          }\r\n16.        ]\r\n17.      }\r\n18.    }\r\n19.  }\r\n\r\n`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png)\r\n```\r\n\r\n使用 query_string 查询，就简单多了：\r\n\r\n```\r\n\r\n\r\n1.  GET laptops-demo/_search\r\n2.  {\r\n3.    \\\"query\\\": {\r\n4.      \\\"query_string\\\": {\r\n5.        \\\"query\\\": \\\"brand: dell OR name: elitebook\\\"\r\n6.      }\r\n7.    }\r\n8.  }\r\n\r\n\r\n```\r\n\r\n我认为你已经明白使用 query_string 比使用 bool 查询要简单得多。 我们刚刚介绍了 query_string 查询的本质，还有很多其他有用的功能可以在[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html \\\"官方文档\\\")中找到。 但是，只有在需要使用更高级的功能时才需要学习它们。\r\n\r\n尽管 query_string 对于简单查询非常方便，但如官方文档所述，它不方便也不推荐用于 nested 文档。 对于 nested 文档的查询，最好使用[这篇文章](https://elasticstack.blog.csdn.net/article/details/100068659 \\\"这篇文章\\\")中更详细演示的 nested 查询。"
    },
    {
        "article_id": "7158258577113612302",
        "snapshot": "",
        "title": "都什么年代了，你居然还连不上GitHub？",
        "preview": "众所周知，GitHub是我们程序员在上班或者学习的时候经常会逛的一个地方[手动狗头]，而且如果我们想参与开源项目的话，GitHub也是一个很好的平台。 可问题是，GitHub网页总是进不去。。。",
        "author": "阿杆",
        "view_count": 28789,
        "collect_count": 512,
        "comment_count": 61,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/de3dfdc0012f9090816782278813f241~300x300.image",
        "category": "开发工具",
        "content": "---\r\ntheme: Chinese-red\r\n---\r\n\r\n\r\n# 前言\r\n\r\n众所周知，GitHub是我们程序员在上班或者学习的时候经常会逛的一个地方[手动狗头]，而且如果我们想参与开源项目的话，GitHub也是一个很好的平台。\r\n\r\n可问题是，GitHub网页总是进不去，提交代码到GitHub也总是超时，简直烦死😭😭。\r\n\r\n![image-20221024200027272](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/262f4337bf214c41a25cdfed111dab5c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n有时候我们在Gitee上看到一个好的开源项目想要参加，但是别人可能只是从GitHub同步到Gitee的，Gitee上的社区完全没人交流，那这种情况下，想参与项目贡献还是得去GitHub才行😖🤐。\r\n\r\n为什么我们访问GitHub这么慢呢？引用网上的解释：\r\n\r\n> GitHub的CDN域名遭到DNS污染，无法使用GitHub的加速分发服务器，而它的服务器又是在国外，所以国内的访问速度就会很慢。\r\n\r\n那有聪明的朋友就要说了：“我有梯子我不怕，访问速度快得很”，那没有梯子的朋友该怎么办呢？\r\n\r\n**如果你也有这些烦恼，那很高兴你能看到这篇文章，因为它或许能够帮你解决这些问题，至少让你能基本使用GitHub🧐。**\r\n\r\n\r\n\r\n# 要解决的问题\r\n\r\n我们要解决的问题，无非就是两个：\r\n\r\n1. 使用git bash操作GitHub远程仓库，比如拉取代码、提交代码等。\r\n2. 访问GitHub网页版。\r\n\r\n下面我会分别就这两个问题给出解决方案，并附上操作教程。\r\n\r\n# 一、操作远程仓库解决方案\r\n\r\n大多数同学可能是使用的http协议创建的远程连接，就是当我们创建远程仓库的时候，使用的是下图里HTTPS的链接，**但其实很多人不知道，用SSH协议操作GitHub仓库其实是很流畅的**：\r\n\r\n![image-20221024201617015](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c061078f00fd437a97950a8fd42d44f4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果不确定自己是否使用的HTTP协议还是SSH协议，可以通过指令`git remote -v show`来查看：\r\n\r\n![image-20221024204050847](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4aa273befab243f78d1d4e73b1ce2d82~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n像我这里同时添加了两个远程仓库，一个是GitHub（用的SSH协议），另一个是Gitee（用的HTTP协议）。\r\n\r\n---\r\n\r\n用HTTP协议连接GitHub远程仓库不行吗？\r\n\r\n如果是对于国内的Gitee或者自己公司的Git仓库，那我们用HTTP协议作为远程仓库都是可以正常访问的。\r\n\r\n**但对于GitHub来说，那就不行了**。那会让你感觉到什么叫写了代码却提交不上🤣，反复重试也只是不断超时，运气好的时候才能正常操作。\r\n\r\n**所以我们要使用SSH协议来作为GitHub远程仓库的链接**。这样就会很流畅了，非常的流畅，跟用Gitee一样流畅🤣🤣。\r\n\r\n下面给大家介绍一下SSH的配置方式，学会了就可以自己去配置啦！\r\n\r\n## 配置SSH\r\n\r\nSSH是通过公钥密钥的方式来验证身份的，密钥放在自己电脑上，公钥存到平台上，所以我们配置好之后，就不再需要使用账号密码登录了。而且你在本机生成好密钥之后，可以在多个平台使用，你只需要把公钥存放在多个平台就好了，他们可以通过密钥识别你的身份。\r\n\r\n> 其实配置SSH的教程网上有很多，如果大家看我下面的教程还没明白，可以上百度再搜一些其他的教程学习\r\n\r\n### 1. 检查是否存在sshkey\r\n\r\n在`C:\\\\Users\\\\用户名\\\\.ssh`文件夹下可以看到当前电脑的sshkey。\r\n\r\n如果有 id_rsa 和 id_rsa.pub 两个文件，就说明已经存在了，可以跳过生成密钥对的步骤，如果找不到目录或者没有这两个文件，则需要先生成。我这里是已经有了的，为了给你们演示，我先把他们删掉😎。\r\n\r\n![image-20221024210244386](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/496acaaa55854fc6a17529f581b60f25~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 2. 生成密钥对\r\n\r\n在 **cmd控制台** 上使用如下命令来生成 sshkey：\r\n\r\n```sh\r\nssh-keygen -t rsa -C \\\"xxxxx@xxxxx.com\\\"\r\n```\r\n\r\n> 注意：这里的 `xxxxx@xxxxx.com` 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。\r\n> 网上的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。\r\n\r\n输入上面的指令并回车后会弹出一些提示：\r\n\r\n1. 第一次提示保存路径，一般不需要修改，直接回车就行\r\n\r\n2. 第二次提示输入密码短语（等于是sshkey的密码），可以有也可以没有（建议还是设置一下），注意输入密码的时候是不会回显的，这里假设我设置的是 *123456*\r\n3. 第三次是重复输入密码\r\n\r\n![image-20221024211632779](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a67817b1583d467d9836229dfc58f209~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n完成三次操作后就生成完毕了，这时候再到.ssh的文件下面去看，能看到你的id_rsa 和 id_rsa.pub 两个文件，就说明你已经生成成功了。\r\n\r\n**注意这个 id_rsa.pub 是公钥，将来要放到GitHub上的，另一个id_rsa是私钥，等于是你的密码，保存好，不要随便发给别人。**\r\n\r\n### 3. 把公钥放到GitHub上\r\n\r\n打开GitHub（打不开咋办？那先看下面的访问GitHub网页教程🤣🤣🤣）\r\n\r\n1. 点击头像 -> settings：\r\n\r\n   ![image-20221024211345125](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e567476ec2684df3b0393d6248200a96~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n2. 点击左边 SSH and GPGkeys，再点击右边 New SSH key：\r\n\r\n   ![image-20221024211818148](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b65efeb498284fd0a89988098f3cef25~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n3. 写个标题（可以随便写，但建议写主机名），然后把刚刚生成的 id_rsa.pub 里面的内容复制过来，粘贴在下面的 key 那个框里（对没错，直接ctrl A全选复制就行）：\r\n\r\n   ![image-20221024212124648](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcf7e49679294bb788f587c5140fcf10~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n4. 最后点击 Add SSH key，系统会让你输入GitHub账号的密码，然后就添加完成啦！\r\n\r\n### 4. 测试\r\n\r\n我们用刚配置的sshkey拉取一下GitHub上的项目代码试试。\r\n\r\n1. 直接去项目里复制一下ssh的链接：\r\n\r\n   ![image-20221024212657751](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30107d47e6a547b0afd5f24c5c18bb4c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n2.  然后到本机找个文件夹打开 Git Bash，输入 git clone 指令：\r\n\r\n   ![image-20221024212816199](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f23503c22f954c58ba0777af3f143085~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n3. 这时候会让你输入密码短语，这个就是我们前面生成密钥的时候设置的东西，我设置的是 *123456* ，那么输入密码，回车，就可以看到项目被成功拉取啦！这个密码只有第一次拉取项目的时候会让你输入，后面再进行别的操作就不需要弄了。\r\n\r\n   ![image-20221024212959677](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8729e55f9abd4d1d8aabc4ee348f41a4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n至此，我们的SSH就配置完成啦！学会的朋友可以去试试了，保证你的 clone、pull、push 等操作将会非常流畅🤣🤣\r\n\r\n\r\n\r\n# 二、访问GitHub网页解决方案\r\n\r\n这个的话，主要是借助于第三方工具 FastGitHub来访问的。\r\n\r\nFastGitHub是一个免费的、开源的、仅用于加速GitHub的工具，作者是 @dotnetcore，它的基本介绍如下：\r\n\r\n![image-20221024213730188](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b074edb2e2aa4c11ac1ce5c4849c324d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n注意：它能且仅能用于GitHub加速，并不具备梯子的功能，主要是通过ip解析和测速来帮助用户选择最快的访问ip，来达到加速访问的效果。\r\n\r\n## 下载FastGitHub\r\n\r\n下载方式：\r\n\r\n1. 在项目的Releases上进行下载（下载最新版即可）：https://github.com/dotnetcore/FastGithub/releases\r\n2. 发送任意邮件到 fastgithub@qq.com\r\n\r\n访问不了GitHub的同学直接发邮件过去就好啦！\r\n\r\n![image-20221024215009174](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30e7f91202254d66a60fd4002658d0e0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 启动服务\r\n\r\n我下载的Windows版的，下载解压之后会有这样一堆东西：\r\n\r\n![image-20221024215646210](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69fd9ace95e4cc2ba0c8106a424b307~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以直接参考README文档，里面的简单的教程。一般的使用方式是双击打开 FastGithub.UI.exe ，会看到如下界面，然后就可以去GitHub ~~玩耍~~ 学习啦🤣🤣！\r\n\r\n![image-20221024201026810](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8d7c09e4fd44a981721113a34e8564~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n启动了FastGitHub服务之后，访问GitHub网页仍然会出现一些卡顿的现象，但是基本可以保持正常使用的状态。访问起来偶尔也会有点卡，但至少能正常使用😎。\r\n\r\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6262cbf5cdf64b9cbddc07a2d5874421~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 注意\r\n\r\n需要注意的是，FastGitHub会通过创建CA证书的方式来建立有效连接，这在某些场合下会出现一些 “是否信任xxx证书” 的提示，比如idea：\r\n\r\n![image-20221024220523697](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f038516689947e4bd9a9403106d7da0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n由于我们配置了SSH协议的远程仓库，所以即使不使用FastGitHub我们也可以正常操作，那这种情况下我们点拒绝就可以了，如果是没配置SSH协议的朋友，那点接受，可以让你通过FastGitHub来建立远程仓库的连接。\r\n\r\n如果觉得在idea里总是弹这个提示很烦人的话，可以去设置里面搜索证书，找到服务器证书的选项，并且勾选自动接受非可信证书的选项，就不会再提醒啦！（是不是很贴心😎）\r\n\r\n![image-20221024220927320](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7061f6504c4418c83d0777cd4e69e6c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n# 后记\r\n\r\n本篇文章讲解了如何流畅的访问GitHub，给出的解决方案是通过配置SSH密钥和使用FastGitHub软件，并且给出了比较详细的教程，如果文章中有任何错误的地方，欢迎各位在评论区指正🥰。\r\n\r\n---\r\n\r\n最后，欢迎各位参与我的开源项目**校园博客**😋，可以试着使用上面教大家的方法来访问项目地址🤣。\r\n\r\n- GitHub地址：[https://github.com/stick-i/scblogs](https://github.com/stick-i/scblogs)\r\n\r\n>项目的技术栈主要是：\r\n>\\\\\r\n>后端 Java + SpringBoot + SpringCloud + Nacos + Getaway + Fegin + MybatisPlus + MySQL + Redis + ES + RabbitMQ + Minio + 七牛云OSS + Jenkins + Docker\r\n>\\\\\r\n>前端 Vue2 + ElementUI + Axios\r\n\r\n**目前项目还有很大改进和完善的空间，欢迎各位有意愿的同学参与项目贡献**（尤其前端），一起学习一起进步😋。\r\n\r\n"
    },
    {
        "article_id": "7186995347003015224",
        "snapshot": "",
        "title": "DDOS攻击",
        "preview": "最近网上爆火的一款游戏 Goose Goose Duck (鹅鸭杀) 游戏官方在近日发布了一则公告，宣布由于服务器屡次遭受黑客攻击，该游戏服务器将暂时关服三天进行维护 遭到了DDOS攻击，背后原因，我",
        "author": "小满zs",
        "view_count": 4261,
        "collect_count": 11,
        "comment_count": 8,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/f406e4f16ef06556e95d7fe50241a5e8~300x300.image",
        "category": "前端",
        "content": "\r\n![100792546_p0_master1200.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d0583ca9c004656904961f3c019d9ed~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n最近网上爆火的一款游戏 `Goose Goose Duck` (鹅鸭杀) 游戏官方在近日发布了一则公告，宣布由于服务器屡次遭受黑客攻击，该游戏服务器将暂时关服三天进行维护 遭到了`DDOS`攻击，背后原因，我们不做讨论，只讨论DDOS。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9142b615d54bab95b28a3338758894~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 什么是DDOS 攻击\r\n\r\n全称为 `分布式拒绝服务攻击 Distributed denial of service attack`\r\n\r\n在这场攻击中一般有三个角色，`用户`，`服务商(App,网站，游戏等)`，`攻击者（黑客）`，黑客通常会使用被控制的`肉鸡（通常也叫傀儡机）`,对服务商进行攻击，由于服务商无法分辨哪些是真正的用户，哪些是黑客的攻击，在巨大的流量攻击下，导致网站无法访问。\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd19d8f883a94c22a854d08738dc2e7e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n举个栗子，例如你有一家超市，最大容纳100人，正常的用户都会买完东西离开，而`DDOS`，他们会疯狂涌入你的超市，而且拒绝购买商品，并且不会离开，还会招呼亲戚朋友一起来，导致你的超市流量爆满无法服务，且真正的用户进不来，长时间的DDOS会让你的超市丢失用户，导致破产。\r\n\r\n# 攻击方式\r\n\r\n攻击方式多种多样，有手动发起的，也有半自动的，随着技术的发展现在有全自动的。\r\n\r\n**1. Synflood**\r\n\r\n该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗，最终导致拒绝服务。\r\n\r\n**2. Ping of Death**\r\n\r\n根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。\r\n\r\n**3. Land-based**\r\n\r\n攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。\r\n\r\n以上列举几种方式\r\n\r\n# 如何解决\r\n\r\nDDOS攻击令人非常头疼，你没有好的办法去区分哪些是用户，哪些是攻击者，而且花样很多，让人防不胜防，目前解决方式主流的还是使用高防IP。\r\n\r\n高防IP 会隐藏真正的IP地址，在我们访问一个网站的时候例如`www.xxx.com`他会通过DNS服务去寻找对应的IP进行解析，然后把网页返回给用户，在加入高防IP之后会隐藏你真正的IP地址，返回的是高防IP，从而隐藏你的地址，缺点就是高防IP费用昂贵，小型网站一般都承受不起。\r\n\r\n举个栗子，高防IP就相当于一个迷宫，迷宫的入口会有管理员，正确的引导用户通过迷宫进入你的超市，而那些非用户的的人，管理员就会带着他在迷宫兜圈子，然后踢出去，进行记录，在下次攻击，通过AI算法能够及时识别。\r\n\r\n其他方式，只能缓解，关闭不必要的端口号，增加带宽，增加服务器容量等方式。\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7156207517385621541",
        "snapshot": "",
        "title": "付费版 VS Code？脑瓜子嗡嗡的吧！",
        "preview": "今天看到一张图，分享给小伙伴看一下： 脑瓜子嗡嗡的吧！ 这不比每周四 v me 50, xx kfc",
        "author": "程序员小航",
        "view_count": 30649,
        "collect_count": 12,
        "comment_count": 92,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/e0425e0b2089fa5ac43e30fc17c51b29~300x300.image",
        "category": "后端",
        "content": "今天看到一张图，分享给小伙伴看一下：\r\n\r\n![](https://oss.liuzhihang.com/article/YPNsb7-4g0BZd.jpg)\r\n\r\n脑瓜子嗡嗡的吧！\r\n\r\n这不比每周四 `v me 50, xx kfc` 来的快，还是给你打折限时活动价，由 google 正版授权的`微软开源 vscode`。\r\n\r\n并且还应该会有人买吧！\r\n\r\n![](https://oss.liuzhihang.com/article/LafxbS-t0ZLfZ.png)\r\n\r\n可能是为了知识付费。\r\n\r\n想不到吧！这还上了 github，还有人专门给 vscode github 提了 issue：\r\n\r\nhttps://github.com/microsoft/vscode/issues/163798\r\n\r\n![](https://oss.liuzhihang.com/article/qrvJJk-e2DRSY.png)\r\n\r\n\r\n更让我长知识的是，竟然这样做，唯一侵犯的只有商标权？\r\n\r\n![](https://oss.liuzhihang.com/article/kjH6Ck-JMB96c.png)\r\n\r\n> 是不是又发现了新的财路。\r\n\r\n不过下面也有人反驳他，具体对不对，我也不知道。我使用 Mac 搜索 VS Code 前几条搜索结果倒不是广告，难道是 Windows 才会这样么？\r\n\r\n感兴趣的小伙伴可以去看看。\r\n\r\n不过说真的，下载软件开发，也就是骗骗小白，不过这钱赚的，有点考验智商！\r\n\r\n看来反诈 APP 有必要出 PC 版了，看留言区，竟然有人为了装 vscode、java 等，还专门装了 `xxx 软件管家`。\r\n\r\n最后，补充一下，下载软件去官网就行，真的不用脑瓜子嗡嗡的！网络不行，找朋友、网友、群友传一个安装包也比 `xxx度` 靠谱。\r\n\r\n\r\n\r\n本文由[mdnice](https://mdnice.com/?platform=2)多平台发布"
    },
    {
        "article_id": "7148075486403362846",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ea9f21cf0824ebfa5e4d0ac29a8ccfd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Qiankun原理——JS沙箱是怎么做隔离的",
        "preview": "相信大家也知道 qiankun 有 SnapshotSandbox, LegacySandbox 和 ProxySandbox 这些沙箱，而它们又可以分为单例和多例两种模式，网上也有很多文章对其进行介",
        "author": "写代码的海怪",
        "view_count": 29681,
        "collect_count": 377,
        "comment_count": 19,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/851dddff199a4c8b71aff35f19ea452f~300x300.image",
        "category": "前端",
        "content": "---\r\nhighlight: an-old-hope\r\ntheme: qklhk-chocolate\r\n---\r\n\r\n**本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！**\r\n\r\n## 前言\r\n\r\n哈喽，大家好，我是海怪。\r\n\r\n相信大家也知道 qiankun 有 `SnapshotSandbox`, `LegacySandbox` 和 `ProxySandbox` 这些沙箱，而它们又可以分为单例和多例两种模式，网上也有很多文章对其进行介绍。\r\n\r\n但这些文章的关注点都是沙箱的环境恢复做的事，那 JS 的隔离到底是怎么做到的呢？\r\n\r\n换个问法，当我写 `window.a = 1` 的时候，`a` 是怎么被挂载到这些 `XXXSandbox` 上的呢？又或者我直接云修改 `window.a = 123` 时，JS 沙箱到底是怎么隔离这个 `a` 的呢？\r\n\r\n总不能这样吧：\r\n\r\n```js\r\nwindow = window.sandbox\r\n\r\nwindow.a = 1 // window.sandbox.a = 1\r\n```\r\n\r\n这篇文章就来简单聊聊 qiankun 沙箱那些事。\r\n\r\n## 复习一下沙箱\r\n\r\n这里我们还是稍微复习一下 qiankun 的三大沙箱吧。\r\n\r\n### SanpshotSandbox\r\n\r\n第一种是快照沙箱。\r\n\r\n它的原理是：**把主应用的 `window` 对象做浅拷贝，将 `window` 的键值对存成一个 `Hash Map`。之后无论微应用对 `window` 做任何改动，当要在恢复环境时，把这个 `Hash Map` 又应用到 `window` 上就可以了。** 大概如下图所示。\r\n\r\n![SnapshotSandbox](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20621cb0fcad4b079473bba57cbece43~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n稍微做下小结：\r\n* 微应用 mount 时\r\n  * 先把上一次记录的变更 `modifyPropsMap` 应用到微应用的全局 `window`，没有则跳过\r\n  * 浅复制主应用的 `window` key-value 快照，用于下次恢复全局环境\r\n* 微应用 unmount 时\r\n  * 将当前微应用 `window` 的 `key-value` 和 `快照` 的 `key-value` 进行 Diff，Diff 出来的结果用于下次恢复微应用环境的依据\r\n  * 将上次快照的 `key-value` 拷贝到主应用的 `window` 上，以此恢复环境\r\n\r\n### LegacySandbox\r\n\r\n上面的 `SnapshotSandbox` 有一个问题：每次微应用 unmount 时都要对每个属性值做一次 Diff，类似这样：\r\n\r\n```js\r\nfor (const prop in window) {\r\n  if (window[prop] !== this.windowSnapshot[prop]) {\r\n    // 记录微应用的变更\r\n    this.modifyPropsMap[prop] = window[prop];\r\n    // 恢复主应用的环境\r\n    window[prop] = this.windowSnapshot[prop];\r\n  }\r\n}\r\n```\r\n\r\n如果有 1000 个属性就要对比 1000 次，不是那么优雅。\r\n\r\n`LegacySandbox` 的想法则是 **通过监听对 `window` 的修改来直接记录 Diff 内容**，因为只要对 `window` 属性进行设置，那么就会有两种情况：\r\n\r\n* 如果是新增属性，那么存到 `addedMap` 里\r\n* 如果是更新属性，那么把原来的键值存到 `prevMap`，把新的键值存到 `newMap`\r\n\r\n*（当然这里的变量名做了简化）*\r\n\r\n通过 `addedMap`, `prevMap` 和 `newMap` 这三个变量就能反推出微应用以及原来环境的变化，qiankun 也能以此作为恢复环境的依据。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ad2165ee3a4c68aab88a59a303d182~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当然这里的监听用到了 ES6 的新语法 `Proxy`，不过这里先不展开讨论，在之后的系列文章上会会自己手动实现一个简单的沙箱。\r\n\r\n### ProxySandbox\r\n\r\n前面两种沙箱都是 **单例模式** 下使用的沙箱。**也即一个页面中只能同时展示一个微应用，而且无论是 `set` 还是 `get` 依然是直接操作 `window` 对象。** \r\n\r\n*在这样单例模式下，当微应用修改全局变量时依然会在原来的 `window` 上做修改，因此如果在同一个路由页面下展示多个微应用时，依然会有环境变量污染的问题。*\r\n\r\n为了避免真实的 `window` 被污染，qiankun 实现了 `ProxySandbox`。它的想法是：\r\n* 把当前 `window` 的一些原生属性（如`document`, `location`等）拷贝出来，单独放在一个对象上，这个对象也称为 `fakeWindow`\r\n* 之后对每个微应用分配一个 `fakeWindow`\r\n* 当微应用修改全局变量时：\r\n  * 如果是原生属性，则修改全局的 `window`\r\n  * 如果不是原生属性，则修改 `fakeWindow` 里的内容\r\n* 微应用获取全局变量时：\r\n  * 如果是原生属性，则从 `window` 里拿\r\n  * 如果不是原生属性，则优先从 `fakeWindow` 里获取\r\n\r\n这样一来连恢复环境都不需要了，因为每个微应用都有自己一个环境，当在 `active` 时就给这个微应用分配一个 `fakeWindow`，当 `inactive` 时就把这个 `fakeWindow` 存起来，以便之后再利用。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6aebde8492943bba6420a0027f09027~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 隔离原理\r\n\r\n看完上面，你大概也知道了这些沙箱是怎么恢复环境的 但是，回到我们的问题：qiankun 是怎么把 `a` 和这些沙箱联系起来呢？也即写下 `window.a = 1` 是怎么做到对 `a` 变量隔离的呢？\r\n\r\n这个逻辑的实现并不在 qiankun 的源码里，而是在它所依赖的 [import-html-entry](https://github.com/kuitos/import-html-entry) 中，这里做一下简化：\r\n\r\n```js\r\nconst executableScript = `\r\n  ;(function(window, self, globalThis){\r\n    ;${scriptText}${sourceUrl}\r\n  }).bind(window.proxy)(window.proxy, window.proxy, window.proxy);\r\n`\r\n\r\neval.call(window, executableScript)\r\n```\r\n\r\n把上面字符串代码展开来看看：\r\n\r\n```js\r\nfunction fn(window, self, globalThis) {\r\n  // 你的 JavaScript code\r\n}\r\n\r\nconst bindedFn = fn.bind(window.proxy);\r\n\r\nbindedFn(window.proxy, window.proxy, window.proxy);\r\n```\r\n\r\n可以发现这里的代码做了三件事：\r\n1. **把要执行 JS 代码放在一个立即执行函数中**，且函数入参有 `window`, `self`, `globalThis`\r\n2. 给这个函数 **绑定上下文** `window.proxy`\r\n3. 执行这个函数，并 **把上面提到的沙箱对象 `window.proxy` 作为入参分别传入**\r\n\r\n因此，当我们在 JS 文件里有 `window.a = 1` 时，实际上会变成：\r\n\r\n```js\r\nfunction fn(window, self, globalThis) {\r\n  window.a = 1;\r\n}\r\n\r\nconst bindedFn = fn.bind(window.proxy);\r\n\r\nbindedFn(window.proxy, window.proxy, window.proxy);\r\n```\r\n\r\n那么此时，`window.a` 的 `window` 就不是全局 `window` 而是 `fn` 的入参 `window` 了。又因为我们把 `window.proxy` 作为入参传入，所以 `window.a` 实际上为 `window.proxy.a = 1`。这也正好解释了 qiankun 的 JS 隔离逻辑。\r\n\r\n## XXX is undefined\r\n\r\n不知道看完上面的实现，你有没有发现问题。\r\n\r\n假如现在代码里有隐式声明或调用全局对象的代码：\r\n\r\n```js\r\nadd = (a, b) => {\r\n  return a + b\r\n}\r\n\r\nadd(1, 2)\r\n```\r\n\r\n**当这样调用 `add` 时，上下文 `this` 则为刚刚绑定的 `window.proxy`。由于隐式声明 `add` 不会自动挂载到 `window.proxy` 上，所以当执行 `add`，`eval` 就会报 `add is undefined`。详见 [这个 Issue](https://github.com/umijs/qiankun/issues/1894)。**\r\n\r\n不要觉得这种情况不会发生，实际上，这还是挺常见的：\r\n* 老旧的第三方 SDK JS 文件\r\n* Webpack 插件引入的 JS\r\n* 公司网关层自动注入的 JS\r\n* 等等...\r\n\r\n我之前就遇到过这种情况：比如下面 Webpack 会注入脚手架定义好的 CDN 资源重试逻辑：\r\n\r\n```html\r\n<script>\r\n  var __JS_RETRY__ = {};\r\n\r\n  function __rpReport(data) {\r\n    console.log('__rpReport');\r\n  }\r\n\r\n  function __rpJsReport(loadType, msidType, url) {\r\n    console.log('__rpJsReport');\r\n  }\r\n\r\n  function __retryPlugin(event) {\r\n    console.log('retryPlugin')\r\n  }\r\n\r\n  // 改成下面就可以了\r\n  // window.__JS_RETRY__ = {};\r\n  //\r\n  // window.__rpReport = (data) => {\r\n  //     console.log('__rpReport');\r\n  // }\r\n  //\r\n  // window.__rpJsReport = (loadType, msidType, url) => {\r\n  //     console.log('__rpJsReport');\r\n  // }\r\n  //\r\n  // window.__retryPlugin = (event) => {\r\n  //     console.log('retryPlugin')\r\n  // }\r\n</script>\r\n```\r\n\r\n这个问题的解决的方法也很简单：\r\n1. 把代码 `a = 1` 改成 `window.a`\r\n2. 添加全局声明 `window a`\r\n\r\n这样一来，你就得每次打包代码以及发布时执行一个脚本来做这些文本替换，非常麻烦。而京东的新微应用框架 [MicroApp](https://zeroing.jd.com/) 则提供了一套插件系统：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e071d149582c476aa44b6e2d079b8e48~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n它可以让开发者在执行 JS 前去做代码文本的替换：\r\n\r\n```js\r\nimport microApp from '@micro-zoe/micro-app'\r\n\r\nmicroApp.start({\r\n  plugins: {\r\n    // ...\r\n    modules: {\r\n      'appName1': [{\r\n        loader(code, url, options) {\r\n          if (url === 'xxx.js') {\r\n            // 替换有问题的代码\r\n            code = code.replace('var abc =', 'window.abc =')\r\n          }\r\n          return code\r\n        }\r\n      }],\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n**如果要对接别的团队的微应用时，而且正好他们有 `a = 1` 这样的代码，那么在加载微应用的时候直接修复全局变量的问题，不需要通知他们修改，也不失为一种策略吧。**\r\n\r\n## 总结\r\n\r\n总结一下，qiankun 一共有 3 种沙箱：\r\n1. `SnapshotSandbox`：记录 `window` 对象，每次 unmount 都要和微应用的环境进行 Diff\r\n2. `LegacySandbox`：在微应用修改 `window.xxx` 时直接记录 Diff，将其用于环境恢复\r\n3. `ProxySandbox`：为每个微应用分配一个 `fakeWindow`，当微应用操作 `window` 时，其实是在 `fakeWindow` 上操作\r\n\r\n要和这些沙箱结合起来使用，qiankun 会把要执行的 JS 包裹在立即执行函数中，通过绑定上下文和传参的方式来改变 `this` 和 `window` 的值，让它们指向 `window.proxy` 沙箱对象，最后再用 `eval` 来执行这个函数。"
    },
    {
        "article_id": "7188802319725625399",
        "snapshot": "",
        "title": "后端语言很难？前端入门go基础语法只需要3小时！（下）",
        "preview": "go的基础语法速学，不来看一下吗？本文是《后端语言很难？前端入门go基础语法只需要3小时》系列的最后一篇",
        "author": "孟祥_成都",
        "view_count": 1404,
        "collect_count": 8,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/89db7db9a82487e9a26011b2624920f8~300x300.image",
        "category": "后端",
        "content": "继续之前这两篇文章，我们讲到了接口。\r\n\r\n- [后端语言很难？前端入门go基础语法只需要3小时！（上）](https://juejin.cn/post/7187303888393863225)\r\n\r\n- [后端语言很难？前端入门go基础语法只需要3小时！（中）](https://juejin.cn/post/7187717463218323493)\r\n\r\n## 接口\r\n\r\n在 Go 中，接口是一种类型，它定义了一组方法。接口类型变量可以存储任何实现了该接口的类型的值，这样就可以在程序中使用统一的接口类型来处理不同的具体类型。\r\n\r\n例如：\r\n\r\n```\r\ntype Reader interface {\r\n    Read(p []byte) (n int, err error)\r\n}\r\n```\r\n\r\n上面的代码定义了一个名为 Reader 的接口，该接口有一个方法 `Read(p []byte) (n int, err error)`。任何类型如果实现了Reader接口中的Read()方法，都可以被赋值给Reader类型变量.\r\n\r\n接口还可以包含多个方法, 例如\r\n\r\n```\r\ntype Writer interface {\r\n    Write(p []byte) (n int, err error)\r\n    Close() error\r\n}\r\n```\r\n\r\n这个Writer接口包含了两个方法，Write和Close。任何类型如果实现了这两个方法，就可以被赋值给Writer类型变量。\r\n\r\n在 Go 中，接口是隐式实现的，因此实现接口不需要显式声明。只要类型定义了接口中的所有方法，就可以认为它实现了该接口。\r\n\r\n接口还可以嵌套, 例如\r\n\r\n```\r\ntype ReadWriter interface {\r\n    Reader\r\n    Writer\r\n}\r\n```\r\n\r\n这个ReadWriter接口包含了Reader和Writer两个接口中所有的方法，任何类型实现了这两个接口中所有的方法就可以被赋值给ReadWriter类型变量。\r\n\r\n> 对比js：这个跟ts也差不多，但语法不太一样，我们的interface要继承或者type通过 && 来聚合，go还有点像ts中type这种组合的方式\r\n\r\n\r\n## 接口的多态\r\n\r\nGo 中，接口还可以用来实现多态。比如我们有一个函数，它接受一个接口类型的参数，那么这个函数就可以接受任何实现了这个接口的类型的参数。这样就可以在编译时就发现类型问题，而不是在运行时。\r\n\r\n例如：\r\n\r\n```\r\ntype Shape interface {\r\n    Area() float64\r\n}\r\n\r\ntype Rectangle struct {\r\n    width, height float64\r\n}\r\n\r\nfunc (r Rectangle) Area() float64 {\r\n    return r.width * r.height\r\n}\r\n\r\ntype Circle struct {\r\n    radius float64\r\n}\r\n\r\nfunc (c Circle) Area() float64 {\r\n    return math.Pi * c.radius * c.radius\r\n}\r\n\r\nfunc getArea(s Shape) float64 {\r\n    return s.Area()\r\n}\r\n\r\nfunc main() {\r\n    r := Rectangle{width: 10, height: 5}\r\n    c := Circle{radius: 5}\r\n\r\n    fmt.Println(\\\"Area of rectangle: \\\", getArea(r))\r\n    fmt.Println(\\\"Area of circle: \\\", getArea(c))\r\n}\r\n```\r\n\r\n上面的代码定义了一个接口 Shape，它有一个方法 Area()。Rectangle 和 Circle 两种类型都实现了这个方法，所以它们都实现了 Shape 接口。\r\n\r\n>这是go中实现面向对象继承的内容，是很重要的，因为面向接口编程，是函数跟业务解耦具体业务是非常重要的，函数本身解耦了数据和行为，有了接口就把数据限制了，把数据变为一种协议，只要实现这个协议的数据就可以，从而实现面向接口实现函数\r\n\r\n## 接口类型断言和类型判断\r\n另外，Go 中的接口还支持类型断言和类型判断，可以在运行时判断一个变量是否实现了某个接口。\r\n\r\n类型断言是指将接口类型断言成具体类型。这样就可以访问具体类型的字段和方法。类型断言的语法如下:\r\n\r\n```\r\nx.(T)\r\n```\r\n\r\nx 是一个接口类型，T 是具体类型。如果 x 断言成功，则返回 x 的具体值，否则返回一个类型断言失败的 panic。\r\n\r\n类型判断是指判断接口类型是否实现了某个接口。这样就可以在运行时判断一个变量是否实现了某个接口。类型判断的语法如下:\r\n\r\n```\r\nx.(type)\r\n```\r\n\r\nx 是一个接口类型。如果 x 实现了 T 接口,返回x的具体类型，否则返回nil\r\n\r\n在 Go 中，类型断言和类型判断可以用来在运行时判断一个变量是否实现了某个接口,并访问具体的字段和方法。这样可以提高代码的灵活性。\r\n\r\n我们举例子说明一下：\r\n\r\n\r\n类型断言：\r\n\r\n```\r\npackage main\r\n\r\nimport \\\"fmt\\\"\r\n\r\ntype animal interface {\r\n    speak()\r\n}\r\n\r\ntype dog struct {\r\n}\r\n\r\nfunc (d dog) speak() {\r\n    fmt.Println(\\\"Woof!\\\")\r\n}\r\n\r\nfunc main() {\r\n    var d animal = dog{}\r\n    if val, ok := d.(dog); ok {\r\n        val.speak()\r\n    } else {\r\n        fmt.Println(\\\"d is not a dog\\\")\r\n    }\r\n}\r\n```\r\n\r\n上面的代码中，我们定义了一个 animal 接口，并实现了一个 dog 类型。在 main 函数中，我们声明了一个 animal 类型的变量 d，并将一个 dog 类型的变量赋值给它。然后我们使用类型断言来判断 d 是否是 dog 类型。如果断言成功，就可以调用 dog 类型的 speak 方法。\r\n\r\n>注意：这里我们需要注意的是，断言是会返回内容的，这个跟typescript是完全不一样的\r\n\r\n类型判断：\r\n\r\n```\r\npackage main\r\n\r\nimport \\\"fmt\\\"\r\n\r\ntype animal interface {\r\n    speak()\r\n}\r\n\r\ntype dog struct {\r\n}\r\n\r\nfunc (d dog) speak() {\r\n    fmt.Println(\\\"Woof!\\\")\r\n}\r\n\r\nfunc main() {\r\n    var d animal = dog{}\r\n    switch v := d.(type) {\r\n        case dog:\r\n            v.speak()\r\n        default:\r\n            fmt.Println(\\\"d is not a dog\\\")\r\n    }\r\n}\r\n```\r\n我们定义了一个 animal 接口，并实现了一个 dog 类型。在 main 函数中，我们声明了一个 animal 类型的变量 d，并将一个 dog 类型的变量赋值给它。然后我们使用类型判断来判断 d 是否实现了 dog 类型。如果判断成功，就可以调用 dog 类型的 speak 方法。\r\n\r\n> 总结：类型断言和类型判断都可以用来在运行时判断一个变量是否实现了某个接口,并访问具体的字段和方法。但是类型断言是访问具体类型的值，类型判断是访问具体类型。\r\n\r\n>对比js，我们的ts好像没有直接把类型变为字符串的能力，毕竟js不是内置类型的，打通js和类型。\r\n\r\n\r\n\r\n## Goroutines和Channels\r\n\r\n并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。Web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户画面同时还会后台执行各种计算任务和网络请求。即使是传统的批处理问题--读取数据，计算，写输出--现在也会用并发来隐藏掉I/O的操作延迟以充分利用现代计算机设备的多个核心。计算机的性能每年都在以非线性的速度增长。\r\n\r\ngo的Goroutines可以类比以下协程，但是它们是有明显区别。\r\n\r\n\r\n在这里很多前端同学对操作系统中，进程、线程、协程并不了解，我们有必要介绍一下：\r\n\r\n一定注意，这些是大概念，具体到实现的语言里，是有区别的 。\r\n\r\n### 进程(Process)，线程(Thread)，[协程]\r\n\r\n- 进程：\r\n\r\n一个进程是计算机中的一个独立的程序关于某数据集合的一次运行活动,是系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间和系统资源，互不干扰。\r\n\r\n进程一般由程序、数据集、进程控制块三部分组成。 \r\n\r\n\r\n-   程序: 指进程所要执行的指令集合,包括可执行程序的机器语言代码和数据。\r\n-   数据集: 指进程所需要的数据,包括全局变量和局部变量。\r\n-   进程控制块: 是系统为每个进程维护的数据结构,记录了进程的当前状态,进程的基本信息,如进程ID,优先级,状态,进程的资源信息等。进程控制块是系统维护进程信息的重要数据结构,用于调度和管理进程,如记录进程。\r\n\r\n最后，**进程的局限是创建、撤销和切换的开销比较大。**\r\n\r\n- 线程：\r\n\r\n线程是进程的一个实体,是被系统独立调度和分派的基本单位,线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源\r\n线程线程是在进程之后发展出来的概念。\r\n\r\n线程的优点是减小了程序并发执行时的开销，提高了操作系统的并发性能，缺点是线程没有自己的系统资源。\r\n  \r\n- 协程：\r\n\r\n协程: 协程是一种用户态的轻量级线程, 它是程序员可控制的（用户态执行）,可以自行暂停和恢复执行,不由系统调度。\r\n\r\n子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。\r\n\r\n然后我们站在协程的角度看看它有什么优缺点：\r\n\r\n-   优点:\r\n\r\n1.  协程是轻量级的，它没有线程那么大的系统开销，所以它比线程更容易创建和管理。\r\n1.  协程是可控的，程序员可以自行控制协程的暂停和恢复，这样可以更灵活的实现并发。\r\n1.  协程能够在单一线程中完成多任务的调度，这样可以减少线程上下文切换的开销。\r\n\r\n-   缺点:\r\n\r\n1.  协程需要额外的机制来避免数据冲突，这可能会增加程序的复杂性。\r\n1.  协程不能利用多核处理器的优势，因为它们运行在单一线程中。\r\n\r\ngo里面的协程是共享数据的。但是，Go语言提供了一些机制来避免在多个协程之间共享变量时的数据冲突。\r\n\r\nGo语言提供了一种叫做channel的机制，允许协程之间进行通信。通过使用channel，可以在多个协程之间传递数据而不会发生数据冲突。\r\n\r\nGo语言还提供了一种叫做互斥锁（mutex）的机制，用于在多个协程之间同步访问共享变量。使用互斥锁可以保证在某一时刻只有一个协程能够访问共享变量。\r\n\r\n## Goroutines\r\n\r\n\r\n在Go语言中，使用关键字`go`来启动一个协程，如：\r\n\r\n```\r\ngo foo()\r\n```\r\n\r\n这样就会在单独的协程中启动函数foo()。\r\n\r\n协程之间可以使用通道（channel）来进行通信。通道是Go语言中的一种数据结构，可以用来在不同协程之间传递数据。\r\n\r\n我们举一个具体的例子：\r\n\r\n一个实用的 Go 协程案例是网络爬虫。网络爬虫程序通常需要同时访问多个网站，并在获取数据后进行处理。使用协程可以在访问一个网站时同时访问其他网站，提高爬取效率。例如：\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"net/http\\\"\r\n)\r\n\r\nfunc main() {\r\n    urls := []string{\r\n        \\\"http://www.example.com\\\",\r\n        \\\"http://www.example.net\\\",\r\n        \\\"http://www.example.org\\\",\r\n    }\r\n\r\n    for _, url := range urls {\r\n        go fetch(url)\r\n    }\r\n    fmt.Scanln()\r\n}\r\n\r\nfunc fetch(url string) {\r\n    resp, err := http.Get(url)\r\n    if err != nil {\r\n        fmt.Println(err)\r\n        return\r\n    }\r\n    defer resp.Body.Close()\r\n    fmt.Println(url, resp.Status)\r\n}\r\n```\r\n\r\n在这个例子中，我们使用了 Go 内置的 net/http 包来访问网站，并在循环中使用 go 关键字来并发地执行 fetch 函数。这样，程序可以同时访问多个网站，而不会阻塞在一个网站上。\r\n\r\n\r\n## Channels\r\n\r\nChannels 是 Go 语言中的一种通信机制，用于在 goroutines 之间进行同步和通信。通过 Channels，一个 goroutine 可以将数据发送到另一个 goroutine，并等待其接收。\r\n\r\nChannels 类似于其他语言中的管道或队列，但是 Channels 在 Go 中是一种内置类型，并提供了丰富的操作方法。\r\n\r\n下面是一个网络爬虫程序的例子，它使用了 Channels 来实现并发爬取，并在爬取完成后将数据发送到另一个 goroutine 进行处理：\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"net/http\\\"\r\n)\r\n\r\nfunc main() {\r\n    urls := []string{\r\n        \\\"http://www.example.com\\\",\r\n        \\\"http://www.example.net\\\",\r\n        \\\"http://www.example.org\\\",\r\n    }\r\n\r\n    // 创建一个用于爬取的 channel\r\n    fetchChannel := make(chan string)\r\n\r\n    // 创建一个用于处理数据的 channel\r\n    processChannel := make(chan string)\r\n\r\n    // 启动多个 goroutine 进行爬取\r\n    for _, url := range urls {\r\n        go fetch(url, fetchChannel)\r\n    }\r\n\r\n    // 启动一个 goroutine 来处理数据\r\n    go process(processChannel)\r\n\r\n    // 从 fetch channel 中读取数据，并发送到 process channel\r\n    for i := 0; i < len(urls); i++ {\r\n        fetchResult := <-fetchChannel\r\n        processChannel <- fetchResult\r\n    }\r\n\r\n    close(processChannel)\r\n    fmt.Scanln()\r\n}\r\n\r\nfunc fetch(url string, fetchChannel chan string) {\r\n    resp, err := http.Get(url)\r\n    if err != nil {\r\n        fetchChannel <- err.Error()\r\n        return\r\n    }\r\n    defer resp.Body.Close()\r\n    fetchChannel <- url + \\\" \\\" + resp.Status\r\n}\r\n\r\nfunc process(processChannel chan string) {\r\n    for data := range processChannel {\r\n        fmt.Println(data)\r\n    }\r\n}\r\n```\r\n在上面的例子中，我们使用了两个 channel\r\n\r\n\r\n# 包\r\n\r\nGo 语言中的包（package）是一种模块化编程的方式，用于将相关的类型、变量、函数和常量组织在一起。\r\n\r\n所有的 Go 程序都必须在一个包中，main 包是一个特殊的包，它是程序的入口。\r\n\r\n包中的类型、变量、函数和常量可以通过 import 关键字导入到其他包中使用。\r\n\r\n例如：\r\n\r\n在一个名为 `math` 的包中定义了一个名为 `Add` 的函数，它接受两个整型参数并返回它们的和。\r\n\r\n```\r\npackage math\r\n\r\nfunc Add(a, b int) int {\r\n    return a + b\r\n}\r\n```\r\n\r\n在另一个名为 `main` 的包中，我们可以导入 math 包并使用它的 Add 函数\r\n\r\n```\r\npackage main\r\n\r\nimport \\\"math\\\"\r\n\r\nfunc main() {\r\n    result := math.Add(1, 2)\r\n    fmt.Println(result)\r\n}\r\n```\r\n\r\n执行这个程序将会输出 3。\r\n\r\nGo 还支持匿名导入，可以使用 _ 关键字导入一个包，但不使用它的任何类型、变量、函数和常量。这可以用于导入一个包中的 init 函数。\r\n\r\n例如：\r\n\r\n```\r\nimport _ \\\"math/rand\\\"\r\n```\r\n\r\n这样会导入 math/rand 包，但不会使用任何类型、变量、函数和常量。\r\n\r\n## 导入路径\r\n\r\n每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。\r\n\r\n```\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"math/rand\\\"\r\n    \\\"encoding/json\\\"\r\n    \\\"golang.org/x/net/html\\\"\r\n    \\\"github.com/go-sql-driver/mysql\\\"\r\n)\r\n```\r\n\r\n\r\n如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。\r\n\r\n\r\n## 包声明\r\n\r\n在每个Go语音源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。\r\n\r\n例如，math/rand包的每个源文件的开头都包含`package rand`包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"math/rand\\\"\r\n)\r\n\r\nfunc main() {\r\n    fmt.Println(rand.Int())\r\n}\r\n```\r\n\r\n通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。\r\n\r\n关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。\r\n\r\n- 第一种，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给 go build 构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。\r\n\r\n- 第二种，包所在的目录中可能有一些文件名是以*test.go为后缀的Go源文件。并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：\r\n    - 一种普通包，\r\n    - 一种则是测试的外部扩展包。\r\n\r\n  所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。后面会介绍test的内容\r\n\r\n- 第三种，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如\\\"gopkg.in/yaml.v2\\\"。这种情况下包的名字并不包含版本号后缀，而是yaml。\\\"\r\n\r\n\r\n# 测试\r\n\r\nMaurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过份悲观的想法，虽然也许不是没有人困惑于他对软件开发的难度的天真看法。\r\n\r\n现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。\r\n\r\n## 测试函数\r\n\r\n每个测试函数必须导入testing包。测试函数有如下的签名：\r\n```\r\nfunc TestName(t *testing.T) {\r\n\r\n// ...\r\n\r\n}\r\n```\r\n测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：\r\n```\r\nfunc TestSin(t *testing.T) { /* ... */ }\r\n\r\nfunc TestCos(t *testing.T) { /* ... */ }\r\n\r\nfunc TestLog(t *testing.T) { /* ... */ }\r\n```\r\n\r\n其中t参数用于报告测试失败和附加的日志信息。\r\n\r\n我们来举一个例子：\r\n\r\ngopl.io/ch11/word1\r\n```\r\n// Package word provides utilities for word games.\r\npackage word\r\n\r\n// IsPalindrome reports whether s reads the same forward and backward.\r\n// (Our first attempt.)\r\nfunc IsPalindrome(s string) bool {\r\n    for i := range s {\r\n        if s[i] != s[len(s)-1-i] {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n```\r\n\r\n\r\n在相同的目录下，word_test.go测试文件中包含了TestPalindrome和TestNonPalindrome两个测试函数。每一个都是测试IsPalindrome是否给出正确的结果，并使用t.Error报告失败信息：\r\n\r\n```\r\npackage word\r\n\r\nimport \\\"testing\\\"\r\n\r\nfunc TestPalindrome(t *testing.T) {\r\n    if !IsPalindrome(\\\"detartrated\\\") {\r\n        t.Error(`IsPalindrome(\\\"detartrated\\\") = false`)\r\n    }\r\n    if !IsPalindrome(\\\"kayak\\\") {\r\n        t.Error(`IsPalindrome(\\\"kayak\\\") = false`)\r\n    }\r\n}\r\n\r\nfunc TestNonPalindrome(t *testing.T) {\r\n    if IsPalindrome(\\\"palindrome\\\") {\r\n        t.Error(`IsPalindrome(\\\"palindrome\\\") = true`)\r\n    }\r\n}\r\n```\r\n`go test`命令如果没有参数指定包那么将默认采用当前目录对应的包（和`go build`命令一样）。我们可以用下面的命令构建和运行测试。\r\n```\r\n$ cd $GOPATH/src/gopl.io/ch11/word1\r\n\r\n$ go test\r\n\r\nok gopl.io/ch11/word1 0.008s\r\n```\r\n\r\n-   测试用例名称一般命名为 `Test` 加上待测试的方法名。\r\n-   测试用的参数有且只有一个，在这里是 `t *testing.T`。\r\n-   基准测试(benchmark)的参数是 `*testing.B`，TestMain 的参数是 `*testing.M` 类型。\r\n\r\n`go test -v`，`-v` 参数会显示每个用例的测试结果，另外 `-cover` 参数可以查看覆盖率\r\n\r\n例如下面的:\r\n\r\n```bash\r\n$ go test -v\r\n=== RUN   TestAdd\r\n--- PASS: TestAdd (0.00s)\r\n=== RUN   TestMul\r\n--- PASS: TestMul (0.00s)\r\nPASS\r\nok      example 0.007s\r\n```\r\n\r\n如果只想运行其中的一个用例，例如 `TestAdd`，可以用 `-run` 参数指定，该参数支持通配符 `*`，和部分正则表达式，例如 `^`、`$`。\r\n\r\n```bash\r\n$ go test -run TestAdd -v\r\n=== RUN   TestAdd\r\n--- PASS: TestAdd (0.00s)\r\nPASS\r\nok      example 0.007s\r\n```\r\n## 子测试(Subtests)\r\n\r\n子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 `t.Run`创建不同的子测试用例：\r\n\r\n```\r\n// calc_test.go\r\n\r\nfunc TestMul(t *testing.T) {\r\n\\tt.Run(\\\"pos\\\", func(t *testing.T) {\r\n\\t\\tif Mul(2, 3) != 6 {\r\n\\t\\t\\tt.Fatal(\\\"fail\\\")\r\n\\t\\t}\r\n\r\n\\t})\r\n\\tt.Run(\\\"neg\\\", func(t *testing.T) {\r\n\\t\\tif Mul(2, -3) != -6 {\r\n\\t\\t\\tt.Fatal(\\\"fail\\\")\r\n\\t\\t}\r\n\\t})\r\n}\r\n```\r\n\r\n-   之前的例子测试失败时使用 `t.Error/t.Errorf`，这个例子中使用 `t.Fatal/t.Fatalf`，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。\r\n\r\n## 反射\r\n\r\n反射是指在运行时动态获取和操作类型、变量、函数和接口的能力。在 Go 语言中，反射是通过内置的 reflect 包实现的。\r\n\r\n常用的api如下：\r\n\r\n`reflect.ValueOf(x)` 会返回一个 `reflect.Value` 类型的变量，它包含了变量的值和类型信息。通过这个变量，我们可以获取变量的值，修改变量的值，获取变量的类型和类别等。\r\n\r\n`reflect.TypeOf(x)` 会返回一个 `reflect.Type` 类型的变量，它包含了变量的类型信息。通过这个变量，我们可以获取变量的类型名称，获取字段和方法等。\r\n\r\n\r\n\r\n\r\n举个例子：\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"reflect\\\"\r\n)\r\n\r\nfunc main() {\r\n    var x float64 = 3.4\r\n    v := reflect.ValueOf(x)\r\n    fmt.Println(\\\"type:\\\", v.Type())\r\n    fmt.Println(\\\"kind is float64:\\\", v.Kind() == reflect.Float64)\r\n    fmt.Println(\\\"value:\\\", v.Float())\r\n}\r\n\r\n```\r\n这里我们使用反射获取了一个 float64 类型的变量的类型、类别和值。\r\n输出：\r\n\r\n```\r\ntype: float64\r\nkind is float64: true\r\nvalue: 3.4\r\n```\r\n我们可以在运行时动态获取变量的类型，类别和值，并进行各种操作。\r\n\r\n在 Go 中，反射还可以用来获取结构体的字段、方法和标签。\r\n\r\n举个例子：\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"reflect\\\"\r\n)\r\n\r\ntype Person struct {\r\n    Name string `json:\\\"name\\\"`\r\n    Age  int    `json:\\\"age\\\"`\r\n}\r\n\r\nfunc (p Person) SayHello() {\r\n    fmt.Println(\\\"Hello, my name is\\\", p.Name)\r\n}\r\n\r\nfunc main() {\r\n    p := Person{Name: \\\"John\\\", Age: 30}\r\n    t := reflect.TypeOf(p)\r\n\r\n    // 获取字段\r\n    fmt.Println(\\\"fields:\\\")\r\n    for i := 0; i < t.NumField(); i++ {\r\n        f := t.Field(i)\r\n        fmt.Printf(\\\"%d: %s %s json=%s\\\r\n\\\", i, f.Name, f.Type, f.Tag.Get(\\\"json\\\"))\r\n    }\r\n\r\n    // 获取方法\r\n    fmt.Println(\\\"\\\r\nmethods:\\\")\r\n    for i := 0; i < t.NumMethod(); i++ {\r\n        m := t.Method(i)\r\n        fmt.Printf(\\\"%d: %s\\\r\n\\\", i, m.Name)\r\n    }\r\n}\r\n```\r\n\r\n输出：\r\n\r\n```\r\nfields:\r\n0: Name string json=name\r\n1: Age int json=age\r\n\r\nmethods:\r\n0: SayHello\r\n```\r\n\r\n我们通过反射获取了结构体 Person 的字段名称、类型和标签，以及方法名称。\r\n\r\n\r\n## 最基础的部分已经完结\r\n\r\n接下来，是看了一个视频（<Go语言从入门到实战>），总结了一些语法上的常见坑点。\r\n\r\n\r\n## 类型转化\r\n\r\n与ts的区别：\r\n\r\n1、Go语言不允许隐式类型转换\r\n2、别名和原有类型也不能进行隐式类型转换\r\n\r\n```\r\npackage main\r\n\r\nfunc main(){\r\n    var a intt = 1\r\n    var b int64\r\n    b = a // 报错\r\n}\r\n```\r\n\r\n如何修正,显示类型转换即可\r\n```\r\n b = int64(a)\r\n```\r\n\r\n我们再看下别名\r\n\r\n```\r\npackage main\r\n\r\ntype MyInt int64\r\n\r\nfunc main(){\r\n    var b int64\r\n    var c MyInt\r\n    c = b // 报错 修正的话：c = MyInt(b)\r\n}\r\n```\r\n\r\n## 指针类型\r\n\r\n\r\n- 不支持指针运算\r\n- 与ts的区别： string是值类型，默认的初始化值是空字符串，不是undefined\r\n\r\n\r\n```\r\npackage main\r\n\r\ntype MyInt int64\r\n\r\nfunc main(){\r\n    a := 1\r\n    aPoint := &a\r\n    aPoint := aPoint + 1\r\n    var b string // 被初始化为一个空值\r\n}\r\n```\r\n\r\n## 算数运算符\r\n\r\n- go没有前置++\r\n\r\n## while循环\r\n\r\n与js的差别，没有while循环，但可以用for循环来实现\r\n\r\n```\r\nn := 0\r\nfor n < 5 {\r\n    n++\r\n    fmt.Println(n)\r\n}\r\n```\r\n\r\n## if语句\r\n\r\n怎么说呢，if的go风格是下面这样的，跟js不太像，跟node其实有点像，node以前是回调函数都有错误优先，go也是这样的，只不过写起来语法不一样，思想是一样的。\r\n```\r\npackage main\r\n\r\n\r\nfunc main(){\r\n   if v, err := someFun(); err == nil {\r\n       xxx\r\n   }  else {\r\n       xxx\r\n   }\r\n}\r\n```\r\n\r\nswitch语句也有类似的用法\r\n\r\n```\r\nswitch os:= runtime.GOOS; os {\r\n    case \\\"darwin\\\":\r\n        fmt.Println(\\\"OS X.\\\")\r\n    case \\\"linux\\\"\r\n        fmt.Println(\\\"Linux.\\\")\r\n    default:\r\n        fmt.Printf(\\\"%s.\\\", os)\r\n}\r\n```\r\n\r\nswitch还有一种用法，跟js完全不同,下面的逗号相当于匹配任意一个就算true\r\n\r\n```\r\nswitch i {\r\n    case 0, 2:\r\n        xx\r\n    case 1, 3:\r\n        xx\r\n    default:\r\n        xx\r\n}\r\n```\r\n\r\n## 多维数组\r\n\r\n例如如何在go中声明2维数组\r\n\r\n```\r\nc := [2][2]int{{1, 2}, {3, 4}}\r\n```\r\n\r\n## go中判断map中某个key是否元素存在\r\n\r\n写法如下，跟js大不相同\r\n\r\n```\r\nm1 := map[int]int{}\r\nm1[2] = 0\r\n\r\nif v,ok := m1[3]; ok {\r\n\r\n} else {\r\n\r\n}\r\n```\r\n\r\n## go中的slice在什么情况下会共享数据\r\n\r\n在 Go 中，slice 是对数组的一个封装。当一个新的 slice 是由一个已经存在的 slice 创建时，两个 slice 会共享同一个底层数组。\r\n\r\n这可能会发生在以下两种情况：\r\n\r\n1.  通过切片语法创建新的 slice：\r\n\r\n```\r\noriginal := []int{1, 2, 3, 4, 5}\r\n// Create a new slice that shares the same underlying array\r\nnew := original[1:3]\r\n```\r\n\r\n2.  通过调用内置函数 `make` 创建新的 slice，并且指定了第三个参数，并且这个参数不为0,表示容量而不是长度，这样创建的slice 会共享同一个底层数组:\r\n\r\n```\r\noriginal := make([]int, 5, 10)\r\n// Create a new slice that shares the same underlying array\r\nnew := original[:3]\r\n```\r\n\r\n在这些情况下，原始的 slice 和新的 slice 都共享相同的底层数组。当修改其中一个 slice 中的数据时，另一个 slice 中的数据也会被更改。\r\n\r\n当然在创建新的slice的时候如果是通过append()来创建的就不会共享数据了，因为append会新开一块新的内存来存储数据。\r\n\r\n## go里面的相面对象其实没有严格的继承功能\r\n\r\n网上很多文章说go支持继承，其实并不支持，严格来讲应该算是组合，而不是继承，类似设计模式的桥接模式。\r\n\r\n在Go语言中，可以通过组合一个类型的结构体字段来实现类似继承的功能。这种方式更加简洁、清晰，同时也避免了继承所带来的复杂性和灵活性问题。\r\n\r\n\r\n## go中的字符串表现为Unicode字符组成的byte切片\r\n\r\n在 Go 语言中，字符串是由一系列Unicode字符组成的，字符串在内存中是以UTF-8编码的形式存储的。实际上，字符串在内存中是一个byte切片，每个字符在内存里是一段连续的区间。\r\n\r\n## 空接口可以表示任何类型\r\n\r\n在 Go 中，空接口（interface{}）表示可以存储任何类型的值。因为所有类型都满足空接口的约束（不需要实现任何方法），所以可以将任何类型的值赋值给空接口类型的变量。这使得空接口非常适用于实现通用函数、数据结构等。\r\n\r\n注意，可以通过断言来将空接口转换为指定类型\r\n\r\n```\r\nv, ok := p.(int) // ok等于true时，转换成功\r\n``` \r\n\r\n## go接口的最佳实践\r\n\r\n倾向于使用小的接口定义，很多接口只包含一个方法，比如\r\n\r\n```\r\ntype Reader interface {\r\n    Read(p []byte)(n int, err error)\r\n}\r\n```\r\n```\r\ntype Writer interface {\r\n    Write(p []byte)(n int, err error)\r\n}\r\n```\r\n较大的接口定义，可以由多个小接口定义组合而成\r\n```\r\ntype ReadWriter interface {\r\n    Reader\r\n    Writer\r\n}\r\n```\r\n\r\n只依赖于必要功能的最小接口\r\n\r\n```\r\nfunc StoreData(reader Reader) error { ... }\r\n```\r\n\r\n## GO没有错误机制\r\n\r\n比如没有try catch语句。我们可以通过errors.New来快速创建错误实例,利用多返回值的特性，去处理错误\r\n\r\n```\r\nerrors.New(\\\"n must be int rhe range [0, 1]\\\")\r\n```\r\n\r\n## 错误处理原则\r\n\r\n及早失败，避免嵌套\r\n\r\n就是说如果函数报错，就直接return了\r\n\r\n## 错误的recover\r\n\r\n常常有同学这样写代码：\r\n\r\n```\r\ndefer func() {\r\n    if err := recover(); err != nil {\r\n        log.Error(\\\"recover panic\\\", err)\r\n    }\r\n}\r\n```\r\n\r\n因为错误可能是我们系统中某些资源消耗完了，我这样恢复了，其实系统依然是不能工作的，我们的健康检查也很难去检查出现在的问题，因为常常健康检查只是检测当前的应用是否正常提供服务，结果还是在的，结果你已经不能提供正常的服务了。\r\n\r\n如何处理呢？\r\n\r\n\\\"Let it Crash\\\"，重启大法好啊！\r\n\r\n## package一致\r\n\r\n同一目录里的Go代码的package要保持一致，要不编译不通过\r\n\r\n## init可以定义多个\r\n\r\n首先 init函数时在main函数被执行前，所有依赖的package的init方法都会被执行\r\n\r\n\r\n并且包的每个源文件也可以有多个init函数，这点比较特殊\r\n\r\n例如：\r\n\r\n// my_series.go\r\n\r\n```\r\npackage series\r\n\r\nfunc init() {\r\n    fmt.Println(\\\"init1\\\")\r\n}\r\n\r\nfunc init() {\r\n    fmt.Println(\\\"init2\\\")\r\n}\r\n\r\nfunc Square(n int) int {\r\n    return n * n\r\n}\r\n```\r\n\r\n```\r\npackage main\r\n\r\nimport \\\"ch15/series\\\"\r\n\r\nfunc main() {\r\n     fmt.Println(series.Square(2)) \r\n}\r\n```\r\n\r\n最后输出，init的函数依次执行了\r\n\r\n## go get 命令默认访问https\r\n\r\n\\\"go get -u\\\" 是 Go 语言中的命令，用于安装和更新 Go 包。\r\n\r\n\\\"go get\\\" 命令用于安装 Go 包，它会从远程代码库下载包的源代码，并安装到本地。\r\n\r\n\\\"-u\\\" 参数表示更新，当安装已经存在的包时，会更新这个包到最新版本。\r\n\r\n例如，执行 \\\"go get -u github.com/golang/example\\\" 命令，会安装或更新名为 \\\"example\\\" 的包，并将其安装到 $GOPATH/src/github.com/golang 目录下。\r\n\r\n需要注意的是，go get命令默认会访问https的代码库，如果你需要访问http的代码库或者本地目录，需要使用-d参数。\r\n\r\n## 协程的原理\r\n\r\ngo的协程开销非常小，初始化的栈只有2k，而java的线程栈大小是1M。java线程和内核对象的映射是1：1，而go的协程和内核对象的映射是M:N（多对多）,明显go要更强。\r\n\r\n\r\n协程并发处理的机制：\r\n\r\n![协程.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f1455d4221347389b3b6dc150f93215~tplv-k3u1fbpfcp-zoom-1.image \\\"协程.png\\\")\r\n\r\n上图中，M代表的是系统线程，P是GO语言自己实现的协程处理器，G是一个协程任务，组成协程队列。\r\n\r\n如果一个协程花费的时间特别长\r\n\r\n**机制1**：协程的守护进程会记录协程处理器完成的协程数量，如果一段时间内，处理器完成的数量没有变化，就会往任务栈中插入一个标记，当前协程遇到非内联函数时，在任务栈中读到该标记，就会把该协程任务移到队列的末尾；\r\n\r\n**机制2**：如果执行协程过程中遇到一个非CPU密集型任务，例如IO，需要中断等待时，协程处理器P会把自己移到另外一个可使用的系统线程中，继续执行队列中其他的协程任务。当中断的协程被重新唤醒后，会把自己重新加入到协程队列里或者全局等待队列中。其中，中断的协程会把context保存在协程对象里，当协程被唤醒后会将其重新读取到寄存器中，继续运行。\r\n\r\n\r\n一个很容出错的案例：\r\n\r\n```\r\nfunc TestGroutine(t *testing.T) {\r\n    for i := 0; i < 10; i++ {\r\n        go func(i int) {\r\n            fmt.Println(i)\r\n        }()\r\n    }\r\n}\r\n```\r\n其中i打印的值都是10，因为go 后面的代码有点像js的异步，for循环是同步代码，当循环完毕，i已经是10了，然后因为go又是词法作用域，所以，每次去寻找外部i的值，都是10。\r\n\r\n\r\n\r\n参考：\r\n- https://geektutu.com/post/quick-go-test.html\r\n"
    },
    {
        "article_id": "7188501899887738939",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2525a3fe31ec4c5998d6de1798947e34~tplv-k3u1fbpfcp-watermark.image?",
        "title": "面试系列：4000字长文，让你了解单点登录（一）",
        "preview": "大家好，我是车辙，由于目前接手的业务涉及到了单点登录，所以一直在疯狂的去补充这方面的知识。也写下了这篇面试形式的文章，写的不好大家轻点 Diss。 面试开始 什么是单点登录 这也太简单了。讲个自己的糗",
        "author": "车辙cz",
        "view_count": 1498,
        "collect_count": 19,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/8c62a511338ea07d450cf504199b541b~300x300.image",
        "category": "后端",
        "content": "大家好，我是车辙，由于目前接手的业务涉及到了单点登录，所以一直在疯狂的去补充这方面的知识。也写下了这篇面试形式的文章，写的不好大家轻点 Diss。\r\n\r\n# 面试开始\r\n> 在焦急的等待中，一位看上去比较年轻的小伙子走了过来。我心想：这么年轻，看来今天的面试稳了。“你好，我是今天的面试官，一位97年的架构师。我看你简历上写了精通单点登录，我们今天就聊聊这个吧”\r\n\r\n# 什么是单点登录\r\n这也太简单了。讲个自己的糗事，在我刚实习的时候，我曾经以为单点登录就是单用户登录，比如说我在一台手机上登录后，另一台手机再次登录就会把原先的那个给挤掉。因为这个在一次技术分享会上还出了大糗。\r\n\r\n实际上，单点登录是指在**多个应用系统**中，用户只需要登录**任意一个系统**，就可以访问其他的互相信任的系统。比如说我在天猫登录后，在浏览器上输入淘宝的域名，你就已经登录成功了。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed6aa964fd1d4bc98a0d32bd89ccc71a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 为什么需要单点登录\r\n面试官：“你觉得为什么需要单点登录，或者说单点登录的价值体现在哪里”\r\n\r\n为了方便，如果一款产品的用户体验很差劲，那么基本上是没有用户愿意持续使用的。\r\n\r\n\r\n通过单点登录，可以让用户在多系统中灵活跳转而**不必重新登录**，能有效提升用户体验。就像我们杭州的最多跑一次。\r\n\r\n# 常见的登录实现\r\n面试官：那我们先来聊一下**常见的登录**是怎么做的？  \r\n\r\n这不就是我们大学时候教的内容么，首先我们后端有个拦截器，每次请求接口时都会在**拦截器**内部进行判断：根据`Cookie`中传递的`SessionId`判断用户信息是否已经保存在`Session`中。如果不存在，说明用户未登录，让浏览器跳转到登录页进行登录。\r\n\r\n登录验证成功后，把用户信息写入到 **服务器Session**中。于是通过`Cookie`中的`SessionId`和服务器建立了会话。\r\n\r\n并且一般来说，浏览器中的`Cookie`不会设置过期时间，而是在服务端的`Session`中设置，由服务端来控制用户的登录态。\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef63379aa6124ca89eb49e2f25d92b8a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 单点登录的设计思路\r\n面试官：有点东西哈，那么如果要你设计实现一个**单点登录系统**，有没有什么**简单点**的方案？\r\n\r\n我：首先我们要了解，单点登录其实就是**用户的登录态在多个系统间进行共享**。我们可以这样思考，假如用户在 A系统 登录后，然后点击 B系统，能够把**用户相关信息给带过去**，然后在 B系统中判断存在用户信息， 从而进行登录。这样做对于用户来说是**完全无感知的**，只需要在系统层面帮助用户进行登录即可。\r\n\r\n\r\n\r\n# 传递数据到前端还是后端\r\n面试官：\\\"既然是传递数据至 系统B，你觉得该把数据传递到 系统B 的浏览器前端页面还是后端服务器呢，或者说两者的**实现方式有什么区别**？\\\"\r\n\r\n我：如果是通过浏览器页面传递信息，前端拿到用户信息后，可以调用 B系统 服务端接口进行登录，与B系统建立会话。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db3b38dce5ac4d659bd97c6930ba79d8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n如果是传递到 B系统 后端服务器，需要在服务器进行登录，然后带上用户信息重定向到B系统前端页面，这时候建立会话完成。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f23cdb7f92a42dc8636f48da2c13de5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在前后端分离的情况下，我们一般采用第一种方式进行数据传递。\r\n\r\n\r\n\r\n# 如何传递数据\r\n面试官：“从你的两种方案中，不管是浏览器层面的跳转，还是后端重定向，都需要带上用户信息。如果是方式1，那么这个用户信息放在哪里呢，是URL链接还是其他地方”。\r\n\r\n我：既然是通过浏览器传递数据，有两种方式，第一种是通过在`Url`上拼接参数，比如 http://www.baidu.com?userId=123 。  \r\n\r\n第二种是通过`Cookie`的形式传递，但是由于`Cookie`不能跨域，就导致了部分局限性。\r\n\r\n为了体现对技术的追求，我偷偷的补充了一句：不过我发现在淘宝的`Cookie`中，能够看到天猫的`domain`，好像是用`Jsonp`实现的。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90dadf4378b54cb685404d0ec6f535fc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n# 安全性如何保证\r\n面试官点了点头，内心多少有点赞许了。接着问了面试中最常见的问题之一：不管是`URL`还是`Cookie`传递数据，你们如何保证数据的安全性呢？\r\n\r\n身为一个对自我要求很高的程序员，这肯定难不倒我。保证数据的安全性总的来说有几种实现：\r\n1. 从软件层面上进行保证，比如说可见性等。\r\n2. 通过加密算法对数据进行加密。\r\n\r\n因为从浏览器层面保证数据不可见不太现实，所以可以对数据进行加密，并且这个数据加解密的过程应该**由服务端来实现**。\r\n\r\n比如：用户在 系统A 登录后，系统A 的服务端通过**某种加密算法**以及**某个秘钥**对用户数据进行加密，接着返回给前端。系统A 页面跳转到系统B时带上这个加密信息，接着调用系统B服务端接口进行登录。系统B 通过解密数据获取登录者的用户信息进行登录即可。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0459b42b828d446b9c3e3bd1781f683b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n> 时序图是用代码画的，想了解的访问我之前的文章[:这是啥操作，用代码能画这样的图](https://juejin.cn/post/7186566887654817851)\r\n\r\n# 你们的单点登录具体是如何实现的\r\n“重头戏来了”，因为我们所有系统的顶级域名都是一样的，因此不会存在跨域问题。为了降低接入成本，我们采用的是 **Cookie加密** 的形式。\r\n\r\n比如用户在 系统A 登录后，系统A会往浏览器中写入`Cookie`, Key 为`userInfo`，value值为`用户A的accountId`。当然这个`accountId`是加密过的。\r\n\r\n然后用户在访问系统B的页面时，由于**属于同一个顶级域名**，会带上 Cookie。调用系统B接口时，判断 `Cookie`中存在用户信息，如果存在，通过`Secret`进行解密获取用户的`accountId`，随后把用户数据放到`Session`中，从而进行登录。\r\n\r\n这样做还有一个好处就是：用户可以直接在浏览器中输入域名进行跳转，而不是需要在 系统A 点击跳转到系统B。毕竟一般的用户都是把链接保存在书签的。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e163b2f5dd1a455580866aaf93d6932e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n# 加密的Secret是怎么实现的\r\n我们的`Secret`采用的是系统约定的形式，我猜面试官肯定会想`Secret`全都一样会不会不安全。\r\n\r\n这个值在系统中以加密的形式进行存储，并且使用的配置中心，再加上我们系统使用的是专用网络，基本不存在泄漏的风险。\r\n\r\n> 有时候面试的时候，不要等面试官问的时候再说。你可以提前预判他要问的问题，这样在他心里能加不少分呢。\r\n\r\n# 使用Cookie 可能会存在被攻击的风险，你知道哪些吗\r\n面试官说到这神情有点异样，莫非它以前经历过？\r\n\r\n使用`Cookie`存储的方式可能会受到`Xss`攻击，也就是攻击者在页面上注入恶意脚本，然后在浏览器上运行这段脚本，从而获取用户的数据，比如Cookie等，危害数据安全。**这有点像我们后端的SQL注入**。\r\n\r\n所以我们的系统在设置用户`Cookie`时都会设置 `HttpOnly=true`，这样通过js脚本将无法读取到`cookie`信息，增强了使用`Cookie`的安全性。\r\n\r\n另外除了`Xss`攻击外，还会存在`Csrf`攻击，也就是跨站请求伪造，攻击者一般会诱导用户进入第三方网站。然后在第三方网站中，通过比较吸引人的链接让用户点击。从而冒充用户对被攻击的网站执行某项操作的目的。\r\n> 关于Xss 和 Csrf 你可以去看美团技术博客的文章，链接我都帮你们准备好了  \r\n> [如何防止XSS攻击？](https://juejin.cn/post/6844903685122703367)\r\n> \r\n> [ 如何防止CSRF攻击？](https://juejin.cn/post/6844903689702866952#heading-24)\r\n\r\n# 我怎么听起来有点像背的，你能举个例子解释下吗\r\n“事也太多了吧，谁面试的时候不准备下八股文背诵”，我默默的竖起了中指。\r\n\r\n清了下嗓子，比如说某银行的官网使用的是`Cookie-Session`登录机制。那么用户在工商银行登录之后，浏览器上会保存有用户的`SessionId`。之后用户访问了第三方网站，网站页面上写着“跳楼大甩卖，100元一枚比特币，点击购买”。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a0fa32823b418e84c0b80d92a69dee~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n你明知道是假的，但还是忍不住。你一点击，脑海里已经幻想着比特币到账100枚，却**没想到收到了短信；“您的银行账户转账10000元”。**\r\n\r\n你突然两眼一黑，战战兢兢的打开链接地址，没想到链接地址是：**“icbc.com?transfer=10000&userId=坏蛋”**，它会向银行发出转账请求。并且由于你之前登录过银行，这个请求还会带上`Cookie`，从而让银行认为这是你发出的“正确行为”。\r\n\r\n我顺道还聊了下解决方式：业界会使用 CSRF Token 的方式解决。只不过这个成本较高，所以我们就使用了**双重Cookie**验证，再加上我们的网络是专用网络，也能提高安全问题。\r\n> 这块内容，美团技术博客的文章都提到了，没看的同学建议去看下，上文给了链接哦。\r\n\r\n# 因为你是Cookie，如果其他人拿到了你的用户信息怎么办\r\nemm，面试官你的问题很刁钻嘛。事实上传统的 `session+cookie` 方案，如果泄露了`sessionId`，别人同样可以盗用你的身份，就像`Csrf`攻击。\r\n> 就像前端页面的真人验证一样，只要你们的信息是保存在前端页面的，只要能看你的前端代码，不管使用的加密逻辑再复杂，总是能被人破解的。\r\n> \r\n> 我之前有个同学，他们公司有部分业务是搞爬虫的，叫 MoXieKeJi。 他们公司就是爬取其他公司的个人征信、个人信息，然后给第三方公司提供风控数据。支付宝的安全做的还不错吧，照样被他们把用户的芝麻信用、蚂蚁花呗的数据搞出来了。蚂蚁改一次逻辑，他们也跟着改，最后蚂蚁发了律师函，后面整个公司都被请去喝茶了。\r\n\r\n所以我觉得考虑这个问题，还不如考虑下别人为什么能够拿到你的信息。比如说使用`Https`。\r\n\r\n不过要是攻击者直接打开了我的浏览器，把我的Cookie信息拿走，那我就真的无能为力了。\r\n\r\n\r\n\r\n# 用户登录的时效性怎么保证\r\n面试官：在这种方式下，用户登录的时效性你们是怎么保证的，不管是对当前系统还是多系统的维度下。\r\n\r\n我：在单系统条件下，如果是标准的 `Cookie-Session` 机制，用户登录后调用接口，这个 Session 会进行续签，从而让会话保持下去。**会话的生命周期变成了主要由服务端来保证**\r\n\r\n但是通过目前的这种形式，通过**Cookie中是否存在用户信息**判断是否登录，会出现一个情况就是只要这个用户信息也就是`Cookie`一直存在，那么用户就永远不会退出。（因为我们只会对数据进行解密，并且用户在登录后，`Cookie`并不会设置有效期），**也就是说这个会话的生命周期变成了由 Cookie 来保证。**\r\n\r\n所以我们有两种方案，一种是对 `Cookie` 添加过期时间，比如 30 分钟，只要`Cookie`消失了，说明用户登录状态失效。第二种是在`userInfo`这个`Cookie`的`Value`值中添加过期信息，然后每次接口调用时服务端判断是否超时。\r\n\r\n# 添加过期时间这种方案可行吗\r\n我好像看见了面试官嘴角的微笑,不急不慢的说到。\r\n\r\n但是问题点在于续签问题，这两种方式不可避免的都需要刷新，也就是说用户只要请求后端服务，都需要重新设置`Cookie的过期时间`或者修改`Value`的值。这个相对的就比较蠢了，而且还会有性能问题。\r\n\r\n所以我们项目的目前方案是由**Cookie来保证这个会话的生命周期，并且不进行续签**。\r\n\r\n\r\n# 有没有更好的解决方案\r\n面试官：你们的单点登录方案其实就是依靠JWT设计实现的。但是通过`Cookie`来保证会话的生命周期终究不是个特别好的思路。有没有更好的方案，比如说由后端来控制会话的生命周期？\r\n>[# JSON Web Token - 在Web应用间安全地传递信息](http://blog.leapoahead.com/2015/09/06/understanding-jwt/)\r\n\r\n我：就知道你要问这个。我们可以把系统A 和 系统B 的用户会话信息由服务端控制，进行统一控制。比如使用`Spring-Session`方案，使用同一个 Redis。这样的话用户在系统A登录后，将用户会话信息保存在`Redis`中。然后在打开系统B时，\r\n因为`Cookie`同域，调用 系统B 接口时，上传的是同一个`SessionId`，系统B从`Redis`中判断用户已经登录了，返回登录成功，进行续签。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42fc51cfd91245ac92623bbbeb462657~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n# 多系统一起写相同的代码，有优化空间没\r\n面试官：这样一来，系统A 和 系统B 都会存在很多相同的后端代码，一个改动其他系统也要跟着改。到时候如果有很多个系统，修改成本是不是太大了？\r\n\r\n我：确实是的。所以我们可以把 系统A 和 系统B 的那些代码搞成个服务端的认证中心，这样一来不是方便多了。而且`Cookie`始终有着跨域的问题。按照这个思路，我是不是可以把前端页面也搞成同一个，形成认证中心的前端页面。 \r\n\r\n“等等，这不就是CAS的设计思路嘛”\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebc3b223456c46ab8e2cb11f0554d7e3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n# 面试结束\r\n\r\n面试官：“好小子，领悟力可以呀，有当架构师的潜力，明天就来上班吧。对了，到时候我们再聊聊 CAS 的问题”\r\n\r\n\r\n# 总结\r\n关于单点登录的内容，这一节就暂时到这啦。下一节我们来聊下这节末尾提到的`CAS`以及相似的`Oauth2`。\r\n\r\n\r\n\r\n补充一点：我们在面试的时候，对于技术思路一定要有连贯性，层层挖掘深入，特别是大厂的那些面试官。比如`JVM`类加载的问题，可能流程是这样的：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad3ecda67b74f2a8651470a46aa55e4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我当初就是被这一套组合拳打的满地找牙，还有最好是结合自己做的项目。有些同学可能会觉得没接触过，你可以把这些技术给带入进去，进行自我的模拟面试，只要逻辑清晰，有自己的理解和思考，面试成绩应该都不会太差。\r\n\r\n\r\n如果这篇文章对您有所帮助，可以关注我的公众号《**车辙的编程学习圈**》，也可以在我的博客网站扫码关注 [**我的博客网站**](https://link.juejin.cn/?target=https%3A%2F%2Fchezhe2.gitee.io%2Fstar%2Fblog%2Faboutme.html \\\"https://chezhe2.gitee.io/star/blog/aboutme.html\\\")。\r\n\r\n我是车辙，掘金小册《SkyWalking》作者，一名常被HR调侃为XX杨洋的互联网打工人。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7189458241229848637",
        "snapshot": "",
        "title": "如何更好的编译 React 组件库 /  Node 模块 ？",
        "preview": "本文介绍了 JavaScript 编译工具的作用，并演示使用 Babel 编译源码，使用 transform-runtime 减少产物体积和避免全局污染。最后介绍如何使用 ICE PKG 构建npm包",
        "author": "luhc0228",
        "view_count": 2085,
        "collect_count": 2,
        "comment_count": 1,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/121cc48ac86fb4ae853f204a21107196~300x300.image",
        "category": "前端",
        "content": "很多时候，我们会把一些公共方法或者通用组件库，抽成一个包，并发布到 npm 上，这样其他开发者就可以通过安装 npm 包的方式使用到这些方法或组件库了。\r\n\r\n可是，为什么发这些库之前为什么要使用编译工具先编译？选择什么编译工具编译？怎么样才能减小的编译产物体积？接下来本文将逐一解答。\r\n\r\n# 为什么发包前需要编译源代码？\r\n\r\n当我们编写好我们 Node 模块或 React 组件库后，我们不能直接给其他开发者使用。主要有以下两点原因：\r\n\r\n1. 兼容低版本的运行环境：比如源代码中使用了最新的 ES 语法，但是我们的 Node 模块是在低版本 Node.js 中运行的，这样的话就会报语法错误\r\n2. 不被编译工具编译：比如我们在前端项目中安装了组件库依赖，但是编译工具不去编译 node_modules 中的依赖，仅仅编译项目的源代码，这时候我们在浏览器中运行也是会直接报语法错误的\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82b6dcf995d94416a17f2000d865329a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n因此，为了让我们的库在最终消费的地方能够正常运行，我们在发布之前，最好还是要把我们的源代码编译一下，以兼容低版本的运行环境（你可以指定你的库最低的运行环境版本）。\r\n\r\n# 使用编译工具编译源代码\r\n\r\n目前社区有很多流行的 JavaScript 编译工具，比如 [Babel](https://babeljs.io/)、[SWC](https://swc.rs/) 等等。它们主要会做两个事情：\r\n\r\n**1. 把最新的 ES 语法转换成目标环境支持的语法代码**\r\n\r\n比如我们最熟悉不过的箭头函数，它是 ES2015 引入的新语法，在 ie 11 中是无法运行的，需要编译工具把它降级成普通函数：\r\n \r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6decf284b76456fb314e612a6288d28~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**2. 对目标环境不支持的 api 增加 polyfill**\r\n\r\n有些高级语法，它们并不能仅仅通过语法转换后就可以在目标环境中运行，需要编译工具额外增加 api。比如 `Array.prototype.at` 语法（它是 ES2022 引入的新语法，可以方便我们更简单的拿到数组中的值），它需要先在运行文件开头在 `Array.prototype` 上扩展一个 `at()` 方法，才可以在低版本的运行环境中使用：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a53ae08b85c432d9dd93a20ec1bbe90~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n在上图中，我们可以看到编译产物中通过 `require()` 的方式引用了 `core-js` 导出的 `modules/es.array.at.js` 代码模块，我们把这个代码模块叫做 [polyfill（垫片）](https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill)代码。由于 polyfill 是在运行时（runtime）引入的，一般我们把提供 polyfill 基础库叫**运行时基础库**。目前提供 polyfill 的运行时基础库主要包括：\r\n\r\n- [core-js](https://github.com/zloirock/core-js)：JS 标准库的 polyfill，包含最新的 ES 标准语法和在提案中的语法\r\n- [regenerator-runtime](https://github.com/facebook/regenerator)：包含 `generator` 和 `async` 函数的运行时代码\r\n\r\n## 使用 Babel 编译\r\n\r\nBabel 是一个 JavaScript 编译器，它可以把我们的源代码编译成目标环境支持的语法代码并增加相应的 polyfill。\r\n\r\n### 使用 @babel/core + @babel/preset-env\r\n\r\n假设我们有以下的源代码：\r\n```js\r\n// src/index.js\r\nconst add = async (a, b) => {\r\n  return Promise.resolve({ res: a + b, succuss: true });\r\n};\r\n\r\nadd(1, 2).then((res) => console.log({ ...res }));\r\n```\r\n\r\n我们需要安装一些依赖才能够编译我们的源代码：\r\n\r\n```bash\r\n$ pnpm i @babel/cli @babel/core @babel/preset-env -D\r\n```\r\n每个依赖的作用如下：\r\n\r\n- [`@babel/cli`](https://babeljs.io/docs/en/babel-cli)：Babel 官方推出的脚手架工具，帮助我们在命令行中运行编译\r\n- [`@babel/core`](https://babeljs.io/docs/en/babel-core)：babel 核心的编译库，会注入各种 [helper 方法](https://github.com/babel/babel/tree/main/packages/babel-helpers)到我们的编译产物\r\n- [`@babel/preset-env`](https://babeljs.io/docs/en/babel-preset-env)：会根据目标环境引入对应的 Babel 插件来实现编译和增加 polyfill 代码\r\n\r\n然后我们在项目根目录中新建 `babel.config.json` 文件，并加入以下代码：\r\n\r\n```json\r\n{\r\n  \\\"presets\\\": [\r\n    [\r\n      \\\"@babel/preset-env\\\",\r\n      {\r\n        \\\"targets\\\": {\r\n          \\\"ie\\\": \\\"11\\\",\r\n          \\\"firefox\\\": \\\"60\\\",\r\n          \\\"chrome\\\": \\\"67\\\",\r\n          \\\"safari\\\": \\\"11.1\\\"\r\n        },\r\n        \\\"useBuiltIns\\\": \\\"usage\\\",\r\n        \\\"corejs\\\": \\\"3\\\"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n这里，我们把 `@babel/preset-env` 加入到 `presets` 中。其中每个选项的作用如下：\r\n\r\n- `targets`：指定我们的目标环境，这时会分析源码中使用了哪些高版本语法，然后按需加载对应的 Babel 插件进行编译\r\n- `useBuiltIns`：开启 polyfill 功能。默认值为 `false`，也就是不开启 polyfill；设置为 `entry` 则会根据目标环境引入 polyfill，但是可能会引入很多没有被使用到的 polyfill；设置为 `usage` 会按需引入 polyfill。这里我们使用 `usage` 配置以减少 polyfill 的引入\r\n- `corejs`：指定使用的 core-js 版本，这里我们使用 `3`\r\n\r\n然后我们在终端调用以下命令编译我们的源代码：\r\n\r\n```bash\r\n$ pnpm babel src --out-dir lib\r\n```\r\n \r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696db5a5b4e045ba8dc1861273d02844~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n注意：要让代码正常运行需要安装 `core-js` 依赖并将其加入到库的 package.json 的 dependencies。\r\n\r\n> 注意：`regenerator-runtime` 在 @babel/helpers@^7.18.0 就作为 inline helper 了，不需要显式指定此依赖。详见 [PR](https://github.com/babel/babel/pull/14538)。\r\n\r\n从上图中我们可以看到，我们使用 `@babel/preset-env` 和 `@babel/core` 对高版本语法进行降级和注入 polyfill。但是存在两个问题：\r\n1. 污染全局空间：从编译产物中可以看到，是直接通过 `require()` 的方式引入 `core-js` 的，而 `core-js` 会直接修改全局环境中的变量或者对象原型链，可能会覆盖其他地方定义的内容\r\n2. 文件体积增大：工具函数（helper）直接写在编译产物中（比如 `_objectSpread`），如果有多个文件需要被编译，那么这些工具函数将会重复出现\r\n\r\n### 使用 @babel/plugin-transform-runtime\r\n\r\n[`@babel/plugin-transform-runtime`](https://babeljs.io/docs/en/babel-plugin-transform-runtime) 能够把 helper 方法和 Polyfill 通过模块的形式导入，很好的解决了上面的两个问题。\r\n\r\n使用前先安装一下依赖：\r\n\r\n```shell\r\n$ pnpm i @babel/plugin-transform-runtime -D\r\n```\r\n\r\n然后我们修改我们的 `babel.config.json` 配置文件：\r\n\r\n```diff\r\n{\r\n+ \\\"plugins\\\": [\r\n+   [\r\n+     \\\"@babel/plugin-transform-runtime\\\"\r\n+     { \\\"corejs\\\": 3 }\r\n+   ]\r\n+ ],\r\n  \\\"presets\\\": [\r\n    [\r\n      \\\"@babel/preset-env\\\",\r\n      {\r\n        \\\"targets\\\": {\r\n          \\\"ie\\\": \\\"11\\\",\r\n          \\\"firefox\\\": \\\"60\\\",\r\n          \\\"chrome\\\": \\\"67\\\",\r\n          \\\"safari\\\": \\\"11.1\\\"\r\n        },\r\n-       \\\"useBuiltIns\\\": \\\"usage\\\",\r\n-       \\\"corejs\\\": \\\"3\\\",\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n`@babel/plugin-transform-runtime` 可以帮我们注入 polyfill，因此 `@babel/preset-env` 的 `useBuiltIns` 配置可以去掉，在 `@babel/plugin-transform-runtime` 指定 `corejs` 版本以注入对应的 polyfill。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ca38ae4fee49dc9340b066ddac9550~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看到，`@babel/plugin-transform-runtime` 可以让我们的编译产物使用非全局版本的 polyfill 而是通过模块化导入；另外把工具函数也通过模块的方式导入，大大减小了产物体积。对于开发库的场景来说这种方式会是更好的选择。\r\n\r\n在代码运行之前，我们需要安装 `@babel/runtime-corejs3` 依赖并将其加入到库的 package.json 的 dependencies 里。\r\n\r\n## 使用 ICE PKG 编译\r\n\r\n[ICE PKG](https://pkg.ice.work/) 是一个用于开发 npm 包的工具，支持开发 React 组件、Node 模块、React 类库等。它拥有开箱即用的编译能力，并且使用了 SWC 代替了 Babel 作为底层的编译工具，有着比 Babel 快数十倍的编译速度。\r\n\r\n我们使用上面相同的示例代码，并且在终端执行 `pnpm ice-pkg build` 命令后就可以看到下面的构建产物：\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4119e4a97d5944048df66026db042389~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看到，ICE PKG 默认是使用了与 `@babel/plugin-transform-runtime` 类似的方案，把 helper 方法和 polyfill 通过模块化的方式从 `@swc/helpers` 导入，避免污染全局环境，同时也减小了产物体积。\r\n\r\n与 `transform-runtime` 方案一样，在代码运行之前，我们需要安装 `@swc/helpers` 依赖并将其加入到库的 package.json 的 dependencies 里，这样在库发布以后，才可以正常运行了。\r\n\r\n另外，ICE PKG 默认支持编译出 ES2017 的构建产物，一些常见的 JavaScript 语法特性比如 async/await、generator 等都会被保留，进一步减小产物的体积。在前端项目中使用的时候，结合框架按照 targets 按需进行编译。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a64963accc5045708b70090edc4db2dd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 总结\r\n\r\n本文先是详细介绍了 JavaScript 编译工具的作用，并且演示如何使用 `@babel/preset-env` + `@babel/core` 编译转换源代码并引入对应的 polyfill，但发现全局引入了 polyfill 会直接污染全局环境，helper 方法重复导入会大大增大了产物体积。\r\n\r\n然后介绍使用 `@babel/plugin-transform-runtime` 插件把 helper 方法和 polyfill 使用模块化的方式导入，很好解决了上面遇到的两个问题。\r\n\r\n最后介绍了如何使用 ICE PKG 结合 `@swc/helper` 更简单更快速的开发 npm 包。\r\n\r\n是否有更好的方式编译我们的库源码呢？欢迎大家讨论。"
    },
    {
        "article_id": "7171281973527838751",
        "snapshot": "",
        "title": "【第五届字节跳动青训营 - 寒假专场 Q&A】  🙌🏻 Ask Me Anything！",
        "preview": "青训营的课程有哪些？如何才能参加？考试不过关会有影响吗？ …… 别担心！请收下这篇为你量身定做的「青训营官方答疑」合集！",
        "author": "青训营官方账号",
        "view_count": 29310,
        "collect_count": 83,
        "comment_count": 145,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/de432cd6200bc3d3f7d633a3ccd528d8~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: smartblue\r\n---\r\n\r\n## 青训营早知晓直播预告\r\n\r\n💐 12月9日晚 - 玩转青训营[回放](https://juejin.cn/live/4959559)\r\n\r\n💐 12月23日晚 - 青训营圆桌会[回放](https://juejin.cn/live/679186)\r\n\r\n\r\n## 哈喽～ 欢迎你加入青训营大家庭！\r\n\r\n或许“字节跳动青训营”这几个字是第一次出现在你的眼前，你的小小脑袋还充满着**大大的疑惑**🤔❓\r\n\r\n青训营的课程有哪些？如何才能参加？考试不过关会有影响吗？ ……\r\n\r\n别担心！请收下这篇为你量身定做的**青训营官方答疑**合集！\r\n\r\n## 青训营是什么呀？\r\n\r\n青训营是**字节跳动** **ByteTech** **社区**发起的**技术系列培训 & 人才选拔项目**，面向在校大学生，旨在培养优秀且具有职业竞争力的开发工程师。 我们的课程**全程免费**，不收取任何费用哦～牢记八个凡是，谨防诈骗！\r\n\r\n## 青训营面向什么人群？\r\n\r\n在校大学生~\r\n\r\n## 在青训营可以收获什么？\r\n\r\n-   全面优质技术课程\r\n\r\n<!---->\r\n\r\n-   实用 coding 经验\r\n\r\n<!---->\r\n\r\n-   志同道合的伙伴\r\n\r\n<!---->\r\n\r\n-   浓厚的技术氛围\r\n\r\n<!---->\r\n\r\n-   青训营官方证书 & 徽章\r\n\r\n<!---->\r\n\r\n-   参加青训营的同学在参与招聘的时候还有内推机会哟~ **更有机会通过字节面试**！\r\n\r\n## 青训营的流程是什么呢？\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5e29371eb734c0c8bdd0f4f42f937ae~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\"  width=\\\"70%\\\"/></p>\r\n\r\n## 青训营的活动形式\r\n\r\n全程都是在**线上**参加的哟！\r\n\r\n## 如何报名青训营？怎样才算报名成功呢？如何进入官方群聊？\r\n\r\n[第五届字节跳动青训营 - 寒假专场报名戳这里 🙋](https://juejin.cn/activityregister/7169021915355807782?utm_source=youthcamp-qa)\r\n\r\n前往页面右上角“头像下拉菜单 - 我的报名”，可以看到自己是否报名成功\r\n\r\n-   报名成功的同学也可以从这里点击进去修改报名信息，提交后会有官方群聊入群指引\r\n\r\n<!---->\r\n\r\n-   未报名的同学在这里看到的是青训营的报名活动，直接点击报名即可，提交后会有官方群聊入群指引\r\n\r\n也可以扫码关注「字节跳动青训营」微信公众号，回复“青训营”获取官方群聊入群指引。\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d716fdbea3b4e1493fa391715941b9f~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\"  width=\\\"30%\\\"/></p>\r\n\r\n\r\n## 报名时选择的基础班、进阶班与都可以有什么区别吗？\r\n\r\n✍ 基础班与进阶班的**笔试难度 & 笔试平台不一样**，同学们可以**根据自身情况且仔细思考后**选择相应班级。\r\n\r\n选择了都可以的同学最终将随机分配笔试。\r\n\r\n最终根据笔试成绩分班。\r\n备注：参与进阶班笔试的同学成绩优异更有可能进入最终的进阶班，未进入进阶班的同学有机会进入基础班（成绩非常低无机会）。\r\n\r\n## 笔试具体是1月7号的几点呢\r\n\r\n没有具体的时间，同学们可以在1月7号 00:00:00-23:59:59 自行选择90分钟答题。\r\n\r\n## 报名青训营后到笔试前可以参加哪些活动？\r\n\r\n除了青训营早知晓，伴学青训营主题系列活动也在进行中，快来参加吧~\r\n\r\n [📚 「阅读打卡活动」](https://juejin.cn/post/7174037539345399839)\r\n\r\n抢跑青训营，50天阅读打卡挑战！\r\n \r\n不仅可以学习技术干货，更有掘金抱枕、保温杯等惊喜好礼为你加油打气 💪🏻\r\n\r\n💗 伴学青训营，带你从学校走进职场、从萌新成长为高手~\r\n\r\n## 如何加入进阶班？进阶班与基础班课程有什么不同吗？\r\n<p align=center><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b86f9e500d19488bb187be8be6349a69~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"image.png\\\"  width=\\\"70%\\\"/></p>\r\n\r\n📋 笔试成绩优秀的同学可以加入**青训营进阶班**。基础班和进阶班的**课程内容相同**，但上课形式不同。 \r\n\r\n📌 进阶班笔试没有通过的同学，我们会视笔试情况酌情调剂到基础班，但不是一定能进入基础班。 \r\n\r\n✨ 另外，我们邀请了字节资深工程师作为导师，为进阶班的同学答疑解惑哦～ \r\n\r\n➡ 参与基础班和进阶班笔试都有机会进入进阶班哦！（进阶班笔试难度高，但进入率也高）\r\n\r\n## 第五届青训营的课程表安排是什么？\r\n\r\n1.  关注“字节跳动青训营”微信公众号；\r\n\r\n<!---->\r\n\r\n2.  回复“前端”or“后端”，获取第五届字节跳动青训营对应技术方向的课程表。\r\n\r\n<p align=center><img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad7788336334886a98f16a8003a3799~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\"  width=\\\"30%\\\"/></p>\r\n\r\n## 报名时候填错信息或者想修改班级怎么办？\r\n\r\n报名时要认真填写个人信息，尤其是**手机号 & 邮箱地址**，填写错误将无法接收笔试等通知，所以请仔细检查！**青训营的所有通知均为邮件通知！** 若不小心填错了信息也不要着急，报名截止时间前可前往页面右上角“头像下拉菜单 - 我的报名”进行修改 ，**报名截止后将无法修改**！\r\n\r\n## 笔试在哪里参加？\r\n\r\n❗❗ 笔试与课程都是在**线上**参加的哟！\r\n\r\n报名成功后会在 1月4日 - 1月5日 收到笔试通知的邮件，在1月7日任意时间段完成作答 & 提交即可。\r\n\r\n## 必须参加笔试吗？笔试题目类型有什么？考什么内容？可以用什么语言？\r\n\r\n**笔试必须参加哦！** 只有参加笔试并且通过考核才可以进入青训营学习哈~\r\n\r\n考试题型： 不定项选择题 14 道，编程题 2 道，主观题 1 道\r\n\r\n考察内容：对应技术方向的基础知识 & 少量其他相关计算机知识\r\n\r\n笔试可用编程语言：**go、C、C++、** **Python** **（基础班无）** **JavaScript**、**Java**\r\n\r\n## 青训营的课程有哪些？\r\n\r\n根据每一期的主题，我们的课程都会有一定的调整。具体可以参考[当期青训营](https://juejin.cn/post/7171281874357059592)的详情介绍～\r\n\r\n## 青训营课程有回放吗？\r\n\r\n当天课程结束会有课程回放视频，但建议同学们尽量看直播哦~\r\n\r\n## 课程内容与网上一般教程有什么区别吗？\r\n\r\n本届字节跳动青训营活动由**字节跳动** **ByteTech** **社区**倾力主办，召集了来自字节各大资深**技术团队技术大咖**及**一线优秀工程师**作为讲师哦！课程学习路线也是讲师们精心设计的。跟着我们的节奏，你将收获科学、系统、全面且优质的课程！\r\n\r\n### 如果仍有困惑，请在**评论区留言**，青训营小助手会及时为你解答哦～\r\n"
    },
    {
        "article_id": "7157681502506090510",
        "snapshot": "",
        "title": "只需百来行代码，为你的Web页面增加本地文件操作能力，确定不试试吗？",
        "preview": "笔者开源了一个Web思维导图，数据默认是存储在localstorage里，如果想保存到本地文件，需要使用导出功能，下次打开再使用导入功能，编辑完如果又想保存到文件，那么又需要从重新导出覆盖原来的文件",
        "author": "街角小林",
        "view_count": 5084,
        "collect_count": 86,
        "comment_count": 9,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/894ec075c1d445a53e71bf0796debe8a~300x300.image",
        "category": "前端",
        "content": "笔者开源了一个`Web`思维导图[mind-map](https://github.com/wanglin2/mind-map)，数据默认是存储在`localstorage`里，如果想保存到本地文件，需要使用导出功能，下次打开再使用导入功能，编辑完如果又想保存到文件，那么又需要从重新导出覆盖原来的文件，不得不说，可以但不优雅，所以最近增加了直接编辑本地文件的能力，体验了一下，还是不错的，并且就是调调`API`的事情，很简单，何乐而不为。\r\n\r\n主角就是[showOpenFilePicker](https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker)和[showSaveFilePicker](https://developer.mozilla.org/en-US/docs/Web/API/Window/showSaveFilePicker)两个`API`，笔者基于它俩开发了三个功能：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae962aaa8ce427eb8539bce66b1f058~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n`新建`和`另存为`其实一样的，只不过一个保存的是空数据，一个是当前的数据，当创建或打开文件成功后，操作的时候数据会直接保存到本地文件里，不再需要进行手动的导出，这种体验其实就和本地编辑器没什么区别了。\r\n\r\n# 打开\r\n\r\n先来看看打开文件，调用的是`showSaveFilePicker`方法，返回一个`Promise`，选择文件成功了那么`Promise`的结果是一个数组，每一项代表一个文件的操作句柄：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a82496d1c4d43be83200721c386e4cb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n如果要获取某个文件的内容或写入某个文件就需要通过这些文件句柄对象。如果没有选择或选择失败了`Promise`则会出错：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a02a85fd184a63ac1fee5012580070~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n这个方法接收一个选项对象作为参数：\r\n\r\n- `options.multiple`\r\n\r\n布尔值，设置是否可以选择多个文件。\r\n\r\n- `options.types`\r\n\r\n一个数组，设置允许被选择的文件类型，数组每一项都是一个对象：\r\n\r\n```js\r\n{\r\n\\tdescription: '',\r\n\\taccept: {\r\n\\t\\t'': []\r\n\\t}\r\n}\r\n```\r\n\r\n`description`用于说明，好像没什么用，`accept`是个对象，`key`为[MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)，`value`为一个数组，代表允许的文件扩展名。\r\n\r\n如果`MIME type`设置的很具体，比如`application/json`，那么`value`不传的话只能选择文件后缀为`.json`的文件，如果`value`设置了扩展名的话，则在默认的`.json`文件外还允许选择设置的扩展名的文件，比如设置为`['.smm']`，那么`.json`和`.smm`为后缀的文件都可以选择：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833a8cafb7184e7fbff79dda4f0a4925~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n如果`MIME type`设置的比较宽泛的话，比如`application/*`，那么所有``MIME type``为`application`类型的文件都可以选择，就算`value`只设置了一个`.json`，其他类型的文件也是可以选择的，所以`value`的作用不是限制，而是扩充。\r\n\r\n但是呢，这种限制可以轻松突破，只要点击扩展名打开下拉列表选择所有文件选项，那么还是想选什么文件就选什么文件，有朋友知道怎么解决的欢迎评论区留言。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/affac5fbd0d14f09922315c27839fd45~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n- `options.excludeAcceptAllOption`\r\n\r\n布尔值，默认为`false`，即允许不配置`types`选项，支持选择所有文件，如果设为`true`，那么`types`选项不能为空，必须要限制一种文件类型。\r\n\r\n笔者的思维导图文件格式使用的是`.json`，并且吃饱了撑的自己定义了一个格式`.smm`，其实就是`json`，并且同一时间只能编辑一个文件，那么打开文件的代码如下所示：\r\n\r\n```js\r\nlet fileHandle = null\r\nasync openLocalFile() {\r\n    try {\r\n        let [ _fileHandle ] = await window.showOpenFilePicker({\r\n            types: [\r\n                {\r\n                    description: '',\r\n                    accept: {\r\n                        'application/json': ['.smm']\r\n                    }\r\n                },\r\n            ],\r\n            excludeAcceptAllOption: true,\r\n            multiple: false\r\n        });\r\n        if (!_fileHandle) {\r\n            return\r\n        }\r\n        fileHandle = _fileHandle\r\n        if (fileHandle.kind === 'directory') {\r\n            this.$message.warning('请选择文件')\r\n            return\r\n        }\r\n        this.readFile()\r\n    } catch (error) {\r\n        if (error.toString().includes('aborted')) {\r\n            return\r\n        }\r\n        this.$message.warning('你的浏览器可能不支持哦')\r\n    }\r\n}\r\n```\r\n\r\n将文件句柄保存起来，接下来都会基于它来操作文件，先来看看文件句柄对象，它存在两个方法：\r\n\r\n- `getFile()`\r\n\r\n返回一个`Promise`，获取该句柄所对应的文件对象，其实就是我们常见的`File`对象：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ee189ead339424b9f3a226ed589c25c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n- `createWritable()`\r\n\r\n返回也是一个`Promise`，创建一个可以写入文件的文件流对象：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13285ccdaf2446149ac3c1a74f552d33~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n基于这两个方法我们就可以读取打开文件的内容及把新内容写入文件：\r\n\r\n```js\r\n// 读取文件\r\nasync readFile() {\r\n    let file = await fileHandle.getFile();\r\n    let fileReader = new FileReader();\r\n    fileReader.onload = async () => {\r\n        // fileReader.result\r\n    }\r\n    fileReader.readAsText(file);\r\n}\r\n\r\n// 写入文件\r\nasync writeLocalFile(content) {\r\n    if (!fileHandle) {\r\n        return;\r\n    }\r\n    let string = JSON.stringify(content);\r\n    const writable = await fileHandle.createWritable();\r\n    await writable.write(string);\r\n    await writable.close();\r\n}\r\n```\r\n\r\n页面内第一次调用`createWritable`方法浏览器会弹个窗询问用户是否允许：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cb9586440da41078a9a769a87049b14~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n每调用一次`createWritable`方法都会在你的本地创建一个`.crswap`文件：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3720751daa345c0b62c693bcd550118~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n相当于一个临时文件，没有调用写入流`writable`的`close`方法前，调用它的`write`方法写入的内容默认都保存在这个文件，只有调用`close`以后才会更新到源文件，并且自动删除这个临时文件，另外页面关闭，也会删除这些文件。\r\n\r\n写入流默认是空的，每调用一次`write`方法，都会在`.crswap`中追加内容，但是可以指定写入的位置：\r\n\r\n```js\r\nawait writable.write({ type: \\\"write\\\", position: 0, data: string });\r\n```\r\n\r\n这样会从指定的字节数开始写入，注意是替换，而不是插入。\r\n\r\n所以为了方便起见，最好还是创建、写入就关闭，再写再创建。\r\n\r\n# 新建\r\n\r\n新建调用的是`showSaveFilePicker`方法，也接收一个选项对象为参数，有两个选项和`showOpenFilePicker`方法是一样的，即`types`和`excludeAcceptAllOption`，之外还有一个选项：\r\n\r\n- `suggestedName`\r\n\r\n默认填充的文件名称，为空则创建文件时输入框就是空的。\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346687a34f6945b5b1dae6e778dd92dd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62abb407f9d64ab6963050fca3d95c26~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n可以直接输入文件名创建新文件，也可以点击已经存在的文件进行替换。\r\n\r\n创建成功返回的也是一个文件句柄，那么创建文件就很简单了：\r\n\r\n```js\r\nasync createLocalFile(content) {\r\n    try {\r\n        let _fileHandle = await window.showSaveFilePicker({\r\n            types: [{\r\n                description: '',\r\n                accept: {'application/json': ['.smm']},\r\n            }],\r\n            suggestedName: '思维导图'\r\n        });\r\n        if (!_fileHandle) {\r\n            return;\r\n        }\r\n        const loading = this.$loading({\r\n            lock: true,\r\n            text: '正在创建文件',\r\n            spinner: 'el-icon-loading',\r\n            background: 'rgba(0, 0, 0, 0.7)'\r\n        });\r\n        fileHandle = _fileHandle;\r\n        await this.writeLocalFile(content);\r\n        await this.readFile();\r\n        loading.close();\r\n    } catch (error) {\r\n        if (error.toString().includes('aborted')) {\r\n            return\r\n        }\r\n        this.$message.warning('你的浏览器可能不支持哦');\r\n    }\r\n}\r\n```\r\n\r\n来看看实际效果：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5b917eb1d84ea18dd3618ec247bcb8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n# 总结\r\n\r\n最后再来看看兼容性：\r\n\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ccc561eda14ae0a6f40d3e7284c30b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n因为目前还是实验性质，所以可以看到是一片红，但是因为我的本身也只是一个示例项目，所以问题不大，有胜于无。\r\n\r\n另外这个特性目前也只能在`HTTPS`协议或`localhost`下才可用，其他情况下`window`对象是不存在这两个`API`的，所以需要做好错误处理。"
    },
    {
        "article_id": "7183999735236132925",
        "snapshot": "",
        "title": "30分钟入门NestJS，带你掌握大前端全栈开发。",
        "preview": "NestJS介绍 NestJS 是一个基于 TypeScript 的服务器端应用程序框架。 它提供了一组丰富的工具和模块来帮助开发人员构建高效、可扩展的服务器端应用程序。",
        "author": "右子",
        "view_count": 12029,
        "collect_count": 14,
        "comment_count": 5,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/d7a63971e933dc990b72d071b81a6dd3~300x300.image",
        "category": "前端",
        "content": "# NestJS介绍\r\n`NestJS` 是一个基于 TypeScript 的服务器端应用程序框架。<br />\r\n它提供了一组丰富的工具和模块来帮助开发人员构建高效、可扩展的服务器端应用程序。\r\n\r\n`NestJS` 的核心思想是使用模块化的方法来构建应用程序。<br />\r\n应用程序可以由多个模块组成，每个模块都可以包含控制器、服务、管道、拦截器和其他类型的元素。<br />\r\n这些元素可以通过依赖注入系统自动注册，并可以在整个应用程序中共享。\r\n\r\n`NestJS` 还提供了一组丰富的工具和模块，可用于构建各种类型的服务器端应用程序，包括 RESTful API、GraphQL API、WebSocket 服务器等。<br />\r\n它还提供了对主流数据库和身份验证系统的集成，可以帮助开发人员快速构建应用程序。\r\n\r\n总的来说，`NestJS` 是一个功能丰富、易于使用的服务器端应用程序框架，可帮助开发人员快速构建高效、可扩展的服务器端应用程序。\r\n\r\n# NestJS的优势\r\n`NestJS` 是一个基于 TypeScript 的服务器端应用程序框架。<br />\r\n它提供了一组丰富的工具和模块来帮助开发人员构建高效、可扩展的服务器端应用程序。\r\n\r\n`NestJS` 的一些优势包括：\r\n-   构建在现代 JavaScript 栈之上，因此使用了最新的 JavaScript 技术。\r\n-   基于 Angular 的架构和语法，提供了强大的模块化系统和依赖注入功能。\r\n-   基于 TypeScript，提供了强类型和静态类型检查。\r\n-   提供了丰富的工具和模块，可用于构建各种类型的服务器端应用程序，包括 RESTful API、GraphQL API、WebSocket 服务器等。\r\n-   提供了一组可扩展的构建块，可用于快速构建应用程序。\r\n-   提供了与主流数据库和身份验证系统的集成。\r\n\r\n# NestJS的目录结构说明\r\n|名称|路径|描述|\r\n|:-------:|:----------|:----------|\r\n|dist[目录]|dist/|编译后的目录，用于预览项目|\r\n|node_modules[目录]|node_modules/|项目使用的包目录，开发使用和上线使用的都在里边|\r\n|src[目录]|src/|源文件/代码，程序员主要编写的目录|\r\n||src/app.controller.spec.ts|对于基本控制器的单元测试样例|\r\n||src/app.controller.ts|控制器文件，可以简单理解为路由文件|\r\n||src/app.module.ts|模块文件，在NestJS世界里主要操作的就是模块|\r\n||src/app.service.ts|服务文件，提供的服务文件，业务逻辑编写在这里|\r\n||src/app.main.ts|项目的入口文件，里边包括项目的主模块和监听端口号|\r\n|test[目录]|test/|测试文件目录，对项目测试时使用的目录|\r\n||test/app.e2e-spec.ts|e2e测试，端对端测试文件，测试流程和功能使用|\r\n||test/jest-e2e.json||jest测试文件，jset是一款简介的JavaScript测试框架|\r\n|.eslintrc.js|./|ESlint的配置文件|\r\n|.gitignore|./|git的配置文件，用于控制哪些文件不受Git管理|\r\n|.prettierrc|./|prettier配置文件，用于美化/格式化代码的|\r\n|nest-cli.json|./|整个项目的配置文件，这个需要根据项目进行不同的配置|\r\n|package-lock.json|./|防止由于包不同，导致项目无法启动的配置文件，固定包版本|\r\n|package.json|./|项目依赖包管理文件和Script文件，比如如何启动项目的命令|\r\n|README.md|./|对项目的描述文件，markdown语法|\r\n|tsconfig.build.json|./|TypeScript语法构建时的配置文件|\r\n|tsconfig.json|./|TypeScript的配置文件，控制TypeScript编译器的一些行为|\r\n\r\n# NestJS的约束\r\n\r\n## 解释\r\n+ [filename]指在使用框架时创建的模块名称，NestJS允许命令行创建 `nest g controller article --no-spec`。\r\n\r\n\r\n## 框架的文件约束\r\n+ 每个模块最少有三种文件组合：module、server、controller。\r\n\r\n### [filename].controller.ts 文件\r\n[filename].controller.ts 文件定义了控制器。控制器是一种特殊的组件，它负责处理 HTTP 请求并返回响应。\r\n在控制器中，你可以使用 @Controller 装饰器来声明控制器，并指定一个路径前缀。例如：\r\n```js\r\n@Controller('/users')\r\nexport class UsersController {\r\n  // ...\r\n};\r\n```\r\n在这里，UsersController 控制器的路径前缀是 '/users'。这意味着所有在 UsersController 中定义的路由都将以 '/users' 为前缀。\r\n\r\n在控制器中，你可以使用 @Get、@Post、@Put 等装饰器来声明路由处理程序。<br />\r\n例如：\r\n```js\r\n@Get('/')\r\nfindAll(): string {\r\n  return 'This action returns all users';\r\n}\r\n\r\n@Get('/:id')\r\nfindOne(@Param('id') id: string): string {\r\n  return `This action returns a #${id} user`;\r\n}\r\n```\r\n在这里，findAll 和 findOne 函数分别声明了两个路由处理程序。<br />\r\nfindAll 函数处理的是 GET 请求 '/users'，findOne 函数处理的是 GET 请求 '/users/:id'。\r\n\r\n总的来说，`controller.ts` 文件用于定义控制器，控制器负责处理 HTTP 请求并返回响应。\r\n\r\n### [filename].module.ts 文件\r\n[filename].module.ts 文件定义了一个模块，该模块是用于组织应用程序中的许多功能的。模块可以包含控制器、服务和其他模块，以及与其他模块一起使用的公共组件。\r\n\r\n在模块中，你可以使用@Module装饰器来声明模块，并指定该模块中应包含哪些元素。<br />\r\n例如：\r\n```js\r\n@Module({\r\n  controllers: [AppController],\r\n  providers: [AppService],\r\n  imports: [AnotherModule]\r\n});\r\nexport class AppModule {};\r\n```\r\n在这里，AppModule 模块包含 AppController 控制器、AppService 服务和 AnotherModule 模块。<br />控制器和服务将被注册到该模块，并可以在模块中使用。<br />\r\nAnotherModule 会被导入到 AppModule 中，并可以在 AppModule 中使用它所提供的功能。\r\n\r\n### [filename].server.ts 文件\r\n[filename].server.ts 文件定义了服务。<br />\r\n服务是一种特殊的组件，它负责封装与业务逻辑相关的代码。\r\n\r\n你可以使用 @Injectable 装饰器来声明服务，并使用 @Inject 装饰器来注入其他服务或依赖。<br />\r\n例如：\r\n```js\r\n@Injectable();\r\nexport class UsersService {\r\n  private readonly users: User[] = [];\r\n\r\n  constructor(@Inject(CACHE_MANAGER) private cacheManager: CacheManager) {}\r\n\r\n  findAll(): User[] {\r\n    return this.users;\r\n  }\r\n\r\n  create(user: User) {\r\n    this.users.push(user);\r\n  }\r\n};\r\n```\r\n在这里，UsersService 服务使用 @Injectable 装饰器声明，并使用 @Inject 装饰器注入了一个名为 CACHE_MANAGER 的依赖。<br />\r\nUsersService 中的 findAll 和 create 函数分别实现了查找所有用户和创建新用户的功能。<br />\r\n[filename].service.ts 文件用于定义服务，服务负责封装与业务逻辑相关的代码。\r\n\r\n# 路由的控制\r\n## RESTful API\r\nRESTful API 是一种常用的 API 设计风格，它遵循 REST（Representational State Transfer）设计原则。在 Nest.js 中，你可以使用以下方法来实现 RESTful API：\r\n\r\n-   HTTP GET 请求：用于查询资源。例如：'/users' 用于查询所有用户。\r\n-   HTTP POST 请求：用于创建新资源。例如：'/users' 用于创建新用户。\r\n-   HTTP PUT 请求：用于更新已有资源。例如：'/users/1' 用于更新 id 为 1 的用户。\r\n-   HTTP DELETE 请求：用于删除已有资源。例如：'/users/1' 用于删除 id 为 1 的用户。\r\n\r\n在 Nest.js 中，你可以使用 @Get、@Post、@Put、@Delete 等装饰器来声明路由处理程序，并使用 app.route().get()、app.route().post() 等方法来实现 RESTful API。<br />\r\n例如：\r\n```js\r\nimport { Controller, Get, Post, Put, Delete } from '@nestjs/common';\r\n\r\n@Controller('/users')\r\nexport class UsersController {\r\n  @Get()\r\n  findAll(): string {\r\n    return 'This action returns all users';\r\n  }\r\n\r\n  @Get(':id')\r\n  findOne(@Param('id') id: string): string {\r\n    return `This action returns a #${id} user`;\r\n  }\r\n\r\n  @Post()\r\n  create(): string {\r\n    return 'This action addsa new user'; \r\n  }\r\n\r\n  @Put(':id') \r\n  update(@Param('id') id: string): string { \r\n    return `This action updates a #${id} user`; \r\n  }\r\n\r\n  @Delete(':id') remove(@Param('id') id: string): string { \r\n    return `This action removes a #${id} user`; } \r\n  }\r\n}\r\n```\r\nUsersController 控制器使用 @Get、@Post、@Put、@Delete 装饰器声明了若干个路由处理程序。<br />\r\n分别对应了 HTTP GET、POST、PUT 和 DELETE 请求。<br />\r\n你也可以使用 app.route().get()、app.route().post() 等方法来实现 RESTful API。 <br />\r\n在 `NestJS` 中，你可以使用 @Get、@Post、@Put、@Delete 装饰器或 app.route().get()、app.route().post() 等方法来实现 RESTful API。\r\n\r\n## 如何在NestJS中如何增加一个顶层路由？\r\n你可以使用 @Controller 装饰器来声明控制器，并指定一个路径前缀。<br />\r\n这个路径前缀就是你要增加的顶层路由。\r\n\r\n例如，假设你想在应用程序中增加一个名为 `'/api'` 的顶层路由。<br />\r\n你可以在 controller.ts 文件中声明一个 UsersController 控制器，并指定 '/api' 为路径前缀：\r\n```js\r\n@Controller('/api')\r\nexport class UsersController {\r\n  // ...\r\n}\r\n```\r\n在这里，UsersController 控制器的路径前缀是 `'/api'`。<br />\r\n这意味着所有在 UsersController 中定义的路由都将以 `'/api'` 为前缀。<br />\r\n例如，如果你在 UsersController 中定义了一个名为 `'/'` 的路由处理程序，那么实际上处理的路由就是 `'/api'`。\r\n\r\n除了使用 @Controller 装饰器声明控制器之外，你还可以使用 app.route() 方法来增加顶层路由。<br />\r\n例如：\r\n```js\r\nimport { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from './app.module';\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  app.route('/api').get((req, res) => res.send('Hello World!'));\r\n  await app.listen(3000);\r\n}\r\nbootstrap();\r\n```\r\n这段代码会为 `'/api'` 路由增加一个路由处理程序，处理来自 GET 请求的请求并返回 \\\"Hello World!\\\"。\r\n```js\r\napp.route('/api').get((req, res) => res.send('Hello World!'));\r\n```\r\n你也可以使用 app.route().post() 等方法来为路由增加处理其他 HTTP 方法的路由处理程序。<br />\r\n例如：\r\n```js\r\napp.route('/api').post((req, res) => res.send('POST request received'));\r\n```\r\n\r\n这段代码会为 `'/api'` 路由增加一个路由处理程序，处理来自 POST 请求的请求并返回 \\\"POST request received\\\"。\r\n\r\n你可以使用 @Controller 装饰器声明控制器或使用 app.route() 方法来增加顶层路由。<br />\r\n一旦增加了路由，你就可以使用 app.route().get()、app.route().post() 等方法来为路由增加路由处理程序。\r\n\r\n# 数据库操作\r\n## GraphQL API\r\nGraphQL API 是一种常用的 API 设计风格，它允许客户端自定义要查询的数据，而服务器端则根据客户端的查询来返回数据。<br />\r\n在 `NestJS` 中，你可以使用以下方法来实现 GraphQL API：\r\n\r\n-   GraphQL 请求：使用 GraphQL 语言描述要查询的数据。例如：`query { users { name } }` 用于查询所有用户的名字。\r\n-   GraphQL 查询：使用 @Query 装饰器声明查询处理程序。例如：\r\n```js\r\n@Query(() => [User])\r\nusers(): User[] {\r\n  return this.usersService.findAll();\r\n}\r\n```\r\n在这里，users 查询处理程序使用 @Query 装饰器声明，并返回所有用户的信息。\r\n\r\n-   GraphQL 变更：使用 @Mutation 装饰器声明变更处理程序。例如：\r\n```js\r\n@Mutation(() => User)\r\ncreateUser(@Args('createUserInput') args: CreateUserInput): User {\r\n  return this.usersService.create(args);\r\n}\r\n```\r\n在这里，createUser 变更处理程序使用 @Mutation 装饰器声明，并创建新用户。\r\n\r\n总的来说，在 Nest.js 中，你可以使用 GraphQL 请求、@Query 装饰器声明的查询处理程序和 @Mutation 装饰器声明的变更处理程序来实现 GraphQL API。\r\n\r\n你还可以使用 GraphQL 语言定义数据类型，并使用 @ObjectType 装饰器声明数据类型。<br />\r\n例如：\r\n```js\r\n@ObjectType()\r\nexport class User {\r\n  @Field()\r\n  id: string;\r\n\r\n  @Field()\r\n  name: string;\r\n\r\n  @Field()\r\n  email: string;\r\n}\r\n```\r\n在这里，User 类型使用 @ObjectType 装饰器声明，并使用 @Field 装饰器声明 id、name 和 email 字段。\r\n\r\n你还可以使用 @InputType 装饰器声明输入类型，用于传递变更处理程序的参数。例如：\r\n\r\n```js\r\n@InputType()\r\nexport class CreateUserInput {\r\n  @Field()\r\n  name: string;\r\n\r\n  @Field()\r\n  email: string;\r\n}\r\n```\r\n在这里，CreateUserInput 输入类型使用 @InputType 装饰器声明，并使用 @Field 装饰器声明 name 和 email 字段。\r\n\r\n你还可以使用 @FieldResolver 装饰器声明字段解析器，用于提供动态计算字段的值。例如：\r\n```js\r\n@FieldResolver()\r\nfullName(@Root() user: User): string {\r\n  return `${user.firstName} ${user.lastName}`;\r\n}\r\n```\r\n在这里，fullName 字段解析器使用 @FieldResolver 装饰器声明，并根据 user 对象的 firstName 和 lastName 字段动态计算出完整的名字。\r\n\r\n总的来说，在 Nest.js 中，你可以使用 GraphQL 请求、@Query 装饰器声明的查询处理程序、@Mutation 装饰器声明的变更处理程序、@ObjectType 装饰器声明的数据类型、@InputType 装饰器声明的输入类型和 @FieldResolver 装饰器声明的字段解析器来实现 GraphQL API。\r\n\r\n需要注意的是，你需要在模块中配置 GraphQL API，并使用 GraphQL 模块提供的方法注册数据类型、查询处理程序、变更处理程序和字段解析器。例如：\r\n```js\r\n@Module({\r\n  imports: [GraphQLModule.forRoot({\r\n    typePaths: ['./**/*.graphql'],\r\n    resolvers: {\r\n      User: {\r\n        fullName: (user: User) => `${user.firstName} ${user.lastName}`,\r\n      },\r\n    },\r\n  })],\r\n})\r\nexport class AppModule {}\r\n```\r\n在这里，GraphQLModule.forRoot() 方法用于配置 GraphQL API，并使用 typePaths 参数指定 GraphQL 语言文件的路径，使用 resolvers 参数注册字段解析器。\r\n\r\n你还可以使用 @Module 装饰器声明模块，并在模块中使用 GraphQLModule.forFeature() 方法注册数据类型、查询处理程序和变更处理程序。\r\n```js\r\n@Module({\r\n  imports: [GraphQLModule.forFeature([UsersResolver])],\r\n})\r\nexport class UsersModule {};\r\n```\r\n在这里，UsersModule 模块使用 GraphQLModule.forFeature() 方法注册 UsersResolver 查询处理程序和变更处理程序。\r\n\r\n总的来说，在 Nest.js 中，你可以使用 GraphQLModule.forRoot() 方法配置 GraphQL API，并使用 GraphQLModule.forFeature() 方法在模块中注册数据类型、查询处理程序和变更处理程序，来实现 GraphQL API。\r\n\r\n在 Nest.js 中，你还可以使用 GraphQL 模块提供的 GraphQLFactory 类来创建 GraphQL 服务器。\r\n```js\r\nconst app = await NestFactory.create(AppModule);\r\nconst graphQLFactory = app.get(GraphQLFactory);\r\nconst schema = await graphQLFactory.createSchema();\r\n\r\napp.use('/graphql', graphqlHTTP({ schema }));\r\n```\r\n在这里，GraphQLFactory 类的 createSchema() 方法用于创建 GraphQL 模式，然后使用 app.use() 方法在应用中注册 GraphQL 路由。\r\n\r\n总的来说，在 `NestJS` 中，你可以使用 GraphQLModule 模块、GraphQL 语言、@Query、@Mutation、@ObjectType、@InputType 和 @FieldResolver 装饰器以及 GraphQLFactory 类来实现 GraphQL API。\r\n\r\n需要注意的是，你需要在 Nest.js 应用的根模块中配置 GraphQLModule 模块，并在模块中注册数据类型、查询处理程序、变更处理程序和字段解析器。<br />\r\n你还可以在模块中使用 GraphQLFactory 类来创建 GraphQL 服务器，并使用 app.use() 方法在应用中注册 GraphQL 路由。\r\n\r\n你还可以使用 GraphQL 语言定义数据类型和查询处理程序、变更处理程序和字段解析器。\r\n```js\r\ntype Query {\r\n  users: [User]\r\n}\r\n\r\ntype Mutation {\r\n  createUser(name: String, email: String): User\r\n}\r\n\r\ntype User {\r\n  id: ID!\r\n  name: String!\r\n  email: String!\r\n  fullName: String\r\n}\r\n\r\ntype User {\r\n  id: ID!\r\n  firstName: String!\r\n  lastName: String!\r\n  fullName: String\r\n}\r\n\r\ntype Query {\r\n  user(id: ID!): User\r\n}\r\n\r\ntype Mutation {\r\n  updateUser(id: ID!, name: String, email: String): User\r\n  deleteUser(id: ID!): User\r\n}\r\n```\r\n在这里，我们定义了 Query 和 Mutation 数据类型，分别用于查询处理程序和变更处理程序。<br />\r\n我们还定义了 User 数据类型，并使用 @ObjectType 装饰器声明。\r\n\r\n在 Nest.js 中，你可以使用 GraphQLModule 模块、GraphQL 语言、@Query、@Mutation、@ObjectType、@InputType 和 @FieldResolver 装饰器以及 GraphQLFactory 类来实现 GraphQL API。<br />\r\n你需要在应用的根模块中配置 GraphQLModule 模块，并在模块中注册数据类型、查询处理程序、变更处理程序和字段解析器。你还可以使用 GraphQL 语言定义数据类型和处理程序，并使用 @ObjectType 装饰器声明数据类型。\r\n\r\n需要注意的是，在使用 GraphQL API 时，你需要注意数据类型、查询处理程序和变更处理程序之间的关系，以及数据类型的字段、输入类型和字段解析器之间的关系。<br />\r\n你还需要注意 GraphQL 请求的格式和参数，以及 GraphQL 响应的格式和内容。\r\n\r\n在 `NestJS` 中使用 GraphQL API 需要注意数据类型、处理程序、字段、输入类型和字段解析器之间的关系，以及 GraphQL 请求和响应的格式和参数。\r\n\r\n# 总结\r\n`NestJS` 是一个基于TypeScript的后端框架，它自身有很多的优势。\r\n\r\n+ 基于模块化设计，使代码更加组织清晰。\r\n+ 基于TypeScript，具有强类型检查和类型安全。\r\n+ 可以使用装饰器来定义控制器和服务，使代码更加简洁。\r\n+ 应用程序调试更容易。\r\n+ 拥有良好的文档和社区支持。\r\n\r\n# 学习文档\r\n[Nest官网](https://nestjs.com/)"
    },
    {
        "article_id": "7187985723545354299",
        "snapshot": "",
        "title": "「码上掘金迎新年」编程比赛结果公示",
        "preview": "「码上掘金迎新年」编程比赛历时一个月已经落下帷幕，在此期间我们经历了一个特别的时期，但是依然收到了 100 多个优秀的参赛作品，感谢各位掘友们的参与和支持！",
        "author": "码上掘金小助手",
        "view_count": 1997,
        "collect_count": 2,
        "comment_count": 7,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e5acdc5b709e7446195a9abd0cd62fd0~300x300.image",
        "category": "代码人生",
        "content": "--- \r\ntheme: cyanosis \r\n---\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe26e300ad654143b3bff43e639e89f7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n「码上掘金迎新年」编程比赛历时一个月已经落下帷幕，在此期间我们经历了一个特别的时期，但是依然收到了 100 多个优秀的参赛作品，感谢各位掘友们的参与和支持！\r\n\r\n## 大赛结果公示\r\n\r\n### 🎯 评审说明\r\n\r\n**参赛作品的评审方式为：初评 + 终评。**\r\n\r\n前期由大赛初评评审团对所有参赛作品进行初评，最后由大赛专家评审团对所有入选作品进行打分。\r\n\r\n最终前端场与后端场分别评选出一等奖 1 名、二等奖 2 名、三等奖 3 名、最佳技术奖｜最佳人气奖｜最佳创意奖 各 1 名、入围奖 16 名。**（同一场比赛的同一用户或同一作品不重复获奖）**\r\n\r\n为保证大赛的公正性，现将获奖结果进行公示。自公示之日起至 2023 年 1 月 15 日 12:00，在此期间如有异议，请向大赛官方提出。[点此填写举报问卷](https://wenjuan.feishu.cn/m?t=sgjevdafWWHi-vybu)，也可扫描下方二维码：\r\n\r\n\r\n<p align=left><img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b132b5a4d34f0599fbb6165b84e1ac~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"举报问卷.png\\\" width=180 /></p>\r\n\r\n### 🏆 获奖结果\r\n\r\n[🕹️「码上掘金迎新年」前端场比赛结果](https://juejin.cn/challenge/2/result)\r\n\r\n[🕹️「码上掘金迎新年」后端场比赛结果](https://juejin.cn/challenge/3/result)\r\n\r\n### 🖼️ 获奖作品展示\r\n\r\n<h4 align=center>前端场获奖作品</h4>\r\n\r\n* * *\r\n\r\n**🥇 一等奖**\r\n\r\n> [wangpeng1478](https://juejin.cn/user/2875978146910600) ｜ AR面部特效(新年特效)\r\n\r\n[jcode](https://code.juejin.cn/pen/7175016747785781308)\r\n\r\n</br>\r\n\r\n**🥈 二等奖**\r\n\r\n> [茶无味的一天](https://juejin.cn/user/2682464103060541) ｜ 2022年终总结互动网页\r\n\r\n[jcode](https://code.juejin.cn/pen/7178839138609659959)\r\n\r\n</br>\r\n\r\n\r\n> [Guowc](https://juejin.cn/user/1732486057965181) ｜ 2022像素掘金之旅\r\n\r\n[jcode](https://code.juejin.cn/pen/7184441180183068672)\r\n\r\n</br>\r\n\r\n**🥉 三等奖**\r\n\r\n> [Defineee](https://juejin.cn/user/2366569662134766) ｜ 云烟花\r\n\r\n[jcode](https://code.juejin.cn/pen/7182787862117482554)\r\n\r\n</br>\r\n\r\n> [叶一一](https://juejin.cn/user/70822370479901) ｜ 手绘新年贺卡之人间皆安\r\n\r\n[jcode](https://code.juejin.cn/pen/7180695387710652431)\r\n\r\n</br>\r\n\r\n> [皮卡丘丘](https://juejin.cn/user/2881155874164855) ｜ 掘金年度报告\r\n\r\n[jcode](https://code.juejin.cn/pen/7178006805040070708)\r\n\r\n</br>\r\n\r\n**💎 最佳技术奖**\r\n\r\n> [大帅老猿](https://juejin.cn/user/2955079655898093) ｜ 2022年度报告3D掘金\\\"社区\\\"\r\n\r\n[jcode](https://code.juejin.cn/pen/7158235994448199717)\r\n\r\n</br>\r\n\r\n**💎 最佳人气奖**\r\n\r\n> [一骑绝尘蛙](https://juejin.cn/user/3509296848192216) ｜ 辞旧迎新\r\n\r\n[jcode](https://code.juejin.cn/pen/7175082253179944992)\r\n\r\n</br>\r\n\r\n**💎 最佳创意奖**\r\n\r\n> [NOTF_API](https://juejin.cn/user/84011408440797) ｜ 送你一部手机\r\n\r\n[jcode](https://code.juejin.cn/pen/7182783217223598095)\r\n\r\n**[👏 更多获奖作品请移步大赛官网查看](https://juejin.cn/challenge/2/result)**\r\n\r\n<h4 align=center>后端场获奖作品</h4>\r\n\r\n***\r\n\r\n**🥇 一等奖**\r\n\r\n> [小草莓子桑](https://juejin.cn/user/1292681406592846) ｜ FastValidate\r\n\r\n[jcode](https://code.juejin.cn/pen/7182876908298698789)\r\n\r\n</br>\r\n\r\n**🥈 二等奖**\r\n\r\n> [K8sCat ](https://juejin.cn/user/588993963244430)｜ Gigrator Git代码仓批量迁移工具\r\n\r\n[jcode](https://code.juejin.cn/pen/7186259430344753155)\r\n\r\n</br>\r\n\r\n> [Depravity](https://juejin.cn/user/2664871914908286) ｜ ByteUtil-字节工具类\r\n\r\n[jcode](https://code.juejin.cn/pen/7177660702708989990)\r\n\r\n</br>\r\n\r\n**🥉 三等奖**\r\n\r\n> [空想chx ](https://juejin.cn/user/822885778989703)｜ Json数据压缩工具\r\n\r\n[jcode](https://code.juejin.cn/pen/7184517158045483040)\r\n\r\n</br>\r\n\r\n> [大帅老猿](https://juejin.cn/user/2955079655898093) ｜ 废话生成器，轻松编写凑字数小作文\r\n\r\n[jcode](https://code.juejin.cn/pen/7179218859914690621)\r\n\r\n</br>\r\n\r\n> [魏一凡](https://juejin.cn/user/3391334911843021) ｜ 麻将工具类\r\n\r\n[jcode](https://code.juejin.cn/pen/7176912807617626173)\r\n\r\n</br>\r\n\r\n**💎 最佳技术奖**\r\n\r\n> [我犟不过你](https://juejin.cn/user/3668388983878573) ｜ 简易动态线程池\r\n\r\n[jcode](https://code.juejin.cn/pen/7177284238457667595)\r\n\r\n</br>\r\n\r\n**💎 最佳人气奖**\r\n\r\n> [南方者](https://juejin.cn/user/2840793779295133) ｜ 身材计算（Java版）\r\n\r\n[jcode](https://code.juejin.cn/pen/7176959500325224509)\r\n\r\n</br>\r\n\r\n**💎 最佳创意奖**\r\n\r\n> [Blacol ](https://juejin.cn/user/2212638687763976)｜ 中国传统日期转换V2\r\n\r\n[jcode](https://code.juejin.cn/pen/7180288605334700032)\r\n\r\n**[👏 更多获奖作品请移步大赛官网查看](https://juejin.cn/challenge/3/result)**\r\n\r\n## 加入码上掘金智囊团\r\n\r\n你是否觉得比赛题目不合口味？\r\n\r\n你是否有一些奇思妙想无处发挥？\r\n\r\n欢迎加入码上掘金智囊团，告诉我们你的 idea！\r\n\r\nidea 一经采纳，官方将送上一份神秘礼品～\r\n\r\n[✨ 填写问卷告诉我们你的 idea 😉](https://wenjuan.feishu.cn/m?t=sgFfWTR458Ii-aggd)"
    },
    {
        "article_id": "7189186468802199613",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55716a65042c499e9dc54d1e184ca325~tplv-k3u1fbpfcp-watermark.image?",
        "title": "20行代码实现的koa洋葱圈模型",
        "preview": "koa的洋葱圈模型在面试中经常会被问到，本文从源码的角度详细介绍了koajs的洋葱圈模型的实现，另外分享了koa-compose作为一个流程引擎的使用经验",
        "author": "秋染蒹葭",
        "view_count": 1337,
        "collect_count": 2,
        "comment_count": 0,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/72916df0d0bbea4bbca9d5ce701e1e9e~300x300.image",
        "category": "前端",
        "content": "下雨了，也快过年了，很多人应该都已经确定回家的行程了吧。下雨当然不能阻挡回家的脚步，最喜欢在家里的柿子树下听着外面爆竹的声音，那一刻年味儿就回来了\r\n\r\n闲言少叙，开始正文\r\n\r\nkoa想必很多人直接或间接的都用过，其源码不知道阅读本文的你有没有看过，相当精炼，本文想具体说说koa的中间件模型，一起看看[koa-compose](https://github.com/koajs/compose)的源码，这也是koa系列的第一篇文章，后续会更新一下koa相关的其他知识点\r\n\r\n## koa中间件的使用\r\n先让我们启动一个koa服务\r\n```js\r\n// app.js\r\nconst koa = require('koa');\r\nconst app = new koa();\r\napp.use(async (ctx, next) => {\r\n  console.log('进入第一个中间件')\r\n  next();\r\n  console.log('退出第一个中间件')\r\n})\r\napp.use(async (ctx, next) => {\r\n  console.log('进入第2个中间件')\r\n  next();\r\n  console.log('退出第2个中间件')\r\n})\r\n\r\napp.use((ctx, next) => {\r\n  console.log('进入第3个中间件')\r\n  next();\r\n  console.log('退出第3个中间件')\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello koa'\r\n})\r\n\r\napp.listen(8080, () => {\r\n  console.log('服务启动，监听8080端口')\r\n})\r\n\r\n```\r\n上述的服务在访问的时候会得到如下结果：\r\n\r\n```txt\r\n服务启动，监听8080端口\r\n进入第1个中间件\r\n进入第2个中间件\r\n进入第3个中间件\r\n退出第3个中间件\r\n退出第2个中间件\r\n退出第1个中间件\r\n```\r\n上面的返回结果有点像一个递归的过程，从现象上看当中间件调用next()的时候，函数会暂停并进入到下一个中间件，当执行了最后一个中间件后，执行代码会回溯上游中间件，并执行next()之后的代码，这就是koa的核心能力，洋葱圈模型\r\n\r\n## 洋葱圈模型\r\n先看一张经典的洋葱圈模型的示意图：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f9b0fd7c764d8f83510c46d5bc10c4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在开发过程中，可以将next()之前的代码理解为**捕获阶段**, 而next()之后的代码可以理解为**释放阶段**，开发者结合这两个状态可以实现一些有趣的操作，比如记录一次请求的时间：\r\n```js\r\nasync function responseTime(ctx, next) {\r\n  const start = Date.now();\r\n  await next();\r\n  const ms = Date.now() - start;\r\n  ctx.set('X-Response-Time', `${ms}ms`);\r\n}\r\n\r\napp.use(responseTime);\r\n```\r\n使用洋葱圈模型可以直接将响应时间记录的操作解耦出来，这样就不需要再去对称的写在业务逻辑中了，这是怎么实现的呢？\r\n\r\n## 洋葱圈模型的实现，koa-compose\r\n我们通过`app.use()`添加了很多函数，这些函数最终传递给了compose函数，先贴上koa-compose的源码，这里笔者删除掉了校验入参的一些非主干逻辑，我们可以看到代码也就十几行，非常简单，接下来让我们一行一行的去看一下代码\r\n```js\r\nfunction compose (middleware) {\r\n  // 返回一个匿名函数，next为可选参数\r\n  return function (context, next) {\r\n    // 记录当前执行位置的游标\r\n    let index = -1\r\n    // 从第一个中间件开始，串起所有中间件\r\n    return dispatch(0)\r\n    function dispatch (i) {\r\n      // 为了不破坏洋葱圈模型，不允许在单个中间件中执行多次next函数\r\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\r\n      // 更新游标\r\n      index = i\r\n      let fn = middleware[i]\r\n      // 判断边界，假如已经到到边界了，可执行外部传入的回调\r\n      if (i === middleware.length) fn = next\r\n      if (!fn) return Promise.resolve()\r\n      try {\r\n        // 核心处理逻辑，进入fn的执行上下文的时候，dispatch就是通过绑定下一个index，变成了next，进入到下一个中间件\r\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))\r\n      } catch (err) {\r\n        return Promise.reject(err)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n```\r\ncompose接收一个的函数数组`[fn1, fn2, fn3, ...]`，compose调用后，返回了一个匿名函数，匿名函数接收两个参数\r\n* 第一个参数是上下文，对于koa的上下文不在本文的探究范围，我们只要记得这个是在各个中间件中的共享的就可以了\r\n* 第二个参数标记为next，可选参数，在中间件执行的最后检查执行，这个和自定义的中间件中的next不完全一样，一般是初始化返回了匿名函数后，调用方自己指定，用于处理一下默认逻辑\r\n\r\n通过源码可以看出，compose是提供了一个洋葱模型完全执行的回调，通过把函数存储起来，用next作为钥匙，串起了我们所有的中间件，其核心代码就是：\r\n```js\r\nPromise.resolve(fn(context, dispatch.bind(null, i + 1)))\r\n```\r\n进入fn的执行上下文的时候，dispatch就是通过绑定下一个index，变成了next，进入到下一个中间件。另外fn（中间件函数）可以是个异步函数，`Promise.resolve`会等到内部异步函数resolve之后触发\r\n\r\n## 单次调用限制\r\n假如在单个中间件中执行多次next函数的话，会造成下游的中间件多次执行，这样就破坏了洋葱圈模型，因此限制了在单个中间件中只能执行一次next函数，实现方式时在函数记录了一个游标index，初始值是-1；这个游标会记录当前执行到哪个中间件，用来禁止在中间件中多次调用next函数\r\n\r\n在一个中间件内多次调用next的时候，你就会收到下面这个报错\r\n\r\n```js\r\nUnhandledPromiseRejectionWarning: Error: next() called multiple times\r\n```\r\n## koa-compose与流程引擎\r\n`koa-compose`不仅仅只是koa的一个依赖包，在有些场景下完全可以作为一个独立的工具来使用的，这里模拟一个代码检测工具的应用，完全可以作为一个流程引擎来使用\r\n```js\r\nconst koaCompose = require('koa-compose');\r\nfunction download = (ctx, next) {\r\n  console.log('download code');\r\n  next();\r\n}\r\nfunction check = (ctx, next) {\r\n  console.log('check style');\r\n  next();\r\n}\r\nfunction post = (ctx, next) {\r\n  next();\r\n  console.log('post result', ctx.result);\r\n}\r\nfunction clean = (ctx, next) {\r\n  next();\r\n  console.log('clean temp, remove code');\r\n}\r\n\r\nconst flowEngine = koaCompose([download, check, post, clean]);\r\nflowEngine(ctx as Context);\r\n```\r\n上述可以看作一个基于koa-compose实现的流程引擎，在node中，我们会经常处理一些多阶段的任务，完全可以通过这样的方式来实现\r\n\r\n## 总结\r\nkoa的洋葱圈模型在面试中经常会被问到，建议可以写一下、理解一下`koa-compose`的源码；另外`koa-compose`作为一个流程引擎也是一个很有用的工具，在有些场景下会有意想不到的效果。\r\n"
    },
    {
        "article_id": "7187664196492853308",
        "snapshot": "",
        "title": "OC 局部变量未初始化的危险性",
        "preview": "问题提出 前几天在协助业务同学排查业务问题时，遇到了一个奇怪的问题。实际的业务代码如上，默认定义了一个局部变量 variable ，通过另一个开关控制这个参数是否为 NO。但观察线上数据，在开关为 N",
        "author": "user8823711748876",
        "view_count": 3810,
        "collect_count": 7,
        "comment_count": 1,
        "avatar": "https://p9-passport.byteacctimg.com/img/mosaic-legacy/3797/2889309425~300x300.image",
        "category": "iOS",
        "content": "---\r\ntheme: github\r\n---\r\n## 问题提出\r\n \r\n![20230112-151134.jpeg](https://p-bytetech.bytedance.net/tos-cn-i-vz0z6vmpra/8a9b824721024613beed8f591964092e~tplv-vz0z6vmpra-image.image)\r\n\r\n前几天在协助业务同学排查业务问题时，遇到了一个奇怪的问题。实际的业务代码如上，默认定义了一个局部变量 variable ，通过另一个开关控制这个参数是否为 NO。但观察线上数据，在开关为 NO 时依旧有参数为 YES 的上报，数量虽然之前版本一直存在但量级较小，视为误差。但最新版本上线后发现这种情况量级突然变大，但是这个函数的代码没有任何改动。\r\n\r\n排除了其他的可能性之后，问题就来到了怀疑 variable 是否值不确定，也就是是否可能是 NO 或者 YES。\r\n\r\n于是同学询问：Objective-c BOOL 默认值在所有系统都是NO吧？\r\n \r\n这一下子就把我问住了，我有印象应该这个在局部变量的时候是未定义的，但非局部变量的情况下我也不是很清楚。我就问了问同组的同学，发现大家对于局部的 BOOL 变量的默认值是什么也有争议，部分同学认为永远是 NO。既然有疑问，那我们就需要进行研究，~~顺便小水一篇~~。\r\n\r\n\r\n我们进一步抽象这个问题，在 ARC 环境下，下面这段代码的各个变量的值是什么？\r\n\r\n```Objective-C\r\n- (void)sample {\r\n    NSObject *obj;\r\n    BOOL boolean;\r\n    NSInteger inter;\r\n    char *pointer;\r\n    static BOOL staticBoolean;\r\n}\r\n```\r\n\r\n\r\n关于阅读本文需要的前置知识，由于篇幅较大，为了大家的阅读体验挪到了本文的最后，如果对 [C 的内存布局](https://juejin.cn/post/7187664196492853308#heading-12) 与 [ARM64 汇编](https://juejin.cn/post/7187664196492853308#heading-16) 不熟悉的同学可以先跳转观看。\r\n\r\n\r\n## 通过汇编进行验证算数类型\r\n\r\n### 分析汇编\r\n\r\n我们可以简单写一个 Demo 验证一下 BOOL 的情况。\r\n\r\n```Objective-C\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    \r\n    for (NSInteger i = 0; i < 1000; i++) {\r\n        BOOL defined = [self defined];\r\n        BOOL undefined = [self undefined];\r\n        NSAssert(undefined == NO, @\\\"\\\"); // 如果认为 BOOL 未经初始化一定是 NO 的话，那这个 Assert 就永远不会中 \r\n    }\r\n}\r\n\r\n- (BOOL)defined {\r\n    BOOL defined = YES;\r\n    return defined;\r\n}\r\n\r\n- (BOOL)undefined{\r\n    BOOL undefined; \r\n    return undefined; // Variable 'undefined' is uninitialized when used here\r\n}\r\n```\r\n\r\n跑起来看看结果，Demo 因为命中 Assert 后抛出 NSException 而崩溃了。因此可以先简单确认结论了。未初始化的临时变量 BOOL 的值并非确定是 NO。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10d383c5d5434f9a8a61f0da34669a3b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但为什么是未定义的？这就需要汇编来帮助我们了。\r\n\r\n在 ARM64 的真机 Debug 下 **disassemble** 一下，如果用的模拟器则会出现 x86 的汇编，感兴趣的同学可以自行尝试，我们这里就以 ARM64 的汇编为例了：\r\n\r\n```Objective-C\r\n- (BOOL)undefined {\r\n    BOOL undefined;\r\n->  return undefined;\r\n}\r\n```\r\n\r\n```Assembly&#x20;Language\r\n(lldb) disassemble\r\ndemo`-[ViewController undefined]:\r\n    0x102fade68 <+0>:  sub    sp, sp, #0x20 // sp = sp - 20，push stack，本身因为调用 @selector(undefined) 新开了一个函数栈，至于为什么是 0x20 是因为 sp 要以 16(0x10) 字节对齐：除了 存 x0（8 字节） x1(8 字节) ，BOOL (1 个字节，读到寄存器再补成了 4 个字节变成了 w8) ，还有 15 个字节就是对齐的成本\r\n    0x102fade6c <+4>:  str    x0, [sp, #0x18] // 把 x0 存到 sp + 0x18 的地址，x0 实际是 self，存储的具体位置是 sp + 0x18 到 sp + 0x20 的这 8 个字节\r\n    0x102fade70 <+8>:  str    x1, [sp, #0x10] // 把 x1 存到 sp + 0x18 的地址，x1 实际是 selector(undefined)，存储的具体位置是 sp + 0x10 到 sp + 0x18 这个位置。\r\n->  0x102fade74 <+12>: ldrb   w8, [sp, #0xf] // w8 直接从 sp + 0xf 的地址读取，但是 sp + 0xf 的位置是未定义的，w8 就是 undefined 这个变量\r\n    0x102fade78 <+16>: and    w0, w8, #0x1 // 把 w8 与 0x1 取并（也就是结果要么 0x0 要么 0x1）塞给 w0（x0），返回给外部\r\n    0x102fade7c <+20>: add    sp, sp, #0x20\r\n    0x102fade80 <+24>: ret   \r\n```\r\n\r\n我们来看下内存分布，加深下对 stack 内存布局的理解，一句话理解结论就是：分给 undefined 的内存 ``sp + 0xf`` 的值是未定义的，因此导致了 undefined 的值也是未定义的。\r\n\r\n```Objective-C\r\n(lldb) reg read sp\r\n      sp = 0x000000016d8e79a0\r\n```\r\n\r\n我们首先打印 **sp** 的值，值为 **0x000000016d8e79a0** 。\r\n\r\n```Objective-C\r\n(lldb) memory read 0x000000016d8e79a0 0x000000016d8e79c0\r\n                                                        sp+0xf\r\n                                                          ⬇️\r\n0x16d8e79a0: 01 00 00 00 00 00 00 00 00 d0 51 02 01 00 00 11  ..........Q.....\r\n              x1  sp+0x10 ~ sp+0x18   x0  sp+0x18 ~ sp+0x20                   \r\n                        ⬇️                       ⬇️                            \r\n0x16d8e79b0: 78 4e 74 b1 01 00 00 00 f0 61 60 17 01 00 00 00  xNt......a`.....\r\n```\r\n\r\n接着我们查看内存中从 **0x000000016d8e79a0**(sp) 到 **0x000000016d8e79c0**(sp + 0x20) 的具体内容，通过 **memory read** 命令，也就是 -\\\\[ViewController undefined] 这个函数本次分配到的栈内存。\r\n\r\n每个参数寄存器对应写入的内存地址与范围已经标注在上方了，例如 x0 对应 ``sp+0x18 ~ sp+0x20`` ，x1 对应 ``sp+0x10 ~ sp+0x18`` 。\r\n\r\n```Objective-C\r\n(lldb) po self\r\n<ViewController: 0x1176061f0>\r\n(lldb) reg read x0\r\n      x0 = 0x00000001176061f0\r\n```\r\n\r\nx0 首先肯定是外部调用的 self，也就是本次的 ViewController ，我们看到由于 ARM64 是小端序，因此展示在内存里的值与我们正常阅读的顺序是反过来的，具体来说就是每个 Byte 位内部不用颠倒，但是整体阅读的时候需要反转，例如 x0 对应的内存区域：``sp+0x18 ~ sp+0x20`` ，``f0 61 60 17 01 00 00 00`` -> ``00 00 00 01 17 60 61 f0`` -> ``0x00000001176061f0`` 。\r\n\r\n```Objective-C\r\n(lldb) reg read x1\r\n      x1 = 0x00000001b1744e78\r\n\r\n(lldb) memory read 0x00000001b1744e70\r\n0x1b1744e70: 63 74 56 61 6c 75 65 00 75 6e 64 65 66 69 6e 65  ctValue.undefine\r\n0x1b1744e80: 64 00 54 42 2c 52 2c 4e 2c 47 69 73 55 6e 64 65  d.TB,R,N,GisUnde\r\n```\r\n\r\n同理我们可以看到 x1 是调用时的 @selector ，写入了内存中  sp+0x18 \\\\~ sp+0x20 的位置，一样可以看到是能对应上的，我们还可以看 x1 指向的内存区域，看看 @selector 是什么，可以看到是 **undefine\\\\0** 。最后的 **\\\\0** 是表达 Cstr 的结束。\r\n\r\n```Objective-C\r\n(lldb) memory read 0x000000016d8e79a0 0x000000016d8e79c0\r\n                                                        sp+0xf\r\n                                                          ⬇️\r\n0x16d8e79a0: 01 00 00 00 00 00 00 00 00 d0 51 02 01 00 00 11  ..........Q.....\r\n// 下面一行略\r\n```\r\n\r\n接着我们再分析 w8 的诞生，w8 就是对 undefined 这个变量的操作，w8 从 sp + 0xf 读取这一个字节，本次运行的时候读取到的值是 0x11 ，然后 ldrb 会高位补 0 ，因此 w8 的结果就是 4 个字节的 0x11 。最后再对 w8 取 与 0x1 ，获得了最终的 BOOL 值。\r\n\r\n这里虽然本次取到的值是 0x11 ，但这个是完全随机的，原因我们在一开始也就讲过了，Stack 的内存内容是完全随机，并且我们的程序也没有对其进行初始化。原本操作系统分给你是什么就是什么，不论是 heap 还是 stack 都一样。对于 Stack 来说，这块内存可能之前有更深的调用使用过，在 pop 的时候并不会清零。\r\n\r\n> A common assumption made by novice programmers is that all variables are set to a known value, such as zero, when they are declared. While this is true for many languages, it is not true for all of them, and so the potential for error is there. Languages such as [C](https://en.wikipedia.org/wiki/C_\\\\(programming_language\\\\)) use [stack](https://en.wikipedia.org/wiki/Stack_\\\\(data_structure\\\\)) space for variables, and the collection of variables allocated for a subroutine is known as a [stack frame](https://en.wikipedia.org/wiki/Stack_frame). While the computer will set aside the appropriate amount of space for the stack frame, it usually does so simply by adjusting the value of the stack [pointer](https://en.wikipedia.org/wiki/Pointer_\\\\(computer_programming\\\\)), and does not set the [memory](https://en.wikipedia.org/wiki/Computer_storage) itself to any new state (typically out of efficiency concerns). Therefore, whatever contents of that memory at the time will appear as initial values of the variables which occupy those addresses.\r\n>\r\n> https://en.wikipedia.org/wiki/Uninitialized\\\\_variable\r\n\r\n\r\n\r\n我们再对比下有默认值的汇编，看看有什么区别：\r\n\r\n```Objective-C\r\n- (BOOL)undefined {\r\n    BOOL defined = YES;\r\n->  return defined;\r\n}\r\n```\r\n\r\n    (lldb) dis\r\n    demo`-[ViewController undefined]:\r\n        0x100b29e60 <+0>:  sub    sp, sp, #0x20\r\n        0x100b29e64 <+4>:  str    x0, [sp, #0x18]\r\n        0x100b29e68 <+8>:  str    x1, [sp, #0x10]\r\n        0x100b29e6c <+12>: mov    w8, #0x1 // 先把 w8 设置成 YES\r\n        0x100b29e70 <+16>: strb   w8, [sp, #0xf] // 把 w8 存到 sp + 0xf 的位置\r\n    ->  0x100b29e74 <+20>: ldrb   w8, [sp, #0xf]\r\n        0x100b29e78 <+24>: and    w0, w8, #0x1\r\n        0x100b29e7c <+28>: add    sp, sp, #0x20\r\n        0x100b29e80 <+32>: ret    \r\n\r\n可以看到主要区别在于 w8 有初始化赋值，其余都没有区别。于此，对于算数类型的初始化验证完毕。\r\n\r\n### 网络上寻找相关资料\r\n\r\n我们看最权威的资料：[\\\"ISO/IEC 9899:TC3 (Current C standard)\\\"](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf) 中 Section 6.7.8 关于 Initialization  的论述。我们在 stack 上分配的变量是 automatic storage，并且是没有经过初始化的，这种值是未定义的。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf277b21c3f447d8a70560593a1befa~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n同时后半句还提到，如果是 static storage 并且未初始化：\r\n\r\n1.  指针类型就是空指针；\r\n\r\n1.  算术类型 (int / float 等) 就是 0 ；\r\n\r\n1.  复合类型 (struct / class) 的每个成员变量以前面的规则初始化；\r\n\r\n1.  对于 union ，只有第一个命名的成员以前面的规则初始化，其余的都是未定义，可以看：[Static storage union and named members initialization in C language](https://stackoverflow.com/questions/54307858/static-storage-union-and-named-members-initialization-in-c-language)。\r\n\r\n### 结论得出\r\n\r\n至此我们就可以解答同学提出的疑问了，对于局部变量且是算数类型时，这个值是不确定的。这个结论也符合现象，之前版本也一直存在这种上报，但是最新版本可能由于任意调用链路上的 stack 调用改动，导致 BOOL 值变成 YES 的概率变大。同理，如果是 NSInteger 或者 CGFloat 或者 别的类型也是一样的结果。\r\n\r\n![20230112-151134.jpeg](https://p-bytetech.bytedance.net/tos-cn-i-vz0z6vmpra/8a9b824721024613beed8f591964092e~tplv-vz0z6vmpra-image.image)\r\n\r\n同时我们发现这么写代码，Xcode 也有对应的警告，可以看下 Clang 相关的静态检查\r\n\r\n> *   **core.uninitialized.ArraySubscript (C)**\r\n>\r\n> \r\n>\r\n> *   **core.uninitialized.Assign (C)**\r\n>\r\n> \r\n>\r\n> *   **core.uninitialized.Branch (C)**\r\n>\r\n> \r\n>\r\n> *   **core.uninitialized.CapturedBlockVariable (C)**\r\n>\r\n> \r\n>\r\n> *   **core.uninitialized.UndefReturn (C)**\r\n>\r\n> \r\n>\r\n> *   **core.uninitialized.NewArraySize (C++)**\r\n>\r\n> https://clang.llvm.org/docs/analyzer/checkers.html#core-uninitialized-assign\r\n\r\n大家可以考虑在项目的 CI 中开启对应的检查，或者本地开启 Warn As Error。\r\n\r\n## 再进一步拓展到普通指针与 NSObject (OC 对象)指针\r\n \r\n### 普通指针\r\n\r\n其实根据刚才上面的分析，我们已经可以大致猜到普通指针的结果，由于分配的区域是 stack ，而 stack 又未经初始化，因此大概率普通的指针默认值也不是 nil 。\r\n\r\n```Objective-C\r\n- (void)viewDidLoad {\r\n    for (NSInteger i = 0; i < 100; i++) {\r\n        NSAssert([self voidPointer] == nil, @\\\"\\\");\r\n    }\r\n}\r\n\r\n- (char *)voidPointer {\r\n    char *voidPointer;\r\n->  return voidPointer;\r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController voidPointer]:\r\n    0x104c1dcb0 <+0>:  sub    sp, sp, #0x20\r\n    0x104c1dcb4 <+4>:  str    x0, [sp, #0x18]\r\n    0x104c1dcb8 <+8>:  str    x1, [sp, #0x10]\r\n->  0x104c1dcbc <+12>: ldr    x0, [sp, #0x8]\r\n    0x104c1dcc0 <+16>: add    sp, sp, #0x20\r\n    0x104c1dcc4 <+20>: ret    \r\n```\r\n\r\n与之前的分析基本一样，只是由于 char \\\\* 本身是一个指针，只是偏移量有所改变，这次 voidPointer 取的是  sp + 0x8 到 sp + 0x10 而已。因此值也是不确定的。与我们设想的一致。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41743b8371444a8f8737936cde6e1bcb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### NSObject 指针\r\n \r\n#### ARC\r\n\r\n到了这时候大家可能会觉得，NSObject 指针有啥不一样的，不也是在 stack 上分配内存吗，那肯定值是不确定的。\r\n\r\n理解到这里我只能说确实是理解了我前文的内容，但是对于 OC 的理解还有欠缺（手动狗头）。\r\n\r\n```Objective-C\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    \r\n    for (NSInteger i = 0; i < 1000; i++) {\r\n        NSAssert([self nsobjectPointer] == nil, @\\\"\\\");\r\n    }\r\n}\r\n\r\n- (NSObject *)nsobjectPointer {\r\n    NSObject *object;\r\n    return object;\r\n}\r\n```\r\n\r\n我们跑起来看下，竟然没有命中 Assert ，看起来 NSObject \\\\* 不初始化也能是 null ？那这是为什么呢？(~~其实标题已经剧透了~~）\r\n\r\n首先我们对这个文件的编译参数是 ARC ，因此对于所有的指针类型默认属性都是 \\\\_\\\\_strong 。\r\n\r\n其实就隐藏在 ARC 帮我们自动插入的代码中，我们也一样来看看汇编。  为了简化代码，我们把函数返回值取消（不然你会看到诸如 objc\\\\_autoreleaseReturnValue 的调用，增加复杂度）。\r\n\r\n```Objective-C\r\n- (void)nsobjectPointer {\r\n    NSObject *object;\r\n->  \r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController nsobjectPointer]:\r\n    0x102f05db8 <+0>:  sub    sp, sp, #0x30\r\n    0x102f05dbc <+4>:  stp    x29, x30, [sp, #0x20]\r\n    0x102f05dc0 <+8>:  add    x29, sp, #0x20\r\n    0x102f05dc4 <+12>: stur   x0, [x29, #-0x8]\r\n    0x102f05dc8 <+16>: str    x1, [sp, #0x10]\r\n    0x102f05dcc <+20>: add    x0, sp, #0x8 // x0 = sp + 0x8\r\n    0x102f05dd0 <+24>: mov    x1, #0x0 // x1 = 0x0\r\n    0x102f05dd4 <+28>: str    xzr, [sp, #0x8] // *(sp + 0x8) = 0 也就是刚写入的 xzr(8 个字节的 0)\r\n->  0x102f05dd8 <+32>: bl     0x102f06374               ; symbol stub for: objc_storeStrong // 接受两个参数，x1 如果是 null 的话就是对 x0 置空\r\n    0x102f05ddc <+36>: ldp    x29, x30, [sp, #0x20]\r\n    0x102f05de0 <+40>: add    sp, sp, #0x30\r\n    0x102f05de4 <+44>: ret    \r\n```\r\n\r\n哦豁，代码量一下子就提高了很多。但没关系我们只需要关注一个点即可，那就是虽然没有任何值赋给 \\\\_\\\\_strong object，但其实 ARC 依旧帮我们调用了 objc\\\\_storeStrong ，并且调用的还是 objc\\\\_storeStrong(sp + 0x8, 0x0)。这个调用的意思就是对 sp + 0x8 这块内存置空。\r\n\r\n```Objective-C\r\n// objc4-706\r\nvoid\r\nobjc_storeStrong(id *location, id obj)\r\n{\r\n    id prev = *location;\r\n    if (obj == prev) {\r\n        return;\r\n    }\r\n    objc_retain(obj);\r\n    *location = obj;\r\n    objc_release(prev);\r\n}\r\n```\r\n\r\n我们可以对比下手动置 nil 的汇编代码，没有任何区别。\r\n\r\n```Objective-C\r\n- (void)nsobjectPointer {\r\n    NSObject *object = nil;\r\n->  \r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController nsobjectPointer]:\r\n    0x102e3ddb8 <+0>:  sub    sp, sp, #0x30\r\n    0x102e3ddbc <+4>:  stp    x29, x30, [sp, #0x20]\r\n    0x102e3ddc0 <+8>:  add    x29, sp, #0x20\r\n    0x102e3ddc4 <+12>: stur   x0, [x29, #-0x8]\r\n    0x102e3ddc8 <+16>: str    x1, [sp, #0x10]\r\n    0x102e3ddcc <+20>: add    x0, sp, #0x8\r\n    0x102e3ddd0 <+24>: mov    x1, #0x0\r\n    0x102e3ddd4 <+28>: str    xzr, [sp, #0x8]\r\n->  0x102e3ddd8 <+32>: bl     0x102e3e374               ; symbol stub for: objc_storeStrong\r\n    0x102e3dddc <+36>: ldp    x29, x30, [sp, #0x20]\r\n    0x102e3dde0 <+40>: add    sp, sp, #0x30\r\n    0x102e3dde4 <+44>: ret    \r\n```\r\n\r\n我们最后再看下对于 \\\\_\\\\_weak 变量，结果是如何的。\r\n\r\n```Objective-C\r\n- (void)nsobjectPointer {\r\n    __weak NSObject *object = nil;\r\n->  \r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController nsobjectPointer]:\r\n    0x104c75db0 <+0>:  sub    sp, sp, #0x30\r\n    0x104c75db4 <+4>:  stp    x29, x30, [sp, #0x20]\r\n    0x104c75db8 <+8>:  add    x29, sp, #0x20\r\n    0x104c75dbc <+12>: stur   x0, [x29, #-0x8]\r\n    0x104c75dc0 <+16>: str    x1, [sp, #0x10]\r\n    0x104c75dc4 <+20>: add    x0, sp, #0x8 // x0 = sp + 0x8\r\n    0x104c75dc8 <+24>: str    xzr, [sp, #0x8] // *(sp + 0x8) = 0x0，这时候 x0 就是 __weak 的 object，也就是置空\r\n->  0x104c75dcc <+28>: bl     0x104c76338               ; symbol stub for: objc_destroyWeak // 只接收了一个参数，x0，也就是把 sp + 0x8 这个地址传入，这个地址的值是 0 \r\n    0x104c75dd0 <+32>: ldp    x29, x30, [sp, #0x20]\r\n    0x104c75dd4 <+36>: add    sp, sp, #0x30\r\n    0x104c75dd8 <+40>: ret    \r\n```\r\n\r\n因此我们知道了在 ARC 下，把 \\\\_\\\\_strong/ \\\\_\\\\_weak 变量初始化为 nil 是编译器特性，由于编译器会帮我们插入 objc\\\\_storeStrong/objc\\\\_retain 等函数来进行控制，在这个时候就会把 NSObject 类型的指针初始化为 0 啦。\r\n\r\n具体可以查看：[Clang - AutomaticReferenceCounting.html](https://releases.llvm.org/11.1.0/tools/clang/docs/AutomaticReferenceCounting.html)&#x20;\r\n\r\n> It is undefined behavior if the storage of a \\\\_\\\\_strong or \\\\_\\\\_weak object is not properly initialized before the first managed operation is performed on the object, or if the storage of such an object is freed or reused before the object has been properly deinitialized. Storage for a \\\\_\\\\_strong or \\\\_\\\\_weak object may be properly initialized by filling it with the representation of a null pointer, e.g. by acquiring the memory with calloc or using bzero to zero it out. A \\\\_\\\\_strong or \\\\_\\\\_weak object may be properly deinitialized by assigning a null pointer into it. A \\\\_\\\\_strong object may also be properly initialized by copying into it (e.g. with memcpy) the representation of a different \\\\_\\\\_strong object whose storage has been properly initialized; doing this properly deinitializes the source object and causes its storage to no longer be properly initialized. A \\\\_\\\\_weak object may not be representation-copied in this way.\r\n\r\n这句话的理解是：类对象的所有 Property 默认值都是 nil，因为类对象是 calloc 出来 或者 通过 bzero 置零了。\r\n\r\n```Objective-C\r\n// objc4-706\r\n\r\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate \r\n// shortcutting optimizations.\r\nstatic ALWAYS_INLINE id\r\ncallAlloc(Class cls, bool checkNil, bool allocWithZone=false)\r\n{\r\n    if (slowpath(checkNil && !cls)) return nil;\r\n\r\n#if __OBJC2__\r\n    if (fastpath(!cls->ISA()->hasCustomAWZ())) {\r\n        // No alloc/allocWithZone implementation. Go straight to the allocator.\r\n        // fixme store hasCustomAWZ in the non-meta class and \r\n        // add it to canAllocFast's summary\r\n        if (fastpath(cls->canAllocFast())) {\r\n            // No ctors, raw isa, etc. Go straight to the metal.\r\n            bool dtor = cls->hasCxxDtor();\r\n            id obj = (id)calloc(1, cls->bits.fastInstanceSize());\r\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\r\n            obj->initInstanceIsa(cls, dtor);\r\n            return obj;\r\n        }\r\n        else {\r\n            // Has ctor or raw isa or something. Use the slower path.\r\n            id obj = class_createInstance(cls, 0);\r\n            if (slowpath(!obj)) return callBadAllocHandler(cls);\r\n            return obj;\r\n        }\r\n    }\r\n#endif\r\n\r\n    // No shortcuts available.\r\n    if (allocWithZone) return [cls allocWithZone:nil];\r\n    return [cls alloc];\r\n}\r\n```\r\n\r\n\r\n\r\n最后，我们把复杂带返回值的这大段汇编的具体理解，就当留一个课后作业给大家，感兴趣的同学可以自行分析。\r\n\r\n```Objective-C\r\n- (NSObject *)nsobjectPointer {\r\n    NSObject *object;\r\n->  return object;\r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController nsobjectPointer]:\r\n    0x100df9ce8 <+0>:  sub    sp, sp, #0x40\r\n    0x100df9cec <+4>:  stp    x29, x30, [sp, #0x30]\r\n    0x100df9cf0 <+8>:  add    x29, sp, #0x30\r\n    0x100df9cf4 <+12>: stur   x0, [x29, #-0x8]\r\n    0x100df9cf8 <+16>: stur   x1, [x29, #-0x10]\r\n    0x100df9cfc <+20>: add    x8, sp, #0x18 // x8 = sp + 0x18\r\n    0x100df9d00 <+24>: str    x8, [sp, #0x8] // *(sp + 0x8) = x8\r\n    0x100df9d04 <+28>: mov    x8, #0x0 // 清空 x8，这时候 x8 其实就是 object 了\r\n    0x100df9d08 <+32>: str    x8, [sp] // *(sp) = x8 = 0 \r\n    0x100df9d0c <+36>: str    xzr, [sp, #0x18] // *(sp + 0x18) = 0x0 (8 个字节的 0)\r\n->  0x100df9d10 <+40>: ldr    x0, [sp, #0x18] // x0 = *(sp + 0x18) ，也就是刚写入的 xzr(8 个字节的 0)\r\n    0x100df9d14 <+44>: bl     0x100dfa2bc               ; symbol stub for: objc_retain // objc_retain 只有一个参数，就是 x0，而上一步 x0 = *(sp + 0x18) ，也就是把 0 传入（啥都没干）\r\n    0x100df9d18 <+48>: ldr    x1, [sp] // 之前 *sp 的位置是被写入了 0x0 的 0x100df9d08 <+32>\r\n    0x100df9d1c <+52>: mov    x2, x0\r\n    0x100df9d20 <+56>: ldr    x0, [sp, #0x8]\r\n    0x100df9d24 <+60>: str    x2, [sp, #0x10]\r\n    0x100df9d28 <+64>: bl     0x100dfa2d4               ; symbol stub for: objc_storeStrong // 接受两个参数，x1 如果是 null 的话就是对 x0 置空\r\n    0x100df9d2c <+68>: ldr    x0, [sp, #0x10]\r\n    0x100df9d30 <+72>: ldp    x29, x30, [sp, #0x30]\r\n    0x100df9d34 <+76>: add    sp, sp, #0x40\r\n    0x100df9d38 <+80>: b      0x100dfa28c               ; symbol stub for: objc_autoreleaseReturnValue\r\n```\r\n\r\n#### MRC\r\n\r\n\r\n如果我们用 MRC 编译文件，来看下对应的汇编代码，与之前的普通指针完全一致，因此在 MRC 情况下，结论与普通指针一致。\r\n\r\n```Objective-C\r\n- (NSObject *)nsobjectPointer {\r\n    NSObject *object;\r\n    return object;\r\n}\r\n```\r\n\r\n```Objective-C\r\n(lldb) dis\r\ndemo`-[ViewController nsobjectPointer]:\r\n    0x1046a1d30 <+0>:  sub    sp, sp, #0x20\r\n    0x1046a1d34 <+4>:  str    x0, [sp, #0x18]\r\n    0x1046a1d38 <+8>:  str    x1, [sp, #0x10]\r\n->  0x1046a1d3c <+12>: ldr    x0, [sp, #0x8]\r\n    0x1046a1d40 <+16>: add    sp, sp, #0x20\r\n    0x1046a1d44 <+20>: ret    \r\n```\r\n\r\n因此也就会发生崩溃。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a0de038752543fcbae941c9875f7a82~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7d4e3c2bd4a49899a6aedb7e37c6091~tplv-k3u1fbpfcp-zoom-1.image)\r\n \r\n## 总结\r\n\r\n```Objective-C\r\n// ARC 环境\r\n- (void)sampleARC {\r\n    NSObject *obj; // nil，值确定\r\n    BOOL boolean; // 未定义，值不确定\r\n    NSInteger inter; // 未定义，值不确定\r\n    char *pointer; // 未定义，值不确定\r\n    static BOOL staticBoolean; // false / 0，值确定\r\n}\r\n\r\n// MRC 环境\r\n- (void)sampleMRC {\r\n    NSObject *obj; // 未定义，值不确定\r\n}\r\n```\r\n\r\n本文通过理解 ARM64 汇编的方式验证了下面的这些情况：\r\n\r\n1.  对于 C 的基础类型，如果未初始化：\r\n    1.  局部变量：值不确定，需要初始化。\r\n    1.  全局变量或者静态变量：值确定为 NULL 或者 0，原因是这部分储存在 \\\\_\\\\_bss/\\\\_\\\\_common 段内存会被初始化为 0。\r\n\r\n1.  指针如果未初始化：\r\n    1.  ARC 情况下，OC 对象指针：由于编译器生成代码协助，值确定为 nil 。\r\n    1.  MRC 情况下，OC 对象指针：值不确定，需要初始化。\r\n    1.  非 OC 对象指针：值不确定，需要初始化。\r\n\r\n## 前置知识\r\n \r\n### C的内存布局\r\n \r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7960e687d162436aabceadec62ab6a49~tplv-k3u1fbpfcp-zoom-1.image)\r\n \r\n#### 堆内存 (stack) 与栈内存 (heap)\r\n\r\n```Objective-C\r\n- (void)memberFunction {\r\n    BOOL memberArithmetic = NO; // 栈\r\n    NSObject *pointer = [[NSObject alloc] init]; // pointer 本身是在栈上，但 *pointer （也就是分配的 NSObject）在堆上\r\n}\r\n```\r\n\r\n对于 OC 来说由于机制的原因，如果是 new 或者 alloc 出来的对象都是 堆 (heap) 内存，而一些结构体或者基础类型，就是 栈 (stack) 内存。如果是 C++ 的话，就比较复杂了，对象可以创建在堆上，也可以创建在栈上，看创建方法。\r\n\r\n如果不熟练的话，可以通过运行时的命令进行 check，对比地址与 fp 与 sp。\r\n\r\n```Objective-C\r\n(lldb)p $fp >= &(memberArithmetic) && &(memberArithmetic) >= $sp // memberArithmetic 在栈上\r\n(bool) $0 = true\r\n(lldb) p $fp >= &(pointer) && &(pointer) >= $sp // pointer 本身是在栈上\r\n(bool) $1 = true\r\n(lldb) p $fp >= (pointer) && (pointer) >= $sp // pointer （也就是分配的 NSObject）在堆上\r\n(bool) $2 = false\r\n```\r\n\r\n分配在栈上的变量的地址一定是处于 fp(frame pointer / x29 / w29) 与 sp(stack pointer) 之间的。里面的变量可以自己进行替换。\r\n\r\n而 栈/堆 内存是由系统分配的虚拟内存（Virtual Memory），实际最终会映射到物理内存，物理内存可能是之前别的进程使用过，也可能是当前进程使用过的，总之拿到这块内存的时候，里面的值不一定都是经过初始化为 0 的。甚至有些 malloc() 的实现会特意在 debug 状态下赋值为非零以充分暴露问题。\r\n\r\n> The operating system does not guarantee a zero'ed out memory, just that you own it. It will probably give you pages of memory that were used before (or never used before, but non-zero). If an application stores potentially-sensitive data, it is expected to zero it before free()'ing.\r\n>\r\n> https://stackoverflow.com/questions/5266260/how-is-the-stack-initialized\r\n>\r\n>\r\n>\r\n> When the OS has to apportion a new page to your process (whether that's for its stack or for the arena used by malloc()), it guarantees that it won't expose data from other processes; the usual way to ensure that is to fill it with zeros (but it's equally valid to overwrite with anything else, including even a page worth of /dev/urandom- in fact some debugging malloc() implementations write non-zero patterns, to catch mistaken assumptions such as yours).\r\n>\r\n> https://unix.stackexchange.com/questions/509232/if-the-heap-is-zero-initialized-for-security-then-why-is-the-stack-merely-unin\r\n\r\n\r\n#### BSS 段\r\n\r\n**BSS** (**B**lock **S**tarting by **S**ymbol )，存放未初始化的 statically allocated objects。statically allocated objects 同时指代：\r\n\r\n特别注意：具体是否分配在 BSS 段是取决于 编译器以及具体的参数的，例如 llvm 中就还有 \\\\_\\\\_common 段（紧跟着 \\\\_\\\\_bss段 ），部分情况也有所不同。这里的解释主要以 wikipedia 为主，wiki 中较多还是以 GCC 角度解释。实际变量存在哪个段中还需要实际查看编译产物。\r\n\r\n1.  未初始化的 全局变量/常量 。（这一条 GCC 与 LLVM 不一致）\r\n\r\n> all uninitialized objects (both variables and [constants](https://en.wikipedia.org/wiki/Constant_\\\\(computer_programming\\\\))) declared at file scope (i.e., outside any function)\r\n>\r\n> A **global variable** is a variable that is defined outside all functions and available to all functions.\r\n\r\n```Objective-C\r\nBOOL unintializedGlobalVariable;\r\nconst BOOL unintializedGlobalConstant;\r\n\r\n- (void)function {}\r\n```\r\n\r\n1.  未初始化的局部静态变量&#x20;\r\n\r\n> uninitialized [static local variables](https://en.wikipedia.org/wiki/Static_local_variable) ([local variables](https://en.wikipedia.org/wiki/Local_variable) declared with the [static](https://en.wikipedia.org/wiki/Static_\\\\(keyword\\\\)) [keyword](https://en.wikipedia.org/wiki/Keyword_\\\\(computer_programming\\\\)));\r\n\r\n```Objective-C\r\n- (void)function {\r\n    static BOOL unintializedLocalStaticVariables;\r\n}\r\n```\r\n\r\n但最后，还有一类变量也可能是在 BSS 端中：初始化为 0 的 全局变量或静态变量。当然这个是看编译器支持的，不是一贯而论的。例如 GCC 的 -fzero-initialized-in-bss 与 -fno-zero-initialized-in-bss 就能控制这个特性。\r\n\r\n> statically-allocated variables and constants initialized with a value consisting solely of zero-valued bits\r\n\r\n```Objective-C\r\nint intializedGlobalVariable = 0;\r\n\r\n- (void)function {}\r\n```\r\n\r\nBSS 段的特征是当程序开始运行时，全部都是 0 （由 OS 内核保证），因此如果是 基础属性，那就是 0 ，如果是指针，那就是 空指针。实际由于未初始化，因此在 .o 文件中不占用实际空间，只是一个占位 (placeholder)，也因此也可以解释为 'Better Save Space' 。\r\n\r\n##### 通过产物查看\r\n\r\n说了这么多可能被绕晕了，whatever ，我们可以直接在产物中 grep 查看对应结果来看到底是不是在 bss 段中。我的编译环境为 Xcode 14.2 （LLVM）。\r\n\r\n```Objective-C\r\nBOOL unintializedGlobalVariable;\r\nconst BOOL unintializedGlobalConstant;\r\n\r\nint intializedGlobalVariable = 0;\r\nconst BOOL intializedGlobalConstant = YES;\r\n\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];\r\n    \r\n    static BOOL unintializedLocalStaticVariable;\r\n    static const BOOL unintializedLocalStaticConstant;\r\n    \r\n    static BOOL intializedLocalStaticVariable = YES;\r\n}\r\n```\r\n\r\n```Objective-C\r\n➜  arm64 objdump -t ViewController.o | grep intialized\r\n0000000000001175 l     O __DATA,__bss _viewDidLoad.unintializedLocalStaticVariable\r\n0000000000000145 l     O __TEXT,__const _viewDidLoad.unintializedLocalStaticConstant\r\n00000000000001c8 l     O __DATA,__data _viewDidLoad.intializedLocalStaticVariable\r\n0000000000000144 g     O __TEXT,__const _intializedGlobalConstant\r\n0000000000001170 g     O __DATA,__common _intializedGlobalVariable\r\n0000000000000146 g     O __TEXT,__const _unintializedGlobalConstant\r\n0000000000001174 g     O __DATA,__common _unintializedGlobalVariable\r\n```\r\n\r\n我们可以看到跟 wiki 上的介绍有些出入，例如 所有常量都在 \\\\_\\\\_TEXT,\\\\_\\\\_const 区；同时 LLVM 把 全局变量(**GlobalVariable**) 统统放到了 DATA,\\\\_\\\\_common 区；未初始化的局部静态变量在 bss 区。\r\n\r\n关于这个输出的具体参数可以查看：[objdump 的 -t/--syms 部分。](https://man7.org/linux/man-pages/man1/objdump.1.html)\r\n\r\n\r\n\r\n> When your program starts running, all the contents of the bss section are zeroed bytes.\r\n>\r\n> http://web.mit.edu/rhel-doc/3/rhel-as-en-3/bss.html\r\n>\r\n> Hence, the BSS segment typically includes all uninitialized objects (both variables and [constants](https://en.wikipedia.org/wiki/Constant_\\\\(computer_programming\\\\))) declared at file scope (i.e., outside any function) as well as uninitialized [static local variables](https://en.wikipedia.org/wiki/Static_local_variable) ([local variables](https://en.wikipedia.org/wiki/Local_variable) declared with the [static](https://en.wikipedia.org/wiki/Static_\\\\(keyword\\\\)) [keyword](https://en.wikipedia.org/wiki/Keyword_\\\\(computer_programming\\\\)));\r\n>\r\n> An implementation may also assign statically-allocated variables and constants initialized with a value consisting solely of zero-valued bits to the BSS section.\r\n>\r\n> https://en.wikipedia.org/wiki/.bss#BSS\\\\_in\\\\_C\r\n>\r\n> If a global variable is explicitly initialized to zero (int myglobal = 0), where that variable will be stored?Compiler is free to put such variable into bss as well as into data.\r\n>\r\n> https://stackoverflow.com/questions/8721475/if-a-global-variable-is-initialized-to-0-will-it-go-to-bss\r\n>\r\n> Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing;contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code.\r\n>\r\n> https://www.geeksforgeeks.org/memory-layout-of-c-program/\r\n>\r\n> 虽然这里没有非常明显的证据，但我们还是可以认为\\\\_\\\\_common段和\\\\_\\\\_bss段没有太大区别；而之所以\\\\_\\\\_common段独立于\\\\_\\\\_bss段，是因为要考虑到 **全局变量需要暴露给外部（external）** ，涉及到“弱符号与强符号”的问题（这里不作介绍），否则与\\\\_\\\\_bss段没区别。\r\n>\r\n> [C-C-中已初始化-未初始化全局-静态-局部变量-常量在内存中的位置](https://www.polarxiong.com/archives/C-C-%E4%B8%AD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.html)\r\n\r\n\r\n\r\n关于这部分内容，详细可以查看：[Memory Layout of C Programs](https://www.geeksforgeeks.org/memory-layout-of-c-program/) 一文。当然实际对于内存的理解还有非常多的内容，例如 page in/out、触发中断、clean/dirty memory 等等，跟本文无关我们就不再展开了。\r\n\r\n### ARM64 汇编\r\n\r\n这是一个比较大的话题，我们在这里只讲解必要的指令帮助大家理解，其余复杂的命令大家如果工作中用得到的话再学习即可。\r\n\r\n#### sub / add\r\n\r\n意思就是简单的加减法，对于 CPU 来说，能直接操作的只有寄存器，不能直接操作内存，因此一般参数都是寄存器。\r\n\r\n``sub    sp, sp, #0x20`` 的意思是 sp = sp - 0x20 。由于 stack 内存是由高地址向地址分配，因此对 sp 进行 sub 操作本质上 push stack 的行为。\r\n\r\n``add    sp, sp, #0x20`` 的意思是 sp = sp + 0x20 。本质上是 pop stack 的行为，一般来说同一个函数调用中，push 跟 pop 的偏移量是保持一致的。\r\n\r\n#### str / ldr(ldrb)\r\n\r\n这是一个对应的操作，str (store register)是把寄存器的值写到内存里，ldr (load register) 是把内存的值读到寄存器里。\r\n\r\n``str    x0, sp``  的意思就是把 sp 的**值**写到 x0 里面。可以理解为 sp = xo 。一般出现于调用 C 函数且第一个参数是指针的情况。\r\n\r\n``str    x0, [sp, #0x18]`` 的意思是把 sp + 0x18 这个地址的**内容**存到 x0 里面。\\\\[] 符号可以理解为 C 语言的 \\\\* 符号，可以理解为 \\\\*(sp + 0x18) = x0。\r\n\r\n``ldr    x0, sp`` 的意思就是把 sp 的**值**读到 x0 里面。可以理解为 x0 = sp。\r\n\r\n``ldr    x8, [sp, #0xf]`` 综上，意思就是把 sp + 0xf 这个地址的**内容**存到 x8 里面。可以理解为 x8 = \\\\*(sp + 0xf) 。\r\n\r\n``ldrb   w1, [sp, #0xf]`` ，与 ldr 大致相同，区别是多了一个 b(byte)，表示只读一个字节，然后用 0 填充到高位，直到满足 4 byte （也就是 w1 的大小）。w1 是访问时是寄存器的 低 32 位（4 byte），x1 访问时是寄存器 R1(Register 1) 的完整的 64 位（8 byte）。\r\n\r\n![image](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a769373a826d4bb8997ecb6ca480c042~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 引用\r\n\r\n1. [How is the stack initialized?](https://stackoverflow.com/questions/5266260/how-is-the-stack-initialized)\r\n\r\n2. [If the heap is zero-initialized for security, then why is the stack merely uninitialized?](https://unix.stackexchange.com/questions/509232/if-the-heap-is-zero-initialized-for-security-then-why-is-the-stack-merely-unini)\r\n\r\n3. [objdump(1) — Linux manual page](https://man7.org/linux/man-pages/man1/objdump.1.html)\r\n\r\n4. [5.5. bss Section](http://web.mit.edu/rhel-doc/3/rhel-as-en-3/bss.html)\r\n\r\n5. [.bss](https://en.wikipedia.org/wiki/.bss#BSS\\\\_in\\\\_C)\r\n\r\n6. [If a global variable is initialized to 0, will it go to BSS?](https://stackoverflow.com/questions/8721475/if-a-global-variable-is-initialized-to-0-will-it-go-to-bss)\r\n\r\n7. [C-C-中已初始化-未初始化全局-静态-局部变量-常量在内存中的位置](https://www.polarxiong.com/archives/C-C-%E4%B8%AD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.html)\r\n\r\n8. [\\\"ISO/IEC 9899:TC3 (Current C standard)\\\"](http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf)\r\n\r\n\r\n9.  [Static storage union and named members initialization in C language](https://stackoverflow.com/questions/54307858/static-storage-union-and-named-members-initialization-in-c-language)\r\n\r\n10. [Uninitialized/ variable](https://en.wikipedia.org/wiki/Uninitialized\\\\_variable)\r\n\r\n11. [Clang AVAILABLE CHECKERS](https://clang.llvm.org/docs/analyzer/checkers.html#core-uninitialized-assign)\r\n\r\n12. [ARC](https://releases.llvm.org/11.1.0/tools/clang/docs/AutomaticReferenceCounting.html)\r\n\r\n"
    },
    {
        "article_id": "7146220688800481294",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597dba12a87941a7a0743159ff4570a2~tplv-k3u1fbpfcp-watermark.image?",
        "title": "外包仔的自我救赎",
        "preview": "一入外包深似海，从此自研是路人！ 毕业的第三年，通过培训班转行Java，包装了两年经验。非科班出身又是半路出家，当时也不懂外包的概念，于是就糊里糊涂进了外包公司。",
        "author": "我一定有办法",
        "view_count": 42290,
        "collect_count": 97,
        "comment_count": 311,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/9586f873f91053da791363dbbfbd1587~300x300.image",
        "category": "代码人生",
        "content": "\r\n\r\n    本人96年后端Javaer一枚，现在在某知名大厂做外包仔（一入外包深似海，从此自研是路人）。\r\n# 为什么做外包仔？\r\n> 开始是没得选\r\n\r\n毕业的第三年，通过培训班转行Java，包装了两年经验。非科班出身又是半路出家，当时也不懂外包的概念，于是就糊里糊涂进了外包公司。第一家公司只干了三个多月就跑路了，一方面是工资太低（8K），另一方面是技术比较老旧（SSH）。第二家公司也是外包，但是项目还不错（spring cloud），薪资也可以接受（12K）。\r\n\r\n> 后来是给的多\r\n\r\n做开发工作的第二年，跳槽时本来想着找一家自研公司，但是没忍住外包公司开的价格，一时脑热又进了外包，也就是现在这家大厂外包。薪资比较满意（18K），项目也很不错（toC业务，各种技术都有涉及）。\r\n# 下定决心跳出外包\r\n> 为什么要离开\r\n\r\n干过外包的小伙伴们多多少少会有一些低人一等的感觉，说实话笔者自己也有。就感觉你虽然在大厂，但你是这里身份最低的存在，很多东西是需要权限才能接触到的。再者就是没有归属感，没有年会、没有团建、甚至不知道自己公司领导叫什么（只跟甲方主管和外包公司交付经理有接触）。\r\n> 潜心修炼技术\r\n\r\n在最近这个项目里确实学到了很多生产经验，自己写的接口也确实发生过线上故障，不再是单单的CRUD，也会参与一些接口性能的优化。对业务有了一定的的理解，技术上也有了一定的提升，大厂的开发流程、开发规范确实比较健全。\r\n> 背诵八股文\r\n\r\n三月份开始就在为跳槽做准备，先后学习了并发编程、spring源码、Mysql优化、JVM优化、RocketMQ以及分布式相关的内容（分布式缓存、分布式事务、分布式锁、分布式ID等）。**学到后面居然又把前面的忘了**。\r\n# 大环境行情和现状\r\n> 大范围裁员\r\n\r\n今年从金三银四开始，各大互联网公司就都在裁员，直到现在还有公司在裁员，说是互联网的寒冬也不为过。笔者所在的厂也是裁员的重灾区，包括笔者自己（做外包都会被优化，说是**压缩预算**）也遭重了，但是外包公司给换了另外一个项目组（从北京换到了杭州）。\r\n> 招聘网站行情\r\n\r\n笔者八月份先在北京投了一波简历（自研公司，外包不考虑了），三十多家公司只有一家公司给了回应（做了一道算法笔试题，然后说笔者占用内存太多就没有后续了），九月中旬又在杭州投了一波简历（也是只投自研），六十多家公司回复也是寥寥无几，甚至没约到面试（有大把的外包私聊在下，是被打上外包仔的标签了吗）。\r\n# 如何度过这个寒冬\r\n> 继续努力\r\n\r\n工作之余（摸鱼的时候），笔者仍然坚持学习，今天不学习，明天变垃圾。虽然身在外包，但是笔者仍有一颗向往自研的心，仍然想把自己学到的技术运用到实际生产中（现在项目用到的技术都是甲方说了算，当然我也会思考哪些场景适合哪些技术）。\r\n> 千万不要辞职\r\n\r\n现在的项目组做的是内部业务，并发几乎没有，但是业务相对复杂。笔者只能继续狗着（简历还是接着投，期望降低一些），希望互联网的寒冬早日结束，希望笔者和正在找工作的小伙伴们早日找到心仪的公司（respect）。"
    },
    {
        "article_id": "7184626139645050935",
        "snapshot": "",
        "title": "我把chatGpt接入了微信群聊",
        "preview": "让chatgpt在群里一起聊天，何尝不是一件美事，项目地址：https://github.com/webfamer/wx-chatgpt",
        "author": "Micha",
        "view_count": 7859,
        "collect_count": 103,
        "comment_count": 26,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/7ca06e07fdaae15600f78302df5c998a~300x300.image",
        "category": "前端",
        "content": "先看效果：\r\n\r\n![聊天.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c714e89f2349ca876d8de93be3a59d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 准备工作\r\n\r\n下面让我们开始完成这个机器人接入：\r\n\r\n**所需资源：**\r\n\r\n1.  可爱猫机器人\r\n1.  openApi密钥\r\n1.  一个微信小号\r\n\r\n## openApi密钥获取\r\n\r\n注册流程：<https://www.v2ex.com/t/900126?p=3>\r\n\r\n上面讲的很清楚啦，按照步骤就行\r\n\r\n有账号之后去这里获取api key:\r\n\r\n<https://beta.openai.com/account/api-keys>\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97094c75317a4a9eb1ff99d0efb23520~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这样就获取到了调用chatGpt所需要的机器人\r\n\r\n## 可爱猫资源下载：\r\n\r\n<https://www.123pan.com/s/Tio9-tCzv3>提取码:juej\r\n\r\n这里我们通过其中的ihttp插件进行开发\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941966265d5446b692626b03f3fb8216~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n开发文档：<https://doc.vwzx.com/web/#/6?page_id=123>\r\n\r\n下载好后，安装微信，并打开可爱猫\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf07271598e245b39e4c8de43ce322fc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n然后登录微信\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1afeb51fb09741248b066e7965c0f1e8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n到此准备工作就暂时完成啦，下面开始让我们用node写一个服务，供机器人调用\r\n\r\n  \r\n\r\n\r\n# 开发node服务\r\n\r\n这里我才用的是express开发\r\n\r\n首先新建server.js,并定义一个接口\r\n\r\n```\r\nlet express = require('express');\r\nlet app = express();\r\napp.post('/api/list', async function (req, res) {\r\n  //这里写接口处理逻辑\r\n}\r\n/**\r\n* 监听8090端口\r\n*/\r\napp.listen('8090');\r\n```\r\n\r\n下面开始在接口里面写我们的处理逻辑：\r\n\r\n这里讲一下插件原理：插件会把接受到的消息用json字符串的形式传递给我们，我们要做的就是根据json字符串返回的信息，返回对应的json代表的事件。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f649eeaaab44e180ad436b8241de8a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bacd70b6bcdd4f4abcbf8d647aa044f7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n具体请看作者定义的开发文档：\r\n\r\n<https://doc.vwzx.com/web/#/6?page_id=123>\r\n\r\n接下来我们写处理逻辑：\r\n\r\n因为我们从app.post里的req拿到的是chunk参数流，不是json消息，所以我这里定义了一个函数处理\r\n\r\n```\r\nfunction parseBodyData(req){\r\n    return new Promise((resolve,reject)=>{\r\n        if (req.body?.data) {\r\n            //能正确解析 json 格式的post参数\r\n            resolve(bodyData)\r\n        } else{\r\n            var body = '', jsonStr;\r\n            req.on('data', function (chunk) {\r\n                body += chunk; //读取参数流转化为字符串\r\n            });\r\n            req.on('end', function () {\r\n                //读取参数流结束后将转化的body字符串解析成 JSON 格式\r\n                try {\r\n                    jsonStr = JSON.parse(body);\r\n                } catch (err) {\r\n                    jsonStr = null;\r\n                }\r\n                resolve(jsonStr);\r\n                // jsonStr ? res.send({\\\"status\\\":\\\"success\\\", \\\"name\\\": jsonStr.data.name, \\\"age\\\": jsonStr.data.age}) : res.send({\\\"status\\\":\\\"error\\\"});\r\n            });\r\n        }\r\n    })\r\n\r\n}\r\nmodule.exports = {\r\n    parseBodyData\r\n}\r\n```\r\n\r\n这样我们就能获得json字符串了\r\n\r\n```\r\n{\r\n    \\\"event\\\":\\\"EventGroupMsg\\\",//事件标示(当前值为群消息事件)\r\n    \\\"robot_wxid\\\":\\\"wxid_5hxa04j4z6pg22\\\",//机器人wxid\r\n    \\\"robot_name\\\":\\\"\\\",//机器人昵称，一般为空\r\n    \\\"type\\\":1,//1/文本消息 3/图片消息 34/语音消息  42/名片消息  43/视频 47/动态表情 48/地理位置  49/分享链接  2000/转账 2001/红包  2002/小程序  2003/群邀请\r\n    \\\"from_wxid\\\":\\\"18900134932@chatroom\\\",//群id，群消息事件才有\r\n    \\\"from_name\\\":\\\"微群测\\\",//群名字\r\n    \\\"final_from_wxid\\\":\\\"sundreamer\\\",//发该消息的用户微信id\r\n    \\\"final_from_name\\\":\\\"遗忘悠剑o\\\",//微信昵称\r\n    \\\"to_wxid\\\":\\\"wxid_5hxa04j4z6pg22\\\",//接收消息的人id，（一般是机器人收到了，也有可能是机器人发出的消息，别人收到了，那就是别人）\r\n    \\\"msg\\\":\\\"图片https://b3logfile.com/bing/20201024.jpg\\\",//消息内容(string/array) 使用时候根据不同的事件标示来定义这个值，字符串类型或者数据类型\r\n    \\\"money\\\":0.01 //金额，只有\\\"EventReceivedTransfer\\\"事件才有该参数\r\n}\r\n```\r\n\r\n接下来我们在接口逻辑里调用这个函数\r\n\r\n```\r\nlet { parseBodyData } = require('./utils.js');\r\nlet { getOpenAiReply } = require('./openai/index.js')\r\nlet express = require('express');\r\nlet app = express();\r\napp.post('/api/list', async function (req, res) {\r\n  //正确解析json 格式的post参数\r\n    let data = await parseBodyData(req)\r\n  let reg = /wxid=(.*)]/g\r\n  reg.test(data.msg)\r\n  let callSomeoneId = RegExp.$1  //获取当前发送消息人的wxID\r\n  //要@机器人才聊天\r\n\\tif (data?.msg?.indexOf('@at') > -1 && callSomeoneId == data.robot_wxid) { \r\n            const newMsg = data.msg.substr(data.msg.lastIndexOf('  ')).trim()\r\n            let robotAnswer = await getOpenAiReply(newMsg) //调用chatGpt获取回复\r\n            console.log(robotAnswer, 'robotAnswer')\r\n            return res.json(\r\n                {\r\n                    \\\"success\\\": true,//true时，http-sdk才处理，false直接丢弃\r\n                    \\\"message\\\": \\\"successful!\\\",\r\n                    \\\"event\\\": \\\"SendGroupMsgAndAt\\\",//告诉它干什么，SendImageMsg是发送图片事件\r\n                    \\\"robot_wxid\\\": data.robot_wxid,//用哪个机器人发\r\n                    \\\"to_wxid\\\": '',//发到哪里？群/好友\r\n                    \\\"member_wxid\\\": data.final_from_wxid,\r\n                    \\\"member_name\\\": data.final_from_name,\r\n                    \\\"group_wxid\\\": data.from_wxid,\r\n                    \\\"msg\\\": robotAnswer,//发送的内容\r\n                }\r\n            )\r\n        }\r\n   \r\n  \r\n}\r\n/**\r\n* 监听8090端口\r\n*/\r\napp.listen('8090');\r\n```\r\n\r\n这里我定义了个getOpenAiReply函数，获取chatGpt的回答，代码如下\r\n\r\n```\r\nimport remark from 'remark'\r\nimport stripMarkdown from 'strip-markdown'\r\nimport { Configuration, OpenAIApi } from 'openai'\r\nimport  dotenv from 'dotenv'\r\nconst env = dotenv.config().parsed // 环境参数\r\nconsole.log(env,'envenvenv');\r\nconst configuration = new Configuration({\r\n  apiKey: env.OPENAI_API_KEY,\r\n})\r\n const openai = new OpenAIApi(configuration)\r\n\r\n async function getOpenAiReply(prompt) {\r\n  console.log('🚀🚀🚀 / prompt', prompt)\r\n  const response = await openai.createCompletion({\r\n    model: 'text-davinci-003',\r\n    prompt: prompt,\r\n    temperature: 0.9, // 每次返回的答案的相似度0-1（0：每次都一样，1：每次都不一样）\r\n    max_tokens: 4000,\r\n    top_p: 1,\r\n    frequency_penalty: 0.0,\r\n    presence_penalty: 0.6,\r\n    stop: [' Human:', ' AI:'],\r\n  })\r\n\r\n  const reply = markdownToText(response.data.choices[0].text)\r\n  console.log('🚀🚀🚀 / reply', reply)\r\n  return reply\r\n}\r\n\r\nfunction markdownToText(markdown) {\r\n  return remark()\r\n    .use(stripMarkdown)\r\n    .processSync(markdown ?? '')\r\n    .toString()\r\n}\r\nmodule.exports={\r\n  getOpenAiReply\r\n}\r\n```\r\n\r\n这里参考的是这个git项目：<https://github.com/wangrongding/wechat-bot?utm_source=gold_browser_extension>\r\n\r\n可以看作者的readme去理解\r\n\r\n上面就实现了整个机器人调用chatgpt的过程，接下来让我们把这个服务接入\r\n\r\n# 接入到微信机器人\r\n\r\n由于我是本地起到服务，所以我用了一个内网传透代理，代理到本地我们的服务端口8090\r\n\r\n我用的是natapp，具体使用可以百度一下 natapp内网传透，我这里找了个教程：<https://www.pudn.com/news/628bb32a16e0ca71414723be.html>\r\n\r\n启动natapp后，我们就能获得网址：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193d5cc6fad74c7d8d348eb1146ac5c8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n然后我们把这个网址填入到插件的地方\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de63bc0da4cd474187550d859ff9ed0a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这样就大功告成啦！！！赶快动手试试吧，让你的群也充满欢声笑语！\r\n\r\n# 项目代码：\r\n\r\n<https://github.com/webfamer/wx-chatgpt>"
    },
    {
        "article_id": "7158285916266561572",
        "snapshot": "",
        "title": "前端框架对比（主要吐槽 React ）",
        "preview": "现状对比 构建工具 与 create-vue 相比， create-react-app 的简陋程度很难让人相信前者出自个人开发者（组成的团队），而后者出自国际大厂；以至于尤雨溪亲自下场，建议 Reac",
        "author": "黑湖科技移动端",
        "view_count": 29049,
        "collect_count": 138,
        "comment_count": 240,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/e5212b3c9953329e701f49f33e78f5eb~300x300.image",
        "category": "前端",
        "content": "现状对比\r\n====\r\n\r\n构建工具\r\n----\r\n\r\n与 create-vue 相比， create-react-app 的简陋程度很难让人相信前者出自个人开发者（组成的团队），而后者出自国际大厂；以至于[尤雨溪亲自下场](https://twitter.com/youyuxi/status/1540359515819847680)，建议 React 使用 Vite、Vitest 而不是 CRA 和 jest（：虽然这种在别人坟头蹦迪的行为不太友好，但我觉得至少这个建议挺有道理的；\r\n\r\ncreate-vue 生成的项目，依赖的工具包干净整洁，CRN 则一堆标黄，不清楚是不是一定要崩掉或是再来一次 [left-pad](https://zhuanlan.zhihu.com/p/20707235) 才想起要升级依赖；\r\n\r\n生态\r\n--\r\n\r\nVue 官方开发并维护路由、状态管理、测试、IDE 插件等；React 只有 React，甚至开发文档都不够友好，以至于需要重写（还没写完） https://beta.reactjs.org/ ; code push 、IDE 插件设置需要友商 MS 来提供；React 源码 flow 编写（曾经是先进性代表，现在使用较少），Vue（Vue 3 之前曾使用 flow）、SolidJS 等现代框架都使用 TS；\r\n\r\n当然，上面这些对比可能不是因为 Meta 不厉害，而是因为 Meta 太超前。\r\n\r\n> Facebook 是一家技术很厉害的公司，能够超前做一些外界没有的东西，但等外界把这个东西做出来了，Facebook 就发现自己迁移不过去了，被自己过去超前做的技术锁定了，因为迁移成本太高。举个例子，在还没有 webpack 的时候 Facebook 就有自己很好的前端构建流水线，但 webpack 出来后 Facebook 无法迁移到 webpack，甚至无法轻易把 transpiler 迁移到 Babel。\r\n> \r\n> 如果我没记错的话，Babel 作者 Sebastian McKenzie 进入 Facebook 后做过一个项目，就是帮助 Facebook 迁移到 Babel。为什么呢？因为在外界还没有 Babel 的时候，甚至在 Babel 前身 6to5 还没出现的时候，Facebook 内部的流水线已经有自己的 transpiler，能够把一部分 ES6 语法转译为 ES5。当时我们可爽了，在外部根本还没意识到能这样做事情的时候，我们已经可以随手写 ES6 了。但有了 Babel 后，内部流水线根本不兼容中间插入 Babel 这一步，所以就需要专门改造这个流水线才能迁移到 Babel。而且 Facebook 已有的大量代码的 ES6 写法是基于内部 transpiler 写的，谁能保证迁移到 Babel 后 100% 兼容？迁移到 Babel 后如果编译出错了，那还能找出来修复。如果不出错，但实际执行结果略微不一样，导致出现线上事故，那怎么办？\r\n> \r\n> React 在写的时候，是基于上述 Facebook 内部流水线写的，所以自然是内部有什么工具就依赖什么工具。React 一开始写的时候，其实是没有 Babel、TypeScript 和 Flow 的，但有上述内部 transpiler，所以就这样写了。到后来有了 Flow，而且要保证依赖于 React 的代码能够得到正确的 Flow 类型推断，自然就加上了 Flow 注释。此外，内部流水线应该是从来没做过 TypeScript 支持的，所以估计就算想用 TypeScript 来写也做不到，因为这不是加个 webpack 插件就能支持的。\r\n\r\n周边\r\n--\r\n\r\n好的一方面是 Meta 一直保持 RN 的迭代更新，而与之相对的阿里 WEEX 项目，活跃程度就差好多，WEEX 2.0 从2021年说到现在，还是神龙见首不见尾；腾讯的 hippy 也是从去年宣传至今，仍未发布。RN 的发展也不是一帆风顺，Airbnb、Notion 因性能问题弃用 RN 转投原生，Flutter 作为后起之秀，因为更好的性能，越来越流行（不支持热更新；Dart 与 JS 相比，学习曲线大；Flutter 包大；嵌套丑）。\r\n\r\n  \r\n\r\nReact 厉害的地方\r\n===========\r\n\r\nJSX、hooks、vdom（fiber）\r\n---------------------\r\n\r\nReact 的超前，体现在首次提出或是首次让以上概念流行，并被 Vue、 SolidJS 等框架借鉴；JSX 简单灵活，学习成本几乎没有，也被 Vue、SolidJS 接纳；hooks + function component 的方式，基本能够代替之前的 class component，“启发” 了 Vue 的 composition api，hooks 成为前端开发范式；\r\n\r\nReact 不那么厉害的地方\r\n==============\r\n\r\n### JSX\r\n\r\nVue 虽然也支持 JSX/TSX，但是更推荐使用 template 模板语法；因为 JSX 过于灵活，而相对呆板的 template 能实现大多数功能的同时，在编译阶段就能[进行优化](https://template-explorer.vuejs.org/#eyJzcmMiOiJcblxuICA8bWFpbj5cbiAgICA8cD57eyBjb3VudCB9fTwvcD5cbiAgICA8YnV0dG9uIEBjbGljaz1cIm9uQWRkQ2xpY2tcIj5hZGQ8L2J1dHRvbj5cbiAgICA8YnV0dG9uIEBjbGljaz1cIm9uRGVsZXRlQ2xpY2tcIj5kZWxldGU8L2J1dHRvbj5cbiAgICA8YnV0dG9uIEBjbGljaz1cIm9uQ2hhbmdlVGltZVwiPmNoYW5nZSB0aW1lPC9idXR0b24+XG4gICAgPHA+c3NzPC9wPlxuICA8L21haW4+XG4iLCJzc3IiOmZhbHNlLCJvcHRpb25zIjp7ImhvaXN0U3RhdGljIjp0cnVlLCJzY29wZUlkIjoic2NvcGUtaWQifX0=)。\r\n\r\n比如下面这段代码：\r\n\r\n    <main>\r\n      <p>{{ count }}</p>\r\n      <!-- cacheHandlers 从 cache 中获取函数 -->\r\n      <button @click=\\\"onAddClick\\\">add</button>\r\n      <button @click=\\\"onDeleteClick\\\">add</button>\r\n      <!-- 静态数据，编译之后提升为 _hoisted_1，render 时无需重新执行 -->\r\n      <p>static</p>\r\n    </main>\r\n\r\n经过编译后：\r\n\r\n    import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, createCommentVNode as _createCommentVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \\\"vue\\\"\r\n    \r\n    const _withScopeId = n => (_pushScopeId(\\\"scope-id\\\"),n=n(),_popScopeId(),n)\r\n    const _hoisted_1 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\\\"p\\\", null, \\\"static\\\", -1 /* HOISTED */))\r\n    \r\n    export function render(_ctx, _cache, $props, $setup, $data, $options) {\r\n      return (_openBlock(), _createElementBlock(\\\"main\\\", null, [\r\n        _createElementVNode(\\\"p\\\", null, _toDisplayString(_ctx.count), 1 /* TEXT */),\r\n        _createElementVNode(\\\"button\\\", {\r\n          onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.onAddClick && _ctx.onAddClick(...args)))\r\n        }, \\\"add\\\"),\r\n        _createElementVNode(\\\"button\\\", {\r\n          onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.onDeleteClick && _ctx.onDeleteClick(...args)))\r\n        }, \\\"add\\\"),\r\n        _hoisted_1\r\n      ]))\r\n    }\r\n    \r\n    // Check the console for the AST\r\n\r\nSolidJS 在支持 JSX 的同时，也能够在编译阶段进行优化，主要是通过提供特定的流程控制组件：\r\n\r\n    import { render } from 'solid-js/web';\r\n    import { createSignal, For } from 'solid-js';\r\n    \r\n    function App() {\r\n      const [cats, setCats] = createSignal([\r\n        { id: 'J---aiyznGQ', name: 'Keyboard Cat' },\r\n        { id: 'z_AbfPXTKms', name: 'Maru' },\r\n        { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }\r\n      ]);\r\n      \r\n      return (\r\n        <ul>\r\n          <For each={cats()}>\r\n          {(cat, i) => (\r\n            <li>\r\n              <a target=\\\"_blank\\\" href={`https://www.youtube.com/watch?v=${cat.id}`}>\r\n                {i() + 1}: {cat.name}\r\n              </a>\r\n            </li>\r\n          )}\r\n        </For>\r\n        </ul>\r\n      );\r\n    }\r\n    \r\n    render(() => <App />, document.getElementById('app'))\r\n    \r\n\r\n与 SolidJS 、 Vue 相比，React 在编译阶段所做的事情相对较少:\r\n\r\n    import {useState} from 'react';\r\n    const App = ()=>{\r\n      const [count,setCount]=useState();\r\n      const [list]=useState([{name:'wjz'}]);\r\n      return <>\r\n          <p>{count}</p>\r\n          <div>app</div>\r\n        {list.map(v => <p>{v.name}</p>)}\r\n        </>\r\n    }\r\n\r\n编译后[结果](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=JYWwDg9gTgLgBAbwK4GcCmBlGBDGaC-cAZlBCHAORRrYDGMFA3AFC0QB2K8AgmGHAF44ACgCUAgHwJmcOG07wA2myTsYAGnQwAwhFUwAugNSYceMS1nyucRQBtgXIyay40wxQnbYQaAFwUAO4AVgBeFPgGopZw1DBIUOxwADwSMrIZyWBSKmr4yQD02ekZKQAmwABuEth8hRXVJYgOXAB0ILXClYISKdkIla3evvlFEqL4TYVp-EA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=false&targets=&version=7.18.13&externalPlugins=&assumptions=%7B%7D)：\r\n\r\n    \\\"use strict\\\";\r\n    \r\n    var _react = require(\\\"react\\\");\r\n    \r\n    const App = () => {\r\n      const [count, setCount] = (0, _react.useState)();\r\n      const [list] = (0, _react.useState)([{\r\n        name: 'wjz'\r\n      }]);\r\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\\\"p\\\", null, count), /*#__PURE__*/React.createElement(\\\"div\\\", null, \\\"app\\\"), list.map(v => /*#__PURE__*/React.createElement(\\\"p\\\", null, v.name)));\r\n    };\r\n\r\n可以看出，与 Vue 和 SolidJS 的编译结果相比，React 只是将 JSX 的预发转换为 JS 可以执行`createElement` 的语法；变量提升、缓存函数等用于加速执行时的优化，在 React 的编译结果中并没有体现；JSX 语法把灵活体现到极致，但正因为太灵活，导致编译环节进行优化困难重重。\r\n\r\n  \r\n\r\n### hooks\r\n\r\nReact 创造性的提出了使用 hooks 来解决代码复用的问题，然后用一个不那么好的实现，引入了其他问题。\r\n\r\n1.  useMemo/useCallback/useEffect 需要手动处理依赖关系\r\n2.  无生命周期，需要通过 useEffect 模拟；\r\n    \r\n3.  Hooks 通过链表实现，限制了调用顺序，不能出现在条件分支中；\r\n    \r\n4.  Function 组件有可能会执行多次；\r\n    \r\n\r\nVue 的 composition api 借鉴了 React，但在设计上：\r\n\r\n1.  Vue 在 0.x 版本开始，就是通过依赖追踪来实现更新（从 defineProperty 到 Proxy）；composition api 的设计一脉相承，自动收集依赖，不需要手动处理依赖关系；\r\n    \r\n2.  保留了 onMounted、onUpdated 生命周期；\r\n    \r\n3.  Hooks 可以出现在条件分支中；\r\n    \r\n\r\n    // 在 Vue 中，这是可以的\r\n    if (n <= 3) {\r\n      watchEffect(() => {\r\n        console.log(\\\"time changed\\\", time.value);\r\n      });\r\n    }\r\n\r\n 4.Setup 函数只执行一次；  \r\n\r\nReact 需手动处理依赖关系，相当于把优化手段交给开发者。虽然有 eslint 工具辅助，但开发体验不佳；\r\n\r\nSolideJS 语法类似 React，实现类 Vue，和 Vue 致敬 React 的同时，一起教 React 团队实现 hooks 的正确方式：\r\n\r\n    import { render } from \\\"solid-js/web\\\";\r\n    import { createSignal, createEffect } from \\\"solid-js\\\";\r\n    \r\n    function Counter() {\r\n      console.log('render only once');\r\n      const [count, setCount] = createSignal(0);\r\n      const increment = () => setCount(count() + 1);\r\n      // 无需手动处理依赖\r\n      createEffect(() => console.log(count()));\r\n      return (\r\n        <button type=\\\"button\\\" onClick={increment}>\r\n          {count()}\r\n        </button>\r\n      );\r\n    }\r\n    \r\n    render(() => <Counter />, document.getElementById(\\\"app\\\")!);\r\n    \r\n\r\n好消息是 React 团队也意识到自家 hooks 在使用上的问题，也就有了 [useEvent 提案](https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md) 和正在实现中的 [React forget](https://zhuanlan.zhihu.com/p/443807113)；\r\n\r\n### vdom（fiber）\r\n\r\nReact 顶层组件 state 更新，如果不进行任何优化，则所有子组件都会重新 render 一遍；\r\n\r\n    import React, { useState } from 'react';\r\n    function Foo(props) {\r\n      console.log('foo render')\r\n      return <>\r\n        {props.children}\r\n        <div>Foo</div>\r\n      </>\r\n    }\r\n    function Bar() {\r\n      console.log('bar render');\r\n      return <div>Bar</div>;\r\n    }\r\n    \r\n    function App() {\r\n      console.log('app render');\r\n      // count 每次更新，app render、 foo render、bar render\r\n      const [count, setCount] = useState(0);\r\n      return (\r\n        <div className=\\\"App\\\">\r\n          <button onClick={()=>setCount((v)=>v+1)}>{count}</button>\r\n          <Foo>\r\n            <Bar />\r\n          </Foo>\r\n        </div>\r\n      );\r\n    }\r\n    \r\n    export default App;\r\n\r\n重新 render 是为了对前后生成的 vdom 进行对比，但实际上，上面代码中的 Foo 组件和 Bar 组件都是无需更新的；在 React 16 版本之前，vdom 的对比是通过递归实现，如果组件树嵌套很深，那性能势必降低；React 16 之后，推出 fiber 架构，虽然省不掉必要的 render，但把递归 diff 改为可打断的循环，并且花费精力解决任务优先级调度问题，优化了用户体验。\r\n\r\n但 React 花大力气解决的问题，在 Vue 中从来不是问题；Vue 在初始版本，都没有引入 vdom，通过 Object.defineProperty 的方式，直接绑定了数据更新和 dom 操作，设置省略了 diff 过程；在 Vue 2中，为了减少内存占用和实现跨平台，引入了 vdom，但依然保持了细粒度的更新逻辑，仅执行组件级别的 diff，而不会去执行整棵 dom 树的 diff；在 Vue 3 中，并没有跟进 React 实现 fiber，因为这是一件可以（花费大经理）但没必要（收益相对较小）的事情。Vue 在设计之初，因为 `Object.defineProperty` 的原因，无法通过 polyfill 的方式来进行兼容非主流浏览器。在 Vue 3 中，Proxy 的使用也意味着 IE11 以下版本浏览器无法使用。不过 2022 年了，微软自己都在跟 IE 告别~\r\n\r\n### 性能\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae09588c22444f9aec1cf5dd24ef445~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n讲道理，随着硬件性能的提升，大多数框架在大多数场景下，一般是不会出现性能问题的。虽然跑分可能并不重要，但 React 的数据甚至比不过类 React 框架 Inferno、Preact 有些让人迷惑；再加上代码体积，Preact 为 3kb， React 为 40 +kb，纯 web 端有不少业务可以尝试进行迁移；不过，列举的这俩类 React 框架，并没有百分百实现 React 的 API，所以考虑到 React 的生态，迁移的成本和收益需要多做考量。\r\n\r\n为什么类 React 框架这么多，而且体积更小、跑得比 React 还要快呢？而类 Vue 框架则相对较少呢？\r\n\r\n> 这其实涉及一个难度问题，在angular里面自带了一个HTML parser与JS parser。 而在React里面， [JSX parser](https://www.zhihu.com/search?q=JSX+parser&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A814347078%7D)已经被babel 插件外置了。因此少了最难的[parser](https://www.zhihu.com/search?q=parser&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A814347078%7D)部分。\r\n> \r\n> 其次是 先行者的研究，我们可以做大量的裁减。\r\n> \r\n> 虽然React的库很大，但是它一半的代码都在事件系统中，而我们可以一个简单的事件系统（不用支持旧式IE，就不用管focus, blur, select,mouseenter,mouserleave, wheel,input 这些令人头痛的兼容问题）。代码量变成1.2~1.5万行了。\r\n> \r\n> 然后我们发现React还有四分之一是各种友好的错误提示，删掉这些用于生产环境的代码后，大概不到1万行。\r\n> \r\n> React仓库把每个模块划分得很细，因此这些我们不想用的东西可以轻松忽略掉。\r\n> \r\n> 然后我们看它最核心的虚拟DOM [diff算法](https://www.zhihu.com/search?q=diff%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A814347078%7D)，打从最开始的virtual-dom库开始，人们就发现更快的diff优化方案，原来官方做的东西是不最优的（fb方面其实更关注于其平台覆盖度，让它可以在各种平台上运行，而不是DOM环境 ）。于是大家在[virtual-dom](https://www.zhihu.com/search?q=virtual-dom&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A814347078%7D)上面的改动才会更来劲。diff算法基本上把字符串算法那套挪过来了，比如最短编辑长度距离，最长上升序列。。。\r\n> \r\n> 作者：司徒正美 链接：https://www.zhihu.com/question/344288548/answer/814347078 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 \r\n\r\n  \r\n\r\n作者：@建忠"
    },
    {
        "article_id": "7183698948194828325",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5579b8eb289a47d9a05199f9ee5a635b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "【网站分享】- Three.js - 衣服定制系统",
        "preview": "在逛Three.js论坛的时候发现的，感觉很有意思，个性化定制衣物，可以调节衣服上不同部位的颜色，还可以添加文字、图案到衣服模型上~",
        "author": "Tomorrowed",
        "view_count": 10881,
        "collect_count": 115,
        "comment_count": 32,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/cff3ca53eb1c1dd8a232ca5ed5414ef2~300x300.image",
        "category": "前端",
        "content": "在逛Three.js论坛的时候发现的，感觉很有意思，个性化定制衣物，可以调节衣服上不同部位的颜色，还可以添加文字、图案到衣服模型上。\r\n\r\n# 原文链接\r\n[Sportswear Design Configurator - Showcase - three.js forum (threejs.org)](https://discourse.threejs.org/t/sportswear-design-configurator/8792/20)\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b015ef0756c54c7da231314b7120b2f0~tplv-k3u1fbpfcp-watermark.image?)\r\n> 【译】 - 我们的产品定制器，可以用于在**短袖、袜子、裤子、夹克**等物体上，**添加图案、文字、图片**。这些添加的图案是**用svg格式保存的**。canvas使用的是**2D矢量库（fabric.js）**，在**3D模型上把canvas当作贴图使用**。\r\n\r\n案例展示链接\r\n- [Teamwear Designer 3D (dsign4you.com)](https://dsign4you.com/3d/)\r\n\r\n\r\n# 页面展示\r\n## 起始页\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5124409623444ec4b410a9d95c07c527~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n开始页面，可以选择四种衣物，**足球、骑行、徒步、日常**。根据不同的场景，展示不同的衣物。\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0d13246e9e8411bbefebf01dcda6050~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 定制页 \r\n### 颜色面板\r\n\r\n选择 足球（运动装） - 宽松\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de8e63bbd7304972a75330e18f6d8646~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/758b7b60c8a5414890bd9b0acb78117f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n设置效果~~~\r\n- 运动色彩~\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3751aec4126408083617ea5be1fa7e8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**近距离还能看到针织效果！**\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60f86e911dfa4ff4a273125b95ea2d5b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 图案面板\r\n\r\n衣服二维展开\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3536ada7084b67849e0ea884804a24~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n裤子二维展开\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0b8c4a722a54368bac63bce695cb99c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们给衣服添加图案\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e762ce2c9aea4d039438c698b03c0cb6~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n加个掘金logo！\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b24d3e356e45eb8afad0db57439154~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n添加文字！\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1455af1b024349f5999e93f18e924c0b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 最终效果\r\n\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adbd8a695a24a8690d77aec70b03188~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 总结\r\n\r\n总结一下收获！\r\n- 根据不同使用情况，可以有不同的衣物选择，案例根据的是运动方式来区分。\r\n- 衣物分为紧身、宽松、V领等。\r\n- 衣物图案，**可以使用canvas贴图到3D模型上**，还需要找点案例。。\r\n- **衣物展示在不同视角、不同灯光会有所不同**！还有360°视觉观看效果也不一样，可以设置！\r\n- **定制分为调色和添加图案**。\r\n\r\n> 我需要安静下来，想象未来怎么安排。时间飞快时间飞快，来不及抹去昨日尘埃 - 《远行 - 李宗盛》"
    },
    {
        "article_id": "7187326853336530981",
        "snapshot": "",
        "title": "Docker安装Jenkins，Nginx，实现前端项目自动化构建",
        "preview": "Docker安装Jenkins，Nginx，实现前端项目自动化构建 安装 Docker 执行一下docker -v，可以用来查看 Docker 安装的版本信息。也可以帮助我们查看 docker 的安装",
        "author": "蝴蝶刀砍手大师",
        "view_count": 3489,
        "collect_count": 21,
        "comment_count": 6,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/a500a744a80b0c10abe9e536c4f854ac~300x300.image",
        "category": "后端",
        "content": "---\r\nslug: /\r\nsidebar_position: 1\r\ntitle: Docker安装Jenkins，Nginx，实现前端项目自动化构建\r\ndata: 2023年1月04日\r\ntheme: channing-cyan\r\n---\r\n\r\n# Docker安装Jenkins，Nginx，实现前端项目自动化构建\r\n\r\n## 安装 Docker\r\n```shell\r\n// 安装\r\ncurl -fsSL get.docker.com -o get-docker.sh\r\nsh get-docker.sh\r\n// 启动Docker服务\r\nsystemctl start docker\r\n// 开机默认启动\r\nsystemctl enable docker\r\n```\r\n执行一下`docker -v`，可以用来查看 Docker 安装的版本信息。也可以帮助我们查看 docker 的安装状态；如果正常展示版本信息，代表 Docker 已经安装成功。\r\n\r\n通过`docker ps`查看容器状态。\r\n\r\n## 安装 Jenkins\r\n\r\n### 拉取 jenkins 镜像\r\n使用 `docker pull` 命令拉取镜像\r\n```shell\r\ndocker pull jenkins/jenkins\r\n```\r\n### 运行容器\r\n```shell\r\ndocker run -d --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins\r\n```\r\n> 参数说明\r\n> - --name 定义一个容器的名字，如果没有指定，那么会自动生成一个随机数字符串当做UUID\r\n> - -d 标识是让 docker 容器在后台运行\r\n> - -p 9000:8080 端口映射，将宿主机9000端口映射到容器8080端口\r\n> - -p 50000:50000 50000端口是基于JNLP的Jenkins代理（slave）通过TCP与 Jenkins master 进行通信的端口。\r\n\r\n启动后可以通过 `docker ps` 来查看服务情况。\r\n![docker 容器状态](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00337b3c63064157bd6eb2aff8ab36fb~tplv-k3u1fbpfcp-zoom-1.image \\\"docker 容器状态\\\")\r\n\r\n**注意：**\r\n* 在云服务器的防火墙里打开8080端口才能访问。\r\n* 然后通过服务器ip：8080端口就可以访问我们的 jenkins 服务\r\n\r\n> 例如在阿里云中进行安全组配置\r\n![安全组配置](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659c219b4d1f46f28ce6bd105b942b7b~tplv-k3u1fbpfcp-zoom-1.image \\\"安全组配置\\\")\r\n\r\n### 配置Jenkins\r\n\r\n通过 `http://<ipaddress>:8080` 访问 Jenkins 界面\r\n\r\n![jenkins初始化密码](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1a27826c77a40de8a69df1598d09e34~tplv-k3u1fbpfcp-zoom-1.image \\\"jenkins初始化密码\\\")\r\n\r\n由于我们是用 docker 安装的，所以密码会被存储到容器中。\r\n管理员初始密码被放到了 `/var/jenkins_home/secrets/initialAdminPassword` 文件中。\r\n\r\n```shell\r\ndocker exec -it jenkins bash\r\n```\r\n进入容器查看密码，然后再 jenkins 页面中输入密码\r\n```shell\r\ncat /var/jenkins_home/secrets/initialAdminPassword\r\n```\r\n#### 问题：\r\n再完成上一步之后，大部分情况下会出现 **您的 Jenkins 已离线**\r\n![jenkins离线](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df087f50ce6745f983ffad3e2c13c598~tplv-k3u1fbpfcp-zoom-1.image \\\"jenkins离线\\\")\r\n\r\n> 原因是jenkins在下载插件之前会先检查网络连接，其会读取这个文件中的网址。默认是：\r\n> 访问谷歌，肯定访问不了，所以将图下的google改为www.baidu.com即可，更改完重启服务。\r\n![jenkins_default_json](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fad233e70884cfb96c1312253f0094e~tplv-k3u1fbpfcp-zoom-1.image \\\"jenkins_default_json\\\")\r\n\r\n首先我们找的 `default.json` 的位置，先进入容器`docker exec -it jenkins bash`，这个文件存放在了 `/var/jenkins_home/updates/` 目录下\r\n\r\ndocker 中的文件无法直接修改\r\n1. 方式一：可以使用 `yum -y install vim` 或者 `apt-get install vim` 命令安装。\r\n然后再通过vim进行修改，**但这种方法不推荐**\r\n```shell\r\nvim default.json\r\n```\r\n2. 方式二：把容器里面的文件拷贝到本机进行修改，然后再拷贝回去\r\n命令如下\r\n```shell\r\ndocker cp [容器名字]:[具体文件地址] [想要拷贝到本地的目标地址]\r\n#例子\r\ndocker cp redis:/test/cptest.txt ./\r\n```\r\n如果使用这种方式，命令如下：\r\n```shell\r\ndocker cp jenkins:/var/jenkins_home/updates/default.json /root/var/tmp\r\n```\r\n然后，我们把修改后的 `default.json` 拷贝回去。\r\n```shell\r\ndocker cp /root/var/tmp/default.json jenkins:/var/jenkins_home/updates \r\n```\r\n\r\n最后一步，打开 `http://<ip>:8080/pluginManager/advanced` 页面滚动到最底部 Update Site 的 URL 为：\r\n* https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\r\n\r\n该地址为 [清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/ \\\"清华大学开源软件镜像站\\\")\r\n\r\n![jenkins修改update_site](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins修改update_site.png \\\"jenkins修改update_site\\\")\r\n如果一切正常的话，就可以正常安装插件了\r\n![jenkins插件安装](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins插件安装.png \\\"jenkins插件安装\\\")\r\n\r\n如果上述步骤出问题，也可以跳过插件安装，在里面手动下载，然后在 Jenkins 的插件管理里面手动安装。\r\n\r\n\r\n### 安装插件\r\n\r\n需要安装两个插件，在\r\n\r\n首页 > 系统管理 > 插件管理 > 可选插件 > 搜索选中 NodeJS > 安装完成后重启服务\r\n\r\n* NodeJs: 代码打包时需要的环境\r\n* Publish Over SSH: 打包完成后通过这个插件ssh连接发送到远程服务器\r\n\r\n1. 配置 NodeJs\r\n这一步是因为有时候用最新的版本安装包会失败，推荐使用最新的稳定版本，我这里是使用的16.13.1这个版本。在\r\n\r\n首页 > 系统管理 > 全局工具工具配置 > NodeJS > 新增\r\n![jenkins_node配置](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins_node配置.png \\\"jenkins_node配置\\\")\r\n\r\n2. 新建项目任务实现构建及部署\r\n\r\n(1) 首页 > 新建任务 > 构建一个自由风格的软件项目\r\n![jenkins新建任务](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins新建任务.png \\\"jenkins新建任务\\\")\r\n\r\n(2) git源码管理\r\n配置这一步是让jenkins去哪个git仓库拉取代码。\r\n![jenkins_git配置](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins_git配置.png \\\"jenkins_git配置\\\")\r\n\r\n* Repository URL: git仓库的地址\r\n* Credentials: 连接git仓库的认证方式，一般使用Username with password或者Secret Text的方式，前者就是用户名和密码的方式，后者是需要生成token密钥，用密钥连接。\r\n* Branches to build: 指定拉取的分支\r\n\r\n(3) 指定构建环境\r\n![jenkins构建环境](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins构建环境.png \\\"jenkins构建环境\\\")\r\n\r\n(4) 构建脚本\r\n![jenkins构建配置脚本](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins构建配置脚本.png \\\"jenkins构建配置脚本\\\")\r\n\r\n这里的命令根据实际情况来\r\n```shell\r\nnpm install\r\nnpm run build\r\ncd dist\r\ntar zcvf dist.tar.gz *\r\n```\r\n\r\n## 安装 Nginx\r\n\r\n获取nginx官方镜像\r\n```shell\r\ndocker pull nginx\r\n```\r\n\r\n将nginx关键目录映射到本机，目的是为了方便我们修改 nginx 的配置\r\n\r\n```shell\r\nmkdir -p /root/nginx/www /root/nginx/logs /root/nginx/conf\r\n```\r\n* www: nginx存储网站网页的目录\r\n\r\n* logs: nginx日志目录\r\n\r\n* conf: nginx配置文件目录\r\n\r\n`481e121fb29f` 为容器id,根据实际情况修改\r\n```shell\r\ndocker cp 481e121fb29f:/etc/nginx/nginx.conf /root/nginx/conf\r\n```\r\n\r\n创建新nginx容器nginx-web,并将 www,logs,conf目录映射到本地\r\n```shell\r\ndocker run -d -p 80:80 --name nginx-web -v /root/nginx/www:/usr/share/nginx/html -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/logs:/var/log/nginx nginx\r\n```\r\n![docker 容器状态](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/docker_ps.png \\\"docker 容器状态\\\")\r\n\r\n配置 nginx config \r\n进入到/root/conf/nginx.conf 添加如下配置\r\n\r\n```shell\r\nserver {\r\n  listen 80;\r\n  charset utf-8;\r\n  server_name 192.168.112.135;\r\n\r\n  location / {\r\n    proxy_pass http://192.168.112.135:8080;\r\n    proxy_redirect default;\r\n  }\r\n}\r\n```\r\n\r\n启动nginx\r\n```shell\r\ndocker start nginx-web\r\n```\r\n\r\nnginx 重启命令\r\n```shell\r\ndocker exec -it nginx service nginx reload\r\n```\r\n\r\n## 把打包后进行部署\r\n\r\n1. 首先在 jenkins 首页配置下publish over ssh的ssh连接配置。\r\n\r\n在 首页 > 系统管理 > 系统配置 > Publish over SSH > 新增\r\n![jenkins_ssh](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins_ssh.png \\\"jenkins_ssh\\\")\r\n\r\n填入这几个配置项，主要是`Hostname`和`Username`，勾选上 Use password authentication, or use a different key，然后输入`Password`。\r\n\r\n完成之后选择构建后的操作\r\n![jenkins构建后操作](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins_ssh.png \\\"jenkins_ssh\\\")\r\n\r\n![jenkins构建后配置](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/jenkins构建后配置.png \\\"jenkins构建后配置\\\")\r\n\r\n* Source files: 源文件，也就是刚才我们压缩好的文件，dist.tar.gz\r\n* Remove prefix: 移除的前缀，就是移除压缩文件前面的dist文件夹，不然移到远程服务器后也有dist文件夹\r\n* Exec command: 完成把文件移动到远程服务器后执行的shell命令，这里大概就是清空之前的项目文件夹下所有文件，然后解压dist.tar.gz到项目文件夹下，最后删除dist.tar.gz压缩包\r\n\r\n```shell\r\ncd ~\r\nmv ./dist.tar.gz /root/nginx/www\r\ncd /root/nginx/www\r\ntar zxvf dist.tar.gz\r\nrm -rf dist.tar.gz\r\n```\r\n\r\n最后一步就是在 Github 的项目中添加 Webhooks\r\n\r\n配置的 Payload URL 为 `http://<jenkins地址>/github-webhook/`\r\n\r\n![github_webhook配置](https://raw.githubusercontent.com/fh332393900/fh332393900.github.io/master/web/Jenkins/img/github_webhook配置.png \\\"github_webhook配置\\\")\r\n\r\n最后推送代码，就可以在 jenkins 中看到任务会自动构建，然后进行发布了。\r\n"
    },
    {
        "article_id": "7171711316422295560",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a476d427434d41fca61abe9058df17fe~tplv-k3u1fbpfcp-watermark.image?",
        "title": "WebRTC + Tensorflow.js 在运动健康类项目中的前端应用🔥",
        "preview": "人体姿态识别，图像分割，目标检测等等；你可能在想：作为一个前端开发员，既没有人工智能和机器学习的基础，又没有深厚的学术理论功底能做深度学习吗？ 答案是肯定的。",
        "author": "荣顶",
        "view_count": 9837,
        "collect_count": 294,
        "comment_count": 41,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/26f254d4ee2f1e58081b5f503fd01dda~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: smartblue\r\nhighlight: atom-one-dark\r\n---\r\n\r\n>作者：[荣顶](https://github.com/wangrongding) 、[github](https://github.com/wangrongding)  \r\n声明：文章为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n\r\n[👉🏻 本文 demo 在线体验地址](https://frontend-park.vercel.app/tensorflow/pose-detection)  \r\n[👉🏻 源代码地址](https://github.com/wangrongding/frontend-park)\r\n\r\n## 前言\r\n\r\n你可能会想，作为一个`前端开发员`,既没有人工智能和机器学习的基础，又没有深厚的学术理论功底能做`深度学习`吗？\r\n\r\n答案是肯定的。 为什么呢？\r\n\r\n首先，我们要知道的是，目前社区中已经有很多非常成熟并且已经训练好的模型，比如：`人脸识别`、`人体姿态识别`、`图像分类`、`图像分割`、`目标检测`等等等等，非常多，这些模型都是经过大量的数据训练得到的，我们只需要学会如何使用这些模型，并不需要自己去写算法，去训练模型。它就像 `npm` 的包一样，安装它，看文档，使用它，就可以了。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68d9f182272d4746bd2d1bed0ece7087~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果我们只是从`应用深度学习`的角度出发，去使用现成的模型，来解决我们现实中存在的问题。那么就像前后端分离一样，让专业的人去做专业的事，深度学习也是如此，我们并不需要去花很多时间，深入了解深度学习的原理，也不需要自己去训练复杂的算法模型。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acebb3accef54dd2a829518fb3a241b3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n而 `Tensorflow.js` 就是一扇前端开发人员进入深度学习领域最好的大门，它提供了一套完整的 API，让我们可以很方便的使用深度学习模型。它可以在浏览器中运行，也可以在 node.js 中运行。它的 API 设计非常简单，而且它的文档也非常详细，我们可以很快的上手。\r\n\r\n一些常见的深度学习模型可以看 [👉🏻 开箱即用的 TensorFlow.js 预训练模型](https://www.tensorflow.org/js/models),它们都是开源的[👉🏻 Github 地址](https://github.com/tensorflow/tfjs-models)。\r\n\r\n社区中所有的模型可以在这里找到 [👉🏻 TensorFlow Hub](https://tfhub.dev/)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc9910cbcf6499bae1350908fe5f45b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 人体姿态识别\r\n\r\n在这篇文章中，我们将会介绍如何使用 WebRTC 相关 API 结合 `Tensorflow.js` 来实现一个运动直播的应用。\r\n\r\nTensorFlow.js 与 WebRTC 结合，可以实现实时的人体姿态检测，从而可以在运动健康的直播中实现人体姿态的跟踪和识别。这样“老师”，或者“学员”能够更加直观的感受到自己和他人的身体姿态是否一致，能更清晰的观察动作的准确性，一致性。当然，这个应用还可以用于其他的场景，比如：`健身房`、`瑜伽教室`、`舞蹈教室`等等。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc811da695b44760a670da3efbe85cb2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n人体姿态估计的方法有很多，如：基于深度学习的方法、基于传统机器学习的方法、基于几何的方法、基于动态规划的方法、基于粒子滤波的方法、基于模板匹配的方法、基于图像分割的方法、基于人体姿态模型的方法等。\r\n\r\n基于深度学习的方法是目前最流行的人体姿态估计方法。基于深度学习的方法可以分为两类：一类是基于 CNN 的方法，如：OpenPose、PoseNet 等；另一类是基于 RNN 的方法，如：PoseFlow 等。\r\n\r\n本文将介绍基于深度学习的方法，使用 `Tensorflow.js` 的 `posenet` 模型来实现人体姿态估计。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5028be9ac8394c81967d047b9a669bd3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nok，相关铺垫就到这里，下面我们开始正式的实现。\r\n\r\n## 开搞\r\n\r\n### 安装相关依赖\r\n\r\n首先，我们需要安装 `Tensorflow.js` 相关的依赖。\r\n\r\n```sh\r\nnpm i @tensorflow-models/pose-detection @tensorflow/tfjs-backend-webgl\r\n```\r\n\r\n其中 `@tensorflow-models/pose-detection` 这个包提供了多个最先进的模型来运行实时姿势检测。`@tensorflow/tfjs-backend-webgl` 这个包为 TensorFlow.js 实现了一个 GPU 加速的 WebGL 后端。可以让我们在浏览器中运行 `Tensorflow.js`。\r\n\r\n安装好后，引入它们\r\n\r\n```typescript\r\nimport * as poseDetection from '@tensorflow-models/pose-detection'\r\nimport '@tensorflow/tfjs-backend-webgl'\r\n```\r\n\r\n一开始我不知道使用`@tensorflow/tfjs-backend-webgl`,后来发现不引入会有以下错误\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed36a7131ead4480bd935f34050a62b4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n准备工作都做好了，下面我们开始正式的实现。\r\n\r\n### 加载模型，创建检测器\r\n\r\n目前`@tensorflow-models/pose-detection` 已有 3 种可选模型，分别是：\r\n\r\n`BlazePose`、`MoveNet`、`PoseNet`。其中 `BlazePose` 是基于 CNN 的方法，`MoveNet` 和 `PoseNet` 是基于 RNN 的方法。\r\n\r\n然后它们大概的特点为：\r\n\r\n- MoveNet：是一种速度快、准确率高的姿态检测模型，可检测人体的 17 个关键点，能够以 50+ fps 的速度在笔记本电脑和手机上运行。\r\n- BlazePose：MediaPipe BlazePose 可以检测人体 33 个关键点，除了 17 个 COCO 关键点之外，它还为脸部、手和脚提供了额外的关键点检测。\r\n- PoseNet：可以检测多个姿态，每个姿态包含 17 个关键点。\r\n\r\n#### 人体关键点\r\n\r\n到这里，我们需要了解下人体关键点的定义：\r\n\r\n> 人体姿态估计的原理是通过检测人体的关键点来估计人体的姿态。人体的关键点包括：头部、颈部、肩部、手臂、腰部、腿部等。人体的姿态包括：站立、坐着、躺着、跑步、跳跃等。\r\n\r\n#### MoveNet, PoseNet（COCO 关键点）\r\n\r\nCOCO 关键点包括：鼻子、左眼、右眼、左耳、右耳、左肩、右肩、左肘、右肘、左手腕、右手腕、左臀、右臀、左膝、右膝、左脚踝、右脚踝。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84f1827caf5a4efca70aea3cd5652867~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### BlazePose\r\n\r\nBlazePose 返回的关键点更多， 有 33 个关键点，除了 17 个 COCO 关键点之外，它还为脸部、手和脚提供了额外的关键点检测。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bd030149f3d445b9aab44a557db6211~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### 相关逻辑\r\n\r\n`PoseNet`最简单了，这里作为演示，直接使用 `PoseNet`让大家更容易理解。 另外两个，我也会在 demo 中更新。 完整源码在这里：[frontend-park](https://github.com/wangrongding/frontend-park)\r\n\r\n好，我们继续，`PoseNet`模型后，创建检测器。\r\n\r\n其中 createDetector，接收两个参数，第一个是模型，第二个是模型的相关配置。  \r\n可配置项有很多，大家可以直接 ctrl + 鼠标左键 点击 createDetector 查看。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77c116c2e6cf4580961a18c81166c208~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里我就不一一列举了，我这里主要用到的是`modelType`,它有三种模型的类型可供选择，分别为：”lite”、”full “和 “heavy”。这些改变了检测模型的大小。Lite 的检测精度最低，但性能最好，而 “heavy “的检测精度最好，但更消耗性能，而 “full “则处于中间位置。我们选择了它 。\r\n\r\n然后我们可以定义一个初始化的函数，在这里面，把一些初始化操作都完成，比如：打开摄像头，获取媒体流，并且将媒体流赋值给 video 标签...\r\n\r\n```html\r\n<video id=\\\"video\\\" autoplay playsinline class=\\\"w-[360px] h-[270px] object-fill\\\"></video>\r\n<canvas id=\\\"output\\\" width=\\\"360\\\" height=\\\"270\\\"></canvas>\r\n```\r\n\r\n```typescript\r\n// 其他地方要用到的公共变量\r\nlet posenetInput: HTMLVideoElement | HTMLImageElement | HTMLCanvasElement\r\nlet posenetOutput: HTMLCanvasElement\r\nlet posenetOutputCtx: CanvasRenderingContext2D\r\nlet detector: PoseDetector\r\nlet model: poseDetection.SupportedModels.PoseNet\r\n\r\n// 初始化\r\nconst init = async () => {\r\n  // 获取 canvas 元素\r\n  posenetOutput = document.getElementById('output') as HTMLCanvasElement\r\n  posenetOutputCtx = posenetOutput.getContext('2d')!\r\n  // 获取视频流\r\n  posenetInput = document.getElementById('video') as HTMLVideoElement\r\n  const stream = await navigator.mediaDevices.getUserMedia({\r\n    audio: false,\r\n    video: true,\r\n  })\r\n  posenetInput.srcObject = stream\r\n  // 定义模型\r\n  model = poseDetection.SupportedModels.PoseNet\r\n  // 加载模型\r\n  detector = await poseDetection.createDetector(model, {\r\n    modelType: 'full',\r\n  })\r\n  // 开始检测\r\n  detectPose()\r\n}\r\n```\r\n\r\n然后我们可以定义一个检测的函数，这里我们需要传入一个检测器，然后在这个函数里面，我们可以获取到检测到的结果，然后我们可以根据结果，来绘制我们的画布。\r\n\r\n```typescript\r\n// 开始检测\r\nconst detectPose = async () => {\r\n  // 获取检测结果\r\n  const poses = await detector.estimatePoses(posenetInput, {\r\n    flipHorizontal: false, // 是否水平翻转\r\n    maxPoses: 1, // 最大检测人数\r\n    scoreThreshold: 0.5, // 置信度\r\n    nmsRadius: 20, // 非极大值抑制\r\n  })\r\n  // 将 pose 上的 17 个关键点的坐标信息存入 pointList\r\n  const pointList = poses[0]?.keypoints || []\r\n  console.log('🚀🚀🚀 / pointList', pointList)\r\n  // 。。。绘制画布\r\n}\r\n```\r\n\r\n这里我们可以通过 `detector.estimatePoses` 获取到检测到的结果，这里我们需要传入两个参数，第一个是我们的输入，第二个是我们的配置项，例如其中的 `maxPoses`，它表示最大检测人数，我们这里设置为 1，因为我们只需要检测到一个人。\r\n\r\n检测的结果信息打印出来，如下图所示：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08d8c3746dd5496bb00a7d9db916ef1d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### 绘制画布\r\n\r\n从上面的返回信息可以看到，因为我们设置最多只检测一个人，所以检测到的结果是一个长度为 1 的数组，里面 `keypoints` 中有 17 个关键点的坐标信息，我们可以通过这些坐标信息，来绘制我们的画布。\r\n\r\n```typescript\r\n// 开始检测\r\nconst detectPose = async () => {\r\n  // 。。。接上面的代码\r\n  // 将 pose 上的 17 个关键点的坐标信息存入一个数组中\r\n  const pointList = poses[0]?.keypoints || []\r\n\r\n  // 绘制视频\r\n  posenetOutputCtx.drawImage(posenetInput, 0, 0, canvas.width, canvas.height)\r\n  // 将这 17 个关键点的坐标信息 画到 canvas 上\r\n\r\n  // 画出所有关键点\r\n  pointList.forEach(({ x, y, score, name }: any) => {\r\n    if (score > 0.5) {\r\n      // 画点\r\n      drawPoint(x, y, 5, '#f00000', posenetOutputCtx)\r\n    }\r\n  })\r\n\r\n  // 获取相邻的关键点信息\r\n  const adjacentPairs = poseDetection.util.getAdjacentPairs(model)\r\n  // 画出所有连线\r\n  adjacentPairs.forEach(([i, j]: any) => {\r\n    const kp1 = pointList[i]\r\n    const kp2 = pointList[j]\r\n    // score 不为空就画线\r\n    const score1 = kp1.score != null ? kp1.score : 1\r\n    const score2 = kp2.score != null ? kp2.score : 1\r\n    if (score1 >= 0.5 && score2 >= 0.5) {\r\n      // 画出所有连线\r\n      drawSegment([kp1.x, kp1.y], [kp2.x, kp2.y], 'aqua', 1, posenetOutputCtx)\r\n    }\r\n  })\r\n\r\n  // requestAnimationFrame(() => detectPose(detector))\r\n  setTimeout(() => {\r\n    detectPose()\r\n  }, 50)\r\n}\r\n```\r\n\r\n封装好一个画点和画线段的函数，方便上面使用。↑\r\n\r\n```typescript\r\n// 画点\r\nfunction drawPoint(x: number, y: number, r: number, color: string, ctx: CanvasRenderingContext2D) {\r\n  ctx.beginPath()\r\n  ctx.arc(x, y, r, 0, 2 * Math.PI)\r\n  ctx.fillStyle = color\r\n  ctx.fill()\r\n}\r\n// 画线段\r\nfunction drawSegment([ax, ay]: number[], [bx, by]: number[], color: string, scale: number, ctx: CanvasRenderingContext2D) {\r\n  ctx.beginPath()\r\n  ctx.moveTo(ax * scale, ay * scale)\r\n  ctx.lineTo(bx * scale, by * scale)\r\n  ctx.lineWidth = 4\r\n  ctx.strokeStyle = color\r\n  ctx.stroke()\r\n}\r\n```\r\n\r\n拿到 17 个点的信息后，我们先将视频绘制到画布上，然后再将这 17 个关键点的坐标信息画到画布上，其中只有在 `score` 大于 0.5 的时候，才会绘制到画布上。 然后我们通过 `poseDetection.util.getAdjacentPairs` 获取到相邻的关键点信息，然后再将这些关键点进行连线，绘制到画布上。\r\n\r\n然后再尾部递归调用 `detectPose` 函数，这样就可以实现实时的检测了。你可以用 `requestAnimationFrame` 来实现，也可以用 `setTimeout` 来实现，`requestAnimationFrame` 通常是每秒 60 次 , 也就是常说的 60 帧（60FPS），如果计算量特别大导致你电脑卡的话，你也可以用 `setTimeout` 自己定义间隔时长，这样就可以控制帧数了。 通常来说人眼能够感知的帧数是 24 帧，电影院的帧数也是 24 帧，所以 24 帧左右够够了。\r\n\r\n然后我们可以看到效果图：[👉🏻 体验地址在这里](https://frontend-park.vercel.app/tensorflow/pose-detection)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45428b9e6f704e9ebdbf6080bebd3380~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 将视频流传输给对端\r\n\r\n媒体流处理，创建连接和信令服务相关的逻辑，我在这个专栏前三篇文章中都有写，这里就不再赘述了。\r\n\r\n然后我们就可以通过`captureStream` API 从 canvas 中拿到视频流，然后通过 `RTCPeerConnection` 提供的 API 将视频流轨道 加到 peerConnection 中传输给对端。\r\n\r\n```typescript\r\nconst peerConnection = new RTCPeerConnection({\r\n  iceServers: [\r\n    {\r\n      urls: 'stun:stun.voipbuster.com ',\r\n    },\r\n  ],\r\n})\r\n// 获取output 中的视频流\r\nconst getVideo = () => {\r\n  const output = document.getElementById('output') as HTMLCanvasElement\r\n  const stream = output.captureStream()\r\n  return stream\r\n}\r\n\r\n// 传输视频流\r\nconst transfer = () => {\r\n  const stream = getVideo()\r\n  stream.getTracks().forEach((track) => {\r\n    peerConnection.addTrack(track, stream)\r\n  })\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n这篇文章主要是介绍了如何使用 WebRTC 与 TensorFlow.js 的结合，实现实时的人体姿态检测。这里只是简单的做了一个 demo，实际上这方面的可玩性非常高。体感游戏，换装，语音识别，人脸识别，都可以结合这个思路来实现。\r\n\r\n好了，这篇文章就到这里了，如果你觉得这篇文章对你有帮助或者有任何疑问，欢迎点赞或者在下方评论区留言，我会及时回复的。感谢支持。\r\n"
    },
    {
        "article_id": "7187346232908447803",
        "snapshot": "",
        "title": "代码整洁之道，好的代码就是为了更美好的生活！",
        "preview": "概述 美国童子军有一条简单的军规：让营地比你来时更干净。当梳理代码时，坚守此军规：每次 review 代码，让代码比你发现它时更整洁。 一位大神说过：“衡量代码质量的唯一有效标准：WTF/min”",
        "author": "零壹技术栈",
        "view_count": 3636,
        "collect_count": 51,
        "comment_count": 7,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/a9fc643b7083c0f9cd213689a197aac0~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: smartblue\r\nhighlight: a11y-dark\r\n---\r\n\r\n\r\n![背景](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54d735b1cf014ae9bbb1876d80a8e9e9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 概述\r\n\r\n美国童子军有一条简单的军规：**让营地比你来时更干净**。当梳理代码时，坚守此军规：**每次 review 代码**，**让代码比你发现它时更整洁**。\r\n\r\n一位大神说过：“衡量代码质量的唯一有效标准：**WTF/min**”，并配了一个形象的图：\r\n\r\n![代码整洁之道](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24686f9658742c5b336234e1b103d3f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n通过别人在 **review** 代码过程中，每分钟 **“爆粗”** 的次数来衡量这个代码好的程度。\r\n\r\n# 代码整洁的必要性\r\n\r\n**好的代码就是为了更美好的生活！**\r\n**Clean Code == Good Code == Good Life！** \r\n\r\n为了把自己和他人从 **糟糕的代码维护工作** 中解脱出来，**必由之路** 就是 **整洁的代码**。于个人来说，代码是否整洁影响心情；于公司来说，代码是否整洁，影响经营生存（因为代码写的烂而倒闭的公司还少吗？）。\r\n\r\n**一念天堂，一念地狱。**\r\n\r\n# 坏味道的代码\r\n\r\n开始阅读之前，大家可以快速思考一下，大家脑海里的 **好代码** 和 **坏代码** 都是怎么样的“形容”呢？\r\n\r\n如果看到这一段代码，如何评价呢？\r\n\r\n```ts\r\nif (a && d || b && c && !d || (!a || !b) && c) { \r\n    doSomething() \r\n} else {\r\n    doSomethingElse()\r\n}\r\n```\r\n\r\n上面这段代码，尽管是特意为举例而写的，要是真实遇到这种代码，想必大家都 **“一言难尽”** 吧！大家多多少少都有一些 **坏味道的代码** 的 “印象”，坏味道的代码总有一些共性：\r\n\r\n\r\n![代码坏味道.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a99ad8deff9b49839810018022bc6a7f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n那坏味道的代码是怎样形成的呢？\r\n\r\n- 上一个写这段代码的程序员经验、水平不足，或写代码时不够用心；\r\n- 业务方提出的奇葩需求导致写了很多 **hack** 代码；\r\n- 某一个模块业务太复杂，需求变更的次数太多，经手的程序员太多。\r\n\r\n当代码的坏味道已经 “弥漫” 到处都是了，这时我们应该了解一下 **重构**。接下来，通过了解 **圈复杂度** 去衡量我们写的代码。\r\n\r\n## 圈复杂度\r\n\r\n**圈复杂度** 可以用来衡量一个模块 **判定结构** 的 **复杂程度**，数量上表现为 **独立现行路径条数**，也可理解为覆盖 **所有执行路径** 使用的 **最少测试用例数**。\r\n\r\n> **圈复杂度**（Cyclomatic complexity，简写CC）也称为 **条件复杂度**，是一种 **代码复杂度** 的 **衡量标准**。由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度。\r\n\r\n\r\n### 1. 判定方法\r\n\r\n圈复杂度可以通过程序控制流图计算，公式为：\r\n\r\n> V(G) = e + 2 - n\r\n\r\n-   e : 控制流图中边的数量\r\n-   n : 控制流图中节点的数量\r\n\r\n有一个简单的计算方法：**圈复杂度** 实际上就是等于 **判定节点的数量** 再加上 `1`。\r\n\r\n### 2. 衡量标准\r\n\r\n\r\n代码复杂度低，代码不一定好，但代码复杂度高，代码一定不好。\r\n\r\n| 圈复杂度 | 代码状况 | 可测性 | 维护成本 |\r\n| --- | --- | --- | --- |\r\n| 1 - 10  | 清晰、结构化 | 高 | 低 |\r\n| 10 - 20 | 复杂 | 中 | 中 |\r\n| 20 - 30 | 非常复杂 | 低 | 高 |\r\n| >30     | 不可读 | 不可测 | 非常高 |\r\n\r\n### 3. 降低代码的圈复杂度\r\n\r\n#### 3.1. 抽象配置\r\n\r\n通过 **抽象配置** 将复杂的逻辑判断进行简化。\r\n\r\n- 优化前\r\n\r\n```ts\r\nif (type === '扫描') { \r\n    scan(args) \r\n} else if (type === '删除') { \r\n    delete(args) \r\n} else if (type === '设置') { \r\n    set(args) \r\n} else { \r\n    other(args)\r\n}\r\n```\r\n\r\n- 优化后\r\n\r\n```ts\r\nconst ACTION_TYPE = { \r\n    '扫描': scan, \r\n    '删除': delete,' \r\n    '设置': set \r\n} \r\nACTION_TYPE[type](args)\r\n```\r\n\r\n#### 3.2. 方法拆分\r\n\r\n将代码中的逻辑 **拆分** 成单独的方法，有利于降低代码复杂度和降低维护成本。当一个函数的代码很长，读起来很费力的时候，就应该思考能否提炼成 **多个函数**。\r\n\r\n- 优化前\r\n\r\n```ts\r\nfunction example(val) {\r\n    if (val > MAX_VAL) {\r\n        val = MAX_VAL\r\n    }\r\n    for (let i = 0; i < val; i++) {\r\n        doSomething(i)\r\n    }\r\n}\r\n```\r\n\r\n- 优化后\r\n\r\n```ts\r\nfunction setMaxVal(val) {\r\n    return val > MAX_VAL ? MAX_VAL : val\r\n}\r\n\r\nfunction getCircleArea(val) {\r\n    for (let i = 0; i < val; i++) {\r\n        doSomething(i)\r\n    }\r\n}\r\nfunction example(val) {\r\n    return getCircleArea(setMaxVal(val))\r\n}\r\n```\r\n\r\n#### 3.3. 简单条件分支优先处理\r\n\r\n\r\n对于复杂的条件判断进行优化，尽量保证 **简单条件分支优先处理**，这样可以 **减少嵌套**、保证 **程序结构清晰**。\r\n\r\n- 优化前\r\n\r\n```ts\r\nfunction checkAuth(user){\r\n    if (user.auth) {\r\n        if (user.name === 'admin') {\r\n            doSomethingByAdmin(user)\r\n        } else if (user.name === 'root') {\r\n            doSomethingByRoot(user)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n- 优化后\r\n\r\n```ts\r\nfunction checkAuth(user){\r\n    if (!user.auth) {\r\n        return\r\n    }\r\n    if (user.name === 'admin') {\r\n        doSomethingByAdmin(user)\r\n    } else if (user.name === 'root') {\r\n        doSomethingByRoot(user)\r\n    }\r\n}\r\n```\r\n\r\n#### 3.4. 合并条件简化条件判断\r\n\r\n- 优化前\r\n\r\n```ts\r\nif (fruit === 'apple') {\r\n    return true\r\n} else if (fruit === 'cherry') {\r\n    return true\r\n} else if (fruit === 'peach') {\r\n    return true\r\n} else {\r\n    return true\r\n}\r\n```\r\n\r\n- 优化后\r\n\r\n```ts\r\nconst redFruits = ['apple', 'cherry', 'peach']\r\nif (redFruits.includes(fruit) {\r\n    return true\r\n}\r\n```\r\n\r\n#### 3.5. 提取条件简化条件判断\r\n\r\n对 **晦涩难懂** 的条件进行 **提取并语义化**。\r\n\r\n- 优化前\r\n\r\n```ts\r\nif ((age < 20 && gender === '女') || (age > 60 && gender === '男')) {\r\n    doSomething()\r\n} else {\r\n    doSomethingElse()\r\n}\r\n```\r\n\r\n- 优化后\r\n\r\n```ts\r\nfunction isYoungGirl(age, gender) {\r\n    return age < 20 && gender === '女'\r\n}\r\nfunction isOldMan(age, gender) {\r\n    return age > 60 && gender === '男'\r\n}\r\nif (isYoungGirl(age, gender) || isOldMan(age, gender)) {\r\n    doSomething()\r\n} else {\r\n    doSomethingElse()\r\n}\r\n```\r\n\r\n# 重构\r\n\r\n重构一词有名词和动词上的理解。\r\n\r\n- 名词：\r\n\r\n> 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。\r\n\r\n- 动词：\r\n\r\n> 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。\r\n\r\n## 1. 为何重构\r\n\r\n如果遇到以下的情况，可能就要思考是否需要重构了:\r\n\r\n- 重复的代码太多\r\n- 代码的结构混乱\r\n- 程序没有拓展性\r\n- 对象结构强耦合\r\n- 部分模块性能低\r\n\r\n为何重构，不外乎以下几点：\r\n\r\n- 重构改进软件设计\r\n- 重构使软件更容易理解\r\n- 重构帮助找到BUG\r\n- 重构提高编程速度\r\n\r\n重构的类型\r\n\r\n- 对现有项目进行代码级别的重构；\r\n- 对现有的业务进行软件架构的升级和系统的升级。\r\n\r\n本文讨论的内容只涉及第一点，仅限代码级别的重构。\r\n\r\n## 2. 重构时机\r\n\r\n> 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。\r\n\r\n- **添加功能**：当添加新功能时，如果发现某段代码改起来特别困难，拓展功能特别不灵活，就要重构这部分代码使添加新特性和功能变得更容易；\r\n\r\n- **修补错误**：在你改 `BUG` 或查找定位问题时，发现自己以前写的代码或者别人的代码设计上有缺陷（如扩展性不灵活），或健壮性考虑得不够周全（如漏掉一些该处理的异常），导致程序频繁出现问题，那么此时就是一个比较好的重构时机；\r\n\r\n- **代码检视**：团队进行 `Code Review` 的时候，也是一个进行重构的合适时机。\r\n\r\n# 代码整洁之道\r\n\r\n代码应当 **易于理解**，代码的写法应当使别人理解它所需的时间最小化。\r\n\r\n## 代码风格\r\n\r\n> 关键思想：一致的风格比 “正确” 的风格更重要。\r\n\r\n原则：\r\n\r\n- 使用一致的 **代码布局** 和 **命名**\r\n- 让相似的代码看上去 **相似**\r\n- 把相关的代码行 **分组**，形成 **代码块**\r\n\r\n## 注释\r\n\r\n注释的目的是尽量帮助读者了解到和作者一样多的信息。因此注释应当有很高的 **信息/空间率**。\r\n\r\n### 1. 好注释\r\n\r\n-   特殊标记注释：如 TODO、FIXME 等有特殊含义的标记\r\n-   文件注释：部分规约会约定在文件头部书写固定格式的注释，如注明作者、协议等信息\r\n-   文档类注释：部分规约会约定 API、类、函数等使用文档类注释\r\n-   遵循统一的风格规范，如一定的空格、空行，以保证注释自身的可读性\r\n\r\n### 2. 坏注释\r\n\r\n-   自言自语，自己感觉要加注释的地方就写上注释\r\n-   多余的注释：本身代码已经能表达意思就不要加注释\r\n-   误导性注释（随着代码的迭代，注释总有一天会由于过于陈旧而导致产生误导）\r\n-   日志式注释：日志本身可以体现出具体语意，不需要多余的注释\r\n-   能用函数或者变量名称表达语意的就不要用注释\r\n-   注释掉的代码应该删除，避免误导和混淆\r\n\r\n## 有意义的命名\r\n\r\n良好的命名是一种以 **低代价** 取得代码 **高可读性** 的途径。\r\n\r\n### 1. 选择专业名词\r\n\r\n单词    | 更多选择                                            |\r\n| ----- | -------------------------------------------------- |\r\n| send  | deliver, despatch, announce, distribute, route     |\r\n| find  | search, extract, locate, recover                   |\r\n| start | launch, create, begin, open                        |\r\n| make  | create, set up, build, generate, compose, add, new |\r\n\r\n### 2. 避免像tmp和retval这样泛泛的名字\r\n\r\n-   `retval` 这个名字没有包含明确的信息\r\n-   `tmp` 只应用于短期存在且临时性为其主要存在因素的变量\r\n\r\n### 3. 用具体的名字代替抽象的名字\r\n\r\n在给变量、函数或者其他元素命名时，要把它描述得更具体，而不是让人不明所以。\r\n\r\n- **反例**：\r\n\r\n```ts\r\nclass DtaRcrd102 {\r\n  private genymdhms: Date; // 你能读出这个变量名么？ \r\n  private modymdhms: Date;\r\n  private pszqint = '102';\r\n}\r\nclass DtaRcrd102 {\r\n  private genymdhms: Date; // 你能读出这个变量名么？ \r\n  private modymdhms: Date;\r\n  private pszqint = '102';\r\n}\r\n```\r\n\r\n- **正例**\r\n\r\n```ts\r\nclass Customer {\r\n  private generationTimestamp: Date;\r\n  private modificationTimestamp: Date;\r\n  private recordId = '102';\r\n}\r\nclass Customer {\r\n  private generationTimestamp: Date;\r\n  private modificationTimestamp: Date;\r\n  private recordId = '102';\r\n}\r\n```\r\n\r\n### 4. 为名字附带更多信息\r\n\r\n如果关于一个 **变量** 有什么重要的含义需要让读者知道，那么是值得把额外的 “词” 添加到名字中。\r\n\r\n### 5. 名字的长度\r\n\r\n-   在小的作用域里可以使用短的名字\r\n-   为作用域大的名字采用更长的名字\r\n-   丢掉没用的词\r\n\r\n### 6. 不会被误解的名字\r\n\r\n-   用 `min` 和 `max` 来表示极限\r\n-   用 `first` 和 `last` 来表示包含的范围\r\n-   用 `begin` 和 `end` 来表示排除范围\r\n-   给布尔值命名：`is`、`has`、`can`、`should`\r\n\r\n###  7. 语义相反的词汇要成对出现\r\n\r\n| 正         | 反         |\r\n| --------- | --------- |\r\n| add       | remove    |\r\n| create    | destory   |\r\n| insert    | delete    |\r\n| get       | set       |\r\n| increment | decrement |\r\n| show      | hide      |\r\n| start     | stop\r\n\r\n\r\n### 8. 其他命名小建议\r\n\r\n-   计算限定符作为前缀或后缀（`Avg`、`Sum`、`Total`、`Min`、`Max`）\r\n-   变量名要能准确地表示事物的含义\r\n-   用动名词命名函数名\r\n-   变量名的缩写，尽量避免不常见的缩写\r\n\r\n## 简化条件表达式\r\n\r\n### 1. 分解条件表达式\r\n\r\n有一个复杂的条件（`if-elseif-else`）语句，从 `if`、`elseif`、`else` 三个段落中分别提炼出 **独立函数**。根据每个小块代码的用途，为分解而得到的 **新函数** 命名。对于 **条件逻辑**，可以 **突出条件逻辑**，更清楚地表明每个分支的作用和原因。\r\n\r\n\r\n### 2. 合并条件表达式\r\n\r\n将这些一系列 **相关联** 的条件表达式 **合并** 为一个，并将这个条件表达式提炼成为一个 **独立的方法**。\r\n\r\n-   确定这些条件语句都没有副作用；\r\n-   使用适当的逻辑操作符，将一系列相关条件表达式合并为一个；\r\n-   对合并后的条件表达式实施进行方法抽取。\r\n\r\n### 3. 合并重复的条件片段\r\n\r\n在条件表达式的每个分支上有着一段 **重复的代码**，将这段重复代码搬移到条件表达式之外。\r\n\r\n### 4. 以卫语句取代嵌套条件表达式\r\n\r\n函数中的条件逻辑使人难以看清正常的执行路径。使用 **卫语句** 表现所有特殊情况。\r\n\r\n> 如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为 “卫语句”（guard clauses）。\r\n\r\n常常可以将 **条件表达式反转**，从而实以 **卫语句** 取代 **嵌套条件表达式**，写成更加 **“线性”** 的代码来避免 **深嵌套**。\r\n\r\n\r\n## 变量与可读性\r\n\r\n### 1. 内联临时变量\r\n\r\n如果有一个临时变量，只是被简单表达式 **赋值一次**，而将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。\r\n\r\n### 2. 以查询取代临时变量\r\n\r\n以一个临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。\r\n\r\n### 3. 总结变量\r\n\r\n接上条，如果该表达式比较复杂，建议通过一个总结变量名来代替一大块代码，这个名字会更容易管理和思考。\r\n\r\n### 4. 引入解释性变量\r\n\r\n将复杂表达式（或其中一部分）的结果放进一个 **临时变量**，以此 **变量名称** 来解释表达式用途。\r\n\r\n在条件逻辑中，引入解释性变量特别有价值：可以将每个 **条件子句** 提炼出来，以一个良好命名的 **临时变量** 来解释对应条件子句的 **意义**。使用这项重构的另一种情况是，在较长算法中，可以运用 **临时变量** 来解释每一步运算的意义。\r\n\r\n好处：\r\n\r\n-   把巨大的表达式拆分成小段\r\n-   通过用简单的名字描述子表达式来让代码文档化\r\n-   帮助读者识别代码中的主要概念\r\n\r\n### 5. 分解临时变量\r\n\r\n程序有某个 **临时变量** 被赋值 **超过一次**，它既不是循环变量，也不是用于收集计算结果。**针对每次赋值，创造一个独立、对应的临时变量**。\r\n\r\n临时变量有各种不同用途：\r\n\r\n-   循环变量\r\n-   结果收集变量（通过整个函数的运算，将构成的某个值收集起来）\r\n\r\n如果临时变量承担多个责任，它就应该被替换（分解）为 **多个临时变量**，每个变量只承担一个责任。\r\n\r\n### 6. 以字面常量取代 Magic Number\r\n\r\n有一个字面值，带有特别含义。创造一个 **常量**，根据其意义为它 **命名**，并将上述的字面数值替换为这个常量。\r\n\r\n### 7. 减少控制流变量\r\n\r\n```ts\r\nlet done = false;\r\nwhile (condition && !done) {\r\n    if (matchCondtion()) {\r\n        done = true;\r\n        continue;\r\n    }\r\n}\r\n```\r\n\r\n像 `done` 这样的变量，称为 **“控制流变量”**。它们唯一的目的就是控制程序的执行，没有包含任何程序的数据。控制流变量通常可以通过更好地运用 **结构化编程而消除**。\r\n\r\n```ts\r\nwhile (condition) {\r\n    if (matchCondtion()) {\r\n        break;\r\n    }\r\n}\r\n```\r\n\r\n如果有 **多个嵌套循环**，一个简单的 `break` 不够用，通常解决方案包括把代码挪到一个 **新函数**。\r\n\r\n\r\n## 重新组织函数\r\n\r\n一个函数尽量只做一件事情，这是程序 **高内聚，低耦合** 的基石。\r\n\r\n### 1. 提炼函数\r\n\r\n当一个过长的函数或者一段需要注释才能让人理解用途的代码，可以将这段代码放进一个 **独立函数**。\r\n\r\n-   函数的粒度小，被 **复用** 的机会就很大；\r\n-   函数的粒度小，**覆写** 也会更容易些。\r\n\r\n一个函数过长才合适？**长度** 不是问题，关键在于 **函数名称** 和 **函数本体** 之间的 **语义距离**。\r\n\r\n### 2. 代码块与缩进\r\n\r\n函数的缩进层级不应该多于 **一层** 或 **两层**，对于 **超过两层** 的代码可以根据 **重载** 或函数的 **具体语意** 抽取的的函数。\r\n\r\n### 3. 函数无副作用\r\n\r\n每个函数应该只做 **一件事**，如果一个函数同时做了多件事，比如：\r\n\r\n- 在 **查询数据** 的过程中对数据进行 **修改**，或者调用 **第三方接口**，那么这个函数是具有 **二义性的**。\r\n\r\n- 一个函数用于校验数据或者异常，但是在校验过程没有统一 **校验规范**，存在同时 **抛出异常** 和 **返回正常结果** 的情况。那这个函数是不纯粹的，也是有夹带现象。\r\n\r\n第一种情况可以考虑把函数进行拆分，拆分为 **读数据函数** 和 **写数据函数**；第二种情况应该将 **校验逻辑** 和 **获取值** 的逻辑抽离为两个函数，**校验函数** 前置于 **获取值函数**。同时保证校验函数尽量轻量级。\r\n\r\n### 4. 函数参数优化\r\n\r\n函数参数格式尽量避免超过 `3` 个。参数过多（类型相近）会导致代码 **容错性降低**，导致参数个数顺序传错等问题。如果函数的参数太多，可以考虑将参数进行 **分组** 和 **归类**，封装成 **单独的对象**。\r\n\r\n### 5. 从函数中提前返回\r\n\r\n可以通过马上处理 “特殊情况”，可以通过 **卫语句** 处理，从函数中 **提前返回**。\r\n\r\n### 6. 重复代码抽取公共函数\r\n\r\n应该避免纯粹的 `copy-paste`，将程序中的 **重复代码** 抽取成公共的函数，这样的好处是避免 **修改**、**删除** 代码时出现遗忘或误判。\r\n\r\n-   两个方法的 **共性** 提取到新方法中，新方法分解到另外的类里，从而提升其可见性\r\n-   模板方法模式是消除重复的通用技巧\r\n\r\n### 7. 拆分复杂的函数\r\n\r\n如果有很难读的代码，尝试把它所做的 **所有任务列出来**。其中 **一些任务** 可以很容易地变成 **单独的函数（或类）**。其他的可以简单地成为一个函数中的逻辑 “段落”。\r\n\r\n- 检查函数的 **命名** 是否 **名副其实**，梳理函数的思路，试图将 **顶层函数** 拆分成 **多个子任务**\r\n- 将和任务相关的 **代码段**、**变量生命** 进行 **聚类归拢**，根据依赖调整 **代码顺序**\r\n- 将 **各个子任务** 抽取成 **单独的函数**，减少 **顶层函数** 的复杂性\r\n- 对于 **逻辑仍然复杂** 的 **子任务**，可以进一步细化，并利用以上原则（**结合重载**）继续剥离抽取\r\n- 对于 **代码复杂性** 和 **内聚性** 本身比较高，代码可能 **复用** 的代码，抽取成单独的 **类文件**\r\n- 对于单独抽取 **类文件** 或者 **方法** 后仍然复杂的代码，可以考虑引入 **设计模式** 进行 **横向扩展** 或 **曲线救国**。\r\n\r\n## 整洁一致的格式\r\n\r\n### 1. 垂直格式\r\n\r\n-   文件长度：**短文件** 比 **长文件** 更易于理解，单个文件平均 `200` 行，最多不超过 `300` 行\r\n-   分隔：封包声明、导入声明、每个函数之间，可以使用 **空白行** 标识着新的 **独立概念**\r\n-   归拢：**紧密相关** 的代码应该互相归拢\r\n-   变量声明：**变量** 应尽可能靠近其 **使用位置**。\r\n-   成员变量：应该放在类的顶部声明，不要四处放置\r\n-   如果某个函数调用了另外一个，就应该把它们放在一起，调用者尽可能放在被调用者之上\r\n\r\n### 2. 水平格式\r\n\r\n-   一行代码不必死守 `80` 字符的上限，偶尔到达 `100` 字符不超过 `120` 字符即可\r\n-   区隔与靠近：空格强调左右两边的分割，赋值运算符 **两边加空格**，**函数名** 与 **左圆括号** 之间不加空格\r\n-   不必水平对齐：例如声明一堆成员变量时，各行不用每一个单词都对齐\r\n-   短小的 `if`、`while` 语句里最好也不要违反 **缩进规则**，不要这样 `if (xx == yy) z = 1;` \r\n\r\n## 对象和数据结构\r\n\r\n### 1. 数据抽象\r\n\r\n类的好处是 **隐藏细节**，所以尽量不要在标准的 **数据对象** 的 `getter()` 和 `setter()` 等函数内部进行 **自定义扩展**。\r\n\r\n### 2. 数据、对象的反对称性\r\n\r\n- 面向数据机构的代码：好处是不改动 **现有数据结构** 前提下增加 **新的函数**\r\n- 面向对象的代码：好处是不改动 **既有函数** 的前提下增加 **新的类（多态）**\r\n\r\n### 3. Demeter法则（最少知识原则）\r\n\r\n- 模块不应该了解它 **所操作对象** 的 **内部实现**，更不应该了解 **对象的对象** 的内部实现\r\n- `class` 的方法只应该调用类本身方法，方法创建的对象，作为参数传递的方法，类所持有的对象\r\n- 方法不应调用由任何函数返回的对象的方法，`final String outputDir = ctxt.getOptions.getScratchDir.getAbsolutePath()`\r\n\r\n> 注意：对于 **函数式编程** 和 **响应式编程**，或者适用 `Optional` 和 `builder` 模式的场景，Demeter法则并不是完全适用。除此之外的链式调用有可能会带来 **空指针** 等问题。\r\n\r\n\r\n## 类\r\n\r\n### 1. 类的结构组织\r\n\r\n**类成员定义的先后顺序**：公共静态常量 -> 私有静态变量 -> 私有实体变量 -> 构造方法 -> 公共函数 -> 私有函数\r\n\r\n### 2. 类应该短小\r\n\r\n-  **类的长度**：对于 **函数** 我们计算 **代码行数** 衡量大小，对于类我们使用 **职责** 来衡量\r\n-  **类的命名**：类的名称描述其 **职责**，类的命名是判断类长度的第一个手段，如果无法为某个类命以准确的名称，这个类就太长了，类名包含模糊的词汇，如 `Processor`、`Manager`、`Super`，就说明有 **不恰当** 的职责聚集情况\r\n-  **类的单一职责**: 类或者模块应该有一个职责，即只有一条修改的理由\r\n-  **类的个数**：系统应该由许多短小精悍的类，而不是少量巨型的类组成\r\n-  **类的成员变量**：类应该只有少量的实体变量，如果一个类中每个实体变量都被每个方法所使用，则说明该类具有最大的内聚性\r\n\r\n### 3. 为修改而组织\r\n\r\n1.  类应当对扩展开放，对修改封闭，即 **开放闭合原则**\r\n2.  在理想系统中，通过扩展系统而非修改现有代码来添加新特性（可惜往往做不到）\r\n\r\n### 4. 组合大于继承\r\n\r\n合和继承各有优劣。这个准则的主要观点是，如果你潜意识地倾向于继承，试着想想组合是否能更好地给你的问题建模，在某些情况下可以。\r\n\r\n什么时候应该使用继承？这取决于你面临的问题。以下场景使用继承更好:\r\n\r\n1. 继承代表的是 `“is-a”` 关系，而不是 `“has-a”` 关系 (人 -> 动物 `vs` 用户 -> 用户详情)。\r\n2. 可复用基类的代码，即有相同行为的代码 (人类可以像所有动物一样移动)。\r\n3. 希望通过更改 **基类** 对 **派生类** 进行 **全局更改** (改变所有动物在运动时的热量消耗)。\r\n\r\n\r\n\r\n## 错误处理\r\n\r\n在处理程序异常时，常常会用到 `try / catch` 代码块，而 `try / catch` 代码块丑陋不堪，使用不慎容易 **搞乱代码结构**，把 **错误处理** 与 **正常流程** 混为一谈。\r\n\r\n\r\n### 1. 使用异常而不是返回错误码\r\n\r\n-  如果使用 **错误码**，调用者必须在函数返回时 **立刻处理错误**，但这很容易被忘记\r\n-  **错误码** 通常会导致 **嵌套判断**，使代码结构不严谨\r\n\r\n### 2. 先写try-catch-finally语句\r\n\r\n-  当编写可能会抛异常的代码时，先写好 `try-catch-finally` 再往里堆逻辑\r\n\r\n### 3. 根据业务场景定义不同的异常处理类\r\n\r\n-  根据业务定义不同的 **异常类**，尽量避免直接使用 `Throwable`、`Exception` 和 `RuntimeException` 捕获 **业务层面** 的异常。\r\n\r\n### 4. 特例模式，创建一个类来处理特例\r\n\r\n-  定义一个配置或者对象来处理特殊情况，你处理了特殊情况后客户代码就不需要捕获异常了\r\n\r\n### 5. 别返回null值\r\n\r\n-  返回 `null` 值的地方都需要 **重复的检查**，只要一处没检查 `null` 值，应用程序就会失败\r\n-  当想返回 `null` 值的时候，可以试试 **抛出异常**，或者返回特例模式的对象\r\n-  可以通过 `Optional.ifPresent()` 和 `Optional.map().orElseGet()` 处理需要返回 `null` 的场景\r\n\r\n### 6. 别传递null值\r\n\r\n-  在方法中传递 `null` 值是一种很危险的做法，应该尽量避免\r\n-  在进行字符串比较时，要避免将可能为 `null` 的参数放在 `equals()` 方法的左侧\r\n-  在方法里用 `if` 或 `assert` 过滤 `null` 值参数，但是还是会出现运行时错误\r\n\r\n# 编码原则\r\n\r\n有必要熟知前人总结的一些经典的 **编码原则**，以此来改善我们既有的编码习惯，所谓 “站在巨人肩上编程”。\r\n\r\n## SOLID原则\r\n\r\n> SOLID 是面向对象设计（OOD）的五大基本原则的首字母缩写组合，由俗称“鲍勃大叔”的Robert C.Martin在《敏捷软件开发：原则、模式与实践》一书中提出来。\r\n\r\n-  **S(Single Responsibility Principle)**：单一职责原则，简称 `SRP`\r\n-  **O(Open Close Principle)**：开放封闭原则，简称 `OCP`\r\n-  **L(Liskov Substitution Principle)**：里氏替换原则，简称 `LSP`\r\n-  **I(Interface SegregationPrinciple)**：接口隔离原则，简称 `ISP`\r\n-  **D(Dependence Inversion Principle)**：依赖倒置原则，简称 `DIP`\r\n\r\n### 1. 单一职责原则\r\n\r\n> A class should have only one reason to change.\r\n\r\n一个类应该有且仅有 **一个原因** 引起它的变更。通俗来讲：一个类只负责一项功能或一类相似的功能。当然这个 “一” 并不是绝对的，应该理解为一个类只负责尽可能独立的一项功能，尽可能少的职责。\r\n\r\n如果一个类的 **功能太多**，修改了其中一处很难确定对代码库中其他 **依赖模块** 的影响。\r\n\r\n**优点**：\r\n\r\n-  功能单一，职责清晰。\r\n-  增强可读性，方便维护。\r\n\r\n**缺点**：\r\n\r\n-  拆分得太详细，类的数量会急剧增加。\r\n-  职责的度量没有统一的标准，需要根据项目实现情况而定。\r\n\r\n这条定律同样适用于组织函数时的编码原则。\r\n\r\n- **反例**：\r\n\r\n```ts\r\nclass UserSettings {\r\n  constructor(private readonly user: User) {\r\n  }\r\n\r\n  changeSettings(settings: UserSettings) {\r\n    if (this.verifyCredentials()) {\r\n      doChangeSettings()\r\n    }\r\n  }\r\n\r\n  verifyCredentials() {\r\n    doVerifyCredentials()\r\n  }\r\n}\r\n```\r\n\r\n- **正例**：\r\n\r\n```ts\r\nclass UserAuth {\r\n  constructor(private readonly user: User) {\r\n  }\r\n\r\n  verifyCredentials() {\r\n    doVerifyCredentials()\r\n  }\r\n}\r\n\r\nclass UserSettings {\r\n  private readonly auth: UserAuth;\r\n\r\n  constructor(private readonly user: User) {\r\n    this.auth = new UserAuth(user);\r\n  }\r\n\r\n  changeSettings(settings: UserSettings) {\r\n    if (this.auth.verifyCredentials()) {\r\n      doChangeSettings()\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n### 2. 开放封闭原则\r\n\r\n> Software entities （classes,modules,functions,etc.）should be open for extension, but closed for modification.\r\n\r\n程序开发过程中（如类、模块、函数等）应该 **对拓展开放，对修改封闭**。换句话说，就是允许在不更改现有代码的情况下添加新功能。\r\n\r\n- **反例**\r\n\r\n```ts\r\nclass AjaxAdapter extends Adapter {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\nclass NodeAdapter extends Adapter {\r\n  constructor() {\r\n    super();\r\n  }\r\n}\r\n\r\nclass HttpRequester {\r\n  constructor(private readonly adapter: Adapter) {\r\n  }\r\n\r\n  async fetch<T>(url: string): Promise<T> {\r\n    if (this.adapter instanceof AjaxAdapter) {\r\n      const response = await makeAjaxCall<T>(url);\r\n      // transform response and return\r\n    } else if (this.adapter instanceof NodeAdapter) {\r\n      const response = await makeHttpCall<T>(url);\r\n      // transform response and return\r\n    }\r\n  }\r\n}\r\n\r\nfunction makeAjaxCall<T>(url: string): Promise<T> {\r\n  // request by ajax and return promise\r\n}\r\n\r\nfunction makeHttpCall<T>(url: string): Promise<T> {\r\n  // request by http and return promise\r\n}\r\n```\r\n\r\n- **正例**\r\n\r\n```ts\r\nabstract class Adapter {\r\n  abstract async request<T>(url: string): Promise<T>;\r\n}\r\n\r\nclass AjaxAdapter extends Adapter {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  async request<T>(url: string): Promise<T>{\r\n    // request by ajax and return promise\r\n  }\r\n}\r\n\r\nclass NodeAdapter extends Adapter {\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  async request<T>(url: string): Promise<T>{\r\n    // request by http and return promise\r\n  }\r\n}\r\n\r\nclass HttpRequester {\r\n  constructor(private readonly adapter: Adapter) {\r\n  }\r\n\r\n  async fetch<T>(url: string): Promise<T> {\r\n    const response = await this.adapter.request<T>(url);\r\n    // transform response and return\r\n  }\r\n}\r\n```\r\n \r\n### 3. 里氏替换原则\r\n\r\n> Functions that use pointers to base classes must be able to use objects of derived classes without knowing it.\r\n\r\n所有能引用 **基类** 的地方必须能透明地使用其 **子类** 的对象。\r\n\r\n只要 **父类** 能出现的地方就可以用 **子类** 来替换它。反之，**子类** 不能替换 **父类**（子类拥有父类的 **所有属性和行为**，但 **子类** 拓展了更多的功能）。\r\n\r\n- **反例**：\r\n\r\n```ts\r\nclass Rectangle {\r\n  constructor(\r\n    protected width: number = 0, \r\n    protected height: number = 0) {\r\n  }\r\n\r\n  render(area: number) {\r\n  }\r\n\r\n  setWidth(width: number) {\r\n    this.width = width;\r\n  }\r\n\r\n  setHeight(height: number) {\r\n    this.height = height;\r\n  }\r\n\r\n  getArea(): number {\r\n    return this.width * this.height;\r\n  }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n  setWidth(width: number) {\r\n    this.width = width;\r\n    this.height = width;\r\n  }\r\n\r\n  setHeight(height: number) {\r\n    this.width = height;\r\n    this.height = height;\r\n  }\r\n}\r\n\r\nfunction renderLargeRectangles(rectangles: Rectangle[]) {\r\n  rectangles.forEach((rectangle) => {\r\n    rectangle.setWidth(4);\r\n    rectangle.setHeight(5);\r\n    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.\r\n    rectangle.render(area);\r\n  });\r\n}\r\n\r\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\r\nrenderLargeRectangles(rectangles);\r\n```\r\n\r\n- **正例**：\r\n\r\n```ts\r\nabstract class Shape {\r\n  setColor(color: string) {\r\n  }\r\n\r\n  render(area: number) {\r\n  }\r\n\r\n  abstract getArea(): number;\r\n}\r\n\r\nclass Rectangle extends Shape {\r\n  constructor(private readonly width = 0, \r\n              private readonly height = 0) {\r\n    super();\r\n  }\r\n\r\n  getArea(): number {\r\n    return this.width * this.height;\r\n  }\r\n}\r\n\r\nclass Square extends Shape {\r\n  constructor(private readonly length: number) {\r\n    super();\r\n  }\r\n\r\n  getArea(): number {\r\n    return this.length * this.length;\r\n  }\r\n}\r\n\r\nfunction renderLargeShapes(shapes: Shape[]) {\r\n  shapes.forEach((shape) => {\r\n    const area = shape.getArea();\r\n    shape.render(area);\r\n  });\r\n}\r\n\r\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\r\nrenderLargeShapes(shapes);\r\n```\r\n\r\n\r\n### 4. 接口隔离原则\r\n\r\n> Clients should not be forced to depend upon interfaces that they don't use. Instead of one fat interface many small interfaces arepreferred based on groups of methods, each one serving one submodule.\r\n\r\n客户端不应该依赖它不需要的接口。用 **多个细粒度** 的接口来替代由 **多个方法** 组成的 **复杂接口**，每一个接口服务于一个子模块。\r\n\r\n接口尽量小，但是要有限度。当发现一个接口过于 **臃肿** 时，就要对这个接口进行适当的 **拆分**。但是如果 **接口过小**，则会造成 **接口数量过多**，使 **设计复杂化**。\r\n\r\n- **反例**：\r\n\r\n```ts\r\ninterface ISmartPrinter {\r\n  print();\r\n  fax();\r\n  scan();\r\n}\r\n\r\nclass AllInOnePrinter implements ISmartPrinter {\r\n  print() {\r\n  }  \r\n\r\n  fax() {\r\n  }\r\n\r\n  scan() {\r\n  }\r\n}\r\n\r\nclass EconomicPrinter implements ISmartPrinter {\r\n  print() {\r\n  }  \r\n\r\n  fax() {\r\n    throw new Error('Fax not supported.');\r\n  }\r\n\r\n  scan() {\r\n    throw new Error('Scan not supported.');\r\n  }\r\n}\r\n```\r\n\r\n- **正例**：\r\n\r\n```ts\r\ninterface IPrinter {\r\n  print();\r\n}\r\n\r\ninterface IFax {\r\n  fax();\r\n}\r\n\r\ninterface IScanner {\r\n  scan();\r\n}\r\n\r\nclass AllInOnePrinter implements IPrinter, IFax, IScanner {\r\n  print() {\r\n  }  \r\n\r\n  fax() {\r\n  }\r\n\r\n  scan() {\r\n  }\r\n}\r\n\r\nclass EconomicPrinter implements IPrinter {\r\n  print() {\r\n  }\r\n}\r\n```\r\n\r\n### 5. 依赖倒置原则\r\n\r\n> High level modules should not depend on low level modules; bothshould depend on abstractions. Abstractions should not depend ondetails. Details should depend upon abstractions.\r\n\r\n这个原则有两个要点:\r\n\r\n1. **高层模块** 不应该依赖于 **低层模块**，两者都应该依赖于 **抽象**。\r\n2. **抽象** 不依赖 **实现**，**实现** 应依赖 **抽象**。\r\n\r\n把具有 **相同特征** 或 **相似功能** 的类，抽象成 **接口** 或 **抽象类**，让具体的 **实现类** 继承这个 **抽象类**（或实现对应的接口）。抽象类（接口）负责定义统一的方法，实现类负责具体功能的实现。\r\n\r\n- **反例**：\r\n\r\n```ts\r\nimport { readFile as readFileCb } from 'fs';\r\nimport { promisify } from 'util';\r\n\r\nconst readFile = promisify(readFileCb);\r\n\r\ntype ReportData = {\r\n}\r\n\r\nclass XmlFormatter {\r\n  parse<T>(content: string): T {\r\n    // Converts an XML string to an object T\r\n  }\r\n}\r\n\r\nclass ReportReader {\r\n  private readonly formatter = new XmlFormatter();\r\n\r\n  async read(path: string): Promise<ReportData> {\r\n    const text = await readFile(path, 'UTF8');\r\n    return this.formatter.parse<ReportData>(text);\r\n  }\r\n}\r\n\r\nconst reader = new ReportReader();\r\nawait report = await reader.read('report.xml');\r\n```\r\n\r\n- **正例**：\r\n\r\n```ts\r\nimport { readFile as readFileCb } from 'fs';\r\nimport { promisify } from 'util';\r\n\r\nconst readFile = promisify(readFileCb);\r\n\r\ntype ReportData = {\r\n  // ..\r\n}\r\n\r\ninterface Formatter {\r\n  parse<T>(content: string): T;\r\n}\r\n\r\nclass XmlFormatter implements Formatter {\r\n  parse<T>(content: string): T {\r\n    // Converts an XML string to an object T\r\n  }\r\n}\r\n\r\nclass JsonFormatter implements Formatter {\r\n  parse<T>(content: string): T {\r\n    // Converts a JSON string to an object T\r\n  }\r\n}\r\n\r\nclass ReportReader {\r\n  constructor(private readonly formatter: Formatter){\r\n\r\n  }\r\n\r\n  async read(path: string): Promise<ReportData> {\r\n    const text = await readFile(path, 'UTF8');\r\n    return this.formatter.parse<ReportData>(text);\r\n  }\r\n}\r\n\r\nconst reader = new ReportReader(new XmlFormatter());\r\nawait report = await reader.read('report.xml');\r\n\r\n// or if we had to read a json report:\r\nconst reader = new ReportReader(new JsonFormatter());\r\nawait report = await reader.read('report.json');\r\n```\r\n\r\n## 是否一定要遵循这些设计原则\r\n\r\n-   软件设计是一个逐步优化的过程\r\n-   不是一定要遵循这些设计原则\r\n\r\n没有充足的时间，或遵实现成本太大。在受限不能遵循 **五大原则** 来设计时，我们还可以遵循下面这些 **更为简单**、**实用** 的原则。\r\n\r\n\r\n## 简单、实用的原则\r\n\r\n### 1. LoD原则（Law of Demeter）\r\n\r\n> Each unit should have only limited knowledge about other units: only units \\\"closely\\\" related to the current unit. Only talk to your immediate friends, don't talk to strangers.\r\n\r\n每一个逻辑单元应该对其他逻辑单元有最少的了解：也就是说只亲近当前的对象。只和直接（亲近）的朋友说话，不和陌生人说话。\r\n\r\n这一原则又称为迪米特法则，简单地说就是：一个类对自己依赖的类知道的越少越好，这个类只需要和直接的对象进行交互，而不用在乎这个对象的内部组成结构。\r\n\r\n例如，类A中有类B的对象，类B中有类C的对象，调用方有一个类A的对象a，这时如果要访问C对象的属性，不要采用类似下面的写法：\r\n\r\n```\r\na.getB().getC().getProperties()\r\n复制代码\r\n```\r\n\r\n而应该是：\r\n\r\n```\r\na.getProperties()\r\n复制代码\r\n```\r\n\r\n### 2. KISS原则（Keep It Simple and Stupid）\r\n\r\n> Keep It Simple and Stupid.\r\n\r\n保持简单和愚蠢。\r\n\r\n-   “简单”就是要让你的程序能简单、快速地被实现；\r\n-   “愚蠢”是说你的设计要简单到任何人都能理解，即简单就是美！\r\n\r\n### 3. DRY原则（Don't Repeat Yourself）\r\n\r\n不要重复你的代码，即多次遇到同样的问题，应该抽象出一个 **通用** 的方法，不要重复开发同样的功能。也就是要尽可能地提高代码的 **复用率**。\r\n\r\n要遵循 `DRY` 原则，实现的方式非常多：\r\n\r\n-  **函数级别的封装**：把一些经常使用的、重复出现的功能封装成一个通用的函数。\r\n-  **类级别的抽象**：把具有相似功能或行为的类进行抽象，抽象出一个基类，并把这几个类都有的方法提到基类去实现。\r\n-  **泛型设计**：`Java` 中可使用泛型，以实现通用功能类对多种数据类型的支持；`C++`中可以使用类模板的方式，或宏定义的方式；`Python` 中可以使用装饰器来消除冗余的代码。\r\n\r\n`DRY` 原则在单人开发时比较容易遵守和实现，但在团队开发时不太容易做好，特别是对于大团队的项目，关键还是团队内的沟通。\r\n\r\n### 4. YAGNI原则（You Aren't Gonna Need It）\r\n\r\n> You aren't gonna need it, don't implement something until it is necessary.\r\n\r\n你没必要那么着急去给你的类实现过多的功能，在你需要它的时候再去实现。\r\n\r\n- 只考虑和设计必需的功能，避免 **过度设计**。\r\n- 只实现目前需要的功能，在以后需要更多功能时，可以再进行添加。\r\n- 如无必要，勿增加复杂性。\r\n\r\n### 5. Rule Of Three原则\r\n\r\n`Rule of three` 称为 `“三次法则”`，指的是当某个功能 **第三次** 出现时，再进行 **抽象化**，即 **事不过三，三则重构**。\r\n\r\n-   第一次实现一个功能时，就尽管大胆去做；\r\n-   第二次做类似的功能设计时会产生反感，但是还得去做；\r\n-   第三次还要实现类似的功能做同样的事情时，就应该去审视是否有必要做这些重复劳动了，这个时候就应该重构你的代码了，即把重复或相似功能的代码进行抽象，封装成一个通用的模块或接口。\r\n\r\n### 6. CQS原则（Command-Query Separation）\r\n\r\n-  **查询（Query）**：当一个方法 **返回一个值** 来响应一个问题的时候，它就具有查询的性质；\r\n-  **命令（Command）**：当一个方法要 **改变对象的状态** 的时候，它就具有命令的性质。\r\n\r\n严格保证方法的行为的方式是 **命令** 或者 **查询**，这样查询方法不会改变对象的状态，没有副作用；而会改变对象的状态的方法不可能有返回值。\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7189411314396037179",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c3c4cf67774ecfaf07db86ad75cdac~tplv-k3u1fbpfcp-watermark.image?",
        "title": "CSS 实例系列 - 03 - Rate 爱心评分",
        "preview": "简单三步完成 Rate 爱心评分，只需要一丢丢的 HTML + JS，再堆「亿丢丢」CSS，搞定收工，so easy~",
        "author": "jsliang",
        "view_count": 964,
        "collect_count": 2,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/fae2936a68be7eac2c5477f18a875fb2~300x300.image",
        "category": "前端",
        "content": "Hello 小伙伴们早上、中午、下午、晚上和深夜好，这里是 **jsliang**~\r\n\r\n今儿要实现的是：**Rate 评分**\r\n\r\n![03-01.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780c238ebf9d4d19baf6f3f1a2ae7a49~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n本期将和小伙伴们探讨：\r\n\r\n* √ 通过 CSS，配合简单的 HTML + JS 完成评分组件\r\n\r\n本实例的代码地址：\r\n\r\n* [Github - all for one](https://github.com/LiangJunrong/all-for-one/tree/master/038-CSS%20系列)\r\n* [码上掘金 - 03 - Rate 爱心评分](https://code.juejin.cn/pen/7189251131267088441)\r\n\r\n## 一 前言\r\n\r\n本 CSS 系列文章：\r\n\r\n1. **主推学以致用**。结合面试题和工作实例，让小伙伴们深入体验 61 个工作常见的 CSS 属性和各种 CSS 知识。\r\n2. **主推纯 CSS**。尽可能使用 HTML + CSS 完成学习目的，但仍然有 “一小部分” 功能需要用到 JavaScript 知识，**适合新人学习 + 大佬复习**。\r\n\r\n如果文章在一些细节上没写清楚或者误导读者，欢迎评论/吐槽/批判，**你的点赞、收藏和关注是我更新的动力 ❤**\r\n\r\n* 更多知识分享文章可见：[jsliang 的文档库](https://github.com/LiangJunrong/document-library)\r\n\r\n## 二 本期知识点\r\n\r\n### 2.1 ::before 和 ::after\r\n\r\n关于伪元素 [::before](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before) 和 [::after](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after) 以及 [content](https://developer.mozilla.org/zh-CN/docs/Web/CSS/content)，我们要简单化理解：\r\n\r\n![03-02.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06db694b355a43d9a7fe463ab82ef24d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n那就是 Web 版的 **jsliang**，为了钱（`content`）瞻前（`::before`）顾后（`::after`）。\r\n\r\n其实就是 `content` 一般配合 `::before` 和 `::after`，来实现内容的填充，`content: ''` 配合 `width/height` 可以完成矩形的绘制（就跟正常 `div` 一样了）\r\n\r\n### 2.2 选择器 ~\r\n\r\n关于 [选择器 ~](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors)，也很容易理解：\r\n\r\n门前大桥下，有着 5 只鸭，数到 2 时用上 `~`，那就匹配 3、4、5。\r\n\r\n![03-03.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bfae13e794e467fbcfce01a4b4fbbe9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 三 实现步骤\r\n\r\nOK，小知识点讲完，下面我们开始写这个实例吧~\r\n\r\n**第一步**，HTML 结构非常简单：\r\n\r\n```html\r\n<!-- 外层容器 - 主要是为了好看 -->\r\n<div class=\\\"container\\\">\r\n  <!-- 内层容器 - 关键评分 -->\r\n  <div class=\\\"rate-container\\\">\r\n    <input type=\\\"radio\\\" class=\\\"rate\\\" name=\\\"rate\\\" value=\\\"5\\\">\r\n    <input type=\\\"radio\\\" class=\\\"rate\\\" name=\\\"rate\\\" value=\\\"4\\\">\r\n    <input type=\\\"radio\\\" class=\\\"rate\\\" name=\\\"rate\\\" value=\\\"3\\\">\r\n    <input type=\\\"radio\\\" class=\\\"rate\\\" name=\\\"rate\\\" value=\\\"2\\\">\r\n    <input type=\\\"radio\\\" class=\\\"rate\\\" name=\\\"rate\\\" value=\\\"1\\\">\r\n  </div>\r\n  <!-- 评分提示 -->\r\n  <p class=\\\"scoring\\\">小伙伴，快评分呀~</p>\r\n</div>\r\n```\r\n\r\n它的显示效果如下：\r\n\r\n![03-04.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc10c0adf4994a2db1bbbee2ac6d699e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**第二步**，我们施加 CSS 魔法：\r\n\r\n```css\r\n/* 关键样式 - Flex 布局 */\r\n.rate-container {\r\n  /* 这里 Flex 是关键 */\r\n  /* 如果用正常顺序的话，使用兄弟元素选择器 ~ */\r\n  /* 会导致 ❤ 的选择反过来 */\r\n  /* 所以需要 flex-direction 再翻转一遍 */\r\n  display: flex;\r\n  flex-direction: row-reverse;\r\n  justify-content: center;\r\n}\r\n/* 去掉默认样式 */\r\n.rate {\r\n  position: relative;\r\n  -webkit-appearance: none;\r\n  border: none;\r\n  outline: none;\r\n  cursor: pointer;\r\n  width: 24px;\r\n  height: 24px;\r\n}\r\n```\r\n\r\n![03-05.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4644bd3378364ffc9f6e33f6f212bf14~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这里我们可以看到，我们原本按照 `5 -> 1` 排序的 `input:radio` 组件，通过 `display:flex` 属性调转过来了。\r\n\r\n然后我们在 `.rate` 上移除了默认样式，所以现在看不到边框了。\r\n\r\n下面我们绘制爱心，并让它有 hover 上去点亮的效果：\r\n\r\n```css\r\n/* 描绘爱心组件 */\r\n.rate::after {\r\n  position: absolute;\r\n  content: '❤';\r\n  font-size: 24px;\r\n}\r\n/* 元素 hover 效果 */\r\n.rate:hover,\r\n/* 元素 hover 后，兄弟元素跟着变 */\r\n/* 这里用 ~ 可以直接让后面所有元素跟着变 */\r\n/* 如果用 + 只会让后面一个元素跟着变 */\r\n.rate:hover ~ .rate,\r\n/* 元素选中后，变化同上 */\r\n.rate:checked,\r\n.rate:checked ~ .rate {\r\n  color: deeppink;\r\n}\r\n```\r\n\r\n此时我们可以看到：\r\n\r\n![03-06.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82d1cc96c7e94fc993a9463211d7f34e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n是不是简简单单~\r\n\r\n> 此时看不懂 `~ .rate` 的意思，可以回顾下开局的 CSS 属性讲解\r\n\r\n**第三步**，我们完成 JavaScript 代码编写，让它的交互更加有意思：\r\n\r\n```js\r\nwindow.onload = () => {\r\n  const scoring = document.querySelector('.scoring');\r\n  const checkboxList = document.querySelectorAll('.rate');\r\n  // 上一次打的分数\r\n  let prevScore = 0;\r\n  checkboxList.forEach((item) => {\r\n\r\n    // 改变评分的时候，设置文本效果\r\n    item.onchange = (e) => {\r\n      const score = Number(e.target.value);\r\n      switch (score) {\r\n        case 1: scoring.innerText = '-_- 谢谢你这么不看好我 -_-'; break;\r\n        case 2: scoring.innerText = '哇塞，我比更低更胜一筹！'; break;\r\n        case 3: scoring.innerText = '中规中矩啦，麻麻嘚~'; break;\r\n        case 4: scoring.innerText = '哇塞，我比更高差了一步！'; break;\r\n        case 5: scoring.innerText = '^_^ 谢谢你这么看好我 ^_^'; break;\r\n        default: scoring.innerText = '小伙伴，快评分呀~'; break;\r\n      }\r\n    };\r\n\r\n    // 点击的时候，判断是选中还是反选\r\n    item.onclick = (e) => {\r\n      const score = Number(e.target.value);\r\n      // 评分相同，则反选，且清空评分\r\n      if (score === prevScore) {\r\n        item.checked = false;\r\n        prevScore = 0;\r\n        scoring.innerText = '小伙伴，快评分呀~'\r\n      } else {\r\n        // 否则设置上一次评分\r\n        prevScore = score;\r\n      }\r\n    };\r\n  });\r\n};\r\n```\r\n\r\n这样，我们就完成了评分效果：\r\n\r\n![03-01.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/604abb01baf64200800b5f76e4a665c9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 四 参考文献\r\n\r\n* [掘金 - 聪明的汤姆 - 讲道理，仅3行核心css代码的rate评分组件，我被自己秀到头皮发麻🙆‍♂️](https://juejin.cn/post/6844903919106129934)\r\n* [GitHub - jawil/blog - 纯CSS实现网站常用的五角星评分和分数展示交互效果](https://github.com/jawil/blog/issues/8)\r\n* [codepen - 纯CSS 评分](https://codepen.io/main2018/pen/oNgYgXv)\r\n\r\n---\r\n\r\n**不折腾的前端，和咸鱼有什么区别！**\r\n\r\n觉得文章不错的小伙伴欢迎点赞/点 Star。\r\n\r\n如果小伙伴需要联系 **jsliang**：\r\n\r\n* [Github](https://github.com/LiangJunrong/document-library)\r\n* [掘金](https://juejin.im/user/3403743728515246)\r\n\r\n个人联系方式存放在 Github 首页，欢迎一起折腾~\r\n\r\n争取打造自己成为一个充满探索欲，喜欢折腾，乐于扩展自己知识面的终身学习斜杠程序员。\r\n\r\n> jsliang 的文档库由 [梁峻荣](https://github.com/LiangJunrong) 采用 [知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议](http://creativecommons.org/licenses/by-nc-sa/4.0/) 进行许可。<br/>基于 [https://github.com/LiangJunrong/document-library](https://github.com/LiangJunrong/document-library) 上的作品创作。<br/>本许可协议授权之外的使用权限可以从 [https://creativecommons.org/licenses/by-nc-sa/2.5/cn/](https://creativecommons.org/licenses/by-nc-sa/2.5/cn/) 处获得。\r\n"
    },
    {
        "article_id": "7189058800286957624",
        "snapshot": "",
        "title": "select for update是行锁还是表锁，还真得看情况",
        "preview": "背景 看到许多写select for update是行锁还是表锁的文章，但每篇文章的结论好像都不太一样。同时，是行锁还是表锁的问题直接影响着系统的性能，所以特意为大家调研一番，也就有了本篇文章，一共为",
        "author": "程序新视界",
        "view_count": 950,
        "collect_count": 15,
        "comment_count": 2,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/12/16dbf1821d122e70~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "## 背景\r\n\r\n看到许多写`select for update`是行锁还是表锁的文章，但每篇文章的结论好像都不太一样。同时，是行锁还是表锁的问题直接影响着系统的性能，所以特意为大家调研一番，也就有了本篇文章，一共为大家汇总验证了20个场景下的结论。\r\n\r\n对于软件或框架来说，特别是在有大版本更新的情况下，脱离了具体版本的结论往往是无意义的。针对这个问题，网络上之所以有多个版本的答案，最主要的原因就是脱离MySQL的版本以及事务隔离级别。\r\n\r\n本文就基于两个MySQL版本（5.7.x、8.0.x）、两种常见事务隔离级别（读已提交、可重复读）来逐一验证。总共有四大类情况，20个小场景。最后，再给大家汇总一个结论性的验证结果。大家可以收藏，已备用到时查阅对照。\r\n\r\n通过阅读本文，你不仅能能够学到相关的结论，同时也提供了一套科学的实验方法论，个人觉得后者对大家来说更为重要。\r\n\r\n## 环境准备\r\n\r\n在验证之前，我们先准备好具体的环境和数据。\r\n\r\n建表语句：\r\n\r\n```\r\nCREATE TABLE `user` (\r\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\r\n  `user_no` varchar(16) DEFAULT NULL COMMENT '用户编号',\r\n  `author` varchar(16) DEFAULT NULL COMMENT '用户名',\r\n  `age` int(3) DEFAULT NULL COMMENT '年龄',\r\n  `address` varchar(128) DEFAULT NULL COMMENT '地址',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE KEY `un_idx_user_no` (`user_no`),\r\n  KEY `idx_author` (`author`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\r\n```\r\n\r\n初始化数据：\r\n\r\n```\r\ninsert into user values(null,'0001','user01',18,'北京');\r\ninsert into user values(null,'0002','user02',19,'上海');\r\ninsert into user values(null,'0003','user03',20,'广州');\r\ninsert into user values(null,'0004','user04',21,'深圳');\r\ninsert into user values(null,'0005','user05',22,'杭州');\r\n```\r\n\r\n数据库版本：\r\n\r\n```\r\n版本一：\r\n>select @@version;\r\n5.7.22\r\n​\r\n版本二：\r\n>select @@version;\r\n8.0.18\r\n```\r\n\r\n查询数据事务隔离级别：\r\n\r\n```\r\n>select @@transaction_isolation;\r\nREPEATABLE-READ\r\n```\r\n\r\nMySQL innodb支持的四种事务隔离级别：\r\n\r\n-   READ_UNCOMMITTED：读未提交；\r\n-   READ_COMMITTED：读已提交，后文简称为RC；\r\n-   REPEATABLE_READ：可重复读，MySQL默认的事务隔离级别。后文简称为RR；\r\n-   SERIALIZABLE：串行读；\r\n\r\n设置全局隔离级别：\r\n\r\n```\r\nset global transaction isolation level REPEATABLE READ;\r\nset global transaction isolation level READ COMMITTED;\r\n```\r\n\r\n设置会话隔离级别：\r\n\r\n```\r\nset session transaction isolation level REPEATABLE READ;\r\nset session transaction isolation level READ COMMITTED;\r\n```\r\n\r\n关闭自动提交：\r\n\r\n```\r\n> set @@autocommit=0;  //设置自动提交关闭\r\n```\r\n\r\n在执行完锁语句之后，可执行`commit`命令进行事务提交。\r\n\r\n```\r\ncommit;\r\n```\r\n\r\n准备完以上数据，便可以开始每一个场景的验证了。每个场景都起了一个编号，比如：**V5.x-RR-主键**，表示在MySQL 5.7.x，事务隔离级别为RR（可重复读），条件字段为主键的场景下进行的实验。\r\n\r\n## 场景1.1：V5.x-RR-主键\r\n\r\n**操作**：使用主键ID作为条件查询，然后新开启一个事务去更新数据。\r\n\r\n**分析思路**：一，如果更新数据被阻塞，则说明加锁成功；二，如果更新其他数据成功，则说明是行锁，如果更新其他数据失败则说明是表锁。三，部分场景会测试插入操作；后续所有操作基本雷同。\r\n\r\n执行悲观锁查询：\r\n\r\n```\r\nselect * from user where id = 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n在此场景下，来看一下数据库加的什么锁。\r\n\r\n当第二条语句被阻塞时，执行查看锁信息语句：\r\n\r\n```\r\nSELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;\r\n```\r\n\r\n注意，必须是正在执行第二条语句，且第二条语句处于阻塞状态下，上述语句才能查询到数据。\r\n\r\n查询结果如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c6f67c9d0d46358b40e28ae3689e46~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第二条记录为for update锁表语句，第一条记录为单纯的update语句。可以看出，此场景下，lock_mode为X，lock_type为RECORD，lock_data为1。\r\n\r\nlock_mode为X（排他锁）：即写锁，允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。\r\n\r\nlock_type为RECORD，说是是行级锁，lock_data表示锁定了1条记录。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为主键时，`select for update`为行级锁。\r\n\r\n当我们执行完一个场景之后，我们需要执行`commit`命令将当前事物提交。\r\n\r\n## 场景1.2：V5.x-RR-唯一索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where user_no = '0001' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息，同场景一的主键一致。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为唯一索引时，`select for update`为行级锁。\r\n\r\n## 场景1.3：V5.x-RR-普通索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where author = 'user01' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c52e1ab924b4475a892944be6909ff9f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，锁类型不仅仅是X排他锁，同时还添加了GAP（间隙锁），也就是说针对数据添加了排他间隙锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n此时再进行一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0006','user05',23,'重庆');\r\n```\r\n\r\n执行成功。\r\n\r\n由于存在了间隙锁，再执行一笔author与查询条件相同的插入操作：\r\n\r\n```\r\ninsert into user values(null,'0008','user01',24,'成都');\r\n```\r\n\r\n执行阻塞，说明此时有排他间隙锁的存在。\r\n\r\n**结论**：当查询条件为普通索引时，`select for update`为行级锁，同时会有排他间隙锁存在，当插入数据满足锁语句查询条件（相等、范围等）时，会发生阻塞。\r\n\r\n## 场景1.4：V5.x-RR-无索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where address = '北京' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行被**阻塞**。\r\n\r\n此时查询锁表信息展示如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3db31632e79e40f6abf6ee82ff57046d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里比较奇怪是lock_type，很明显，上述锁操作已经锁住了整张表，但lock_type依旧为RECORD。出处暂时有些费解。\r\n\r\n**结论**：当查询条件无索引时，`select for update`为表级锁。\r\n\r\n## 场景1.5：V5.x-RR-索引-范围查询\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where id > 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n执行成功，说明并没有锁定id为1的记录。\r\n\r\n执行插入操作：\r\n\r\n```\r\ninsert into user values(null,'0007','user07',24,'武汉');\r\n```\r\n\r\n插入操作被阻塞。这是因为插入的数据生成的id满足大于1的条件，会被阻塞。\r\n\r\n所信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfc23128d19b4c44866c09ffdeae6737~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，lock_type虽然是RECORD，但是lock_data显示supremum pseudo-record ，这就是InnoDB为了解决幻读问题的临键锁(Next-key Lock)，这里间隙锁和临键锁可以看做是一样的。\r\n\r\n需要注意的是：supremum pseudo-record有可能是间隙锁，需要结合死锁日志里的heap no判断。heap no 1是间隙锁。\r\n\r\n**结论**：当查询条件有索引且查询条件为范围时，`select for update`会采用间隙锁或临键锁，对指定范围内的数据进行加锁。当然，当查询条件无索引时，与场景1.4一致，为表锁。\r\n\r\n## 场景2.1：V8.x-RR-主键\r\n\r\n执行悲观锁查询：\r\n\r\n```\r\nselect * from user where id = 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查看数据库对应的锁：\r\n\r\n```\r\nSELECT * FROM performance_schema.data_locks;\r\n```\r\n\r\n注意，在MySQL 8中，采用了performance_schema替代了MySQL5中基于INFORMATION_SCHEMA的锁查询方式。\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92e746d60213448aa7db9ac7dbd86020~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上述查询结果中，有两条记录。lock_type字段展示锁范围，lock_mode字段展示了锁的类型。可以看到，该SQL语句先是在表范围上加了一把IX（意向排他锁，表锁）。然后，在记录（Record）范围上添加了一把X（排他锁），一把REC_NOT_GAP（行锁），综合起来就是对这条记录添加了行级排他锁，其他事务不能够再对其添加任何锁了。\r\n\r\n这里，既然在表的层面上添加了IX（意向排他锁），为什么不是表锁呢？这是因为意向排他锁的作用仅仅表名意向的锁，当其他事务要对全表的数据进行加锁时，那么就不需要判断每一条数据是否被加锁了。\r\n\r\n事务在给一行记录加排他锁前，必须先取得该表的IX锁，意向排他锁之间相互兼容，可以并行，不会产生冲突。意向排他锁存在的意义是为了更高效的获取表锁，主要目的是显示事务正在锁定某行或者试图锁定某行。\r\n\r\n继续实验，执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为主键时，`select for update`为行级锁。\r\n\r\n## 场景2.2：V8.x-RR-唯一索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where user_no = '0001' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3253d623b1a8408384c4dd215371eee5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，可以看到三把锁，一把表级别的IX锁，一把基于唯一索引的行级排他锁，一把基于主键的行级排他锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为唯一索引时，`select for update`为行级锁。\r\n\r\n## 场景2.3：V8.x-RR-普通索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where author = 'user01' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/423d3032c1a04b7aa56fe27e000af7c4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，可以看到四把锁，一把表级别的IX锁，一把基于普通索引的X排他锁，一把基于主键的行级排他锁，一把基于普通索引的`X,GAP`排他间隙锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功，说明更新操作没有影响。\r\n\r\n既然有排他间隙锁，此时需再测试一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0006','user05',23,'重庆');\r\n```\r\n\r\n执行成功。\r\n\r\n再执行一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0007','user01',24,'武汉');\r\n```\r\n\r\n注意这里插入的记录`author`与锁查询条件相同，发现操作被阻塞。\r\n\r\n通过两笔插入操作可以看出，排他间隙锁会阻塞符合查询条件（author='user01'）的数据的插入。\r\n\r\n**结论**：当查询条件为普通索引时，`select for update`为行级锁，同时会多一把排他间隙锁，如果插入数据满足锁语句的查询条件（等于、范围条件等），则无法插入。\r\n\r\n## 场景2.4：V8.x-RR-无索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where address = '北京' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86381d8eaf694a8480473fc06ef389b6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，数据库一共加了8把锁，一把表级别的IX意向排他锁，6把基于主键的针对数据记录（总共6条）的X锁，一把针对记录的supremum pseudo-record锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行被**阻塞**。\r\n\r\n**结论**：当查询条件无索引时，`select for update`为表级锁。\r\n\r\n## 场景2.5：V8.x-RR-索引-范围查询\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where id > 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n执行成功，说明并没有锁定id为1的记录。\r\n\r\n执行插入操作：\r\n\r\n```\r\ninsert into user values(null,'0007','user07',24,'武汉');\r\n```\r\n\r\n插入操作被阻塞。这是因为插入的数据生成的id满足大于1的条件，会被阻塞。\r\n\r\n查询锁信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4fa9f10df5b4ae6b9b6d15d9a7b3cf6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，锁信息对比场景2.4，少了一条不满足条件记录（id=1）的锁，其他符合条件的数据均被锁。\r\n\r\n**结论**：当查询条件有索引且查询条件为范围时，`select for update`会采用间隙锁或临键锁，对指定范围内的数据进行加锁。\r\n\r\n完成了上面针对RR事务隔离级别的验证，下面将数据库事务隔离级别切换为RC。\r\n\r\n```\r\nset global transaction isolation level READ COMMITTED;\r\n```\r\n\r\n注意，此处可能需要重启数据库，如果通过命令配置无效，可通过数据库配置文件进行配置，重启。\r\n\r\n另外，也可以通过在所有命令窗口执行`session`级别的设置，也可以达到效果，设置完成之后注意需要进行验证。\r\n\r\n## 场景3.1：V5.x-RC-主键\r\n\r\n执行悲观锁查询：\r\n\r\n```\r\nselect * from user where id = 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n锁信息与RR事务相同。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为主键时，`select for update`为行级锁。\r\n\r\n## 场景3.2：V5.x-RC-唯一索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where user_no = '0001' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息，与RR一致。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为唯一索引时，`select for update`为行级锁。\r\n\r\n## 场景3.3：V5.x-RC-普通索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where author = 'user01' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9d29d309bc4ae488d7016b4f1dd579~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n再把RR场景下的锁信息贴出来：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7010f3e492f43a98afad611ef547135~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看出，RC事务隔离级别时比RR事务隔离级别时少了一个GAP（间隙锁）。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n此时再进行一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0009','user01',24,'郑州');\r\n```\r\n\r\n执行成功。\r\n\r\n再验证下间隙锁是否真的不存在，执行一笔author与查询条件相同的插入操作：\r\n\r\n```\r\ninsert into user values(null,'0008','user01',24,'成都');\r\n```\r\n\r\n执行成功，说明此时间隙锁的不存在了。\r\n\r\n**结论**：当查询条件为普通索引时，`select for update`为行级锁，无间隙锁。\r\n\r\n## 场景3.4：V5.x-RC-无索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where address = '北京' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n锁信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f1b33eecbbb4ec383b49b3cbe44fed8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n显示基于主键的排他锁，这块挺出乎意料的，并没有进行表锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n再执行一笔插入操作，插入数据与查询条件address一致：\r\n\r\n```\r\ninsert into user values(null,'0011','user01',24,'北京');\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件无索引时，`select for update`为行级锁，也就说，在RC事务隔离级别下，即便无索引，也是只锁记录，与通常的直知觉不同。\r\n\r\n**原因**：会出现上述情况的原因是，本来如果锁条件上没有索引，MySQL会走聚簇（主键）索引进行全表扫描过滤，每条记录都会添加上X锁。但为了效率，MySQL会对扫描过程中不满足条件的记录进行解锁操作。\r\n\r\n## 场景3.5：V5.x-RC-索引-范围查询\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where id > 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n执行成功，说明并没有锁定id为1的记录。\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n操作被阻塞。这是因为操作的数据的id满足大于1的条件，会被阻塞。\r\n\r\n所信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8d9ee08d44440fb14d858a88f6f546~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**结论**：当查询条件有索引且查询条件为范围时，`select for update`对指定范围内的数据进行加锁。\r\n\r\n## 场景4.1：V8.x-RC-主键\r\n\r\n执行悲观锁查询：\r\n\r\n```\r\nselect * from user where id = 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n锁信息同RR。\r\n\r\n继续实验，执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为主键时，`select for update`为行级锁。\r\n\r\n## 场景4.2：V8.x-RC-唯一索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where user_no = '0001' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n锁信息同RR。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件为唯一索引时，`select for update`为行级锁。\r\n\r\n## 场景4.3：V8.x-RC-普通索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where author = 'user01' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04236a1a80114e12895c2719c73a0ee5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对照一下RR场景下的锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c46f04ba9e74d719a3d2465bbab6f38~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看出RC场景下笔RR场景下少了一条行级间隙锁。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功，说明更新操作没有影响。\r\n\r\n验证一下是否有排他间隙锁，此时需再测试一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0010','user05',23,'重庆');\r\n```\r\n\r\n执行成功。\r\n\r\n再执行一笔插入操作：\r\n\r\n```\r\ninsert into user values(null,'0007','user01',24,'武汉');\r\n```\r\n\r\n注意这里插入的记录`author`与锁查询条件相同，执行成功，说明真的不存在X，GAP（排他间隙锁）。\r\n\r\n**结论**：当查询条件为普通索引时，`select for update`为行级锁。\r\n\r\n## 场景4.4：V8.x-RC-无索引\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where address = '北京' for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n此处更新操作被阻塞，说明数据锁定成功。\r\n\r\n查询锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74af25a46b944806ba53b5480f9caa7b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对照一下RR场景：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ece910de9ae4e9b81ce87fc7716367b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对于RR场景，RC场景下，只有一条排他行锁（X,REC_NOT_GAP）。\r\n\r\n执行更新其他记录操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 2;\r\n```\r\n\r\n执行成功。\r\n\r\n**结论**：当查询条件无索引时，`select for update`为行级锁。这里的原因与场景3.4一致。\r\n\r\n## 场景4.5：V8.x-RC-索引-范围查询\r\n\r\n执行悲观锁操作：\r\n\r\n```\r\nselect * from user where id > 1 for update;\r\n```\r\n\r\n执行更新操作：\r\n\r\n```\r\nupdate user set age = age +1 where id = 1;\r\n```\r\n\r\n执行成功，说明并没有锁定id为1的记录。\r\n\r\n执行插入操作：\r\n\r\n```\r\ninsert into user values(null,'0012','user12',24,'--');\r\n```\r\n\r\n执行成功。\r\n\r\n查询锁信息如下：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1dafd69f942426dbafa6149588ba5f7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n对照RR场景下的锁信息：\r\n\r\n![锁信息](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec5934ba9dcd4b51a5b4839b139c9c5f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n此时，RC场景下，少了临键锁，排他锁也变为了行级排他锁。\r\n\r\n**结论**：当查询条件有索引且查询条件为范围时，`select for update`会对指定范围内的数据进行加锁，只会阻塞符合条件的记录，不影响插入操作。\r\n\r\n## 场景及结论\r\n\r\n完成了上面的实验之后，我们通过一个表格来总结一下所有的场景和结论。\r\n\r\n| 版本               | 主键                  | 唯一索引                | 普通索引                                        | 无索引              | 范围查询               |\r\n| ---------------- | ------------------- | ------------------- | ------------------------------------------- | ---------------- | ------------------ |\r\n| MySQL 5.7.x - RR | X：行锁                | X，行锁                | X,GAP：行锁，间隙锁，条件范围内会阻塞                       | 表锁               | 指定范围加锁，insert阻塞    |\r\n| MySQL 8.0.x - RR | X,REC_NOT_GAP：行级排他锁 | X,REC_NOT_GAP：行级排他锁 | X；X,REC_NOT_GAP；X,GAP：行锁+排他间隙锁，阻塞范围内insert； | 表锁，每条记录一个X锁      | 指定范围加锁，insert阻塞    |\r\n| MySQL 5.7.x - RC | X：行锁                | X，行锁                | X，行锁，无间隙锁；                                  | 行锁               | 指定范围加锁，更新、insert阻塞 |\r\n| MySQL 8.0.x - RC | X,REC_NOT_GAP：行级排他锁 | X,REC_NOT_GAP：行级排他锁 | X,REC_NOT_GAP：行锁，无间隙锁；                      | X,REC_NOT_GAP：行锁 | 指定范围加锁，不阻塞insert   |\r\n\r\n从上面表中我们可以总结出以下结论（基于RR、RC两种事务隔离级别）：\r\n\r\n-   无论哪个版本的MySQL，查询条件为主键、唯一索引、普通索引的情况下，为行锁；\r\n-   查询条件为普通索引时，事务隔离级别为RR时，MySQL还会添加一个间隙锁，条件内的插入、更新会被阻塞；\r\n-   事务隔离级别为RR时，查询条件无索引，为表锁；\r\n-   事务隔离级别为RC时，查询条件无索引，为行锁；\r\n-   查询条件为范围时，有索引的情况下，除MySQL 8.0.x RC场景下不阻塞插入操作，其他场景均阻塞指定范围更新、插入操作；\r\n\r\n通过上面的结论，我们可以看出，并不是简单的说“有索引就是行锁，无索引就是表锁”，因为在事务隔离级别为RC时，无索引，同样表现（被优化）为行锁。\r\n\r\n至于，根据范围条件（大于、小于、不等于、between、like等）查询、查询无结果等情况，大家可根据上述实验方法进行自行验证。\r\n\r\n本文为大家提供了实验方法，并针对常见的场景给出了结论，希望能够帮到你，也希望大家能够点赞、转发、收藏，以备不时之需。"
    },
    {
        "article_id": "7174071206717423646",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ca088b4f704caa90338842a0408eba~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一起用Go写一个小游戏（下）",
        "preview": "打包资源 使用file2byteslice包我们可以将图片和config.json文件打包进二进制程序中，之后编译生成一个二进制程序。然后拷贝这一个文件即可，不用再拷贝图片和其他配置文件了。 gola",
        "author": "darjun",
        "view_count": 14756,
        "collect_count": 18,
        "comment_count": 6,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/6/166e82b48a1eb3d9~tplv-t2oaga2asx-image.image",
        "category": "后端",
        "content": "## 打包资源\r\n\r\n使用file2byteslice包我们可以将图片和config.json文件打包进二进制程序中，之后编译生成一个二进制程序。然后拷贝这一个文件即可，不用再拷贝图片和其他配置文件了。\r\n\r\ngolang有很多第三方包可以将打包资源，原理其实很简单——读取资源文件的内容，然后生成一个go文件，在这个文件中创建一个变量保存这个文件的二进制内容。\r\n\r\n我们将使用ebiten作者编写的file2byteslice包。首先使用`go install`命令安装它：\r\n\r\n```cmd\r\n$ go install github.com/hajimehoshi/file2byteslice\r\n```\r\n\r\nfile2byteslice的命令格式如下：\r\n\r\n```cmd\r\n$ file2byteslice -input INPUT_FILE -output OUTPUT_FILE -package PACKAGE_NAME -var VARIABLE_NAME\r\n```\r\n\r\n故我们可以这样来打包文件：\r\n\r\n```cmd\r\n$ file2byteslice -input ../images/ship.png -output resources/ship.go -package resources -var ShipPng\r\n$ file2byteslice -input ../images/alien.png -output resources/alien.go -package resources -var AlienPng\r\n$ file2byteslice -input config.json -output resources/config.go -package resources -var ConfigJson\r\n```\r\n\r\n生成文件如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31293e3366a44275ac9e2caa1b889cc0~tplv-k3u1fbpfcp-zoom-1.image)\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2051a50c699949abbc00c5e4bead0f4b~tplv-k3u1fbpfcp-zoom-1.image)\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705ac78c614a42e3b1d144c1cc5e7c9f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n相应的加载这些文件的代码需要相应的修改：\r\n\r\n```golang\r\n// alien.go\r\nfunc NewAlien(cfg *Config) *Alien {\r\n  img, _, err := ebitenutil.NewImageFromReader(bytes.NewReader(resources.AlienPng))\r\n  if err != nil {\r\n    log.Fatal(err)\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n```golang\r\n// ship.go\r\nfunc NewShip(screenWidth, screenHeight int) *Ship {\r\n  img, _, err := ebitenutil.NewImageFromReader(bytes.NewReader(resources.ShipPng))\r\n  if err != nil {\r\n    log.Fatal(err)\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n```golang\r\n// config.go\r\nfunc loadConfig() *Config {\r\n  var cfg Config\r\n  if err := json.NewDecoder(bytes.NewReader(resources.ConfigJson)).Decode(&cfg); err != nil {\r\n    log.Fatalf(\\\"json.Decode failed: %v\\\r\n\\\", err)\r\n  }\r\n\r\n  return &cfg\r\n}\r\n```\r\n\r\n然后，我们就可以编译成一个游戏二进制程序随意拷贝到其他电脑上运行了：\r\n\r\n```cmd\r\n$ go build -o alien_invasion\r\n```\r\n\r\n### go generate\r\n\r\n前面先安装file2byteslice程序，然后一个命令一个命令地执行打包，操作起来很是繁琐。如果有文件修改，这个过程又需要来一次。\r\n\r\n实际上，我们可以使用`go generate`让上面的过程更智能一点。在main.go文件中添加如下几行注释：\r\n\r\n```golang\r\n//go:generate go install github.com/hajimehoshi/file2byteslice\r\n//go:generate mkdir resources\r\n//go:generate file2byteslice -input ../images/ship.png -output resources/ship.go -package resources -var ShipPng\r\n//go:generate file2byteslice -input ../images/alien.png -output resources/alien.go -package resources -var AlienPng\r\n//go:generate file2byteslice -input config.json -output resources/config.go -package resources -var ConfigJson\r\n```\r\n\r\n注意，`//`和`go:generate`之间一定不能有空格，一定不能有空格，一定不能有空格，重要的事情说3遍！然后执行下面的命令即可完成安装file2byteslice和打包资源的工作：\r\n\r\n```cmd\r\n$ go generate\r\n```\r\n\r\n## 让游戏在网页上运行\r\n\r\n借助于wasm的强大功能，我们的游戏可以很好地在web上运行！为了让程序能够在网页上运行，我们需要将其编译成wasm。Go内置对wasm的支持。编译方式如下：\r\n\r\n```cmd\r\n$ GOOS=js GOARCH=wasm go build -o alien_invasion.wasm\r\n```\r\n\r\nGo提供的胶水代码，将位于`$GOROOT/misc/wasm`目录下的wasm_exec.html和wasm_exec.js文件拷贝到我们的项目目录下。注意wasm_exec.html文件中默认是加载名为test.wasm的文件，我们需要将加载文件改为alien_invasion.wasm，或者将生成的文件改名为test.wasm。\r\n\r\n然后编写一个简单的web服务器：\r\n\r\n```golang\r\npackage main\r\n\r\nimport (\r\n  \\\"log\\\"\r\n  \\\"net/http\\\"\r\n)\r\n\r\nfunc main() {\r\n  if err := http.ListenAndServe(\\\":8080\\\", http.FileServer(http.Dir(\\\".\\\"))); err != nil {\r\n    log.Fatal(err)\r\n  }\r\n}\r\n```\r\n\r\n运行：\r\n\r\n```cmd\r\n$ go run main.go\r\n```\r\n\r\n打开浏览器输入地址：localhost:8080/wasm_exec.html。\r\n\r\n![](https://darjun.github.io/img/in-post/godailylib/ebiten25.png#center)\r\n\r\n点击run按钮即可愉快地玩耍啦！\r\n\r\n![](https://darjun.github.io/img/in-post/godailylib/ebiten26.gif#center)\r\n\r\n## 项目的不足\r\n\r\n到目前为止，我们的游戏基本上可玩，但是还有很多的不足：\r\n* 没有声音！\r\n* 外星人没有横向的运动！\r\n* 分数都没有！\r\n\r\n这些有兴趣的童鞋可以自己去实现了😀。\r\n\r\n## 总结\r\n\r\n接着上文，本文介绍了如何将资源文件打包进一个二进制程序中，方便相互之间的传播。然后我们不费吹灰之力就将这个游戏移至到了网页之中。\r\n\r\n总的来说ebiten是一款简单、易上手的2D游戏开发引擎。对游戏开发感兴趣的童鞋可以使用它来快速开发，引起自己的兴趣。用它来开发一些小游戏也是得心应手，而且自带跨平台功能，十分方便。但是，大型、复杂游戏的开发还是要借助专业的引擎。\r\n\r\n大家如果发现好玩、好用的 Go 语言库，欢迎到 Go 每日一库 GitHub 上提交 issue😄\r\n\r\n## 参考\r\n\r\n1. Go 每日一库 GitHub：[https://github.com/darjun/go-daily-lib](https://github.com/darjun/go-daily-lib)\r\n2. ebitengine 官网：[https://ebitengine.org/](https://ebitengine.org/)\r\n3. Python 编程（从入门到实践）：[https://book.douban.com/subject/35196328/](https://book.douban.com/subject/35196328/)\r\n\r\n## 我\r\n\r\n我的博客：[https://darjun.github.io](https://darjun.github.io)\r\n\r\n欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~"
    },
    {
        "article_id": "7187330076772417595",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca9c3248af14558a7861caf01c2cd25~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3发布快两年半，我才用它完成了第一个项目——vue3+setup🔥",
        "preview": "距离 vue3 2020年09月18日正式发布已经过去快两年半了, 以前还能说是对新技术、新特性的观望，但是经过两年半的沉淀该有的都有了，也正好通过项目学习一下vue3",
        "author": "沉狗蛋",
        "view_count": 2953,
        "collect_count": 83,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ace2b3704f45bed351a44f3d170aef04~300x300.image",
        "category": "前端",
        "content": "---\r\nhighlight: a11y-dark\r\ntheme: smartblue\r\n---\r\n\r\n## 前言\r\n距离 vue3 2020年09月18日正式发布已经过去快两年半了, 以前还能说是对新技术、新特性的观望，新技术用到生产会产生什么什么样不可预知的问题，但是经过两年半的沉淀该有的都有了，刚好也是有个新起的项目技术栈使用的是vue3，经过一个多月vue3的体验，对这个学习过程记录下来做个总结，也便于日后的梳理。\r\n\r\n## 版本\r\n既然要开始使用vue3，那就直接从最新的版本开始`\\\"vue\\\": \\\"^3.2.0\\\"`。3.2之后只需在`script`中添加`setup`，然后就可以在标签中直接使用vue3的`组合式API`，也不用写 setup 函数，响应式的属性和方法也不用 return 出来才能使用，像 `ref` ， `reactive`这些方法通过 `unplugin-auto-import` 这个插件也不用每次都 `import` 导入进来，总之比最开始的时候在书写方面简洁了许多，要不怎么说是经过了两年半的沉淀呢。\r\n\r\n## 准备工作\r\n1. 初始化 `npm init vue@latest`\r\n2. 安装 vscode 插件 Volar，**注意** vue2项目中使用 Vetur，vue3中使用Volar\r\n3. 使用`unplugin-auto-import` 插件给每个`.vue`文件导入 `vue组合式API`\r\n4. 将浏览器的启用自定义格式设置工具勾选上\r\n![企业微信截图_16734207098350.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a491747cb6ce437185f7aee954d112b9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![企业微信截图_16734209963835.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/215617862cec43b3b15ed4398890f080~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb721bd564849e1b32874d42ec7c7f8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以直观的看到响应式变量的值，调试的时候不用多点一次。\r\n    \r\n接下来让我们愉快的体验下vue3 setup，先用一张图感受一下组合式API的直观感受\r\n\r\n![v2-8f40f129a8f05f75f5238839f1714c5d_b (1).webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56583c7c64744e5fa752599063c60422~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 认识 ref 系列\r\n### ref\r\n**ref：** 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`，所以访问的时候要通过 `.value` 的形式访问，在 `<tamplate>` 会自动解析，不需要 .value\r\n\r\n```js\r\nconst state = ref(1)\r\nconsole.log('state---', state)\r\nconsole.log('state.value---', state.value)\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb721bd564849e1b32874d42ec7c7f8~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### shallowRef\r\n**shallowRef：** `ref()` 的浅层作用形式，只有对 `.value` 的访问是响应式的，和 `ref()` 不同的是不会被深层递归地转为响应式。\r\n```html\r\n<template>\r\n  <div>state:{{ state }}</div>\r\n</template>\r\n<script setup>\r\nconst state = shallowRef({ count: 1 })\r\n// 不会触发视图更改\r\nsetTimeout(() => {\r\n state.value.count = 2\r\n}, 2000)\r\n// 会触发视图更改\r\nsetTimeout(() => {\r\n  state.value = { count: 2 }\r\n}, 2000)\r\n</script>    \r\n```\r\n> `ref()`和`shallowRef()`不能同时使用，ref会调用triggerRefValue会更新视图，会导致shallowRef的数据一并被更新\r\n\r\n### triggerRef\r\n**triggerRef：** 强制触发依赖于一个浅层ref的副作用，这通常在对浅引用的内部值进行深度变更后使用，比如更新 `shallowRef()` 深层的视图更新。\r\n```js\r\nconst state1 = shallowRef({ count: 1 })\r\nsetTimeout(() => {\r\n  // 不会触发更改\r\n  state.value.count = 2 \r\n  // 调用triggerRef会触发视图更改\r\n  triggerRef(state)\r\n}, 2000)\r\n```\r\n### customRef\r\n**customRef：** 创建一个自定义的 ref，提供的track, trigger这两个依赖的收集和触发方法，也是方便我们在任何地方调用，让 ref 根据自己的需求更加灵活，比如在 set 的时候加个防抖，一般 track 收集在 get 中调用，trigger 触发在 set 中调用，除非你有自己的想法。\r\n```html\r\n<template>\r\n  <div>name:{{ name }}</div>\r\n  <button @click=\\\"change\\\">修改 customRef</button>\r\n</template>  \r\n\r\n<script setup>\r\nconst myRef = value => {\r\n  let timer\r\n  return customRef((track, trigger) => {\r\n    return {\r\n      get() {\r\n        track()\r\n        return value\r\n      },\r\n      set(newVal) {\r\n        clearTimeout(timer)\r\n        timer = setTimeout(() => {\r\n          console.log('触发了set')\r\n          value = newVal\r\n          trigger()\r\n        }, 500)\r\n      },\r\n    }\r\n  })\r\n}\r\nconst name = myRef('测试')\r\nconst change = () => {\r\n   name.value = '测试变了'\r\n}\r\n</script>\r\n```\r\n\r\n## 认识Reactive系列\r\n### reactive\r\n**reactive：** 返回一个对象的响应式代理，用来绑定复杂的数据类型，不可以绑定普通的数据类型，相比 `ref` ，不用通过 `.value` 的方式来访问\r\n```js\r\nlet obj = reactive({ count: 0 })\r\nobj.count = 2\r\n```\r\n**关于数组异步赋值问题及解决方案**，在开发中经常碰到异步赋值的问题，在vue3中不能通过像vue2那样直接用`=` 赋值的操作，这样会破坏数据原有的响应式，只能通过数据原有的方法，或者在它的外层再包裹一层结构来解决\r\n```\r\nlet arr = reactive([])\r\nsetTimeout(() => {\r\n  arr = [1, 2, 3] // 这样arr赋值会脱离响应式\r\n  console.log(arr);\r\n},1000)\r\n\r\n// 解决办法：使用数组的push方法\r\nsetTimeout(() => {\r\n  arr.push(...[1, 2, 3])\r\n  console.log(arr)\r\n}, 1000)\r\n\r\n// 解决办法：再外层包裹一个对象\r\nlet arr = reactive({\r\n  list: [],\r\n})\r\nsetTimeout(() => {\r\n  arr.list = [1, 2, 3]\r\n  console.log(arr)\r\n}, 1000)\r\n```\r\n### shallowReactive\r\n**shallowReactive：** `reactive()` 的浅层作用形式。和 `reactive()` 不同的是这里没有深层级的转换，一个浅层响应式对象里只有根级别的属性是响应式的，如果是深层的数据只会改变值，不会改变视图\r\n```html\r\n<template>\r\n  <div>shallowReactive：state:{{ state }}</div>\r\n  <button @click=\\\"change1\\\">test1</button>\r\n  <button @click=\\\"change2\\\">test2</button>\r\n</template>  \r\n\r\n<script setup>\r\nlet obj = {\r\n  a: 1,\r\n  first: {\r\n    b: 2,\r\n    second: {\r\n      c: 3,\r\n    },\r\n  },\r\n}\r\nconst state = shallowReactive(obj)\r\nconst change1 = () => {\r\n  state.a = 7\r\n}\r\nconst change2 = () => {\r\n  state.first.b = 8\r\n  state.first.second.c = 9\r\n  console.log(state)\r\n}\r\n</script>\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc7bb3c103e44738963848d3422621e3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 如上图所示，点击 `test2` 的时候虽然数据变了，但是视图并未更新，也不能像 `shallowRef` 那样通过 `triggerRef` 来解决视图更新，而且也不能和 `reactive`一起使用，一般只会在数据层级深且数据量大只使用顶级属性的时候才会用 `shallowReactive` 解决性能问题\r\n\r\n## 认识to系列\r\n**toRef：** 基于**响应式对象**上的一个**属性**，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。重点是基于响应式对象，用它包裹普通对象没有什么意义，虽然值会改变，但是是非响应式的。\r\n```js\r\nconst obj = reactive({\r\n  foo: 2,\r\n  bar: 1,\r\n})\r\nconst barRef = toRef(obj, 'bar')\r\n// obj响应式对象的bar属性 转化为响应式对象\r\nconst change = () => {\r\n  barRef.value++\r\n  console.log('obj', obj)\r\n  console.log('barRef', barRef)\r\n}\r\nconst change2 = () => {\r\n  obj.bar++\r\n  console.log('obj', obj)\r\n  console.log('barRef', barRef)\r\n}\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c65d9ec51141473b8b054c25fc702ce5~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### toRefs\r\n\r\n**toRefs：** 将一个**响应式对象**转换为一个**普通对象**，这个普通对象的每个属性都是指向源对象相应属性的 ref，每个单独的 ref 都是使用 `toRef()` 创建的，可以帮我们批量创建ref来方便我们解构使用。\r\n```js\r\nconst state = reactive({\r\n  foo: 1,\r\n  bar: 2,\r\n})\r\nconst stateAsRefs = toRefs(state)\r\nconst { foo, bar } = toRefs(state)\r\nfoo.value = 999\r\nconsole.log('state：', state)\r\nconsole.log('stateAsRefs：', stateAsRefs)\r\nconsole.log('foo：', foo)\r\nconsole.log('bar：', bar)\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600ed490f50e439ba0c8a1874fb2830c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### toRaw\r\n**toRaw：** 根据一个 Vue 创建的代理返回其原始对象，将**响应式对象转化为普通对象**，这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，需谨慎使用。\r\n```js\r\nconst foo = {}\r\nconst reactiveFoo = reactive(foo)\r\nreactiveFoo.a = 1\r\nconst toRawFoo = toRaw(reactiveFoo)\r\nconsole.log('foo：', foo)\r\nconsole.log('reactiveFoo：', reactiveFoo)\r\nconsole.log('toRawFoo：', toRawFoo)\r\nconsole.log('toRawFoo === foo：', toRawFoo === foo)\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92c0c8692b74392b933dea2c6055452~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## readonly和shallowReadonly\r\n### readonly\r\n**readonly：** 接受一个对象 (不论是响应式还是普通的) 或是一个ref，返回一个原值的**只读**代理，强制更改会有警告。\r\n```js\r\nconst state = reactive({ count: 1 })\r\nconst copy = readonly(state)\r\n\r\ncopy.count++\r\n```\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b94405e525a04a60ac476c79c95209e0~tplv-k3u1fbpfcp-zoom-1.image)\r\n### shallowReadonly\r\n**shallowReadonly：** `readonly()` 的浅层作用形式，只有根层级的属性变为了只读，深层次的属性修改不会有警告。\r\n\r\n## computed计算属性\r\n**computed：** 就是当依赖的属性的值发生变化的时候，才会触发更改，如果依赖的值，不发生变化的时候，使用的是缓存中的属性值。它接受一个getter函数，返回一个只读的响应式ref对象。该 ref 通过 `.value` 暴露 getter 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 ref 对象。\r\n\r\n`computed`总的来说vue2和vue3的差别不是很大，就是写法有些区别。\r\n```js\r\nlet price = ref(1)\r\n// 只读\r\nlet cPrice = computed(() => {\r\n  return '￥' + price.value\r\n})\r\nconsole.log('cPrice:', cPrice.value)\r\n// 可写\r\nlet cWritePrice = computed({\r\n  get() {\r\n    return '￥' + price.value\r\n  },\r\n  set(value) {\r\n    price.value = 'set' + value\r\n  },\r\n})\r\ncWritePrice.value = 2\r\nconsole.log('price:', price.value)\r\nconsole.log('cWritePrice:', cWritePrice.value)\r\n```\r\n\r\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433df93bda974fdf8ddc3900de654fb3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## watch侦听器\r\n**watch：** 侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。\r\n1.  第一个参数是侦听器的源。这个来源可以是以下几种：\r\n    -   一个函数，返回一个值\r\n        ```js\r\n        const state = reactive({ count: 0 })\r\n        watch(\r\n          () => state.count,\r\n          (newVal, oldVal) => {\r\n            console.log(newVal, oldVal)\r\n          }\r\n        )\r\n        ```\r\n    -   一个 ref\r\n        ```js\r\n        const count = ref(0)\r\n        watch(count, (newVal, oldVal) => {\r\n          console.log(newVal, oldVal)\r\n        })\r\n        ```\r\n    -   一个响应式对象，侦听器会自动启用深层模式,**但是无法正确获得oldValue！！**，**会自动启用深层模式**\r\n        ```js\r\n        const state = reactive({\r\n          foo: {\r\n            a: 1,\r\n          },\r\n          bar: {\r\n            b: 2,\r\n          },\r\n        })\r\n        watch(state, (newVal, oldVal) => {\r\n          console.log(newVal, oldVal) // 下图可以看出oldVal和newVal是一样的\r\n        }, {\r\n          // deep: true  // 自动启用深层模式\r\n        })\r\n        ```\r\n        ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd0005eec68348cc87bf14d3b8b26967~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n    -   或是由以上类型的值组成的数组\r\n        ```\r\n        watch(\r\n          [() => state.foo, () => state.bar],\r\n          (newValue, oldValue) => {\r\n            console.log(newValue, oldValue)\r\n          },\r\n          {\r\n            deep: true,\r\n          }\r\n        )\r\n        ```\r\n2. 第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。\r\n3. 第三个可选的参数是一个对象，支持以下这些选项：\r\n    -   `immediate`：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。\r\n\r\n    -   `deep`：如果源是对象，强制深度遍历，以便在深层级变更时触发回调，使用reactive监听深层对象开启和不开启deep 效果一样\r\n\r\n    -   `flush`：调整回调函数的刷新时机。\r\n        | | pre | sync | post    |\r\n        | --- | --- | --- | --- |\r\n        | 更新时机 | 组件更新前执行 | 强制效果始终同步触发 | 组件更新后执行 |\r\n\r\n## watchEffect高级侦听器\r\n**watchEffect：** 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。\r\n```js\r\n//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\r\nwatchEffect(() => {\r\n  const bar = state.bar\r\n  const foo = state.foo\r\n  console.log('watchEffect配置的回调执行了')\r\n})\r\n```\r\n### watchEffect，watch，computed的区别\r\n-   `watch`：既要指明监听的属性，也要指明监听的回调。\r\n\r\n-   `watchEffect`：不用指明监听哪个属性，监听的回调中用到哪个属性，那就监听哪个属性。\r\n\r\n-   `watchEffect`有点像`computed`，但`computed`注重的计算出来的值（回调函数的返回值），必须要写返回值，而`watchEffect`更注重的是过程（回调函数的函数体），不用写返回值。\r\n\r\n## 自定义`hook`函数\r\n### 什么是`hook`\r\n`hook` 本质是一个函数，把`setup`函数中使用的组合式API进行了封装。\r\n### 和vue2.x中的`mixin`比较\r\n1. mixin的缺点：变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护；多个`mixin`的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突，所以在 vue3 中已弃用。\r\n2. 自定义 `hook` 的优势：复用代码, 很清楚复用功能代码的来源。\r\n\r\n### 实现一个记录当前鼠标点击位置的hook\r\n创建一个hooks文件夹，里面创建文件usePoint.js\r\n```\r\nimport { reactive, onMounted, onBeforeUnmount, toRefs } from 'vue'\r\nexport default function () {\r\n  let point = reactive({\r\n    x: 0,\r\n    y: 0,\r\n  })\r\n  const savePoint = event => {\r\n    point.x = event.pageX\r\n    point.y = event.pageY\r\n    console.log(event.pageX, event.pageY)\r\n  }\r\n  onMounted(() => {\r\n    window.addEventListener('click', savePoint)\r\n  })\r\n  onBeforeUnmount(() => {\r\n    window.removeEventListener('click', savePoint)\r\n  })\r\n  return toRefs(point)\r\n}\r\n```\r\n在组件中使用\r\n```html\r\n<template>\r\n  <h2>当前点击时鼠标的坐标为：x：{{pointX}}，y：{{pointY}}，point：{{ point }}</h2>\r\n</template>\r\n<script setup>\r\nimport usePoint from '@/hooks/usePoint'\r\nconst point = usePoint()\r\nconst { x: pointX, y: pointY } = usePoint()\r\n</script>\r\n```\r\n## CSS相关\r\n### 新增的选择器\r\n1. 深度选择器`:deep()`：处于 `scoped` 样式中的选择器如果想要做更“深度”的选择，可以使用 `:deep()` 这个伪类，可以不用在使用 `::v-deep`\r\n2. 插槽选择器`:slotted`：默认情况下，作用域样式不会影响到 `<slot/>` 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 `:slotted` 伪类以明确地将插槽内容作为选择器的目标\r\n3. 全局选择器`:global` ：如果想让其中一个样式规则应用到全局，可以使用 `:global` 伪类来实现，不用再另外创建一个 `<style>`\r\n\r\n### CSS Modules\r\n**CSS Modules：** `<style module>` 标签会被编译为 CSS Modules 并且将生成的 CSS class 作为 `$style` 对象暴露给组件，也可以通过 module `<style module=\\\"classes\\\">`自定义注入名称\r\n```html\r\n<template>\r\n  css modules\r\n  <!-- 默认注入名称 -->\r\n  <p :class=\\\"$style.red\\\">red</p>\r\n  <!-- 自定义注入名称 -->\r\n  <p :class=\\\"classes.green\\\">green</p>\r\n</template>\r\n\r\n/* 默认注入的名称 $style */\r\n<style module>\r\n.red {\r\n  color: red;\r\n}\r\n</style>\r\n/* 自定义注入的名称 classes */\r\n<style module=\\\"classes\\\">\r\n.green {\r\n  color: green;\r\n}\r\n</style>\r\n```\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca3ccbee58cd475fb40a939603e013c5~tplv-k3u1fbpfcp-zoom-1.image)\r\n### 在css中使用js变量\r\nCSS 中的 `v-bind()`:单文件组件的 `<style>` 标签支持使用 `v-bind` CSS 函数将 CSS 的值链接到动态的组件状态,且支持 JavaScript 表达式 (需要用引号包裹起来)\r\n```html\r\n<template>\r\n  <p>hello</p>\r\n</template>\r\n\r\n<script setup>\r\nconst theme = {\r\n  color: 'red'\r\n}\r\n</script>\r\n\r\n<style scoped>\r\np {\r\n  color: v-bind('theme.color');\r\n}\r\n</style>\r\n```\r\n## 新增的内置组件\r\n\r\n### Fragment\r\n1. 在Vue2中: 组件 `<template>` 必须有一个根标签\r\n2. 在Vue3中: 组件 `<template>` 可以没有根标签, 内部会将多个标签包含在一个`Fragment`虚拟元素中\r\n3. 好处: 减少标签层级, 减小内存占用\r\n\r\n### Teleport\r\n1. **Teleport** 可以将其插槽内容渲染到指定 DOM 节点，不受父级`style`、`v-show`等属性影响，但`data`、`prop`数据依旧能够共用的技术；\r\n2. Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下呈现 HTML，而不必求助于全局状态或将其拆分为两个组件。\r\n3. 使用： 通过to 属性插入到指定元素位置，如 body，html，自定义className等等，不能是组件中的某些位置否则会报错。\r\n\r\n    ```html\r\n    <teleport to=\\\"移动位置\\\">我是一个弹窗<</teleport>\r\n    ```\r\n    \r\n## Suspense\r\n1. `<Suspense>` 接受两个插槽：`#default` 和 `#fallback`。它将在内存中渲染默认插槽的同时展示后备插槽内容。\r\n2. 如果在渲染时遇到异步依赖项 (异步组件和具有 `async setup()` 的组件)，它将等到所有异步依赖项解析完成时再显示默认插槽。\r\n3. `<script setup>` 中可以使用顶层 `await`。结果代码会被编译成 `async setup()`\r\n4. 使用：实际开发中没有使用，个人觉得列表数据加载中配合骨架屏使用应该不错\r\n\r\n### 示例\r\n异步组件\r\n```html\r\n<template>\r\n  <div>异步组件</div>\r\n</template>\r\n\r\n<script setup>\r\nconst res = async () => {\r\n  return await new Promise(resolve => {\r\n    setTimeout(() => {\r\n      resolve()\r\n    }, 2000)\r\n  })\r\n}\r\nawait res()\r\n</script>\r\n```\r\n\r\n异步引入组件\r\n```html\r\n<template>\r\n  <Suspense>\r\n    <AsyncView />\r\n    <template #fallback>\r\n      <div>loading...</div>\r\n    </template>\r\n  </Suspense>\r\n</template>\r\n\r\n<script setup>\r\nconst AsyncView = defineAsyncComponent(() => import('./AsyncView.vue'))\r\n</script>\r\n```\r\n## v-model\r\n**`v-model`** 其实是一个语法糖 通过props和emit组合而成的，在Vue3中v-model 是破坏性更新的\r\n### vue2和vue3中两者的区别\r\n1. 默认值的改变\r\n    -   prop：value -> modelValue\r\n    -   事件：input -> update:modelValue\r\n2. 新增 支持多个v-model\r\n3. 新增 支持自定义 修饰符 Modifiers\r\n4. v-bind 的 .sync 修饰符和组件的 model 选项已移除\r\n\r\n### 示例\r\n\r\n```html\r\n<!-- 父组件 -->\r\n<UserName v-model:first-name=\\\"first\\\" v-model:last-name=\\\"last\\\" />\r\n```\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <input type=\\\"text\\\" :value=\\\"firstName\\\" @input=\\\"$emit('update:firstName', $event.target.value)\\\" />\r\n  <input type=\\\"text\\\" :value=\\\"lastName\\\" @input=\\\"$emit('update:lastName', $event.target.value)\\\" />\r\n</template>\r\n\r\n<script setup>\r\ndefineProps({\r\n  firstName: String,\r\n  lastName: String,\r\n})\r\n\r\ndefineEmits(['update:firstName', 'update:lastName'])\r\n</script>\r\n```\r\n也可以看看我之前写的[vue2和vue3组件封装父子组件之间的通信之v-model](https://juejin.cn/post/7164701603327377445)\r\n\r\n## 指令directive\r\n### 指令钩子函数\r\n相比vue2中的指令，vue3中的生命周期更好理解，它的生命周期和vue2的生命周期触发时机是一样的，参数和vue2基本一样。\r\n```js\r\nconst vMyDirective = {\r\n  // 在绑定元素的 attribute 前\r\n  // 或事件监听器应用前调用\r\n  created(el, binding, vnode, prevVnode) {\r\n    // 下面会介绍各个参数的细节\r\n  },\r\n  // 在元素被插入到 DOM 前调用\r\n  beforeMount(el, binding, vnode, prevVnode) {},\r\n  // 在绑定元素的父组件\r\n  // 及他自己的所有子节点都挂载完成后调用\r\n  mounted(el, binding, vnode, prevVnode) {},\r\n  // 绑定元素的父组件更新前调用\r\n  beforeUpdate(el, binding, vnode, prevVnode) {},\r\n  // 在绑定元素的父组件\r\n  // 及他自己的所有子节点都更新后调用\r\n  updated(el, binding, vnode, prevVnode) {},\r\n  // 绑定元素的父组件卸载前调用\r\n  beforeUnmount(el, binding, vnode, prevVnode) {},\r\n  // 绑定元素的父组件卸载后调用\r\n  unmounted(el, binding, vnode, prevVnode) {}\r\n}\r\n\r\n// 简写 对于自定义指令来说，一个很常见的情况是仅仅需要在 mounted 和 updated 上实现相同的行为\r\n// 除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示\r\nconst vMyDirective = (el, binding) => {\r\n  // 这会在 `mounted` 和 `updated` 时都调用\r\n  /* ... */\r\n}\r\n```\r\n### 钩子参数\r\n1. `el`：指令绑定到的元素。这可以用于直接操作 DOM。\r\n\r\n2. `binding`：一个对象，包含以下属性。\r\n\r\n    -   `value`：传递给指令的值。例如在 `v-my-directive=\\\"1 + 1\\\"` 中，值是 `2`。\r\n    -   `oldValue`：之前的值，仅在 `beforeUpdate` 和 `updated` 中可用。无论值是否更改，它都可用。\r\n    -   `arg`：传递给指令的参数 (如果有的话)。例如在 `v-my-directive:foo` 中，参数是 `\\\"foo\\\"`。\r\n    -   `modifiers`：一个包含修饰符的对象 (如果有的话)。例如在 `v-my-directive.foo.bar` 中，修饰符对象是 `{ foo: true, bar: true }`。\r\n    -   `instance`：使用该指令的组件实例。\r\n    -   `dir`：指令的定义对象。\r\n\r\n3. `vnode`：代表绑定元素的底层 VNode。\r\n\r\n4. `prevNode`：之前的渲染中代表指令所绑定元素的 VNode。仅在 `beforeUpdate` 和 `updated` 钩子中可用。\r\n### 指令注册\r\n全局注册\r\n```\r\n// 全局注册\r\nconst app = createApp({})\r\napp.directive('myDirective', {\r\n  /* ... */\r\n})\r\n```\r\n局部注册：在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以被用作一个自定义指令。\r\n```js\r\nconst vMyDirective = () => {\r\n  /* ... */\r\n}\r\n```\r\n### 实现一个简单的指令`v-color` \r\n```html\r\n<template>\r\n  <div style=\\\"width: 200px; height: 200px\\\" v-color=\\\"'red'\\\"></div>\r\n</template>\r\n<script setup>\r\nconst vColor = (el, binding) => {\r\n  el.style.background = binding.value\r\n}\r\n</script>\r\n```\r\n\r\n## 最后\r\n文中有问题或者有异议也欢迎大家指出。\r\n"
    },
    {
        "article_id": "7172903844366516260",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d5ccc950a148dc9ce48ba820c884ad~tplv-k3u1fbpfcp-watermark.image?",
        "title": "都React V18了，还不会正确使用React Hooks吗，万字长文解析Hooks的常见问题",
        "preview": "本文主要介绍React Hooks的常见的几个问题与最优实践，同时介绍一下随着React V18版本的API的变化，希望看完这篇长文解析文章，可以让你可以优雅的使用React Hooks",
        "author": "秋染蒹葭",
        "view_count": 3120,
        "collect_count": 119,
        "comment_count": 4,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/72916df0d0bbea4bbca9d5ce701e1e9e~300x300.image",
        "category": "前端",
        "content": "***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\r\n\r\n杭州下雪了，突然想去西湖看雪了，雪后的杭州更有水墨画里的感觉，一下雪杭州就成了临安。希望这个冬天不要太冷吧，也希望来年春暖花开的时候，春天可以真正来到。\r\n\r\n闲言少叙，直接进入正文\r\n\r\n## 前言\r\n\r\n今天主要想说一下react hooks，react hooks是react v16.8 之后引入的API，现在react都已经到V18了，hooks怎么还能不会用呢？\r\n\r\n首先hooks引入的目的是给函数式组件增加数据状态管理的能力，同时增加代码的可复用能力。但是同时hooks也是一个潘多拉魔盒，因为函数式组件不再只是单纯的一个纯函数了，可以在内部处理副作用了，使用不好就会经常遇到各种各样的问题，而且错误的使用方式也会引起re-render，引起一些性能上的问题\r\n\r\n本文主要介绍hooks的常见的几个问题与最优实践，同时介绍一下随着React最新版本的API的变化，首先，在使用之前，笔者还是想强调一下\r\n\r\n**请配置上`eslint-plugin-react-hooks`**\r\n**请配置上`eslint-plugin-react-hooks`**\r\n**请配置上`eslint-plugin-react-hooks`**\r\n\r\nhooks的的使用确实很爽，但是和纯函数相比，还是有挺多反直觉的写法的，比如不能在判断语句中使用hooks。这就很容易有问题，我们需要使用工具来规避这些问题，来提醒我们有些写法是错误的。当然hooks的有其自己的合理性问题，我们暂时不做讨论，这个插件提醒可以保证让我们的写法是符合当前规范的，不至于出现低级错误\r\n## 异步调用的闭包问题\r\n先看看这段代码，实现一个统计1秒内按钮点击的次数的功能\r\n```js\r\nexport default function Demo() {\r\n  const [number, setNumber] = React.useState(0);\r\n  const click = () =>\r\n    setTimeout(() => {\r\n      setNumber(number + 1);\r\n    }, 1000);\r\n  return <button onClick={click}> 点击 {number} 次</button>;\r\n}\r\n```\r\n当多次点击的时候的时候，显示的点击次数是不对的。点击click方法内的闭包回调函数在组件render的时候捕获了number变量，为了解决这个问题可以使用函数方法来更新数据\r\n```js\r\nconst click = () =>\r\n    setTimeout(() => {\r\n      setNumber(number => number + 1);\r\n    }, 1000);\r\n```\r\n在调用状态更新函数的时候，会将准确的数据回调给当前的更新函数\r\n\r\n### 更近一步\r\n同样的，假如我们统计开屏1秒内的点击次数，在计时结束后，将点击次数发送给server端的时候，就会遇到另一个问题\r\n```js\r\nexport default function Demo() {\r\n  const [number, setNumber] = React.useState(0);\r\n  useEffect(() => {\r\n    const timer = setTimeout(() => {\r\n      // do fetch\r\n      console.log(number);\r\n    }, 1000);\r\n    return () => {\r\n      clearTimeout(timer);\r\n    };\r\n    // 依赖这里会有个警告\r\n  }, []);\r\n\r\n  return <button onClick={() => setNumber((c) => c + 1)}>点击{number}次</button>;\r\n}\r\n\r\n```\r\n首先我们会遇到一个`eslint-plugin-react-hooks`警告\r\n```js\r\nReact Hook useEffect has a missing dependency: 'number'. Either include it or remove the dependency array. (react-hooks/exhaustive-deps)\r\n```\r\n而且执行结果也是由于闭包的原因不能正常提交，熟悉useEffect到都知道，这个原因是使用useEffect的时候，依赖需要添加到依赖数组内，这样才能更新数据到useEffect内，但是在这个例子中，添加了依赖后，每次点击都会引起计时器重新执行，引起倒计时失效，就和需求有冲突了，那这种情况下怎么解决呢？\r\n\r\n这个问题其实可以简单归累为：**不想让useEffect重新执行的依赖怎么使用的问题**，这个场景下就只能使用useRef来实现了\r\n```js\r\nexport default function Demo() {\r\n  const [number, setNumber] = React.useState(0);\r\n  const numberRef = useRef(number);\r\n  numberRef.current = number;\r\n  useEffect(() => {\r\n    const timer = setTimeout(() => {\r\n      // do fetch\r\n      console.log(numberRef.current);\r\n    }, 1000);\r\n    return () => {\r\n      clearTimeout(timer);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <button onClick={() => setNumber((c) => c + 1)}>点击{number}次</button>\r\n  );\r\n}\r\n\r\n```\r\n通过useRef可以来保证访问到的number一直是最新的，解决了闭包的问题，同时useEffect未直接依赖number，当number变化的时候不会引起重新执行\r\n\r\n### 小结\r\n虽然和hooks的写法有关，本质上还是闭包问题，比如forEach内写的定时器也会有同样的问题；但是对于异步场景下的写法，**不想引起useEffect重新执行的变量，就可以用useRef做一层代理**，这种用法只能说是对react hooks设计的一种妥协\r\n\r\n## 用useCallback肯定能提升性能吗\r\nuseCallback的作用是缓存函数，避免重复生成新函数，引起组件重新渲染，比如：\r\n```js\r\nconst Children = (props) => <button onClick={props.doFetch}>提交</button>;\r\n\r\nexport default function Demo() {\r\n  const doFetch = useCallback(() => {\r\n    // fetch();\r\n  }, []);\r\n\r\n  return <Children doFetch={doFetch} />;\r\n}\r\n```\r\n这是一个很常见的写法，但是需要明确在class组件的时候我们通常使用`shouldComponentUpdate`来拦截更新，通过比较父组件传入的props的变化，来判断是否re-render子组件，上面的🌰中，`<Children />`只是一个普通组件，只对传入的函数包裹一层useCallback是不能起到优化作用的，需要通过包裹一层`React.memo`才可以，React.memo会对对传入的props进行一次浅比较，避免非必要的更新，如下\r\n```js\r\nconst Children = React.memo((props) => <button onClick={props.doFetch}>提交</button>);\r\n```\r\n另外需要补充的是，假如有一些特别复杂的对象属性需要传入的话，可以考虑通过useMemo进行一层包裹，避免一些不必要的re-render。当然，使用useMemo也是有一定的性能成本的，假如只是简单计算的话，直接计算就可以了，可能这样的成本还小一些。\r\n\r\n### 思考题\r\n下面这个场景下useCallback和React.memo组合可以起到优化的作用吗？\r\n```js\r\nconst Children = React.memo((props) => <button onClick={props.doSubmit}>提交</button>);\r\n\r\nexport default function Demo() {\r\n  const [number, setNumber] = useState(0);\r\n\r\n  const doSubmit = useCallback(() => {\r\n    console.log(`Number: ${number}`);\r\n  }, [number]); // 把number写在依赖数组里\r\n\r\n  return (\r\n    <>\r\n      <input value={number} onChange={(e) => setNumber(e.target.value)} />\r\n      <Children doSubmit={doSubmit} />\r\n    </>\r\n  );\r\n}\r\n```\r\n结论是不行，原因可以考虑一下useCallback的deps该怎么处理，有没有方法可以避免doSubmit函数重新生成呢\r\n\r\n### 小结\r\n只需要记得**使用useCallback的时候，对应的子组件一定要使用React.memo包裹**，否则使用useCallback就没有任何的意义。当然useCallback的deps要根据实际场景来添加，否则就不会有任何的优化效果。\r\n\r\n另外对于useCallback，笔者个人的理解是有些破坏代码的可读性了，使用的时候需要按照场景具体评估一下，是否真的需要无脑使用，平衡好代码可维护性和性能\r\n\r\n## hooks组件怎么优雅的使用refs\r\n其实这个问题有些伪命题的感觉，当我们使用在父组件中通过ref操作子组件的方法时，已经就是不优雅的了。官方文档这样说：\r\n> 在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素\r\n\r\n只能说非必要的尽量避免直接使用ref吧，尽量避免打乱react的单向数据流。那回到我们的问题，使用hooks的时候如何使用更优雅的使用ref呢\r\n\r\n官方文档提供了以下几个场景刚好适合使用Refs\r\n* 处理focus、文本选择或者媒体播放\r\n* 触发强制动画\r\n* 基层第三方库\r\n\r\n### useRef\r\n由于函数组件没有实例，在函数组件内不能使用string ref,callback ref, create ref，会有如下报错\r\n> Uncaught Invariant Violation: Function components cannot have refs. Did you mean to use React.forwardRef()?\r\n\r\n所以在函数组件内是能使用useRef,由于useRef返回一个对象，这个对象只有current一个值，并且这个值的地址在整个组件的生命周期内不会改变，所以useRef提供了组件生命周期内共享数据的存储，修改了ref.current的值不会触发组件re-render，而且组件re-render的时候，ref.current的值也会保留，类似class组件的静态变量，因此我们可以用useRef做很多事情，比如挂载特定的dom或者子组件的实例、存储全局定时器等等\r\n\r\n那useRef怎么使用呢，针对官方问题提供的几个场景，笔者简单给出几个demo\r\n\r\n#### 获取特定dom\r\n对于原生元素可以直接使用\r\n```jsx\r\nfunction Input(props) {\r\n  const inputRef = useRef(null);\r\n\r\n  function click() {\r\n    inputRef.current.focus();\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input type=\\\"text\\\" ref={inputRef} />\r\n      <input type=\\\"button\\\" value=\\\"Focus the text input\\\" onClick={click} />\r\n    </div>\r\n  );\r\n}\r\n```\r\n通过ref.current可以直接操作input\r\n\r\n### useRef,forwardRef,useImperativeHandle组合用法\r\n首先先说一下forwardRef\r\n> Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。\r\n\r\n简答来说，就是函数式组件要想暴露给父组件ref的时候，需要使用forwardRef才能进行ref的传递。需要明确的是**不能在函数式组件上使用ref属性，因为函数式组件没有实例**，使用的话会直接抛出异常。\r\n\r\n然后再说一下useImperativeHandle，函数式组件使用useImperativeHandle 可以通过 forwardRef 暴露给父组件的自定义方法。这可以类比于class组件，我们可以通过class组件获取ref的组件实例，进而调用内部方法，我们也可以通过useImperativeHandle暴露的方法，调用函数式组件的内部方法，直接看🌰\r\n```jsx\r\nimport React, { useRef, useImperativeHandle } from \\\"react\\\";\r\nconst Children = React.forwardRef((props, ref) => {\r\n  const inputRef = useRef(null);\r\n  useImperativeHandle(\r\n    ref,\r\n    () => {\r\n      const handleRefs = {\r\n        onFocus() {\r\n          inputRef.current.focus();\r\n        }\r\n      };\r\n      return handleRefs;\r\n    },\r\n    []\r\n  );\r\n  return <input placeholder=\\\"请输入\\\" ref={inputRef} />;\r\n});\r\n\r\nconst Demo = () => {\r\n  const childRef = useRef(null);\r\n  const click = () => {\r\n    const { onFocus } = childRef.current;\r\n    onFocus();\r\n  };\r\n  return (\r\n    <>\r\n      <Children ref={childRef} />\r\n      <button onClick={click}>输入框focused</button>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Demo;\r\n```\r\n\r\nuseImperativeHandle 接受三个参数：\r\n* forWardRef转发过来的ref\r\n* 自定义处理函数，返回值时暴露给父组件的ref对象\r\n* 依赖项deps，根据实际的依赖传入即可，用于更新ref对象\r\n\r\n通过useImperativeHandle外部组件就可以相对优雅的获取到子组件的“实例”，调用子组件的内部方法\r\n\r\n### 小结\r\n写到这里，其实我们也能发现，useRef的使用频率还是挺高的，我们既可以把useRef当成普通的ref的相关API，用来操作子组件，也可以将其作为一个函数式组件内的静态变量来使用，可以说是hooks遇到问题的时候非常万金油的存在了\r\n\r\n说回ref,基本对于函数式组件来说，useRef,forwardRef,useImperativeHandle组合用法能覆盖所有需求了，但是还是那句话，能尽量避免使用的就避免使用，让自己的代码有更高的可维护性\r\n\r\n\r\n## 如何封装自定义hooks\r\n自定义hooks是基于react hooks api的自定义扩展，可以将一段通用性逻辑封装起来，达到复用的效果；简单来说通过自定义 Hook，可以将组件逻辑提取到可重用的函数中，可以在组件内直接使用\r\n\r\n封装的自定义hooks一般内部使用多个react hooks API，用于解决一些复杂且通用的逻辑。接下来看几个🌰，然后可以对比一下自己的场景，也并不是所有能用自定义hooks的地方，就必须要用自定义hooks的，还是要判断一下可复用程度再做决定\r\n\r\n### 提取自定义 hooks\r\n> 当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。\r\n\r\n自定义 hooks 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。自定义hooks和普通的函数并没有任何不同，但是结合公共hooks API的能力，在react的调度下，我们可以实现很多很有趣的功能，社区有实现的[ahooks](https://github.com/alibaba/hooks?spm=ata.21736010.0.0.1b261134fcWTYx)自定义hooks库，也可以自己参考一下\r\n\r\n接下来简单放几个相对有代表性的🌰：\r\n\r\n### useState属性合并\r\n你的代码里是不是写过这样的代码\r\n```js\r\nconst [duration, setDuration] = useState(0);\r\nconst [currentTime, setCurrentTime] = useState(0);\r\nconst [volume, setCurrent] = useState(0);\r\nconst [speed, setSpeed] = useState(0);\r\n...\r\n```\r\n这段代码是之前封装播放器的一段代码，里面对video的属性进行一定的提取，导致了代码中一排蔚为壮观的useState，这样的写法其实可以优化到一个字段内\r\n```js\r\nconst [player, setPlayer] = useState({\r\n  duration: 0,\r\n  currentTime: 0,\r\n  volume: 0,\r\n  speed: 0,\r\n});\r\n```\r\n当然这个时候更新装状态需要带上旧的状态\r\n```js\r\nsetPlayer({...player, duration});\r\n```\r\n那怎么才能再省点代码，让我可以直接修改需要修改的参数，不需要改变的依旧保持现状呢，这个时候就可以封装一个自定义hooks，如下\r\n```js\r\nimport { useState } from 'react';\r\n\r\nconst useMergeState = (initialState) => {\r\n  const [state, setState] = useState(initialState);\r\n  const setMergeState = (pickState) => {\r\n    setState(preState => {...preState, ...pickState});\r\n  }\r\n  return [state, setMergeState]\r\n}\r\n```\r\n这样就可以直接使用了\r\n```js\r\nconst [player, setPlayer] = useMergeState({\r\n  duration: 0,\r\n  currentTime: 0,\r\n  volume: 0,\r\n  speed: 0,\r\n});\r\n\r\nsetPlayer({ duration: 2});\r\n```\r\n这就是一个最简单的自定义hooks，当然useMergeState还有可优化的地方，比如参考useState的用法，pickState可能是个函数，需要判断一下入参类型；然后内部的实现setMergeState其实可以通过useCallback进行一下包裹，让函数不用每次都初始化等等\r\n\r\n### dom相关的自定义hooks\r\n我们经常会监听dom的滚动来做一些自定义的逻辑，比如滚动翻页等等，一个监听滚动的自定义hooks该怎么实现呢，我们需要先确定我们需获取到哪些值，以及我们的入参数是什么\r\n#### 需求分析\r\n入参：毋庸置疑肯定是dom元素的引用，可以使用useRef来实现\r\n返回值：一般都是元素滚动的信息，可以根据自己的实际来决定\r\n\r\n#### 代码实现\r\n```js\r\nimport { useState, useEffect } from 'react'\r\n\r\nconst useScroll = (target) => {\r\n  const [position, setPosition] = useState();\r\n\r\n  useEffect(() => {\r\n    function onscroll(e){\r\n      setPos([target.current.scrollLeft, target.current.scrollTop])\r\n    }\r\n    target.current.addEventListener('scroll', onscroll, false)\r\n    return () => {\r\n      target.current.removeEventListener('scroll', onscroll, false)\r\n    }\r\n  }, [])\r\n\r\n  return position\r\n}\r\n\r\nexport default useScroll\r\n```\r\n上述代码也是有一些可以优化的地方，比如一些参数有效性的判断等，这个🌰只是一个演示，提供一个参考思路\r\n\r\n### 防抖函数\r\n防抖节流函数大家肯定经常在开发中遇到，面试的估计也没有被少问。一般都是我们避免频繁调用接口，或者在react中避免频繁改动state的时候需要使用的，防抖节流的区别这里也不赘述了，简单来说，其主要区别是防抖是操作后n秒内只能调用一次，假如n秒内又触发了操作，重新倒计时n秒；节流就是操作n秒内只能调用一次，即使是多次触发操作也是n秒内执行一次；节流一般用在输入框搜索，需要在最后一次提交后触发；节流一般用在滚动监听等等。\r\n\r\n#### 代码实现\r\n```js\r\nimport { useEffect, useMemo } from 'react';\r\nimport debounce from 'lodash/debounce';\r\n\r\nconst useDebounce = (fn, wait) => {\r\n  const wait = wait ?? 1000;\r\n\r\n  const debounced = useMemo(\r\n      () =>\r\n        debounce(\r\n          fn(),\r\n          wait\r\n        ),\r\n      [],\r\n  );\r\n  return [debounced.run, debounced.cancel];\r\n}\r\n```\r\n上述代码为了突出自定义hooks的用法，基于lodash/debounce实现了一个节流hooks，其实核心就是简化debounce的用法，当然lodash/debounce还有更多的配置，自己可以基于自己的实际场景进行封装\r\n\r\n至于节流函数就作为一个思考题可以自己实现一下\r\n\r\n### 小结\r\n自定义hooks可以维护在项目中的一个单独hooks文件夹内，作为全局公共方法提供，当然也可以发布到自己的npm组件，提供给更多的项目使用。还有很多的有趣的封装方法就不再一一演示了，可以自己多看看第三方包的实现，加深对自定义hooks的理解\r\n\r\n## React V18新增了哪些hooks API\r\n\r\nReact V18已经发布了一段时间了，针对hooks也提供了一些新的API。新增的API有`useId，useInsertionEffect，useTransition，useDeferredValue，useSyncExternalStore`，让我们一一看看提供了什么新的能力。\r\n\r\n### Before，先看看React V18带来了什么\r\n可以可选的开启 Concurrent Mode，大幅提高了React的性能，推出了时间切片和任务优先级的概念，让 React 有了更多的可能性，更多的描述可以去看看官方文档，我们关注的点还是这几个新增的hooks，让我们简单的了解一下这几个API，具体的使用方法可以自己写一写demo试一下\r\n\r\n### useSyncExternalStore\r\n顾名思义，这个API是针对React的第三方状态管理库的。由于V18可以开启concurrent mode,使得render这个过程能够切分成以fiber为最小单位的多次任务，这些任务可能就会存在对外部状态的修改。假如在render的多个任务分片不同阶段，部分外部状态被修改了，那就会造成多次渲染结果不一致的问题，也就是**tearing 问题**，tearing 通俗地讲，就是外部状态不受 react 异步调度控制，非常容易错乱。useSyncExternalStore就是防止tearing的出现，通过订阅的方式保持最终渲染结果的一致性。\r\n\r\n最后简单看看API\r\n```js\r\nuseSyncExternalStore(\r\n    subscribe, // 接收一个subscribe函数，该函数接收一个函数用于通知react外部状态发生变更\r\n    getSnapshot, // 返回外部状态的最新快照值\r\n)\r\n```\r\n### useTransition\r\ntransition 特性也是依赖 concurrent mode的，可以用来降低渲染优先级。当我们用startTransition包裹计算量大的函数的时候，就相当于通知了React当前计算的优先级很低，可以降低更新的优先级，减少重复渲染次数，可以当成一个防抖函数来处理（不完全相同）。\r\n\r\n```js\r\nconst Demo = () => {\r\n  const [isPending, startTransition] = useTransition();\r\n  return (\r\n      <input\r\n        type=\\\"text\\\"\r\n        onChange={(event) => {\r\n          startTransition(() => {console.log(event.target.value);\r\n        }}}\r\n      />\r\n  );\r\n}\r\n```\r\n\r\n可以看看官方的这个[demo](https://codesandbox.io/s/sparkling-field-41z4r3)\r\n\r\n### useDeferredValue\r\n和useTransition类似，useDeferredValue的特性也是依赖 concurrent mode 的，可以直接翻译为使用一个推迟的值。 useDeferredValue 可以让我们延迟渲染优先级不高的部分，等高优先级的渲染任务结束后，延迟的渲染才开始，并且可中断不会阻塞用户输入。\r\n\r\n```js\r\nconst Demo = (value) => {\r\n  // React 将会在合适的时间生成deferredValue\r\n  const deferredValue = useDeferredValue(value, { timeoutMs: 1000 });\r\n  return (\r\n    <div>\r\n      {\r\n        deferredValue\r\n      }\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### useInsertionEffect\r\n类似useLayoutEffect，区别就是不能访问dom\r\n\r\nuseInsertionEffect的出现就是为了解决cssinjs问题的，用于插入样式规则，而且一般是插入全局DOM节点，比如`<style/>`等。这个hooks为了避免在concurrent mode下，客户端生成或编辑`<style/>`时引起性能问题，可以在这个hooks中操作插入一些css节点\r\n```js\r\nfunction useCSS(rule) {\r\n  useInsertionEffect(() => {\r\n    document.head.appendChild(rule);\r\n  });\r\n  return rule;\r\n}\r\nconst Demo = () => {\r\n  let className = useCSS(rule);\r\n  return <div className={className} />;\r\n}\r\n```\r\n\r\n### useID\r\n一般用于服务端渲染，生成一个ID，但是不要把这个ID作为数组循环渲染的key，渲染的唯一key一般是从你的数据中生成的, 就不再详细介绍了\r\n\r\n\r\n## 总结\r\nReact Hooks很好用，但是想用好，还是需要多一点思考的。框架提供的能力，想转换为实际的生产力就需要我们不停的去学习如何使用这些能力，不断总结。\r\n\r\n好了，感谢大家阅读，有问题可以留言交流\r\n\r\n\r\n**参考资料**\r\n\r\n[Refs 和 DOM官方文档](https://react.html.cn/docs/refs-and-the-dom.html)\r\n\r\n[自定义 Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)\r\n\r\n[如何理解 React 18 中的 useSyncExternalStore ?](https://www.zhihu.com/question/502917860)\r\n\r\n[useTransition/useDerferredValue使用指南](https://blog.shabby.in/how-to-use-useTransition/useDerferredValue/)\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***"
    },
    {
        "article_id": "7178467482456293434",
        "snapshot": "",
        "title": "从 await-to-js 到 try-run-js",
        "preview": "之前在做 code review 时候发现有同事使用 try catch 包装了一堆异步代码，于是个人就觉得很奇怪，难道不应该只 catch 可能出问题的代码吗？同事告诉我说 try catch 太细",
        "author": "jump_jump",
        "view_count": 13195,
        "collect_count": 138,
        "comment_count": 26,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/27697e05e5d0196dcc8a13687e8c7be3~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n之前在做 code review 时候发现有同事使用 try catch 包装了一堆异步代码，于是个人就觉得很奇怪，难道不应该只 catch 可能出问题的代码吗？同事告诉我说 try catch 太细的话会出现内外作用域不一致，需要提前声明变量。\r\n\r\n```ts\r\nlet res: Data[] = [];\r\n\r\ntry {\r\n  res = await fetchData();\r\n} catch (err) {\r\n  // 错误操作或者终止\r\n  // return\r\n}\r\n\r\n// 继续执行正常逻辑\r\n```\r\n\r\n的确，一方面开发者不应该大范围包裹非异常代码，另一方面提前声明变量会让代码不连贯同时也会打断思路。其中一个方式是直接使用原生 Promie 而不是 async。\r\n\r\n```ts\r\nfetchData().then((res) => {\r\n}).catch((err) => {\r\n});\r\n```\r\n\r\n这样对于单个异步请求当然没有任何问题，如果是具有依赖性的异步请求。虽然可以再 Promise 中返回另外的 Promise 请求，但是这样处理 catch 却只能有一个。\r\n\r\n```ts\r\nfetchData().then((res) => {\r\n  // 业务处理\r\n  return fetchData2(res);\r\n}).then((res) => {\r\n  // 业务处理\r\n}).catch((err) => {\r\n  // 只能做一个通用的错误处理了\r\n});\r\n```\r\n\r\n如果需要多个 catch 处理，我们就需要这样写。\r\n\r\n```ts\r\nfetchData().then((res) => {\r\n  // 业务处理\r\n  return fetchData2(res);\r\n}).catch((err) => {\r\n  // 错误处理并且返回 null\r\n  return null;\r\n}).then((res) => {\r\n  if (res === null) {\r\n    return;\r\n  }\r\n  // 业务处理\r\n}).catch((err) => {\r\n  // 错误处理\r\n});\r\n```\r\n\r\n这时候开发者也要考虑 fetchData2 会不会返回 null 的问题。于是个人开始找一些方法来帮助我们解决这个问题。\r\n\r\n## await-to-js\r\n\r\n[await-to-js](https://github.com/scopsy/await-to-js) 是一个辅助开发者处理异步错误的库。我们先来看看该库是如何解决我们问题的。\r\n\r\n```ts\r\nimport to from \\\"await-to-js\\\";\r\n\r\nconst [fetch1Err, fetch1Result] = await to(fetchData());\r\nif (fetch1Err) {\r\n  // 错误操作或者终止\r\n  // return\r\n}\r\n\r\nconst [fetch2Err, fetch1Result] = await to(fetchData2(fetch1Result));\r\nif (fetch2Err) {\r\n  // 错误操作或者终止\r\n  // return\r\n}\r\n```\r\n\r\n源码非常简单。\r\n\r\n```js\r\nexport function to(\r\n  promise,\r\n  errorExt,\r\n) {\r\n  return promise\r\n    .then((data) => [null, data])\r\n    .catch((err) => {\r\n      if (errorExt) {\r\n        const parsedError = Object.assign({}, err, errorExt);\r\n        return [parsedError, undefined];\r\n      }\r\n      return [err, undefined];\r\n    });\r\n}\r\n```\r\n\r\n## 使用 try-run-js\r\n\r\n看到 await-to-js 将错误作为正常流程的一部分，于是个人想到是不是能通过 try catch 解决一些异步代码问题呢？\r\n\r\n我立刻想到了需要获取 DOM 节点的需求。现有框架都使用了数据驱动的思路，但是 DOM 具体什么时候渲染是未知的，于是个人想到之前代码，Vue 需要获取 ref 并进行回调处理。\r\n\r\n```ts\r\nfunction resolveRef(refName, callback, time: number = 1) {\r\n  // 超过 10 次跳出递归\r\n  if (time > 10) throw new Error(`cannot find ref: ${refName}`);\r\n  // \r\n  const self = this;\r\n  // 获取 ref 节点\r\n  const ref = this.$refs[refName];\r\n  if (ref) {\r\n    callback(ref);\r\n  } else {\r\n    // 没有节点就下一次\r\n    this.$nextTick(() => {\r\n      resolveRef.call(self, refName, callback, time + 1);\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n当然了，上述代码的确可以解决此类的问题，在处理此类问题时候我们可以替换 ref 和 nextTick 的代码。于是 await-to-js 的逻辑下，个人开发了 [try-run-js](https://github.com/wsafight/try-run-js) 库。我们先看一下该库如何使用。\r\n\r\n```ts\r\nimport tryRun from \\\"try-run-js\\\";\r\n\r\ntryRun(() => {\r\n  // 直接尝试使用正常逻辑代码\r\n  // 千万不要添加 ?.\r\n  // 代码不会出错而不会重试\r\n  this.$refs.navTree.setCurrentKey(\\\"xxx\\\");\r\n}, {\r\n  // 重试次数\r\n  retryTime: 10,\r\n  // 下次操作前需要的延迟时间\r\n  timeout: () => {\r\n    new Promise((resolve) => {\r\n      this.$nextTick(resolve);\r\n    });\r\n  },\r\n});\r\n```\r\n\r\n我们也可以获取错误数据和结果。\r\n\r\n```ts\r\nimport tryRun from \\\"try-run-js\\\";\r\n\r\nconst getDomStyle = async () => {\r\n  // 获取一步的\r\n  const { error: domErr, result: domStyle } = await tryRun(() => {\r\n    // 返回 dom 节点样式，不用管是否存在 ppt\r\n    // 千万不要添加 ?.\r\n    // 代码不会出错而返回 undefined\r\n    return document.getElementById(\\\"domId\\\").style;\r\n  }, {\r\n    // 重试次数\r\n    retryTime: 3,\r\n    // 返回数字的话，函数会使用 setTimeout\r\n    // 参数为当前重试的次数，第一次重试 100 ms，第二次 200\r\n    timeout: (time) => time * 100,\r\n    // 还可以直接返回数字，不传递默认为 333\r\n    // timeout: 333\r\n  });\r\n\r\n  if (domErr) {\r\n    return {};\r\n  }\r\n\r\n  return domStyle;\r\n};\r\n```\r\n\r\n当然了，该库也是支持返回元组以及 await-to-js 的 Promise 错误处理的功能的。\r\n\r\n```ts\r\nimport { tryRunForTuple } from \\\"try-run-js\\\";\r\n\r\nconst [error, result] = await tryRunForTuple(fetchData());\r\n```\r\n\r\n## try-run-js 项目演进\r\n\r\ntry-run-js 核心在于 try catch 的处理，下面是关于 try-run-js 的编写思路。希望能对大家有一些帮助\r\n\r\n### 支持 await-to-js\r\n\r\n```ts\r\nconst isObject = (val: any): val is Object =>\r\n  val !== null &&\r\n  (typeof val === \\\"object\\\" || typeof val === \\\"function\\\");\r\n\r\nconst isPromise = <T>(val: any): val is Promise<T> => {\r\n  // 继承了 Promise\r\n  // 拥有 then 和 catch 函数，对应手写的 Promise\r\n  return val instanceof Promise || (\r\n    isObject(val) &&\r\n    typeof val.then === \\\"function\\\" &&\r\n    typeof val.catch === \\\"function\\\"\r\n  );\r\n};\r\n\r\nconst tryRun = async <T>(\r\n  // 函数或者 promise\r\n  promiseOrFun: Promise<T> | Function,\r\n  // 配置项目\r\n  options?: TryRunOptions,\r\n): Promise<TryRunResultRecord<T>> => {\r\n  // 当前参数是否为 Promise\r\n  const runParamIsPromise = isPromise(promiseOrFun);\r\n  const runParamIsFun = typeof promiseOrFun === \\\"function\\\";\r\n\r\n  // 既不是函数也不是 Promise 直接返回错误\r\n  if (!runParamIsFun && !runParamIsPromise) {\r\n    const paramsError = new Error(\\\"first params must is a function or promise\\\");\r\n    return { error: paramsError } as TryRunResultRecord<T>;\r\n  }\r\n\r\n  if (runParamIsPromise) {\r\n    // 直接使用 await-to-js 代码\r\n    return runPromise(promiseOrFun as Promise<T>);\r\n  }\r\n};\r\n```\r\n\r\n### 执行错误重试\r\n\r\n接下来我们开始利用 try catch 捕获函数的错误并且重试。\r\n\r\n```ts\r\n// 默认 timeout\r\nconst DEFAULT_TIMEOUT: number = 333\r\n\r\n// 异步等待\r\nconst sleep = (timeOut: number) => {\r\n  return new Promise<void>(resolve => {\r\n    setTimeout(() => {\r\n      resolve()\r\n    }, timeOut)\r\n  })\r\n}\r\n\r\nconst tryRun = async <T>(\r\n  promiseOrFun: Promise<T> | Function,\r\n  options?: TryRunOptions,\r\n): Promise<TryRunResultRecord<T>> => {\r\n  const { retryTime = 0, timeout = DEFAULT_TIMEOUT } = {\r\n    ...DEFAULT_OPTIONS,\r\n    ...options,\r\n  };\r\n\r\n  // 当前第几次重试\r\n  let currentTime: number = 0;\r\n  // 是否成功\r\n  let isSuccess: boolean = false;\r\n\r\n  let result;\r\n  let error: Error;\r\n\r\n  while (currentTime <= retryTime && !isSuccess) {\r\n    try {\r\n      result = await promiseOrFun();\r\n      // 执行完并获取结果后认为当前是成功的\r\n      isSuccess = true;\r\n    } catch (err) {\r\n      error = err as Error;\r\n      // 尝试次数加一\r\n      currentTime++;\r\n\r\n      // 注意这里，笔者在这里犯了一些错误\r\n      // 如果没有处理好就会执行不需要处理的 await\r\n      // 1.如果当前不需要重新请求（重试次数为 0），直接跳过\r\n      // 2.最后一次也失败了(重试完了)也是要跳过的\r\n      if (retryTime > 0 && currentTime <= retryTime) {\r\n        // 获取时间\r\n        let finalTimeout: number | Promise<any> = typeof timeout === \\\"number\\\"\r\n          ? timeout\r\n          : DEFAULT_TIMEOUT;\r\n        \r\n        // 如果是函数执行函数\r\n        if (typeof timeout === \\\"function\\\") {\r\n          finalTimeout = timeout(currentTime);\r\n        }\r\n\r\n        // 当前返回 Promise 直接等待\r\n        if (isPromise(finalTimeout)) {\r\n          await finalTimeout;\r\n        } else {\r\n          // 如果最终结果不是 number，改为默认数据\r\n          if (typeof finalTimeout !== \\\"number\\\") {\r\n            finalTimeout = DEFAULT_TIMEOUT;\r\n          }\r\n          // 这里我尝试使用了 NaN、 -Infinity、Infinity \r\n          // 发现 setTimeout 都进行了处理,下面是浏览器的处理方式\r\n          // If timeout is an Infinity value, a Not-a-Number (NaN) value, or negative, let timeout be zero.\r\n          // 负数，无穷大以及 NaN 都会变成 0\r\n          await sleep(finalTimeout);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // 成功或者失败的返回\r\n  if (isSuccess) {\r\n    return { result, error: null };\r\n  }\r\n\r\n  return { error: error!, result: undefined };\r\n};\r\n```\r\n\r\n这样，我们基本完成了 try-run-js.\r\n\r\n### 添加 tryRunForTuple 函数\r\n\r\n这个就很简单了，直接直接 tryRun 并改造其结果：\r\n\r\n```ts\r\nconst tryRunForTuple = <T>(\r\n  promiseOrFun: Promise<T> | Function,\r\n  options?: TryRunOptions): Promise<TryRunResultTuple<T>> => {\r\n  return tryRun<T>(promiseOrFun, options).then(res => {\r\n    const { result, error } = res\r\n    if (error) {\r\n      return [error, undefined] as [any, undefined]\r\n    }\r\n    return [null, result] as [null, T]\r\n  })\r\n}\r\n```\r\n\r\n代码都在 [try-run-js](https://github.com/wsafight/try-run-js) 中，大家还会在什么情况下使用 try-run-js 呢？同时也欢迎各位提交 issue 以及 pr。\r\n\r\n## 鼓励一下\r\n如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。 \r\n\r\n[博客地址](https://github.com/wsafight/personBlog)\r\n\r\n## 参考资料\r\n\r\n[await-to-js](https://github.com/scopsy/await-to-js)\r\n\r\n[try-run-js](https://github.com/wsafight/try-run-js)\r\n"
    },
    {
        "article_id": "7159445281203814414",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86009f7d78634e01ace954019cfd0540~tplv-k3u1fbpfcp-watermark.image?",
        "title": "深入理解函数式编程（上）",
        "preview": "函数式编程是一种历史悠久的编程范式。作为演算法，它的历史可以追溯到现代计算机诞生之前的λ演算，本文希望带大家快速了解函数式编程的历史、基础技术、重要特性和实践法则。",
        "author": "美团技术团队",
        "view_count": 3298,
        "collect_count": 105,
        "comment_count": 12,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/8eba923cc05dc9180a3bbe446d9b8353~300x300.image",
        "category": "前端",
        "content": "> 函数式编程是一种历史悠久的编程范式。作为演算法，它的历史可以追溯到现代计算机诞生之前的λ演算，本文希望带大家快速了解函数式编程的历史、基础技术、重要特性和实践法则。在内容层面，主要使用JavaScript语言来描述函数式编程的特性，并以演算规则、语言特性、范式特性、副作用处理等方面作为切入点，通过大量演示示例来讲解这种编程范式。同时，文末列举比较一些此范式的优缺点，供读者参考。因为文章涵盖一些范畴论知识，可能需要其他参考资料一起辅助阅读。\r\n\r\n## 前言\r\n\r\n本文分为上下两篇，上篇讲述函数式编程的基础概念和特性，下篇讲述函数式编程的进阶概念、应用及优缺点。函数式编程既不是简单的堆砌函数，也不是语言范式的终极之道。我们将深入浅出地讨论它的特性，以期在日常工作中能在对应场景中进行灵活应用。\r\n\r\n## 1. 先览：代码组合和复用\r\n\r\n在前端代码中，我们现有一些可行的模块复用方式，比如：\r\n\r\n![图 1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/242084d05cd94037a79340aa05e9a91d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n除了上面提到的组件和功能级别的代码复用，我们也可以在软件架构层面上，通过选择一些合理的架构设计来减少重复开发的工作量，比如说很多公司在中后台场景中大量使用的**低代码平台**。\r\n\r\n可以说，在大部分软件项目中，我们都要去探索**代码组合和复用**。\r\n\r\n函数式编程，曾经有过一段黄金时代，后来又因面向对象范式的崛起而逐步变为小众范式。但是，函数式编程目前又开始在不同的语言中流行起来了，像Java 8、JS、Rust等语言都有对函数式编程的支持。\r\n\r\n今天我们就来探讨JavaScript的**函数**，并进一步探讨**JavaScript中的函数式编程**（关于函数式编程风格软件的**组织、组合和复用**）。\r\n\r\n![图 2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4faedb9f7b2d431aa2a8955c4a360523~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 2. 什么是函数式编程？\r\n\r\n### 2.1 定义\r\n\r\n函数式编程是一种风格范式，没有一个标准的教条式定义。我们来看一下维基百科的定义：\r\n\r\n> 函数式编程是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算是该语言最重要的基础。而且**λ演算**的函数可以接受函数作为输入的参数和输出的返回值。\r\n\r\n我们可以直接读出以下信息：\r\n    \r\n1. 避免状态变更\r\n2. 函数作为输入输出\r\n3. 和**λ演算**有关\r\n\r\n那什么是**λ演算**呢？\r\n\r\n### 2.2 函数式编程起源：λ演算\r\n\r\n**λ演算（读作lambda演算）**由数学家**阿隆佐·邱奇**在20世纪30年代首次发表，它从**数理逻辑**（Mathematical logic）中发展而来，使用变量绑定（binding）和代换规则（substitution）来研究函数如何抽象化定义（define）、函数如何被应用（apply）以及递归（recursion）的形式系统。\r\n\r\n> **λ演算**和图灵机等价（图灵完备，作为一种研究语言又很方便）。\r\n\r\n通常用这个定义形式来表示一个**λ演算**。\r\n\r\n![图 3](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73d459d2f0f4bce88d5d00b519a9127~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n所以**λ演算式**就三个要点：\r\n\r\n1. **绑定关系**。变量任意性，x、y和z都行，它仅仅是具体数据的代称。\r\n2. **递归定义**。λ项递归定义，**M**可以是一个λ项。\r\n3. **替换归约**。λ项可应用，空格分隔表示**对M应用N**，**N**可以是一个λ项。\r\n\r\n比如这样的演算式：\r\n\r\n![图 4](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef09dfd49334916be8c07834e2ef09c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过变量**代换（substitution）**和**归约（reduction）**，我们可以像化简方程一样处理我们的演算。\r\n\r\n**λ演算**有很多方式进行，数学家们也总结了许多和它相关的规律和定律（可查看维基百科）。\r\n\r\n举个例子，小时候我们学习整数就是学会几个数字，然后用加法/减法来推演其他数字。在函数式编程中，我们可以用**函数**来定义自然数，有很多定义方式，这里我们讲一种实现方式：\r\n\r\n![图 5](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d499580d9b4a58a08b28ccfdbe297b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上面的演算式表示有一个函数**f**和一个参数**x**。令**0**为**x**，**1**为**f x**，**2**为**f f x**...\r\n\r\n什么意思呢？这是不是很像我们数学中的幂：**a^x（a的x次幂表示a对自身乘x次）**。相应的，我们理解上面的演算式就是**数字n就是f对x作用的次数**。有了这个数字的定义之后，我们就可以在这个基础上定义运算。\r\n\r\n![图 6](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93e9177ba2c94329aa24d82b6d0ae69e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n其中**SUCC**表示后继函数（**+1操作**），**PLUS**表示加法。现在我们来推导这个正确性。\r\n\r\n![图 7](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf582a6e69f64777ac5beb89c32266a2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这样，进行**λ演算**就像是方程的代换和化简，在一个已知前提（公理，比如0/1，加法）下，进行规则推演。\r\n\r\n#### 2.2.1 演算：变量的含义\r\n\r\n在**λ演算**中我们的表达式只有一个参数，那它怎么实现两个数字的二元操作呢？比如加法a + b，需要两个参数。\r\n\r\n**这时，我们要把函数本身也视为值**，可以通过把一个变量绑定到上下文，然后返回一个新的函数，来实现数据（或者说是状态）的保存和传递，被绑定的变量可以在需要实际使用的时候从上下文中引用到。\r\n\r\n比如下面这个简单的演算式：\r\n\r\n![图 8](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9cc08fc63994b8bbc80fd27216aba4e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第一次函数调用传入**m=5**，返回一个新函数，这个新函数接收一个参数**n**，并返回**m + n**的结果。像这种情况产生的上下文，就是**Closure（闭包，函数式编程常用的状态保存和引用手段）**，我们称变量**m**是被**绑定（binding）**到了第二个函数的上下文。\r\n\r\n除了绑定的变量，**λ演算**也支持自由的变量，比如下面这个**y**：\r\n\r\n![图 9](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/011f6df1075f4abfab75a8422b9fe5a6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里的**y**是一个没有绑定到参数位置的变量，被称为一个**自由变量**。\r\n\r\n**绑定变量**和**自由变量**是函数的两种状态来源，一个可以被代换，另一个不能。实际程序中，通常把绑定变量实现为局部变量或者参数，自由变量实现为全局变量或者环境变量。\r\n\r\n### 2.2.2 演算：代换和归约\r\n\r\n演算分为**Alpha**代换和**Beta**归约。 前面章节我们实际上已经涉及这两个概念，下面来介绍一下它们。\r\n\r\n**Alpha代换**指的是变量的名称是不重要的，你可以写**λm.λn.m + n**，也可以写**λx.λy.x + y**，在演算过程中它们表示同一个函数。也就是说我们只**关心计算的形式**，而不关心细节用什么变量去实现。这方便我们不改变运算结果的前提下去修改变量命名，以方便在函数比较复杂的情况下进行化简操作。实际上，连整个lambda演算式的名字也是不重要的，我们只需要这种形式的计算，而不在乎这个形式的命名。\r\n\r\n**Beta归约**指的是如果你有一个**函数应用（函数调用）**，那么你可以对这个函数体中与标识符对应的部分做**代换（substitution）**，方式为使用参数（可能是另一个演算式）去替换标识符。听起来有点绕口，但是它实际上就是**函数调用的参数替换**。比如：\r\n\r\n![图 10](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6b6074508f14be7a14d9e3fc4251102~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以使用**1**替换**m**，**3**替换**n**，那么整个表达式可以化简为**4**。这也是函数式编程里面的引用透明性的由来。需要注意的是，这里的**1**和**3**表示表达式运算值，可以替换为其他表达式。比如把**1替换为(λm.λn.m + n 1 3)**，这里就需要做两次归约来得到下面的最终结果：\r\n\r\n![图 11](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18e053c6aa84dc1b2d72312c1983271~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 2.3 JavaScript中的λ表达式：箭头函数\r\n\r\nECMAScript 2015规范引入了箭头函数，它没有**this**，没有**arguments**。只能作为一个**表达式（expression）**而不能作为一个**声明式（statement）**，表达式产生一个箭头函数引用，该箭头函数引用仍然有**name**和**length**属性，分别表示箭头函数的名字、形参（parameters）长度。一个箭头函数就是一个单纯的运算式，箭头函数我们也可以称为**lambda函数**，它在书写形式上就像是一个**λ演算式**。\r\n\r\n![图 12](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cea02ad58a45454d817cedb20cd5953a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以利用箭头函数做一些简单的运算，下例比较了四种箭头函数的使用方式：\r\n\r\n![图 13](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e0843aabd9458c9ebed46d01d26f40~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这是直接针对数字（基本数据类型）的情况，如果是针对函数做运算（**引用数据类型**），事情就变得有趣起来了。我们看一下下面的示例：\r\n\r\n![图 14](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5c90fa0538a41e4a6b9d2a39efbed66~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**fn_x**类型，表明我们可以利用函数内的函数，当函数被当作数据传递的时候，就可以对函数进行应用（apply），生成更高阶的操作。 并且**x => y => x(y)**可以有两种理解，一种是**x => y**函数传入**X => x(y)**，另一种是**x**传入**y => x(y)**。\r\n\r\n**add_x**类型表明，一个运算式可以有很多不同的路径来实现。\r\n\r\n> 上面的add_1/add_2/add_3我们用到了JavaScript的立即运算表达式**IIFE**。\r\n\r\n**λ演算**是一种抽象的数学表达方式，我们不关心真实的运算情况，我们只关心这种**运算形式**。因此上一节的演算可以用JavaScript来模拟。下面我们来实现**λ演算的JavaScript表示**。\r\n\r\n![图 15](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abca175f704646ec866e42c1e9df62da~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们把**λ演算中**的**f**和**x**分别取为**countTime**和**x**，代入运算就得到了我们的自然数。\r\n\r\n这也说明了不管你使用**符号系统**还是**JavaScript语言**，你想要表达的**自然数**是等价的。这也侧面说明**λ演算**是一种**形式上的抽象（和具体语言表述无关的抽象表达）**。\r\n\r\n### 2.4 函数式编程基础：函数的元、柯里化和Point-Free\r\n\r\n回到JavaScript本身，我们要探究**函数**本身能不能带给我们更多的东西？我们在JavaScript中有很多创建函数的方式：\r\n\r\n![图 16](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44388a2db4ca4c5d90bde568394ab36a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n虽然函数有这么多定义，但function关键字声明的函数带有arguments和this关键字，这让他们看起来更像是对象方法（method），而不是函数（function） 。\r\n\r\n况且function定义的函数大多数还能被构造（比如new Array）。 \r\n\r\n接下来我们将只研究箭头函数，因为它更像是数学意义上的函数（仅执行计算过程）。\r\n\r\n- 没有arguments和this。\r\n- 不可以被构造new。\r\n\r\n#### 2.4.1 函数的元：完全调用和不完全调用\r\n\r\n不论使用何种方式去构造一个函数，这个函数都有两个固定的信息可以获取：\r\n\r\n- **name** 表示当前标识符指向的函数的名字。\r\n- **length** 表示当前标识符指向的函数定义时的参数列表长度。\r\n\r\n在数学上，我们定义**f(x) = x**是一个一元函数，而**f(x, y) = x + y**是一个二元函数。在JavaScript中我们可以使用函数定义时的**length**来定义它的元。\r\n\r\n![图 17](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59928c57bc604562a856cb3733828fb4~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n定义**函数的元**的意义在于，我们可以对函数进行归类，并且可以明确一个函数需要的确切参数个数。函数的元在编译期（类型检查、重载）和运行时（异常处理、动态生成代码）都有重要作用。\r\n\r\n如果我给你一个**二元函数**，你就知道需要传递两个参数。比如+就可以看成是一个二元函数，它的左边接受一个参数，右边接受一个参数，返回它们的和（或字符串连接）。\r\n\r\n在一些其他语言中，+确实也是由抽象类来定义实现的，比如Rust语言的**trait Add<A, B>**。\r\n\r\n但我们上面看到的**λ演算**，每个函数都只有一个元。为什么呢？\r\n\r\n只有一个元的函数方便我们进行代数运算。λ演算的参数列表使用λx.λy.λz的格式进行分割，返回值一般都是函数，如果一个二元函数，调用时只使用了一个参数，则返回一个「不完全调用函数」。这里用三个例子解释“不完全调用”。\r\n\r\n第一个，不完全调用，代换参数后产生了一个**不完全调用函数 λz.3 + z**。\r\n\r\n![图 18](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570a859cf1274b70b09e8c0c7f2f0157~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第二个，Haskell代码，调用一个函数**add**（类型为**a -> a -> a**），得到另一个函数**add 1**（类型为**a -> a**）。\r\n\r\n![图 19](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19b4fe323eb14dcda0dda9249dcbe752~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n第三个，上一个例子的JavaScript版本。\r\n\r\n![图 20](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66a324bee845443e8271c0ac4b7dadee~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n“不完全调用”在JavaScript中也成立。实际上它就是JavaScript中闭包（Closure，上面我们已经提到过）产生的原因，一个函数还没有被销毁（调用没有完全结束），你可以在子环境内使用父环境的变量。\r\n\r\n注意，上面我们使用到的是一元函数，如果使用三元函数来表示addThree，那么函数一次性就调用完毕了，不会产生不完全调用。\r\n\r\n函数的元还有一个著名的例子（面试题）：\r\n\r\n![图 21](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f07de45c5a14544addca2e49a5ea694~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n造成上述结果的原因就是，**Number**是一元的，接受**map**第一个参数就转换得到返回值；而**parseInt**是二元的，第二个参数拿到进制为**1**（**map**函数为三元函数，第二个参数返回元素索引），无法输出正确的转换，只能返回**NaN**。这个例子里面涉及到了一元、二元、三元函数，多一个元，函数体就多一个状态。如果世界上只有一元函数就好了！我们可以全通过一元函数和不完全调用来生成新的函数处理新的问题。\r\n\r\n认识到函数是有元的，这是函数式编程的重要一步，多一个元就多一种复杂度。\r\n\r\n#### 2.4.2 柯里化函数：函数元降维技术\r\n\r\n柯里化（curry）函数是一种把函数的元降维的技术，这个名词是为了纪念我们上文提到的数学家**阿隆佐·邱奇**。\r\n\r\n首先，函数的几种写法是等价的（最终计算结果一致）。\r\n\r\n![图 22](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bab0db59f85469aaee402c6b7af611f~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里列一个简单的把普通函数变为柯里化函数的方式（柯里化函数Curry）。\r\n\r\n![图 23](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3080316268f4a6a9d0e8560024e1bb2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n柯里化函数帮助我们把一个多元函数变成一个不完全调用，利用Closure的魔法，把函数调用变成延迟的偏函数(不完全调用函数)调用。这在函数**组合、复用**等场景非常有用。比如：\r\n\r\n![图 24](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee95f16e61844eefbc62ee26ba61129b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n虽然你可以用其他闭包方式来实现函数的延迟调用，但Curry函数绝对是其中形式最美的几种方式之一。\r\n\r\n#### 2.4.3 Point-Free｜无参风格：函数的高阶组合\r\n\r\n函数式编程中有一种**Point-Free**风格，中文语境大概可以把**point**认为是参数点，对应**λ演算**中的函数应用（Function Apply），或者JavaScript中的函数调用（Function Call），所以可以理解**Point-Free就指的是无参调用**。\r\n\r\n来看一个日常的例子，把二进制数据转换为八进制数据：\r\n\r\n![图 25](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ac8746167c4d3ea5da404eb27a1d69~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这段代码运行起来没有问题，但我们为了处理这个转换，需要了解 **parseInt(x, 2)** 和 **toString(8)** 这两个函数（为什么有魔法数字2和魔法数字8），并且要关心数据（函数类型**a -> b**）在每个节点的形态（关心数据的流向）。有没有一种方式，可以让我们只关心入参和出参，不关心数据流动过程呢？\r\n\r\n![图 26](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5124532e1be46f395c3d7c10e912a71~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上面的方法假设我们已经有了一些基础函数**toBinary**（语义化，消除魔法数字2）和**toStringOx**（语义化，消除魔法数字8），并且有一种方式（**pipe**）把基础函数组合（**Composition**）起来。如果用**Typescript**表示我们的数据流动就是：\r\n\r\n![图 27](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42230ee56a99480e8d7c2cdcdf95e1c7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n用Haskell表示更简洁，后面都用Haskell类型表示方式，作为我们的符号语言。\r\n\r\n![图 28](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05bf37754848414e8fdba12097599889~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n值得注意的是，这里的**x-> [int] ->y**我们不用关心，因为**pipe(..)**函数帮我们处理了它们。pipe就像一个盒子。\r\n\r\n![图 29](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e110b1a058344805bcbb43cccce17037~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**BOX**内容不需要我们理解。而为了达成这个目的，我们需要做这些事：\r\n\r\n- **utils** 一些特定的工具函数。\r\n- **curry** 柯里化并使得函数可以被复用。\r\n- **composition** 一个组合函数，像胶水一样粘合所有的操作。\r\n- **name** 给每个函数定义一个见名知意的名字。\r\n\r\n综上，Point-Free风格是粘合一些基础函数，最终让我们的数据操作不再关心中间态的方式。这是函数式编程，或者说函数式编程语言中我们会一直遇到的风格，表明我们的基础函数是值得信赖的，我们仅关心数据转换这种形式，而不是过程。JavaScript中有很多实现这种基础函数工具的库，最出名的是Lodash。\r\n\r\n可以说函数式编程范式就是在不停地组合函数。\r\n\r\n### 2.5 函数式编程特性\r\n\r\n说了这么久，都是在讲函数，那么究竟什么是函数式编程呢？在网上你可以看到很多定义，但大都离不开这些特性。\r\n\r\n- **First Class** 函数：函数可以被应用，也可以被当作数据。\r\n- **Pure** 纯函数，无副作用：任意时刻以相同参数调用函数任意次数得到的结果都一样。\r\n- **Referential Transparency** 引用透明：可以被表达式替代。\r\n- **Expression** 基于表达式：表达式可以被计算，促进数据流动，状态声明就像是一个暂停，好像数据到这里就会停滞了一下。\r\n- **Immutable** 不可变性：参数不可被修改、变量不可被修改---宁可牺牲性能，也要产生新的数据（Rust内存模型例外）。\r\n- **High Order Function** 大量使用高阶函数：变量存储、闭包应用、函数高度可组合。\r\n- **Curry** 柯里化：对函数进行降维，方便进行组合。\r\n- **Composition** 函数组合：将多个单函数进行组合，像流水线一样工作。\r\n\r\n另外还有一些特性，有的会提到，有的一笔带过，但实际也是一个特性（以Haskell为例）。\r\n\r\n- **Type Inference** 类型推导：如果无法确定数据的类型，那函数怎么去组合？（常见，但非必需）\r\n- **Lazy Evaluation** 惰性求值：函数天然就是一个执行环境，惰性求值是很自然的选择。 \r\n- **Side Effect** IO：一种类型，用于处理副作用。一个不能执行打印文字、修改文件等操作的程序，是没有意义的，总要有位置处理副作用。（边缘）\r\n\r\n数学上，我们定义函数为集合A到集合B的映射。在函数式编程中，我们也是这么认为的。函数就是把数据从某种形态映射到另一种形态。注意理解“映射”，后面我们还会讲到。\r\n\r\n![图 30](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e068f55aaf554b05a6d4b1e18980ba50~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n#### 2.5.1 First Class：函数也是一种数据\r\n\r\n函数本身也是数据的一种，可以是参数，也可以是返回值。\r\n\r\n![图 31](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e752ddac3aa4958af9ab4efa0e1dacf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过这种方式，我们可以让函数作为一种可以保存状态的值进行流动，也可以充分利用不完全调用函数来进行函数组合。把函数作为数据，实际上就让我们有能力获取函数内部的状态，这样也产生了闭包。但函数式编程不强调状态，大部分情况下，我们的“状态”就是一个函数的元（我们从元获取外部状态）。\r\n\r\n#### 2.5.2 纯函数：无状态的世界\r\n\r\n通常我们定义输入输出（IO）是不纯的，因为IO操作不仅操作了数据，还操作了这个数据范畴外部的世界，比如打印、播放声音、修改变量状态、网络请求等。这些操作并不是说对程序造成了破坏，相反，一个完整的程序一定是需要它们的，不然我们的所有计算都将毫无意义。\r\n\r\n但纯函数是可预测的，引用透明的，我们希望代码中更多地出现纯函数式的代码，这样的代码可以被预测，可以被表达式替换，而更多地把IO操作放到一个统一的位置做处理。\r\n\r\n![图 32](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1269e359f946b18ed9e98542a489ca~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这个add函数是不纯的，但我们把副作用都放到它里面了。任意使用这个add函数的位置，都将变成不纯的（就像是async/await的传递性一样）。需要说明的是抛开实际应用来谈论函数的纯粹性是毫无意义的，我们的程序需要和终端、网络等设备进行交互，不然一个计算的运行结果将毫无意义。但对于函数的元来说，这种纯粹性就很有意义，比如：\r\n\r\n![图 33](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfb3c7894e844ad398145e72b8b22a8a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当函数的元像上面那样是一个引用值，如果一个函数的调用不去控制自己的纯粹性，对别人来说，可能会造成毁灭性打击。因此我们需要对引用值特别小心。\r\n\r\n![图 34](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f782164ff0364a7e8a7494b32a6feb0c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上面这种解构赋值的方式仅解决了第一层的引用值，很多其他情况下，我们要处理一个引用树、或者返回一个引用树，这需要更深层次的解引用操作。请小心对待你的引用。\r\n\r\n函数的纯粹性要求我们时刻提醒自己降低状态数量，把变化留在函数外部。\r\n\r\n#### 2.5.3 引用透明：代换\r\n\r\n通过表达式替代（也就是λ演算中讲的归约），可以得到最终数据形态。\r\n\r\n![图 35](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/775caadff16746fa9ca3593213b1e815~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是说，调用一个函数的位置，我们可以使用函数的调用结果来替代此函数调用，产生的结果不变。\r\n\r\n一个引用透明的函数调用链永远是可以被合并式代换的。\r\n\r\n#### 2.5.4 不可变性：把简单留给自己\r\n\r\n一个函数不应该去改变原有的引用值，避免对运算的其他部分造成影响。\r\n\r\n![图 36](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3486aab9bc447d39c92066c87977a72~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n一个充满变化的世界是混沌的，在函数式编程世界，我们需要强调参数和值的不可变性，甚至在很多时候我们可以为了不改变原来的引用值，牺牲性能以产生新的对象来进行运算。牺牲一部分性能来保证我们程序的每个部分都是可预测的，任意一个对象从创建到消失，它的值应该是固定的。\r\n\r\n一个元如果是引用值，请使用一个副本（克隆、复制、替代等方式）来得到状态变更。\r\n\r\n#### 2.5.5 高阶：函数抽象和组合\r\n\r\nJS中用的最多的就是Array相关的高阶函数。实际上Array是一种Monad（后面讲解）。\r\n\r\n![图 37](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5ede42c0c58430d9eac818dce75363b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过高阶函数传递和修改变量：\r\n\r\n![图 38](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d588d63a6ac14f6388e5e081412831d2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n高阶函数实际上为我们提供了注入环境变量（或者说绑定环境变量）提供了更多可能。React的高阶组件就从这个思想上借用而来。一个高阶函数就是使用或者产生另一个函数的函数。高阶函数是函数组合（Composition）的一种方式。\r\n\r\n高阶函数让我们可以更好地组合业务。常见的高阶函数有：\r\n\r\n- map\r\n- compose\r\n- fold\r\n- pipe\r\n- curry\r\n- ....\r\n\r\n#### 2.5.6 惰性计算：降低运行时开销\r\n\r\n惰性计算的含义就是在真正调用到的时候才执行，中间步骤不真实执行程序。这样可以让我们在运行时创建很多基础函数，但并不影响实际业务运行速度，唯有业务代码真实调用时才产生开销。\r\n\r\n![图 39](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fbaa789d14a443aabfddfeea5828eef~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\nmap(addOne)并不会真实执行+1，只有真实调用exec才执行。当然这个只是一个简单的例子，强大的惰性计算在函数式编程语言中还有很多其他例子。比如：\r\n\r\n![图 40](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1506f784a5434b888be6c0d66088a565~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n“无穷”只是一个字面定义，我们知道计算机是无法定义无穷的数据的，因此数据在take的时候才真实产生。\r\n\r\n惰性计算让我们可以无限使用函数组合，在写这些函数组合的过程中并不产生调用。但这种形式，可能会有一个严重的问题，那就是产生一个非常长的调用栈，而虚拟机或者解释器的函数调用栈一般都是有上限的，比如2000个，超过这个限制，函数调用就会栈溢出。虽然函数调用栈过长会引起这个严重的问题，但这个问题其实不是函数式语言设计的逻辑问题，因为调用栈溢出的问题在任何设计不良的程序中都有可能出现，惰性计算只是利用了函数调用栈的特性，而不是一种缺陷。\r\n\r\n记住，任何时候我们都可以重构代码，通过良好的设计来解决栈溢出的问题。\r\n\r\n#### 2.5.7 类型推导\r\n\r\n当前的JS有TypeScript的加持，也可以算是有类型推导了。\r\n\r\n![图 41](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cdbb67bef1448358756a9e4d73dfb65~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n没有类型推导的函数式编程，在使用的时候会很不方便，所有的工具函数都要查表查示例，开发中效率会比较低下，也容易造成错误。\r\n\r\n但并不是说一门函数式语言必须要类型推导，这不是强制的。像Lisp就没有强制类型推导，JavaScript也没有强制的类型推导，这不影响他们的成功。只是说，有了类型推导，我们的编译器可以在编译器期间提前捕获错误，甚至在编译之前，写代码的时候就可以发现错误。类型推导是一些语言强调的优秀特性，它确实可以帮助我们提前发现更多的代码问题。像Rust、Haskell等。\r\n\r\n#### 2.5.8 其他\r\n\r\n你现在也可以总结一些其他的风格或者定义。比如强调函数的组合、强调Point-Free的风格等等。\r\n\r\n![图 42](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751e006b8a584a5ab88de54e80153162~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 3. 小结\r\n\r\n函数式有很多基础的特性，熟练地使用这些特性，并加以巧妙地组合，就形成了我们的“函数式编程范式”。这些基础特性让我们对待一个**function**，更多地看作**函数**，而不是一个**方法**。在许多场景下，使用这种范式进行编程，就像是在做数学推导（或者说是类型推导），它让我们像学习数学一样，把一个个复杂的问题简单化，再进行累加/累积，从而得到结果。\r\n\r\n同时，函数式编程还有一块大的领域需要进入，即副作用处理。不处理副作用的程序是毫无意义的（仅在内存中进行计算），下篇我们将深入函数式编程的应用，为我们的工程应用发掘出更多的特性。\r\n\r\n## 4. 作者简介\r\n\r\n俊杰，美团到家研发平台/医药技术部前端工程师。\r\n\r\n**阅读美团技术团队更多技术文章合集**\r\n\r\n[前端](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765958&idx=1&sn=8201546812e5a95a2bee9dffc6d12f00&chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07#rd) | [算法](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765957&idx=1&sn=c4014e8901b62257b5275567f407abc8&chksm=bd1265888a65ec9e6c6f4f2dc5206d727e5fe91f580f91c326da3dbab381e3da58f75cd52204#rd) | [后端](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765966&idx=1&sn=24485355d27894e8a1b5a1746f6e3235&chksm=bd1265838a65ec95dbb6e54e12170aeb9f6643b9fa0abf221c0f301c03e84543f67294785b77#rd) | [数据](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765964&idx=1&sn=ab6d8db147234fe57f27dd46eec40fef&chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e#rd) | [安全](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765965&idx=1&sn=37e0c56c8b080146ce5249243bfd84d8&chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84#rd) | [运维](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765963&idx=1&sn=a3de9ef267d07d94118c1611776a4b28&chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612#rd) | [iOS](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765973&idx=1&sn=32a23bf1d278dda0398f993ab60a697e&chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d#rd) | [Android](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765972&idx=1&sn=afe02ec92762c1ce18740d03324c4ac3&chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5#rd) | [测试](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651765974&idx=1&sn=763c1e37d04acffd0142a2852ecfb000&chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e#rd)\r\n\r\n**|**  在公众号菜单栏对话框回复【2021年货】、【2020年货】、【2019年货】、【2018年货】、【2017年货】等关键词，可查看美团技术团队历年技术文章合集。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9276995cfd70409f8329336a8189a7eb~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n| 本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明“内容转载自美团技术团队”。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至tech@meituan.com申请授权。\r\n"
    },
    {
        "article_id": "7172462429929111559",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95f157d80f8d480dbc1c84eb4b595ea3~tplv-k3u1fbpfcp-watermark.image?",
        "title": "🌋 2022年终总结征文大赛暨吐槽大会正在进行中！吐出不快，展望未来！",
        "preview": "2022年已接近尾声，在这一年中，你经历过哪些酸甜苦辣？跟着掘金一起，盘点自己的2022吧！还有超多好礼等你来拿！",
        "author": "掘金酱",
        "view_count": 41257,
        "collect_count": 60,
        "comment_count": 474,
        "avatar": "https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/mirror-assets/168e0858b6ccfd57fe5~tplv-t2oaga2asx-image.image",
        "category": "代码人生",
        "content": "---\r\ntheme: cyanosis\r\n---\r\n2022年已接近尾声，在这一年中，你经历过哪些酸甜苦辣？无论过去一年发生了什么，在2022快要结束的时候对过去的自己做一个总结是很有必要的。接下来，跟着掘金一起，盘点自己的2022吧～\r\n\r\n\r\n\r\n# 活动亮点\r\n\r\n本次活动分为两个赛道，分别是「**[掘金主赛道](https://juejin.cn/post/7172462429929111559#heading-2)**」、以及与[火山引擎开发者社区](https://juejin.cn/user/3307770588439422)联合举办的「**[合作赛道](https://juejin.cn/post/7172462429929111559#heading-8)**」，同步发文有机会获得双重奖励哦！注意，**两个赛道的结束时间有差别**，不要记错了哟！\r\n\r\n合作赛道已开奖，请点击链接查看：https://developer.volcengine.com/articles/7186245602710126629\r\n\r\n# 活动玩法\r\n## 掘金赛道：回顾2022，展望2023\r\n### 文章写作方向参考\r\n\r\n-   就业形势\r\n-   面试总结\r\n-   职业规划\r\n-   行业动态/动荡\r\n-   最大的Bug\r\n-   晒娃、晒宠\r\n-   技术写作经历\r\n-   我与掘金的故事\r\n-   在掘金薅过的那些羊毛\r\n-   2022的那些小遗憾or成就榜\r\n-   2022我想做什么 \r\n-   **2022最想吐槽的点** ……\r\n\r\n### 活动时间\r\n\r\n**投稿时间：2022年12月5日-2023年1月31日**\r\n\r\n**获奖名单公布：预计7个工作日内**\r\n\r\n### 文章要求\r\n\r\n| **文章要求** | 具体内容                                                                                                                                                                                    |\r\n| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| 文章类型     | **掘金赛道要求：技术学习、生活总结、工作职业成长、人生感悟、技术总结类、技术趋势预测类文章等**                                                                                                                                   |\r\n| 正文第一句/文末    | 「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」                                                                                                                                                     |\r\n| 文章分类     | 请根据文章内容选择，可优先选择阅读和代码人生                                                                                                                                                                  |\r\n| 文章内容     | 文章要求原创，内容符合[掘金社区的内容标准和规范](https://juejin.cn/book/6844733795329900551/section/6844733795380232199)， 字数不得少于500字，不得有广告/洗稿/凑字数等行为。如果发现**有一篇抄袭/洗稿的文章，以及发现违规刷阅读量、用僵尸账号评论点赞的，都将直接取消资所有的获奖资格**。\r\n\r\n\r\n### 掘金赛道奖项\r\n#### 常规奖\r\n\r\n> BEST 50 评选规则：由数据表现分+内容评分综合排名，数据表现分=阅读量/1000+点赞/100+评论/50；内容分由内容评审进行评分，主要考察是否认真回顾、内容题材是否乐观积极向上、排版和文章结构是否清晰、是否刻意煽动情绪等。\r\n\r\n奖项分类                  | 获奖条件                  | 奖品名称                                                |\r\n| --------------------- | --------------------- | --------------------------------------------------- |\r\n| 掘金 2022 年度个人总结 BEST50 | 第 1 名                 | Apple Watch Series 7 智能手表GPS款                       |\r\n|                       | 第 2 名                 | 开拓者系列 人体工学椅                                         |\r\n|                       | 第 3 名                 | Apple HomePod蓝牙音箱                                   |\r\n|                       | 第 4～10 名              | ikbc 樱桃cherry无线机械键盘|\r\n|                       | 第 11～20 名             | SKG 颈椎按摩仪                                           |\r\n|                       | 第 21～50 名             | 米家榨汁杯                                               |\r\n| 优秀总结奖                 | 参与活动的文章中有一篇满足阅读量≥120，点赞≥6（不包含自己点赞）并且符合活动要求 | 码赛克运动毛巾+小黄鸭盲盒                                         |\r\n| 阳光普照奖                 | 成功参与年终总结征文的用户         | 掘金小册5折优惠券\r\n| 新人奖 | 第一次注册掘金并且首次参加活动发文且文章满足发文要求的用户，即可获得新人奖 | 掘金手机支架（随机款） \r\n\r\n\r\n<img src=\\\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c29e86e4b9e455287661d1479681cc4~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"奖品图.png\\\" width=\\\"100%\\\" />\r\n\r\n#### 个性总结奖\r\n> 不同类别奖项的评奖规则不同，具体见获奖条件，根据内容质量评定，获奖名额根据大家写作情况会有所调整。\r\n\r\n奖项分类                          | 获奖条件                               | 奖品名称                                         |\r\n| ----------------------------- | ---------------------------------- | -------------------------------------------- |\r\n| 掘金 2022 年度个人总结 - women power奖 | 女性开发者、架构师或IT从业者（产品、运营、测试等）*3名      | who cares 咖啡杯+click抱枕+保温杯                                   |\r\n| 掘金 2022 年度个人总结 - 不忘初心奖        | 大龄程序员或 IT 从业者 *3名                  | who cares 咖啡杯+鼠标垫                                      |\r\n| 掘金 2022 年度个人总结 - 天天向上奖        | 学生 / 工作 1～3 年的掘友 *3名               | who cares 咖啡杯+工卡套+技术书籍随机*1                             |\r\n| 掘金 2022 年度个人总结 - 标新立异 Flag 奖  | 2023 年的 Flag 最有创意 / 最狠的掘友 *3名      | who cares 咖啡杯+杜邦特包                                      |\r\n| 神秘奖                           | 掘金 2022 年度个人总结 - XXXX奖 （根据内容质量定数量） | **评奖的时候，可能会根据大家的写作情况，增加趣味奖项哦～ 大胆秀出你的2022成长历程吧！**\r\n\r\n\r\n<img src=\\\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444c5c325a8b4d0d9c9f464cca46bf91~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"个性奖.png\\\" width=\\\"100%\\\" />\r\n\r\n\r\n\r\n## 合作赛道：我的2022技术盘点与总结（已开奖）\r\n\r\n### 获奖名单\r\nhttps://developer.volcengine.com/articles/7186245602710126629\r\n\r\n### **合作方**\r\n\r\n[<img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8db6de9348541e1ad06f9cad7127f1d~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"火山引擎开发者社区.png\\\" width=\\\"30%\\\" />](https://juejin.cn/user/3307770588439422)\r\n\r\n### 活动时间\r\n\r\n-   **投稿时间：2022年12月5日-2022年12月30日**\r\n\r\n-   **结果公布：2023年1月9日**，届时请关注[火山引擎开发者社区](<https://zjsms.com/rKqRQXr/>)和本文章，将会同时公布。\r\n\r\n### 文章要求\r\n\r\n文章必须是**云基础/云原生、大数据、移动开发、音视频、AI** 这几个主题相关的技术内容，可以是对某一技术的学习总结、趋势预测、参与项目的分享，也可以是个人技术能力成长方面的心得体会。文章整体要求：\r\n\r\n1.  字数 800+ （不包括代码字符），内容通顺结构完整；\r\n\r\n2.  投稿请避免：翻译文章、入门教程文章、环境搭建等内容；\r\n\r\n3.  文章必须为原创，不得有广告引流/洗稿/凑字数等行为，一经发现侵权，取消活动参与资格。\r\n\r\n### 活动规则\r\n\r\n1.  **在规定时间段内注册火山引擎开发者社区帐号并在社区【文章】板块发布文章，标题请带上“社区征文”字样，并选择标签「社区征文」**。示例：“社区征文｜火山引擎全栈云原生架构实践”\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f88ede233ba4e98a1a0ef6d8f4f564d~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"50%\\\" />\r\n\r\n2.  文章发布后请在 [活动页面](<https://zjsms.com/rKqDLwT/>) **评论区留言文章链接**，格式为：**文章标题+链接**。示例：如何排查RDS for MySQL 查询运行缓慢的问题 https://developer.volcengine.com/articles/7047068964626628621\r\n\r\n> **掘金** **用户在** **火山引擎** **开发者社区参与活动，请在文章末尾加上本文在掘金网站的链接。**\r\n\r\n3.  文章评审将根据专家评审得分和文章的点赞评论数量得分加权计算。\r\n\r\n**文章得分=专家评审得分*70%+点赞量*30%**\r\n\r\n**专家评委评审评分维度（总分 100 分）** ：\r\n\r\n1.  排版：文章排版清晰，图文并茂、 段落间隔及重点突出。（20）\r\n\r\n2.  结构：文章结构完整，有背景介绍、正文阐述、结尾。（30）\r\n\r\n3.  内容：文章技术内容阐述详实，有可借鉴性、实用性和创新性是加分项。（50）\r\n\r\n\r\n### 合作赛道奖品\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8e43f8c6ac422cb77202755ef40550~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"火山奖品图.png\\\" width=\\\"100%\\\" />\r\n\r\n\r\n\r\n## 活动Q&A\r\n\r\n**Q：合作赛道的奖励在哪里公布？**\r\n\r\nA：已发布：https://developer.volcengine.com/articles/7186245602710126629\r\n\r\n**Q：合作赛道的文章可以参与掘金赛道吗？**\r\n\r\nA：可以。参与合作赛道有机会获得由火山引擎开发者社区提供的奖品，同时在掘金发布的文章也可以参与到掘金赛道的评奖中哦！**发布在不同社区的文章需要满足不同赛道的格式要求**。例如：小明写了一篇2022年云原生的总结文章，符合合作赛道的要求，同时也满足掘金赛道的奖项要求，则可以获得两份奖励。\r\n\r\n**Q：掘金赛道和合作赛道的区别？**\r\n\r\nA：包含关系。即合作赛道的掘金文章可以在参与掘金赛道的奖项评选中；同时满足合作赛道的要求也有机会获得由火山引擎开发者社区提供的奖品。不过掘金赛道的文章不是都可以参与合作赛道，例如：非技术类的个人总结。\r\n\r\n**Q：投稿数量有限制吗？**\r\n\r\nA：没有。\r\n\r\n**Q：一篇文章可以参与多个社区活动吗？**\r\n\r\nA：不行。一篇文章只能参与一个社区活动，可以写多篇文章参与不同的活动。\r\n\r\n**Q：奖品发放问题**\r\n\r\nA：合作赛道的奖品统一由火山引擎开发者社区发放，掘金赛道的奖品由掘金社区进行信息收集并发放，请注意两边的信息公示。\r\n\r\n## 转发有奖（已结束）\r\n\r\n参与时间：12月2日-12月6日\r\n\r\n规则：公开转发本文章或者活动海报到朋友圈，集齐5个赞，截图发到本文评论区，抽10个人获得掘金周边*1 （随机）\r\n\r\n中奖名单：恭喜[秒写二叉树](https://juejin.cn/user/2626095935403016)、[手可摘棉花](https://juejin.cn/user/1820446987402632)、[王也518](https://juejin.cn/user/1319052270121608)、[异星球的小怪同志](https://juejin.cn/user/497427546904615)、[用户7210340961494](https://juejin.cn/user/3576077040754397)、[悔不该杀那华佗吆](https://juejin.cn/user/2661282005391480)、[颜雨烟小可爱](https://juejin.cn/user/3118689452297367)、[掘金用户爱中奖](https://juejin.cn/user/2960356138032136)、[mingdu明渡](https://juejin.cn/user/1649686730507806)、[路人贾富甲一方](https://juejin.cn/user/114004940305358) 10位掘友获得奖品。请中奖掘友查看系统消息，并于12.12日前填写领奖问卷。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feaa24875e6c4322b8b48ffd31188548~tplv-k3u1fbpfcp-watermark.image?\\\" alt=\\\"海报-1080X1920.png\\\" width=\\\"50%\\\" />\r\n\r\n\r\n"
    },
    {
        "article_id": "7188781090986721339",
        "snapshot": "",
        "title": "为什么处理一个排好序的数组比未排序的数组要快？",
        "preview": "这是stack overflow上一个非常火热的问题： 为什么对数组排序能提高执行效率？先看下面的代码，执行分为： 生成随机数放入数组 对数组进行排序 对数组中的数字进行累加 排序后的执行时间：2.2",
        "author": "Hoeller",
        "view_count": 1262,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0e466d365612d64690d726441f984d32~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: juejin\r\n---\r\n\r\n这是stack overflow上一个非常火热的问题：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30ef67e8500e45438eb253f3394e438d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n为什么对数组排序能提高执行效率？先看下面的代码，执行分为：\r\n\r\n1. 生成随机数放入数组\r\n2. 对数组进行排序\r\n3. 对数组中的数字进行累加\r\n```java\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        // 生成随机数\r\n        int arraySize = 32768;\r\n        int data[] = new int[arraySize];\r\n\r\n        Random rnd = new Random(0);\r\n        for (int c = 0; c < arraySize; ++c)\r\n            data[c] = rnd.nextInt() % 256;\r\n\r\n        // 排序\r\n        Arrays.sort(data);\r\n\r\n        // 累加，测试执行时间\r\n        long start = System.nanoTime();\r\n        long sum = 0;\r\n        for (int i = 0; i < 100000; ++i) {\r\n            for (int c = 0; c < arraySize; ++c) {\r\n                if (data[c] >= 128)\r\n                    sum += data[c];\r\n            }\r\n        }\r\n\r\n        System.out.println((System.nanoTime() - start) / 1000000000.0);\r\n        System.out.println(\\\"sum = \\\" + sum);\r\n    }\r\n}\r\n```\r\n\r\n排序后的执行时间：2.2350021s\r\n未排序后的执行时间：6.385857s\r\n\r\n可以发现：**排序后的执行时间是未排序的执行时间的3倍。**\r\n\r\n为什么会这样，这就跟分支预测有关系，什么是分支预测呢？\r\n\r\n计算机在执行某一条指令的过程中，会分为四个步骤：\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a0cda253b84890a54045ef3f0a5086~tplv-k3u1fbpfcp-zoom-1.image)\r\n每个步骤会有对应的电路组件负责。\r\n\r\n假设现在有一段程序对应的计算机指令为：\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671b8faf91b84ead9b4d673d79cfe0d0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n那么计算机应该先执行指令1，然后根据指令1的结果看接下来应该执行哪条指令，假设接下来要执行的就是指令2，那指令流水线会是下图吗？\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c061d4445ab64a148c4115049f8a1b11~tplv-k3u1fbpfcp-zoom-1.image)\r\n假设每个步骤要1毫秒，那执行完这两条指令就需要8毫秒，但是前面说过，指令的四个步骤是由特定的组件来执行的，所以其实可以这么执行：\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a785556750094e74a4a4987bfb3f1d95~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n在解码指令1的过程中，就可以读取指令2了，这样执行完两条指令只需要5毫秒，如果后续指令也按这个节奏执行，那么效率提升会很大，比如串行执行3条指令需要3*4=12毫秒，而并行执行3条指令只需要6毫秒，快了一倍了。\r\n\r\n那这个跟分支预测有什么关系呢？\r\n\r\n我们在来看\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d33c2631cc4726882c794f9251c03d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n假如指令2是一条判断指令，根据判断结果，要么执行指令3，要么执行指令4。\r\n\r\n如果不对判断结果进行预测，那么就只能等指令2执行完之后才知道接下来要执行哪条指令，那指令流水线就是下面这样：\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6523e6b764e64935890b2ddbcc7912ac~tplv-k3u1fbpfcp-zoom-1.image)\r\n执行这三条指令要9毫秒。\r\n\r\n但是，如果在执行指令2之前，我们就能预测出指令2的判断结果，假如预测的是指令3，那么指令流水线就可以这样：\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4aba67620174f8198d474ec3f86c995~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n相当于在解码指令2的时候，就同时去读取指令3，如果执行完指令2后，发现判断结果和预测的结果**是一致的**，那么就可以直接把指令3的结果写回了，这样就大大提高效率，执行这3条指令只需要6毫秒。\r\n\r\n当然如果执行完指令2后，发现预测错了，那么就不能把指令3的结果写回了，而是得读取并执行正确的指令。\r\n\r\n以上就是分支预测，简单总结一下就是，计算机会对分支，比如判断指令的结果进行预测，从而提前去做一些事情，而不是等判断结果出来后才去做事情。\r\n\r\n回到上面的Java代码：\r\n```java\r\nfor (int c = 0; c < arraySize; ++c) {\r\n    if (data[c] >= 128)\r\n        sum += data[c];\r\n}\r\n```\r\n\r\nif语句就相当于是一个判断指令，根据判断结果就会有两个分支：\r\n\r\n1. 要么进行累加\r\n2. 要么取数组中的下一个数字。\r\n\r\n所以，当执行if语句时，计算机就可以进行预测:\r\n\r\n1. 比如预测当前判断的数字是大于128的，那么就可以在判断结果没有出来之前提前进行累加\r\n2. 或者预测当前判断的数字是小于128的，那么就可以在判断结果没有出来之前提前取下一个数字\r\n\r\n只要预测对了，就能提高执行效率，所以，我们要做的就是尽可能让计算机能预测准确，这就是**数组排序的作用**。\r\n\r\n比如计算机在执行指令过程中，发现连续10个数字都是大于128的，那么就可以预测接下来的一个数字也是大于128的，所以只要数组是排好序的，那么这个预测就是正确的，从而也就提高了执行效率。\r\n\r\n以上，就是分支预测，不知道大家看明白没...\r\n\r\n关注公众号一起讨论：\r\n\r\n![qrcode_for_gh_a54d62abe870_258 (1).jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bc960841ad4493a51d91c74f04a73a~tplv-k3u1fbpfcp-watermark.image?)\r\n"
    },
    {
        "article_id": "7186161640121827387",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c566e1ae805475d947766fdfe6521fa~tplv-k3u1fbpfcp-watermark.image?",
        "title": "新时代的 SSR 框架破局者：qwik",
        "preview": "抛弃完全多余的 hydration ，让你的SSR应用性能突破天际。今天我们来聊聊一种全新的服务端渲染思路，一起来看看号称世界上第一个SSR框架：qwik。",
        "author": "19组清风",
        "view_count": 8080,
        "collect_count": 89,
        "comment_count": 19,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/0b2bf89c8fa30c59c10753d91dd327d7~300x300.image",
        "category": "前端",
        "content": "# 引言\r\n\r\n今天这篇文章中和大家聊一聊**号称世界上第一个 O(1) 的 JavaScript SSR 框架：qwik。**\r\n\r\n别担心，如果你不是特别了解 SSR 也没关系，文章大概会从以下几个方面作为切入点：\r\n\r\n+ 🌟 首先会围绕对比 SSR 与 SPA 各自的优劣势，从而展开 SSR 的运行机制以及 SSR 相较于 SPA 究竟为了解决什么问题。\r\n\r\n+ 🌟 之后，会根据 NextJs 的运行机制思考针对目前主流 SSR 框架设计思路上存在的不足从而引出 qwik 为何会在众多成熟框架中脱颖而出。\r\n\r\n+ 🌟 最后，笔者会针对于 qwik 提出自己的看法以及聊聊目前 qwik 存在的”问题“。\r\n\r\n诸如社区内部 SSR 框架其实已经产生了非常优秀的作品，比如大名鼎鼎的 NextJS 以及新兴势力代表的 Remix 和 isLands 架构的 Astro、Fresh 等等优秀框架。\r\n\r\n为何 qwik 可以在众多老牌优秀框架中脱颖而出。接下来，让我们一起来一探究竟吧。\r\n\r\n# SSR & CSR \r\n\r\n目前业内存在非常多基于 SSR 的优秀框架，比如 Next、Remix、Nuxt 等等。\r\n\r\n针对于 Qwik 我们先来聊聊基于 Next 体系的传统 SSR 方案。\r\n\r\n## Client Side Rendering\r\n\r\n在开始 SSR 之前我们先来聊聊它的对立面，所谓的 CSR(Client Side Rendering)。 \r\n\r\n服务器端渲染 (SSR) 是一种在服务器中进行渲染 HTML 而不是由浏览器中执行 JS 获得网页(SPA)的技术。\r\n\r\n目前国内社区中主流框架比如 VueJs、React 等严格意义上来说都是基于 CSR(Client Side Rendering) 的产物。\r\n\r\n所谓 CSR 的意味着当发出一个请求时，服务器会返回一个空的 HTML 页面以及对应的 JavaScript 脚本。\r\n\r\n比如\r\n\r\n```html\r\n<html>\r\n<head> \r\n   <title>携程商旅</title> \r\n</head> \r\n \r\n<body> \r\n     <div id=\\\"root\\\"> </div> \r\n     <script src=\\\"./index.js\\\"> </script> \r\n </body>\r\n </html>\r\n```\r\n\r\n当浏览器下载完成对应的 JS 脚本后才会动态执行对应的 JS 脚本然后在返回的 HTML 页面上进行渲染页面内容。\r\n\r\n你可以简单的理解为上述的 `./index.js` 会在客户端下载完成后执行该脚本，从而执行 `document.getElementById('root').innerHTML = '...'` 来进行页面渲染。\r\n\r\n**这种方式并不是从服务端下发的 HTML 文件来进行渲染页面，相反而是通过浏览器获取到服务端下发 HTML 中的所有的 JS 文件后执行 JS 代码从而在客户端通过脚本进行页面渲染。**\r\n\r\n以及通常在 CSR 中当我们点击任何页面中的导航链接并不会向服务端发起请求，而是通过下载的 JS 脚本中的路由模块(比如 ReactRouter、VueRouter 这样的模块)重新执行 JS 来处理页面跳转从而进行页面重新渲染。\r\n\r\n上面的概念是非常典型的 CSR ，浏览器仅仅接受一个***用作网页容器的 HTML 页面***，这样的方式通常也被称为**单页面应用 (SPA)**。\r\n\r\n### 优势\r\n\r\n那么上述我们提到的 CSR 广泛存在于目前大量页面中，必然存在它自己的优势。\r\n\r\n**在页面初始化访问后加载速度极快且响应非常迅速。** 在页面初始化后，网站所有的 HTML 内容都是在客户端通过执行 JS 生成，并不需要再次请求服务器即可重新渲染 HTML 。\r\n\r\n此外，有关任何实时的数据获取都可以通过 AJAX 请求对于页面进行局部更新从而刷新页面。\r\n\r\n### 劣势\r\n\r\n可是，CSR 真的有那么完美吗。任何一件技术方案一定存在它的两面性，我们来看看 CSR 方式究竟存在哪些问题：\r\n\r\n1. **初始加载时间长**。首次请求完服务器获取到 HTML 页面后，初始化的页面仍然需要在一段时间内处于白屏状态。\r\n    \r\n    在初始渲染之前，浏览器必须等待 HTML 页面中的所有 Javascript 脚本加载完成并且执行完毕，此时页面才会进行真正的渲染。\r\n    \r\n> 当然，使用代码拆分或延迟加载等多种方案可以有效的减少上述的问题。但是这些方式始终是治标不治本，因为它并没有从本质上解决 CSR 存在的问题。\r\n\r\n2. **SEO（搜索引擎优化） 的负面影响。** \r\n    \r\n    上边我们提到过，所谓 CSR 本质上首先会返回一个空的 HTML 页面，所以这也就造成了在搜索引擎对于该页面的数据爬取中会认为它是一个空页面。从而影响对应的搜索结果排名。\r\n    \r\n    虽然说在最新的 Google 中已经可以触发执行 JS 对于网站进行关键字排名，但是在 JS 体积足够大的时候针对于 SEO 仍然是存在一部分问题导致无法解析出正确的关键字匹配。\r\n    \r\n当然 CSR 还存在一些其他方面的缺点，比如网站强依赖于 JS 当用户禁用 JS 时网站只能是白屏展现给用户等等之类。\r\n\r\n## Server Side Render\r\n\r\n简单聊完客户端渲染后，我们稍微来看看所谓的服务端渲染是什么含义。\r\n\r\n基于旧时代的类似 Java 的 JSP 页面我在这里就不赘述了，显然 JSP 的方式每个 HTML 都需要单独请求服务器返回对应的 HTML 内容严格意义上来说这也是 SSR 的方式但是很明显这已经被时代淘汰了。\r\n\r\n目前国内各家公司广泛应用的服务端渲染技术大概的思路是这样的（Next 的 SSR 模式也是同样的思路）：\r\n\r\n当用户首次访问你的应用站点时：\r\n\r\n   1. 首先服务器会根据对应的 URL 在服务端根据对应路径渲染对应的 HTML 模版。\r\n   \r\n       注意这里渲染的 HTML 模版是具有该页面真正的内容。同时它并不具备任何交互逻辑（比如 DOM 元素的点击事件），这是一份完全的静态站点。\r\n       \r\n   2. 服务器会下发这份仅具有静态内容的 HTML 模版，同时这份模版中也会包含对应的 JavaScript 执行脚本。\r\n    \r\n        第一时间会展示给用户对应的 HTML 页面，此时对于访问站点的用户来说**首屏渲染相较于 SPA 应用来说会非常快**。因为它并不需要在客户端浏览器上再次下载和执行 JavaScript 脚本来进行页面渲染。\r\n        \r\n        其次，针对于 SEO 的优化也会非常良好，因为服务器上下发的 HTML 页面是包含当前站点的真实 HTML 结构，对于搜索引擎的爬虫来说会非常容易的匹配到当前关键字。\r\n        \r\n   3. 之后，浏览器会下载当前这份 HTML 的 JS 脚本。\r\n       \r\n       因为首先呈现给用户的一份静态的 HTML 页面，并不具备任何交互效果。我们需要为页面上的元素增加对应交互，HTML 页面中的 JS 脚本中会包含网站的交互逻辑。\r\n       \r\n   4. 最后，当下载完 HTML 脚本中的 JS 脚本后，自然会执行这些 script 脚本。从而发生一种被称为 **# hydrate(水合)** 的方式，从而为页面上静态 HTML 元素再次添加对应的事件处理从而保证页面具有交互性。\r\n\r\n   **当 hydration 过程完成后，会由我们的客户端框架接管网站的后续渲染。**\r\n   在后续的导航链接跳转和页面渲染中和服务器已经没有任何关系了，我们完全可以利用客户端的路由切换（History Api/Hash Api）利用 JS 进行页面渲染从而保证切换页面不用再次请求浏览器保证非常及时的页面交互。\r\n\r\n### hydration \r\n\r\n上述过程中有一个非常重要的关键字 hydration（水合）。\r\n\r\n**首次访问页面时，页面的静态 HTML 是在服务端生成的。** 在服务端我们将生成的静态 HTML 以及 HTML 中携带的 JS 脚本发送到客户端。\r\n\r\n此时静态 HTML 会立即显示在用户视野中，然后浏览器会利用网络进程下载当前 HTML 脚本中的 JS 脚本。\r\n\r\n当 JS 脚本下载完成后，会立即执行同时发生一种被称为 **hydration** 的过程。\r\n\r\n所谓的 **hydration** 简单来说，也就是客户端下载完成 JS 脚本后，浏览器会执行下载的 JS 脚本这些脚本中有部分内容会将**已经存在的 HTML 内容通过执行下载的 JS 脚本添加上对应的事件监听器** 从而保证页面的交互。\r\n\r\n**注意**，在 React、Vue 中 hydration 并不意味这重新渲染。因为在 Server 端已经渲染了和 Client 完全相同的 DOM 结构所以完全没有必要在此重新渲染。\r\n\r\n所以 hydration 的过程是给当前页面中已经生成的 HTML 页面添加上对应的事件监听器。\r\n\r\n> 这也是为什么在 Next 等框架中为什么必须要保证 Server 端和 Client 的渲染 HTML 结构必须一致的原因。\r\n\r\n比如我们以 Next 举例来说（Vue 也是同样的道理）：\r\n\r\n1. 当用户访问 www.trip.biz.com 时，服务端接收到请求调用 ReactDOMServer.renderToString() 生成当前页面的 HTML 静态结构。\r\n\r\n2. 服务器会下发这个 HTML 页面给客户端，同时这个 HTML 页面上也会携带一部分 JS 脚本 script 标签。\r\n\r\n3. 用户的浏览器中会立即展现到该 HTML 页面，同时也会下载对应 JS 脚本并执行。\r\n\r\n4. 当 JS 脚本执行完毕后，客户端会调用 ReactDOM.hydrate() 发生水合为当前页面的 HTML 页面添加事件交互处理，同时后续由 JS 接管页面的跳转渲染。\r\n\r\n> 针对于第一步 Next 中存在 [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimization) 的优化，并不一定会在每次访问时调用 renderToString 方法，有可能在构建时也会直接生成对应的 HTML 模版。\r\n\r\n> 当然，在最新的 Next 版本中已经支持了[Stream](https://nextjs.org/blog/next-13#streaming)以及 [Server Components](https://nextjs.org/blog/next-13#server-components)。\r\n\r\n整个过程就像是这张图中的样子：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b5aa457ede4eed97f91ddef7e74dfe~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 优势\r\n\r\n简单聊过了所谓 SSR 的原理后，如果你有认真看上述的内容。其实我相信相较于 CSR ，SSR 这种方式的好处不言而喻：\r\n\r\n1. 更好的搜索引擎优化 SEO 方式，HTML 模板是从服务端直接下发这也就导致搜索引擎爬虫中更多的关键字匹配。\r\n\r\n2. 更快的首屏渲染，因为相较于 SPA 它少了在 Client 中下载和执行 JS 脚本后渲染的过程。\r\n\r\n3. 页面不需要 JS 也可以正常渲染，虽然没有 JS 意味着页面失去了可交互性。但对于禁用 JS 的用户来说，展示一些静态内容总比 SPA 应用的白屏来的更加友好一些对吧。\r\n\r\n### 劣势\r\n\r\n当然，任何技术方案在不同场景下也存在它自己的不足。\r\n\r\n1. 强依赖于服务。\r\n\r\n    针对于 CSR 的方式它是一种纯静态资源。我们可以直接将它放在 CDN 上就可以良好的用户访问到，而 SSR 的方式必须依赖于一个服务器进行服务端预渲染。（当然纯 SSG 应用我们不在这个讨论范围之内）\r\n    \r\n    同时，有服务的地方就存在并发压力。当你需要为你的应用考虑服务端渲染的方式时，一定不要忘记为你的服务器进行压测。\r\n    \r\n2. [Time to Interactive](https://web.dev/tti/) 可交互时间 (TTI) 的增长，虽然说 SSR 的方式有效的缩短了首屏加载的方式，但是会增加所谓的TTI（可交互时间）。\r\n\r\n    所谓的 TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。\r\n    \r\n    因为 SSR 的方式在用户访问时会下发当前页面中静态的 HTML 内容，也就是所谓的 [First Contentful Paint 首次内容绘制 (FCP)](https://web.dev/fcp/) 会非常快速，但是页面需要用户交互效果缺又需要下载和执行完成 JS 脚本发生 hydatrion 后才具有交互性。\r\n    \r\n    这也就造成页面的 TTI 相较于 CSR 方式会有所差劲，因为 CSR 在渲染完成后就会立即具有交互性（不需要其他任何多余步骤）。\r\n\r\n## qwik\r\n\r\n上述聊了那么多前置内置，终于要和大家切入正题了。\r\n\r\n所谓磨刀不费砍柴功，上边和大家强调现阶段 SSR 的方案以及对应的优劣势就是为了引入下面的内容。\r\n\r\n首先，这篇文章的目的是为了让大家在当前众多 SSR 框架中**思考性能方面**是否可以有所提升的，在服务器方面不会过多的深入。\r\n\r\n我们可以稍微思考下上述服务器端渲染的过程：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b5aa457ede4eed97f91ddef7e74dfe~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**第一步我们需要在服务端获取对应页面的 HTML 页面，大多数情况（非纯静态页面）就需要在服务端掉用对应渲染方法渲染出 HTML 页面。**\r\n\r\n**那么，如果我们能在第一步渲染 HTML 页面时，就添加对应的事件处理。后续的 3 步是不是完全可以省略下来了对吧。**\r\n\r\n其实社区内部之前已经有非常多的方案来提升所谓 SSR 框架的性能方案。\r\n\r\n比如 Remix 的 HTTP [stale-while-revalidate 缓存指令](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate)\r\n\r\n比如 [astro](https://astro.build/) 等新兴框架的 Islands 架构方案，关于 Islands 有兴趣的朋友可以参考神三元的这篇 [Islands 架构原理和实践](https://juejin.cn/post/7155300194773860382#heading-10)。\r\n\r\n针对于上面的概念，我们直接来看看 qwik 中提到的 Hydration is Pure Overhead （完全多余的 Hydration）。\r\n\r\n### Hydration 造成的开销\r\n\r\n首先针对于 Hydration 的过程，我们提过到首先会在服务器上进行一次静态 HTML 渲染，之后当 HTML 下发到客户端后又会再次进行 hydrate 的过程，在客户端进行重新执行脚本添加事件。\r\n\r\nHydration 过程的难点就在于我们需要知道需要什么事件处理程序，以及将该事件处理程序附加在哪个对应的 DOM 节点上。\r\n\r\n这个过程中，我们需要处理：\r\n\r\n+ 每一个事件处理程序中的内容，绝大多数框架中的状态都做为闭包函数保存在内容中。所以需要 hydration 的过程来重新获取状态。\r\n\r\n+ 其次，在搞清楚了每个事件处理函数的内容后。我们也需要将对应的事件处理函数附加到对应的 DOM 节点上，同时还要确保该监听器的正确事件类型。\r\n\r\n更加复杂每个事件处理函数中的内容是一个闭包函数，这个函数内部需要处理两种状态，APP_STATE 以及 FRAMEWORK_STATE。\r\n\r\n+ APP_STATE：应用程序的状态。简单来说应用程序的状态就是 HTML 事件中的各个状态事件，如果不存在这些事件状态那么所有的内容都是没有任何交互效果的。\r\n\r\n+ FRAMEWORK_STATE：框架内部状态。通常我们会利用诸如 React 或者 Vue 等框架进行接替渲染。如果没有 FRAMETER_STATE，框架内部就不知道应该更新哪些DOM节点，也不知道应该在什么时候更新它们。\r\n\r\n**通俗来说 Hydration 就是在客户端重新执行 JS 去修复应用程序内部的 APP_STATE 以及 FRAMEWORK_STATE。**\r\n\r\n同样还是这这张图\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd50eb2803a4bc1aae9276f960a214e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在图中的前三个阶段可以被称为 RECOVERY 阶段，这三个阶段主要是在重建你的应用程序。\r\n\r\n当从 Server 端下发的 HTML 静态页面后，我们希望它是具有交互效果的 HTML 正常应用程序。\r\n\r\n那么此时 hydartion 的过程必须经历下载 HTML 、下载所有相关 JS 脚本、解析并且执行下载的 JS 脚本。\r\n\r\n`RECOVERY` 阶段是和 hydartion 的页面的复杂性成正比，在移动设备上很容易花费 10 秒。\r\n\r\n由于`RECOVERY`是昂贵的部分，大多数应用程序的启动性能都不是最佳的，尤其是在移动设备上。\r\n\r\n**前三个阶段被称为 `RECOVERY` 的阶段其实是完全没有必要的**，因为在服务端我们已然渲染过对应的 HTML ，但是为了应用程序的可交互性以及服务端仅保留了静态的 HTML 模版导致不得不在 Client 上继续执行一次 Server 端的逻辑。\r\n\r\n总而言之，hydration 其实是通过下载并重新执行 SSR/SSG 呈现的 HTML 中的所有 JS 脚本并执行来恢复组建中的事件处理程序。\r\n\r\n同一个应用程序，会被发送到客户端两次，一次作为 HTML，另一次作为 JavaScript。\r\n\r\n此外，框架必须立即执行 JavaScript 以恢复在服务器上被丢掉的 `APP_STATE`和`FRAMEWORK_STATE`。所有这些工作只是为了检索服务器已经拥有但丢弃的东西！！\r\n\r\n比如这样一个例子：\r\n\r\n```tsx\r\nexport const Main = () => <>\r\n   <Greeter />\r\n   <Counter value={10}/>\r\n</>\r\n\r\nexport const Greeter = () => {\r\n  return (\r\n    <button onClick={() => alert('Hello World!'))}>\r\n      Trip Biz\r\n    </button>\r\n  )\r\n}\r\n\r\nexport const Counter = (props: { value: number }) => {\r\n  const store = useStore({ count: props.number || 0 });\r\n  return (\r\n    <button onClick={() => store.count++)}>\r\n      {store.count}\r\n    </button>\r\n  )\r\n}\r\n```\r\n\r\n上边的例子中我们编写了一个 Counter 的计数器组件，在传统 SSR 过程中该组件会被渲染成为：\r\n\r\n```html\r\n<button>Greet</button>\r\n<button>10</button>\r\n```\r\n\r\n可以看到上边的两个按钮**不拥有任何处理状态的能力。**\r\n\r\n要使网页具有交互性，必须要做的就是通过下载对应 HTML 页面中的 script 脚本并执行代码从而恢复按钮上的交互逻辑和状态。\r\n\r\n**为了具有交互性，客户端不得不执行代码实例化组件后重新创建状态。**\r\n\r\n当上述过程完成后，你的应用程序才会真正具有可交互性。无疑，同一个组件的渲染逻辑被执行了两遍，这是一个非常冗余且耗费性能的过程。\r\n\r\n### Resumability: 更加优雅的 hydartion 替代方案\r\n\r\n所以为了消除额外的开销，我们需要思考如何避免重复的 `RECOVERY` 阶段。同时还要避免上面的第四步，第四步是执行脚本后给现有的 HTML 附加正确的事件处理程序。\r\n\r\nqwik 中提出了一个全新的思路来规避 `RECOVERY` 带来的外开销：\r\n\r\n1.  **将所有必需的信息序列化为 HTML 的一部分。**\r\n\r\n    qwik 将需要的状态以及事件序列化保存在 Server 端下发的 HTML 模版中，需要序列化信息需要包括`WHAT`（事件处理函数内容）, `WHERE`（哪些节点需要哪些类型的事件处理函数）, `APP_STATE`（应用状态）, 和`FRAMEWORK_STATE`（框架状态）。\r\n\r\n2. **依赖于事件冒泡来拦截所有事件的全局事件处理程序。**\r\n   \r\n   qwik 中事件处理程序是在全局处理的，这样我们就不必在在特定的 DOM 元素上单独注册所有事件。\r\n   \r\n3. qwki 内部存在一个可以延迟恢复事件处理程序的工厂函数。\r\n\r\n    该工厂函数主要用于处理 WHAT 阶段，也就是用来识别某个事件处理函数中应该存在什么脚本逻辑。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6fd763b0dc04b709aa2b192ea579a65~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们可以看到所谓的 Resumable 对比 Hydration 明显可以省略不需要后三个阶段，直接获取 HTML 后页面其实就已经准备完毕，这无疑对于性能的提升是巨大的。\r\n\r\n\r\n**对比传统的 hydration 方案，在客户端获得服务端下发的 HTML 后会立即请求需要的 JS 脚本并执行从而为页面附加对应的交互效果。**\r\n\r\n**而 qwik 提出的概念恰恰相反，获取完服务端下发的 HTML 页面后所有的交互效果实际上都是一种惰性创建的效果。**\r\n\r\n**因为我们在 HTML 中的每个元素中都已经通过序列化从而在它的标签属性上记录了对应事件处理函数的位置以及脚本内容（自然内容中也包含对应的状态），所以当获得 HTML 页面后其实就可以说此时页面已经加载完毕了而不需要任何实时的 JS 执行。**\r\n\r\n这样做的好处是在 qwki 中完全可以省略 hydration 的多余步骤，甚至可以说完全抛弃了 hydration 的概念。\r\n\r\n客户端完全不必和服务端的 HTML 进行水合，相同的渲染内容仅仅是在 Server 端进行一次渲染客户端即可拥有对应的事件处理内容。\r\n\r\n简单来讲**Qwik的工作原理就是在服务端序列化 HTML 模版，从而在客户端延迟创建事件处理程序，这也是它为什么非常快速的原因。**\r\n\r\n### qwik 工作机制\r\n\r\n上边我们讲到了 qwik 的原理部分，同样拿上边的计数器的例子我们来对比下：\r\n\r\n```tsx\r\nexport const Main = () => <>\r\n   <Greeter />\r\n   <Counter value={10}/>\r\n</>\r\n\r\nexport const Greeter = () => {\r\n  return (\r\n    <button onClick={() => alert('Hello World!'))}>\r\n      Trip Biz\r\n    </button>\r\n  )\r\n}\r\n\r\nexport const Counter = (props: { value: number }) => {\r\n  const store = useStore({ count: props.number || 0 });\r\n  return (\r\n    <button onClick={() => store.count++)}>\r\n      {store.count}\r\n    </button>\r\n  )\r\n}\r\n```\r\n\r\n在 qwik 编译后，服务端会序列化对应组件的 HTML 结构从而下发如下的模板：\r\n\r\n```html\r\n<div q:host>\r\n  <div q:host>\r\n    <button on:click=\\\"./chunk-a.js#button\\\">Trip Biz</button>\r\n  </div>\r\n  <div q:host>\r\n    <button q:obj=\\\"1\\\" on:click=\\\"./chunk-b.js#count[0]\\\">10</button>\r\n  </div>\r\n</div>\r\n<script id=\\\"qwikloader\\\">/* qwik 中设置全局事件监听器的代码 */</script>\r\n<script id=\\\"qwik/json\\\">/* 用于反序列化的 JSON 相关信息 */</script>\r\n```\r\n\r\n\r\n我们可以看到经过 qwik 编译后的 html 结构并不单单只有 DOM 元素，同时会在对应需要状态 & 事件的 DOM 元素上通过 HTML 元素属性来记录当前元素的事件和状态信息，这既是 qwik 中的序列化。\r\n\r\n\r\n比如上边 button 的 `on:click` 属性记录了该元素后续需要恢复的所有信息。\r\n\r\n**需要注意的是序列化这一步是在服务端渲染时完成的，这也就意味着后续客户端可以通过服务端序列化的属性信息进行反序列化从而达到所谓的可恢复性而不需要重复执行组件。**\r\n\r\n当然你可能会好奇 qwik 是如何进行这些事件 & 状态的恢复，qwik 正是通过在返回的 HTML 页面中内嵌的所谓 qwikloader 的 script 脚本（这段脚本的大小不超过 1kb）配合 qwikjson 映射表，从而在全局进行恢复事件和状态的逻辑。\r\n\r\n正因为这个原因，使得 qwik相较于传统 SSR 的 hydration 在 Client 中再次执行渲染从而水合页面状态和事件处理程序，这简直可以说是接近零 JS 的执行过程。\r\n\r\n最终在用户触发事件时候达到惰性的创建事件并执行，这个过程中完全没有重复任何服务器已经完成的任何工作。\r\n\r\n整个工作过程就像下面这张图描述的那样：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a3047a2d5347b993c8809d50b3be9d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n上边的这张图完美的描述了 qwik 的工作原理，相信经过上述的描述大家对于这张图中想表达的思想已经可以完美的理解了。\r\n\r\n利用 qwik 的这个优势，在绝大多数应用中我们可以利用 qwik 保证你的 SSR 应用在保证快速的 FCP 的前提也同样拥有与之不相上下的 TTI 体验效果。\r\n\r\n### 惰性加载脚本会影响用户交互体验吗\r\n\r\n当然上文说过任何框架的优势和劣势都不是绝对的，在笔者看来 qwik 的确会存在以下一些问题。\r\n\r\n大多数同学看完上边的内容我相信也会存在“惰性加载脚本会影响用户交互体验吗”这样的疑问。\r\n\r\n首先，qwik 中既然选择在触发用户行为时，再惰性加载并执行响应的 JS 脚本。那么难免需要在用户触发交互时动态生成对应的事件处理函数进行执行。\r\n\r\n这样的方式相较于传统 hydration 的确会存在一些不足，需要额外生成事件会额外造成交互响应时间的损耗而传统 SSR 方式在页面首次加载时就已经绑定好（相当于生成了）相应的事件处理函数。\r\n\r\n就惰性加载生成事件这点在我看来：\r\n\r\n   针对于动态加载 JS 脚本，其实已经存在诸如非常多的 prefetch 等等预加载技术。\r\n   \r\n   无论是基于传统 Next 方案还是基于 qwik 这种惰性可恢复的方案，利用 prefetch 等预加载技术优先在网络空闲时加载响应重要的 JS 脚本都是非常有必要的，所以这点在我看来并不是特别重要的问题。\r\n   \r\n   \r\n### 延迟加载会带来 bundle 数量的上升吗\r\n\r\nqwik 推崇的延迟加载其实已经是一项非常成熟的构建技术了。无论是使用 webpack、rollup 又或是其他任何构建工具都存在延迟加载 & 代码分割的技术。\r\n\r\n传统构建工具中关于代码分割会带来以下两点的困难：\r\n\r\n1. 需要开发人员自行去处理更加细粒度的代码分割，当然这并不是最主要的。因为目前我们可以利用 [Magic Comments](https://webpack.js.org/api/module-methods/#magic-comments) 配合 [Dynaic Imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports) 来解决需要手动切入多个入口点的问题。\r\n\r\n当然，这一系列事情比起魔法注释。因为 qwik 本身提倡的就是所谓的延迟加载，所以在框架内部已经帮我们足够智能的去处理这个过程。\r\n\r\n但是需要注意的是这并不意味着开发者无法自主去控制这个过程。只是在使用框架的过程中，qwik 希望开发者更加专注于他们自身的业务逻辑。\r\n\r\n2. **当存在非常多的延迟加载时，传统构建工具会从一个大 bundle 分割成为无数个小的 bundle 。**\r\n\r\n延迟加载模块的确会存在多个 small bundle 的问题，可是当我们拥有的 bundle 越多，其实我们就拥有更多的自由度去以各种各样的方式去拼装成为单个大的 bundle。\r\n\r\nqwik 中存在足够的方式提供给我们将多个小的 chunk 自由组合成为一个从而有效的减少细碎 chunk 的数量，当然这个点在传统构建工具中也是这样。\r\n\r\n### 动态创建事件函数会造成内存泄漏吗\r\n\r\nqwik 的设计思想在与每次事件触发时通过 qwikloader 来动态创建事件处理函数，相信有的同学存在疑问“那么多次触发事件会造成额外的开销吗”。\r\n\r\nqwik 的作者 **miško hevery** 在 [Hydration is Pure Overhead](https://www.builder.io/blog/hydration-is-pure-overhead) 中明确的表示过 qwik 会在每次事件执行完毕后释放函数，相当于每次事件执行完毕都会进行一次“去水合”的过程。\r\n\r\n所以，当你触发一次事件和无数次事件函数在执行过程中对于内存占用来说是相差无几的。\r\n\r\n当然相较于传统 hydration 的方式（在页面首次渲染时在内存中记录所有状态），无疑 qwik 这种并不在内存中记录任何状态的方式恰恰对于内存的占用比 dyration 更加轻量化。\r\n   \r\n### qwik 真的有那么快吗\r\n\r\n说了那么多，那么 qwik 真的有那么快吗。\r\n\r\n![WechatIMG144.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5dce3a32394eada285886cc1f73aca~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n上图是利用 qwik 搭建的 [builder.io](https://www.builder.io/) 官方网站，我相信 builder.io 的数据已经告诉我们答案了。\r\n\r\n固然上述的数据并不仅仅只是单纯一个 qwik 框架带给网站的优化，一定会有代码层面或者构建层面等等方面的优化配合而来的数据。但是针对于 FCP 和 TTI 时间上的一致性这在一个中型 SSR 应用程序其实可以称得上是非常优秀了，我相信这足以说明了 qwik 的确名副其实。\r\n   \r\n# 结语\r\n\r\n我们可以看出来，qwik 的核心思路还是通过更加细粒的代码控制配合惰性加载事件处理程序以及事件委托来缩短首屏 TTI。\r\n\r\n文章中我们也讲到了 qwik 其实并不是因为使用了多么牛逼的算法导致它有多么快，而它的速度正是得益于它的设计思路，省略了传统 SSR 下首屏需要加载庞大的 JS 进行 hydration 的过程。\r\n\r\n当然，笔者对于 qwik 也仍是在学习阶段。后续会在公司里的更多项目尝试 qwik 之后也会和大家分享关于它的更多心得。\r\n\r\n总而言之，qwik 的”无水合“设计思路目前看来的确会在框架层面带来巨大的性能提升。大家如果有机会的话也可以在项目中尝试一下 qwik ，相信会给你带来意想不到的收益效果。\r\n\r\n\r\n\r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7184970952298463290",
        "snapshot": "",
        "title": "团队技术专家回老家了，留下的技术设计模板真好用！",
        "preview": "大家好，我是老三，转眼间，团队的技术专家B哥，已经离职一年了，我还时不时会想起他，因为他留下的j技术设计模版，我觉得真的很好用，基本上涵盖了设计需要考虑的方方面面。",
        "author": "三分恶",
        "view_count": 7889,
        "collect_count": 178,
        "comment_count": 9,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/1035af1f1261526990c117454a5e3fab~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: v-green\r\n---\r\n大家好，我是老三，转眼间，团队的技术专家B哥，已经离职一年了，我还时不时会想起他，因为他留下的j技术设计模版，我觉得真的很好用，基本上涵盖了设计需要考虑的方方面面。接下来，以一个CRM项目的用户触达模块为例，给大家分享一下。\r\n\r\n# 一、CRM\\\\_技术设计文档_消息触达模块\r\n\r\n| 项目名称   | CRM系统      |\r\n| ---------- | ------------ |\r\n| 项目负责人 | 三分恶       |\r\n| 模块名称   | 用户触达模块 |\r\n| 模块负责人 | 三分恶       |\r\n\r\n\r\n\r\n\r\n> 老三说：第一部分主要说明项目或者模块的概况，这一部分虽然不太重要，但是是必须的。\r\n\r\n# 二、修订记录\r\n\r\n| 版本 | 修订人 | 修订内容 | 修订日期   |\r\n| ---- | ------ | -------- | ---------- |\r\n| V1.0 | 三分恶 | 创建     | 2022-12-23 |\r\n\r\n> 老三说：技术设计不是一成不变的，经常会随着业务的变化，或者根据遇到的一些问题，进行完善和优化，但是每一个版本，都应该留下记录和备份。\r\n\r\n# 三、需求/背景\r\n\r\n产品文档：xxxx\r\n\r\n为了实现用户的精细化运营，通过多种途径，向用户发送消息通知……\r\n\r\n> 老三说：这一部分就是结合产品文档，把需求/背景简单提炼一下，必须，但不是重点。\r\n\r\n# 四、设计目标\r\n\r\n> 老三说：设计目标一般分为两部分：\r\n>\r\n> - 实现功能：这一部分就是就是分析需求，把产品文档里的东西，拆解成一个个的功能，也就是CRUD。\r\n> - 设计指标：CRUD也有区别，一把梭，随便写也能实现功能，但是我们CRUD也得有点追求，而且面向C端用户的系统，也基本上会有一些性能、可用性之类的要求，比如接口响应平均多少多少毫秒以下、单机QPS1000、系统几个9可用……\r\n\r\n## 4.1.实现功能\r\n\r\n1. 多种渠道给用户推送消息，主要包含站内和站外两大部分：\r\n\r\n- 站内：\r\n  - 站内信\r\n  - 弹屏\r\n- 站外：\r\n  - 邮件\r\n  - 短信\r\n  - push\r\n  - 微信\r\n  - ……\r\n\r\n2. 触达任务管理\r\n\r\n- 支持定时/延时消息发送\r\n- 支持触发型消息发送\r\n- 支持用户分群发送\r\n\r\n……\r\n\r\n> 老三说：功能点比较多的话，这一部分还可以用思维导图的形式来整理。\r\n\r\n![思维导图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f2bd977664947628926e8ebba9867c1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 老三说：这一部分评审的时候一定要拉上产品经理或者相关的业务方，确定功能点没有错漏。\r\n\r\n## 4.2.设计指标\r\n\r\n1. 性能要求\r\n\r\n- 百万级消息分钟级发送完成\r\n- xx接口，性能指标：单机1000并发，95%响应<=200ms\r\n\r\n……\r\n\r\n> 老三说：一般C端的服务都是有比较严格的性能要求的，毕竟如果系统响应慢的话，用户的流失率就会变高。当然，用户触达，其实主要在于推，用户主动查会少一些，消息的推送通常也会要求速度，比如，有个网红，九点钟要在app上直播，直播开始的时候，要做一个推送，那就要求尽可能快地把消息推送给每个用户，不能说等到十二点直播完了，有的用户才收到消息。\r\n\r\n2. 可用性\r\n\r\n- 触达模块99.9%可用\r\n- 消息推送成功率80%以上\r\n\r\n……\r\n\r\n> 老三说：C端系统的可用性比较重要，毕竟挂一会，影响的用户可能都是以万计，所以，设计的时候，也要考虑可用性，分析系统的瓶颈在哪里，流量突然上来，哪里可能顶不住，是要扩容，还是要限流、熔断降级……\r\n\r\n3. 扩展性\r\n\r\n- 采用策略模式+配置，新增消息渠道，只需少量代码+代码即可实现\r\n- 引入规则引擎，同一消息类型的不同渠道，可以通过规则调整，无需发版\r\n\r\n……\r\n\r\n> 老三说：这一部分也是设计中应当考虑的，不能一味求快，否则很容易堆屎山。\r\n\r\n4. 兼容性\r\n\r\n- 接口xxx向前兼容app 1.9.0版本，低版本需强制更新\r\n\r\n……\r\n\r\n> 老三说：C端系统的开发，有时候比较麻的是低版本app的兼容，尽可能早期设计的时候，就考虑可能的扩展，如果实在没法兼容，那就只能app强制更新，当然这种用户体验就非常不好了。\r\n\r\n5. 可观测性\r\n\r\n- 接入Prometheus和Grafana，对服务和业务进行监控\r\n  - 服务监控：通过控制面板观察服务的内存、CPU、JVM、接口QPS、接口RT……\r\n  - 业务监控：通过埋点上报，收集用户触达数据，通过面板可以分设备、渠道查看用户触达成功率……\r\n\r\n> 老三说：这一部分也很重要，我们一般上班的第一件事，就是看监控面板，分析有没有什么异常的地方。服务的可观测性，一般公司都是用一些开源的或者付费的监控平台，大厂一般都会自研监控平台。服务的监控很多是通过插桩来实现，业务的监控一般都需要打埋点。\r\n\r\n6. 告警\r\n\r\n- 通过PrometheusAlert实现服务的告警，告警信息分级别，进行飞书通知、电话通知，告警类型分为服务告警和业务告警\r\n  - 服务告警：内存、CPU占用过高，接口QPS过多，接口RT过长，触发告警\r\n  - 业务告警：用户触达成功率过低告警\r\n\r\n> 老三说：告警通常也是和监控在一起的，毕竟开发人员也不可能二十四小时盯着告警，一般开源的、付费的、自建的监控系统，都支持配置告警规则，并通过不同的方式，邮件、短信、电话之类的渠道进行通知。\r\n\r\n# 五、概要设计\r\n\r\n> 老三说：概要设计，就是做个大概的系统整体设计。\r\n\r\n## 5.1.设计思路\r\n\r\n- 数百万消息段时间发送完成，流量较大，对数据存储性能要求较高，需要选用高性能DB，对存储压力也比较大，同时需要一定削峰处理\r\n- 定时/延时消息发送采用消息队列实现，对MQ的消费要求较高，并发度要高，批量消费\r\n- ……\r\n\r\n> 老三说：这一部分主要是梳理一下整体的开发设计思路，把一些零散的想法梳理成点或者面，前期大家的讨论可以整理在这里。\r\n\r\n## 5.2.技术选型\r\n\r\n- 存储：TiDB\r\n- 缓存：Redis\r\n- 消息队列：业务RocketMQ，埋点Kafka\r\n- 注册中心：Nacos\r\n- 配置中心：Nacos\r\n- RPC：Dubbo\r\n- 网关：Gateway\r\n- Push通道：自建\r\n\r\n……\r\n\r\n> 老三说：这一部分就是大概定一下技术选型，其实要是整个项目做好了选型，这一部分也可以不做，一般需要高级技术人员或者架构师，来整体地进行把握，当然，很多时候选型也没好选的，基本就是主流的那些，而且一般一个团队，都是统一的技术选型，方便维护。\r\n\r\n## 5.3.业务架构\r\n\r\n![业务架构](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e12887f85744b6bf13b05cd7ff993e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 老三说：这一部分就是大概对功能分分层，分分块，把大概的功能切一切。\r\n\r\n## 5.4.技术架构\r\n\r\n> 老三说：技术选型+业务架构，其实一个大概的技术架构就出来了。\r\n\r\n![技术架构](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb45efcaaba4f9898d979e8efc0c1c7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 老三说：技术架构图类型，其实也没有特别固定的形式，主要是图能达意，我这个图是通过draw.io画的，还有一些其它的还用的工具，比如大家应该都听过“PPT架构师”，用PPT画也是可以的。当然这个图是我随手画的。\r\n\r\n## 5.5.系统环境\r\n\r\n- JDK版本：11\r\n- 部署环境：k8s+Containerd，单pod8核CPU+4G内存，服务集群32个pod\r\n- 数据库：\r\n  - 业务数据：TiDB 64核CPU+128G内存\r\n  - 离线数据：Hbase……\r\n- ……\r\n\r\n> 老三说：如果是项目初建，一般还需要对系统的环境进行评估，根据技术选型、数据容量、系统QPS等等，来选择系统的环境，这一部分一般评审的时候会拉上运维同学，提前确定好系统环境，和运维同学对齐需求和排期。\r\n\r\n# 六、详细设计\r\n\r\n> 老三说：详细设计，就是具体指导开发的设计部分了，包括流程啊、数据模型啊、具体用到的算法、和客户端的接口，等等，这一部分很重要，如果没做好，没对齐，那么搞不好就要返工，耽误进度。\r\n\r\n## 6.1.流程设计\r\n\r\n- push流程\r\n\r\n![push流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cea7140e1914431bb021b050dc60f27a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n> 老三说：用户触达，业务流程基本比较简单，对于一些交易类的，比如支付，或者B端的系统，比如ERP，在开始开发之前，流程一定要梳理清楚，一般通过流程图、时序图来描述业务流程。给大家看一下我之前对接alipay画的简单的时序图：\r\n>\r\n> ![Alipay接入时序图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6368d64b5c447ac825c64798584fc0a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 6.2.算法设计\r\n\r\n- 渠道分流：同一消息类型，多种渠道，支持按比例分流，采用加权随机算法实现\r\n- ……\r\n\r\n> 老三说：算法设置不一定数据结构相关的算法，代码里的一些涉及到一些需要进行逻辑计算的，都可以称之为算法，这一部分也可以先梳理一下。\r\n\r\n## 6.3.数据模型设计\r\n\r\n- crm_user_toutch_tash：用户触达任务表\r\n\r\n| 字段    | 描述     | 数据类型 |\r\n| ------- | -------- | -------- |\r\n| id      | 主键     | bigint   |\r\n| task_no | 任务编号 | bigint   |\r\n| comment | 描述     | varchar  |\r\n| ……      |          |          |\r\n\r\n> 老三说：数据模型设计非常重要，可以说是系统设计的根基，如果没有设计好，开发和维护起来真的很痛苦，每个公司应该都有一定的数据库设计规范，基本就是结合业务和规范来设计了。\r\n>\r\n> 具体用什么工具设计呢？业务比较简单的C端系统，其实直接拿表格也行，之前也试过PdMan，还行吧。\r\n\r\n## 6.4.接口设计\r\n\r\n| 接口名称     | 添加支付任务         |\r\n| ------------ | -------------------- |\r\n| 接口文档地址 | https://yapi.com/xxx |\r\n| 入参         |                      |\r\n| 入参描述     | comment：任务描述    |\r\n| 出参         |                      |\r\n| 出参描       |                      |\r\n\r\n> 老三说：这一部分也是重量级，但凡涉及到客户端，或者其它服务的，这一部分都少不了，一般可以通过YApai之类的接口工具，但是建议大家还是在文档里做个重复工作，把入参出参之类的描述一下，有些地方标标重点，因为有些人真的不怎么会看文档。\r\n>\r\n> 接口设计的时候一定要和相关的同学对齐，不要怕花时间，后期改接口，是一件很痛苦的事情。\r\n\r\n## 6.5.异常处理\r\n\r\n- 系统中的不确定异常，进行统一处理，响应“Network Error”\r\n- 埋点异步发送，不影响主要功能\r\n- ……\r\n\r\n> 老三说：异常处理也是需要考虑的地方，哪些异常可以吞掉降级，哪些没法处理，怎么给客户端展示，怎么打日志，都需要考虑。\r\n\r\n# 七、风险评估\r\n\r\n> 老三说：其实每一次上线都伴随着风险，从设计，一直到上线之前，都要对存在的风险进行评估，上线了要重点观察风险点，也要提前设计好回滚或者处理方案，一旦发现不对劲，及时回滚和处理。\r\n\r\n## 7.1.已知风险\r\n\r\n- 对数据相关服务压力较大，用户分群、用户画像等数据服务崩溃风险\r\n- MQ存在堆积风险，导致用户收到消息延迟\r\n- QPS较高，数据库CPU飙升风险\r\n- ……\r\n\r\n## 7.2.可能风险\r\n\r\n- 场景类消息延迟，可能会影响交易相关流程，拉低转化率和成交率\r\n\r\n……\r\n\r\n# 八、测试建议\r\n\r\n> 老三说：需求评审阶段、设计评审阶段，最好都拉上测试同学，测试同学要对整体的功能，还有性能，都有比较清楚的了解。但是啊，如果只看功能的话，可能就是表面的点点点，具体实现逻辑，还是开发比较清楚，所以说给测试同学提一些测试建议，给测试的测试用例提供参考。\r\n>\r\n> 同时，我个人觉得，从测试的角度进行思考，也能有效减少写代码的bug。\r\n\r\n## 8.1.功能测试\r\n\r\n| 功能         | 测试步骤     | 预期结果     |\r\n| ------------ | ------------ | ------------ |\r\n| 定时消息发送 | 创建定时消息 | 消息定时发送 |\r\n| ……           |              |              |\r\n\r\n\r\n\r\n> 老三说：这一部分基本就是结合设计目标的实现功能，列一下测试步骤和预期结果\r\n\r\n## 8.2.性能测试\r\n\r\n- xxx接口压测，预估单机QPS1000\r\n\r\n> 这一部分基本就是压测了，很多时候，系统的压测没那么简单，尤其是链路长的时候，压一次都得兴师动众。\r\n\r\n# 九、上线准备\r\n\r\n- 运维搭建环境\r\n- 数据初始化\r\n- 添加配置\r\n- 消息队列创建\r\n- 依赖服务上线\r\n- 服务上线\r\n\r\n> 老三说：这一部分算是上线的备忘吧，有些wiki类的工具，支持在文档里建任务，把上线前需要做的事情列出来，有不知道你经历过“测试环境猛如虎，上线一看原地杵”没？可能就是上线准备没做好，缺了什么，少了什么。\r\n\r\n# 十、评审及意见\r\n\r\n| 评审意见                                                | 提出人 | 提出日期     | 解决意见     | 解决人 | 解决日期     |\r\n| ------------------------------------------------------- | ------ | ------------ | ------------ | ------ | ------------ |\r\n| xxx接口需要考虑一下兼容性，建议xx字段，从object改为list | 老六   | 2023年1月1日 | 修改字段类型 | 老三   | 2023年1月1日 |\r\n| ……                                                      |        |              |              |        |              |\r\n\r\n> 老三说：设计文档不是写完，啪，丢出去就完事了，还要上设计评审会，评审的时候，通常相关同学会提出一些评审意见，这些都应该记录下来，解决完了之后，再次评审，直到评审通过，然后就可以开始CRUD了。\r\n\r\n<br>\r\n\r\n<hr>\r\n\r\n好了，看完这个模板，想必你对技术设计也有一定的认识了，老三实际上没怎么接触过用户运营相关的东西，所以内容大家随便看看，主要看模板。\r\n\r\n当然模板是相对固定的，但是设计是灵活的，做技术设计的时候，也不用拘泥于固定的形式，根据具体的需求，考虑到需要考虑的点，能做到设计指导开发就够了。\r\n\r\n那么，假如你已经能做好技术设计……\r\n\r\n但是——\r\n\r\n老板：三某，这个需求，三天能不能搞定？\r\n\r\n老三：可能不太……\r\n\r\n老板：这个需求很急，而且我不能不急，你懂我的意思吧？\r\n\r\n老三：没问题，三天够了！\r\n\r\n而且——\r\n\r\n老板：呦，三某的文档写的很清晰，代码也很优雅，今年公司绩效不好，找个实习生把他替了吧。\r\n\r\n……\r\n\r\n![绷不住](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78679db19aa4176a2d3d65524431338~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n\r\n<br>\r\n\r\n<hr>\r\n<big><b>参考：</b></big>\r\n\r\n[1].用户运营：触达系统应该如何搭建:https://www.woshipm.com/user-research/4239618.html)\r\n\r\n[2].一个实时精准触达系统的自我修养:https://juejin.cn/post/6844904009770221581\r\n\r\n<hr>\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7161712791089315877",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46c3103741254802b8df1893ca0c8e9e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "好烦啊，为什么点个链接还让我确认一下？",
        "preview": "背景 最近经常看到各大SNS平台有这样一项功能，点击跳转链接，如果不是本站的链接，那么就会跳转到一个中转页，告诉你跳转了一个非本站链接，提醒你注意账号财产安全",
        "author": "CodePlayer",
        "view_count": 15053,
        "collect_count": 140,
        "comment_count": 73,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/15709186cf010b3ff9689d507079782d~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\n---\r\n> 万丈苍穹水更深，无限乾坤尽眼中\r\n\r\n### 背景\r\n最近经常看到各大SNS平台有这样一项功能，点击跳转链接，如果不是本站的链接，那么就会跳转到一个中转页，告诉你跳转了一个非本站链接，提醒你注意账号财产安全，如图：\r\n\r\n![A6C73047-4041-4584-9F97-BA04C896D73E.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac23f9d476494d37a2424d66c2c3b2f5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n很明显，这个是为了一定程度的避免用户被钓鱼，预防XSS或CRSF攻击，所以请不要像标题一样抱怨，多点一下也花不了2S时间。\r\n\r\n### 原理\r\n那么这个是如何实现的呢，原理其实很简单。\r\n\r\na标签的onclick事件可以被拦截，当返回false时不会默认跳转。\r\n\r\n那么具体如何实现呢，拿掘金来举例：\r\n```javascript\r\n        function SetSafeA(whiteDomList: string[], safeLink = 'https://link.juejin.cn/?target=') {\r\n          const aArr = document.getElementsByTagName('a')\r\n          Array.from(aArr).forEach(item=>{\r\n            item.onclick = ()  => {\r\n              let target = item.getAttribute('href')!\r\n              if(/^\\\\//.test(target)) {\r\n                // 相对本站链接\r\n                return true\r\n              }\r\n             const isSafe = undefined !==  whiteDomList.find(item=>{\r\n                 return target.indexOf(item) !== -1\r\n              })\r\n              if(!isSafe) {\r\n                window.open(`${safeLink}${target}`, '_blank')\r\n              } else {\r\n                return true\r\n              }\r\n              return false\r\n            }\r\n          })\r\n        }\r\n```\r\n\r\n可以随便找一个网页在控制台执行一下，都能跳到掘金的中转页，中转页的代码就不写了^_^\r\n\r\n### 实践\r\n刚好最近遇到一个使用场景，公司APP产品里面都有各自用户协议，其中SDK协议我们都是直接跳转链接的，结果在部分渠道如小天才，步步高等对用户信息非常敏感的平台上，要求所有的链接必须要跳转到平台默认的安全浏览器上，不能在APP内打开。那么协议有很多如何快速处理呢。由于项目用到了vue，这里就想到使用指令，通过批量添加指令来达到快速替换，比如'<a' =>'<a v-link=\\\"x\\\"',代码如下：\r\n```javascript\r\nVue.directive('outlink', {\r\n  bind: (el, binding) => {\r\n    el.outlink = () => {\r\n      if (GetEnv() === 'app') {\r\n        const from = isNaN(+binding.value) ? 1 : +binding.value\r\n        const url = el.getAttribute('href')\r\n        if (url && url !== '' && url != 'javascript:;') {\r\n          window.location.href = `${GetSchemeByFrom(from)}://outside_webview?url=${url}`\r\n        }\r\n        return false\r\n      }\r\n    }\r\n    el.onclick = el.outlink\r\n  },\r\n  unbind: (el) => {\r\n    el.onclick = null\r\n    delete el.outlink\r\n  }\r\n})\r\n```\r\n这里我们传入了from值来区分APP平台，然后调用APP提供的相应scheme跳转到客户端的默认浏览器,如下:\r\n\r\n![DE2DFA5F-ED19-4e74-97B6-2D19246D5D84.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a120b68cca8b4f0a9133139fb2cd0386~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 结语\r\n链接拦截可以做好事，也可以做一些hack，希望使用的人保持一颗爱好和平的心;当然遇到让你确认安全的链接时，也请你保持一颗感谢的心。\r\n"
    },
    {
        "article_id": "7171418322943737869",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d670cf87ef96496d90d4ff474713fa94~tplv-k3u1fbpfcp-watermark.image?",
        "title": "SpringBoot3.0正式发布，我来尝尝鲜",
        "preview": "SpringBoot3.0 中最重要的特性就是对 GraalVM 的支持，从而达到更快的启动速度，有两种使用方式。 利用 GraalVM 构建可执行文件 新建一个 SpringBoot 3.0 的 M",
        "author": "Hoeller",
        "view_count": 17531,
        "collect_count": 71,
        "comment_count": 12,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0e466d365612d64690d726441f984d32~300x300.image",
        "category": "后端",
        "content": "> GraalVM 版本：graalvm-ce-java17-22.3.0\r\n\r\nSpringBoot3.0 中最重要的特性就是对 GraalVM 的支持，从而达到更快的启动速度，有两种使用方式。\r\n\r\n## 利用 GraalVM 构建可执行文件\r\n\r\n> 因为需要利用 GraalVM 来打包可执行文件，所以需要你的机器上安装了 GraalVM。\r\n\r\n新建一个 SpringBoot 3.0 的 Maven 工程，引入 parent、starter 依赖、以及两个重要的插件：\r\n\r\n```\r\n<build>\r\n  <plugins>\r\n    <plugin>\r\n      <groupId>org.graalvm.buildtools</groupId>\r\n      <artifactId>native-maven-plugin</artifactId>\r\n    </plugin>\r\n    <plugin>\r\n      <groupId>org.springframework.boot</groupId>\r\n      <artifactId>spring-boot-maven-plugin</artifactId>\r\n    </plugin>\r\n  </plugins>\r\n</build>\r\n```\r\n\r\n然后执行：\r\n\r\n```\r\nmvn -Pnative clean native:compile\r\n```\r\n\r\n需要花费一些时间...\r\n\r\n执行完能看到 BUILD SUCCESS： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3f49c3f39449a5a3084915a835b86d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n然后进入 target，就能看到一个 exe 文件： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5c3ec645cfd47faa24bbc924a6786cd~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n我们可以直接运行该 exe 来启动我们的 SpringBoot 应用： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eaaf4dadad944ad9764340d7f163e15~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这样，我们就可以把这个可执行文件发送给另外的 windows 机器了，并且对方机器都不需要安装 JDK 就能运行我们的 SpringBoot 程序（亲自测过，确实能直接运行）。\r\n\r\n不过大家应该发现了问题，在 windows 上编译出来的是 exe 文件，它是不能在 linux 上运行的，那么怎么办呢？\r\n\r\n## 利用 Buildpacks 构建可执行文件 Docker 镜像\r\n\r\n我们可以直接把 SpringBoot 应用对应的本地可执行文件构建为一个 Docker 镜像，这样就能跨操作系统运行了。\r\n\r\n> Buildpacks，类似 Dockerfile 的镜像构建技术\r\n\r\n> 注意要安装 docker，并启动 docker\r\n\r\n> 注意这种方式并不要求你机器上安装了 GraalVM，会由 SpringBoot 插件利用/paketo-buildpacks/native-image 来生成本地可执行文件，然后打入到容器中\r\n\r\nDocker 镜像名字中不能有大写字母，我们可以配置镜像的名字：\r\n\r\n```\r\n<properties>\r\n  <maven.compiler.source>17</maven.compiler.source>\r\n  <maven.compiler.target>17</maven.compiler.target>\r\n  <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n  <spring-boot.build-image.imageName>springboot3demo</spring-boot.build-image.imageName>\r\n</properties>\r\n```\r\n\r\n然后执行：\r\n\r\n```\r\nmvn -Pnative spring-boot:build-image\r\n```\r\n\r\n来生成 Docker 镜像。\r\n\r\n执行完之后，就能看到 docker 镜像了： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d3c16503e845afa6712459301d6bcf~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n然后就可以运行容器了：\r\n\r\n```\r\ndocker run --rm -p 8080:8080 springboot3demo\r\n```\r\n\r\n顺便记录一下相关教程：\r\n\r\n1.  <https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application.native-build-tools>\r\n1.  <https://www.graalvm.org/22.2/reference-manual/native-image/guides/build-spring-boot-app-into-native-executable/>\r\n"
    },
    {
        "article_id": "7182194367904841765",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeaa3d2b2c614a05a8cb8d576ce12379~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2023年，祝你有个好习惯！",
        "preview": "在总结的时候，我就感觉，好习惯真的非常重要，尤其是我们希望自己能够抽出时间来学习新知识的人。所以必须给大伙好好讲讲。",
        "author": "石云升",
        "view_count": 1605,
        "collect_count": 8,
        "comment_count": 9,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/6c635cfd69c6df18e557000fe4719e2e~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: vuepress\r\n---\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n---\r\n今年如愿的换了产品经理岗位，这是年初就规划好的， 转型还挺顺利的。主要有两个原因，一个是之前做过很多年这个岗位的工作，另一个就是平常喜欢学习心理学、经济学、哲学等等的课程。虽然当初学的时候不知道有用，但实际它已经深入到自己的思维中了。在学习目标上，因为这几年都已经成了学习的习惯，所以如果只是从时间上看的话，也是超出了年初的目标。\r\n\r\n在总结的时候，我就感觉，好习惯真的非常重要，尤其是我们希望自己能够抽出时间来学习新知识的人。所以必须给大伙好好讲讲。\r\n\r\n### 为什么要养一个好习惯？\r\n\r\n很多事情都是需要时间熬出来的。学习新技术，换新的工作岗位都面临着许多新的知识来学习。如果是那种有明确答案的，我们还可以通过跟专家学而快速习得，问题在于，我们面临的大多数问题都是那种没有明确答案的，或者说，这个明确答案需要我们自己给出的。这就需要具有持续学习的能力。\r\n\r\n去年我总结了读过的书，学过的课。今年这两点基本也没落下，跟去年比，应该还超出了。当然，数量不重要，重要是有收获。很多时候，在往前走的过程中你不知道自己收获了什么，但真正用的时候，这些收获就出来了。这也是持续学习的魅力所在。而能做到这点，我总结起来就是两个字”习惯“。\r\n\r\n做事情如果要靠毅力来坚持，那我估计很难。但如果你是靠习惯来坚持某项行为，那其实很容易。就像你每天起床会刷牙，每餐到点了要吃饭一样，你从来不会想着坚持做这些事，而是变成无意识的行为。\r\n\r\n### 怎么样培养一个好习惯？\r\n\r\n万里之行始于足下，好的习惯起始于一个很小的第一步行动。\r\n\r\n不管你要达到的目的是什么，我们首先第一步就是拆解目标，跟拆解工作任务一样，拆解到最小行动单元，然后让自己在**固定场景**下去做即可。\r\n\r\n比如我想每天完成2小时的音频学习的目标。2小时，非工作时间。那么上下班通勤时间够不够？假设通勤时间来回1小时，如果能达到2倍速听，那么这个通勤听音频习惯就能达到我的学习目标。\r\n\r\n拆解完之后，接着就要行动了。但这时候不应该是完成多少时间，而是固定你现在的动作。早上出门戴上耳机，打开音频，开始播放。先从1.25倍音速开始听，一开始如果你觉得收获不到特别多的知识。那就准备少一点音频，重复听。下班也是一样。只要坚持戴上耳机，坚持播放学习的音频。只要一星期，这个习惯就能初步养成，有21天的话，行为就已经完全固定为习惯了。\r\n\r\n听的习惯养成后，再来培养你的专注力，每天到底听了啥？一开始你能听到的知识很少，因为专注力不够。但只要你坚持听，慢慢的你就能听到越来越多。这个时间可长可短。在这个过程中，你可以慢慢提高音频倍数，1.5倍，1.75倍，慢慢的，大部分人都是可以听清楚2倍数的了。这里考验的不是听力敏感程度，而是专注力。我自己的经验是专注力也是可以锻炼的。\r\n\r\n我一年能听几十门课，上下班通勤听音频的习惯功不可没。\r\n\r\n### 怎样改掉一个坏习惯\r\n\r\n改掉一个坏习惯，其实是很难的。更好的做法是，培养一个新的好习惯覆盖坏习惯。只有魔法才能打败魔法。\r\n\r\n比如，我以前中午午休有两个小时，除开吃饭其实可以自由自配的时间有1个半小时，这中间留30分钟睡午觉，也还有一个小时。因为不知道干啥，就养成了刷视频或玩游戏的坏习惯。每次吃完饭就习惯性的打开游戏。一打就1个多小时，午觉时间有时候都会被占用。不玩游戏也是刷抖音，都一样。整个人还感觉特别空虚。我不怪自己，毕竟腾讯、字节早就把我们研究的透透的，我们又怎么斗得过人的天性呢？所以想要改掉这个坏习惯，唯一的办法就是不开始，但想要不开始，就得给自己找事做，用新场景替代玩游戏，刷抖音的场景。\r\n\r\n我自己的做法是，直接把抖音、王者这类游戏给卸载掉，就算我想玩，还要下载，这些都是门槛。其次，我的一些学习类知识服务APP上有很多视频的课程，平常都没有这么好的时间段来看，中午的1小时简直是绝配。所以我就把这1个多小时用来看视频。到点我就打开混沌、得到的视频课。像混沌的案例课，一节课基本是1个多小时，看完后正好还能做个评价。就这样一年我看了上百个商业案例的视频。\r\n\r\n### 注意事项\r\n\r\n1. 时间是有限的，只做那些你想做的。\r\n\r\n不管再怎么规划，人的时间还是有限的。所以，我们特意培养的习惯一定要是对自己特别重要的事情。\r\n\r\n什么事情特别重要呢？对我来说，打造一个能证明自己的作品很重要，所以我的很多习惯都是基于个人能力成长的。我也建议你从工作入手。\r\n\r\n如果你每天到公司还不知道干什么，那么说明进入工作状态的习惯没培养好。正常来说，每个岗位都有其固定的工作内容的，比如我到公司就会先检查下我本天的工作重点，然后开始一个一个解决掉。\r\n\r\n\r\n2. 我们总是喜欢做容易的事情来逃避难的事情。\r\n\r\n这是个不易察觉的坏习惯。我以前也有这毛病。如果有一件事情需要你持续思考，且思考后还不一定能得出什么好解决思路。那么这个问题我就容易逃避。既然想1个小时没效果，那我先做能看到的效果的事情吧\r\n\r\n这不对，职场也好，人生也好，我们一辈子能做的事情很少，时间有限，我们要把时间放在最重要的事情上。反而那些简单的，做与不做都可以的事情应该坚决不做。我突然想到故事：\r\n\r\n“有个人向巴菲特请教，怎样才能把事情做好？巴菲特让他把最重要的25件事情写下来。然后挑选出最重要的5件事情。\r\n\r\n哦，我知道了，你是让我把心思放在这5件事情，然后有时间再去做另外20件事情？\r\n\r\n巴菲特说，我确实是让你把时间精力放在前面5件事情上，但对于另外20件事情，我希望你完全放弃，你要像躲避瘟疫一样躲避它们。它们会在不知不觉中占据你的注意力。”\r\n\r\n思维习惯也有很多不好的，最终会体现在行为上。对于这类坏习惯，我们需要提高警惕。比如，有些公司每天都很忙，但其实每天的工作价值并不高，这种行为的背后，是大家习惯以工作时间来体现价值。每个人都很很卷，但实际上对公司和对自己都没有实际价值。这种坏习惯我认为是需要用一个新的好习惯来替代的。\r\n\r\n---\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559 \\\"https://juejin.cn/post/7172462429929111559\\\")」\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7171748794164805645",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd94d21ac6b4899b06d5e0cabae191b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "一道JS题，让我更深刻的理解了JS的执行机制",
        "preview": "闲逛摸鱼发现一道有趣的题，题目如下，本来是不想拿出来单独写一篇文章的，因为太短了，但是我需要存在感，沸点没人看，所以还是写一篇文章吧；",
        "author": "田八",
        "view_count": 1134,
        "collect_count": 10,
        "comment_count": 7,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6a646066de6c1376525669efb70295e9~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: juejin\r\nhighlight: a11y-dark\r\n---\r\n\r\n\r\n闲逛摸鱼发现一道有趣的题，题目如下：\r\n\r\n```js\r\nlet i = 0;\r\n\r\nfunction x() {\r\n    i++;\r\n    return 10;\r\n}\r\n\r\ni += x();\r\nconsole.log(i) // 10 or 11\r\n```\r\n\r\n这道题我发沸点了，本来是不想拿出来单独写一篇文章的，因为太短了，但是我需要存在感，沸点没人看，所以还是写一篇文章吧；\r\n\r\n原沸点在这里：[https://juejin.cn/pin/7169568535033675784](https://juejin.cn/pin/7169568535033675784)\r\n\r\n## 题目分析\r\n\r\n题目很简单，有效代码只有6行，按照流程分析一下：\r\n\r\n1. 声明变量 i，赋值为 0\r\n2. 声明函数 x，函数内部 i 自增，返回 10\r\n3. i 加等于 x 的返回值\r\n\r\n结束，这个时候 i 的值是 10 还是 11 呢？可以在浏览器中执行一下；\r\n\r\n答案是：**10**\r\n\r\n## 为什么是 10\r\n\r\n`js`的代码执行大家都知道是从上到下，从左到右的（排除异步、回调等），然后还有一些特殊的情况，比如函数声明提升、变量提升等，操作符的优先级等等，这些就不在这里讲了;\r\n\r\n这道题的关键在于函数`x`内部执行了一个`i++`，下面又有一个`i += x()`，这里需要将执行过程拆解一下：\r\n\r\n1. 定义变量 i，赋值为 0\r\n2. 定义函数 x\r\n   1. i 自增\r\n   2. 返回 10\r\n3. i 加等于 x 的返回值\r\n   1. i += x()\r\n   2. i = i + x()\r\n   3. i = 0 + x()\r\n   4. i = 0 + 10\r\n   5. i = 10\r\n\r\n看到这里应该就了解为什么是 10 了，因为`js`的执行机制是从左到右;\r\n\r\n`i += x()`最终会被解释为`i = i + x()`，从左到右执行，是先取出`i`的值，然后再执行`x()`；\r\n\r\n`i`不是一个引用类型，所以是直接拿到`i`的值`0`再执行`x()`，`x()`内部执行的`i++`并不会影响到已经获取到的`i`的值，所以最终的结果是`10`；\r\n\r\n## 怎么让结果是 11\r\n\r\n上面讲到了js的执行是从左到右的，我们只需要`i`的取值在`x()`执行之后就可以了，如下：\r\n\r\n```js\r\nlet i = 0;\r\n\r\nfunction x() {\r\n    i++;\r\n    return 10;\r\n}\r\n\r\ni = x() + i;\r\nconsole.log(i) // 10 or 11\r\n```\r\n\r\n这样就可以了，因为`i`的取值是在`x()`执行之后，所以`i`的值是`1`，最终结果就是`11`了；\r\n\r\n## 解惑\r\n\r\n上面讲的是这道理的整体运作原理和流程，不能我说`i += x()`最终解释的结果就是`i = i + x()`，但是事实就是如此，下面截图来自[MDN 表达式与运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E8%BF%90%E7%AE%97%E7%AC%A6)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a813f485e74b61924c4bfdd858268f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n可以看到最终的解释就是如此，从这里可以看到上面解题的分析是正确的，`+=`运算符可能就是一个语法糖，最后让结果变成`11`又引发我一个问题。\r\n\r\n以前有一道题是这样的，如何让`a === 1 && a === 2 && a === 3`成立，那么我改造一下，成为下面这种形式是否也是可以的呢？代码如下：\r\n\r\n```js\r\nvar a = 1;\r\nvar result = a++ === 1 && a++ === 2 && a++ === 3;\r\nconsole.log(result);\r\n```\r\n\r\n或者现这种形式：\r\n\r\n```js\r\nvar a = 0;\r\nvar result = ++a === 1 && ++a === 2 && ++a === 3;\r\nconsole.log(result);\r\n```\r\n\r\n上面这两种形式，最终`result`的结果都是`true`，感兴趣可以在控制台输出看看，非常有趣。\r\n\r\n## 总结\r\n\r\n确实是一道有趣的题，让我对`js`的执行机制有了更深的理解，用这道题分析简单的分析了一下`js`的执行机制，`js`的执行机制是自上而下，从左往右，内部会将一些语法进行拆解，对于非引用类型取值之后，取值的地方就固定了，不会发生修改。\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***"
    },
    {
        "article_id": "7164928163774988302",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61989183decf425398c36c26de346b3b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "「2022」JavaScript最新高频面试题指南（上）",
        "preview": "大家好，我是CoderBin，本次总结了关于JavaScript的上百道高频面试考点，并且会持续更新，感谢大家的留言点赞收藏 💗 如果文中有不对、疑惑或者错字的地方，欢迎在评论区留言指正🌻",
        "author": "CoderBin",
        "view_count": 5571,
        "collect_count": 234,
        "comment_count": 27,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/880868841b36eb13d36e1a0ab7a52cac~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: jzman\r\nhighlight: atom-one-dark\r\n---\r\n\r\n# 前言\r\n大家好，我是**CoderBin**，本次总结了关于JavaScript的上百道高频面试考点，并且会持续更新，感谢大家的留言点赞收藏 💗\r\n\r\n如果文中有不对、疑惑或者错字的地方，欢迎在评论区留言指正🌻\r\n\r\n>高频面试总结\r\n>\r\n>【1】[「2022」关于Vue的一些高频面试题总结](https://juejin.cn/post/7135251623864958984)\r\n>\r\n>【2】[「2022」CSS最新高频面试题指南](https://juejin.cn/post/7150840051453149197)\r\n>\r\n>【3】[「2022」TypeScript高频面试题汇总](https://juejin.cn/post/7162011064819777567)\r\n>\r\n>【4】[「2022」JavaScript最新高频面试题指南（上）](https://juejin.cn/post/7164928163774988302)\r\n>\r\n>【5】[「2022」JavaScript最新高频面试题指南（下）](https://juejin.cn/post/7166051817560735757)\r\n>\r\n\r\n\r\n# 基础篇\r\n\r\n## 1. 将数组的length设置为0，取第一个元素会返回什么？\r\n设置 `length = 0` 会清空数组，所以会返回 `undefined`\r\n\r\n## 2. e.target和e.currentTarget有什么区别？\r\n当你触发一个元素的事件的时候，该事件从该元素的祖先元素传递下去，此过程为`捕获`，而到达此元素之后，又会向其祖先元素传播上去，此过程为`冒泡`\r\n\r\n我们可以总结出区别：\r\n-   `e.target`：**触发**事件的元素\r\n-   `e.currentTarget`：**绑定**事件的元素\r\n\r\n## 3. 如何获取到一个实例对象的原型对象？\r\n* 从 `构造函数` 获得 原型对象：\r\n```js\r\n构造函数.prototype\r\n```\r\n* 从 `对象实例` 获得 `父级原型对象`：\r\n```js\r\n方法一： 对象实例.__proto__ 【 有兼容性问题，不建议使用】\r\n方法二：Object.getPrototypeOf(对象实例)\r\n```\r\n\r\n## 4. Math.ceil和Math.floor有什么区别？\r\n`Math.ceil()`： 向上取整，函数返回一个大于或等于给定数字的最小整数。\r\n\r\n`Math.floor()`： 向下取整，函数返回一个小于或等于给定数字的最大整数。\r\n\r\n## 5. 浏览器的同源策略是什么？\r\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\r\n\r\n它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，**它们应该只被允许访问来自同一站点的资源**，而不是那些来自其它站点可能怀有恶意的资源。\r\n\r\n*所谓同源是指：**域名**、**协议**、**端口**相同。*\r\n\r\n另外，同源策略又分为以下两种：\r\n\r\n-   **DOM 同源策略**：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。\r\n-   **XMLHttpRequest 同源策略**：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。\r\n\r\n## 6. document.write和innerHTML有什么区别？\r\n**document.write**：是直接写入到页面的内容流，如果在写之前没有调用`document.open`, 浏览器会自动调用open。\r\n* 每次写完关闭之后重新调用该函数，会导致页面被重写。\r\n\r\n**innerHTML**：则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改`document.documentElement.innerElement`。\r\n\r\n-   innerHTML将内容写入某个DOM节点，不会导致页面全部重绘\r\n-   innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的哪一个部分。\r\n\r\n## 7. 使用原生js给一个按钮绑定两个onclick事件\r\n使用事件监听 绑定多个事件\r\n```js\r\n//事件监听 绑定多个事件\r\nvar btn = document.getElementById(\\\"btn\\\");\r\n\r\nbtn.addEventListener(\\\"click\\\",hello1);\r\nbtn.addEventListener(\\\"click\\\",hello2);\r\n\r\nfunction hello1(){\r\n alert(\\\"hello 1\\\");\r\n}\r\nfunction hello2(){\r\n alert(\\\"hello 2\\\");\r\n}\r\n```\r\n\r\n## 8. 什么是类数组对象？\r\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象。\r\n\r\n类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\r\n\r\n常见的类数组转换为数组的方法有以下4种：\r\n```js\r\n//（1）通过 call 调用数组的 slice 方法来实现转换\r\nArray.prototype.slice.call(arrayLike);\r\n\r\n//（2）通过 call 调用数组的 splice 方法来实现转换\r\nArray.prototype.splice.call(arrayLike, 0);\r\n\r\n//（3）通过 apply 调用数组的 concat 方法来实现转换\r\nArray.prototype.concat.apply([], arrayLike);\r\n\r\n//（4）通过 Array.from 方法来实现转换\r\nArray.from(arrayLike);\r\n```\r\n\r\n## 9. typeof NaN 的结果是什么？\r\nNaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\r\n\r\n```js\r\ntypeof NaN; // \\\"number\\\"\r\n```\r\n\r\nNaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。\r\n\r\n## 10. JavaScript中的基本数据类型有哪些？\r\nJavaScript共有七种基本数据类型，分别是 Undefined、Null、Boolean、Number、String、Symbol、BigInt。\r\n\r\n## 11. 如何把十进制的0.2转换成二进制？\r\n进制转换是比较基础的，如果大家熟悉 js 的 API ，那么会首先想到这两个方法：\r\n\r\n-   十进制转二进制：num.toString(2)\r\n-   二进制转十进制：parseInt(num, 2)\r\n\r\n所以答案就是 `(2).toString(2)`\r\n\r\n## 12. map和filter有什么区别？\r\n首先，map和filter函数的参数，是完全相同的\r\n\r\n> array.map(function(currentValue,index,arr), thisValue)\r\n>\r\n> array.filter(function(currentValue,index,arr), thisValue)\r\n\r\n-   currentValue：数组元素；\r\n-   index：索引\r\n-   arr：原数组；\r\n-   thisValue：作为该执行回调时使用，传递给函数，用作 \\\"this\\\" 的值\r\n\r\n但是在用途上，它们是有区别的：\r\n\r\n1.  map方法返回的新数组是原数组的映射，何为映射？就是和原数组的长度相同，数值做相应处理。\r\n2.  filter方法返回的值是过滤原数组后的新数组，和原数组长度不同，数值不变。\r\n\r\n**示例**\r\n```js\r\nlet arr = [\\\"1\\\",\\\"2\\\",\\\"3\\\"];\r\nlet a = arr.map((item,index,a) =>{\r\n    return item + 1\r\n});\r\nconsole.log(a);//[\\\"11\\\", \\\"21\\\", \\\"31\\\"]\r\nlet b = arr.filter((item,index,a) =>{\r\n    return item > 1\r\n})\r\nconsole.log(b);//[\\\"2\\\", \\\"3\\\"]\r\n```\r\n另外，filter可过滤NaN、null、undefined、0\r\n```js\r\nlet arr = [NaN,null,undefined,\\\"0\\\",0,1,2,3];\r\nlet newArr = arr.filter(item => item);\r\nconsole.log(newArr);//[\\\"0\\\", 1, 2, 3]\r\n```\r\n\r\n## 13. argments如何转换成数组？\r\nargments属于类数组对象，转换成数组的方法可以看第八题\r\n\r\n## 14. ['1', '2', '3'].map(parseInt) 的返回值是什么？\r\n首先整个题目考校的是两个函数，和一个字符串转数字的概念\r\n\r\n1. 数组的`map`函数，接受三个参数，当前值，当前索引，当前数组。\r\n2. parseInt接受两个参数，需要转换的字符串，基数（基数取值范围2~36）\r\n    ```js\r\n    var new_array = arr.map(function callback(currentValue, index, array) {  \r\n      // Return element for new_array  \r\n     })  \r\n     parseInt(string, radix)\r\n    ```\r\n4. 根据上面的两个函数的解释，我们可以发现实际上，上面的`['1','2','3'].map(parseInt)` 其实就是等价于下面的代码。\r\n    ```js\r\n    ['1','2','3'].map((item, index) => {  \r\n      return parseInt(item, index)  \r\n    })  \r\n    //  parseInt('1', 0)  1  \r\n    //  parseInt('2', 1)  NaN  \r\n    //  parseInt('3', 2)  NaN\r\n    ```\r\n4. 如果我们需要返回1，2，3需要怎么办？\r\n    ```js\r\n    function parseIntFun(item) {  \r\n      return parseInt(item, 10)  \r\n    }  \r\n    ['1','2','3'].map(parseIntFun)  \r\n    //  parseInt('1', 10)  1  \r\n    //  parseInt('2', 10)  2  \r\n    //  parseInt('3', 10)  3\r\n    ```\r\n综上所述，返回值是 [1,NaN,NaN]\r\n\r\n## 15. 说说你对new.target的理解\r\n`new.target`属性允许你检测函数或构造方法是否是通过new运算符被调用的。\r\n\r\n在通过new运算符被初始化的函数或构造方法中，`new.target`返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是undefined。\r\n\r\n我们可以使用它来检测，一个函数是否是作为构造函数通过new被调用的。\r\n```js\r\nfunction Foo() {\r\n  if (!new.target) {\r\n    throw \\\"Foo() must be called with new\\\";\r\n  }\r\n  console.log(\\\"Foo instantiated with new\\\");\r\n}\r\n\r\nFoo(); // throws \\\"Foo() must be called with new\\\"\r\nnew Foo(); // logs \\\"Foo instantiated with new\\\"\r\n```\r\n\r\n## 16. arguments这种类数组，如何遍历？\r\n1. 使用普通的for循环\r\n```js\r\nfor(var i = 0, len = arrayLike.length; i < len; i++) {\r\n  ……\r\n}\r\n```\r\n3. 转换为真正的数组，再进行遍历（具体看第八题）\r\n\r\n## 17. new Fn() 和 new Fn 有区别吗？\r\n用 `new` 创建构造函数的实例时，通常情况下 `new` 的构造函数后面需要带括号（譬如：`new fn()`）。具体的区别要看在什么场景下\r\n\r\n有些情况下`new`的构造函数后带括号和不带括号的情况一致，譬如：\r\n```js\r\nfunction Fn(){\r\n  this.num = 1;\r\n}\r\nconsole.log(new Fn()); //Fn {num:1}\r\nconsole.log(new Fn);   //Fn {num:1}\r\n```\r\n但有些情况下`new`的构造函数后带括号和不带括号的情况并不一致，譬如：\r\n```js\r\nfunction Fn(){\r\n  this.num = 1;\r\n}\r\nconsole.log(new Fn().num);  // 1\r\nconsole.log(new Fn.num);    // 报错\r\n```\r\n结果分析：\r\n\r\n* 从报错信息来看，`new Fn.num`执行顺序是这样的：先执行`Fn.num`，此时返回结果为`undefined`；后执行`new`，因`new`后面必须跟构造函数，所以`new undefined`会报错。\r\n\r\n* `new Fn().num`相当于`(new Fn()).num`，所以结果返回1。\r\n\r\n从结果来看，`new Fn.num`代码相当于`new (Fn.num)`，`new Fn().num`相当于`(new Fn()).num`。由此看来 `new` 的构造函数后跟括号优先级会提升。\r\n\r\n## 18. Object与Map有什么区别？\r\n-   **Object**\r\n\r\n在ECMAScript中，`Object`是一个特殊的对象。它本身是一个顶级对象，同时还是一个构造函数，可以通过它（如：`new Object()`）来创建一个对象。我们可以认为JavaScript中所有的对象都是`Object`的一个实例，对象可以用字面量的方法`const obj = {}`声明。\r\n\r\n-   **Map**\r\n\r\nMap是Object的一个子类，可以有序保存任意类型的数据，使用键值对去存储，其中键可以存储任意类型，通过`const m = new Map()`即可得到一个map实例。\r\n\r\n* **使用场景**\r\n\r\n1. 如果只需要简单的存储key-value的数据，并且key不需要存储复杂类型的，直接用对象\r\n2. 如果该对象必须通过JSON转换的，则只能用对象，目前暂不支持Map\r\n3. map的阅读性更好，所有操作都是通过api形式去调用，更有编程体验\r\n\r\n## 20. cookie的有效时间设置为0会怎么样？\r\nCookie过期时间设置为0，表示跟随系统默认，其销毁与Session销毁时间相同，即都在浏览器关闭后的特定时间删除。如果我们写程序的时候不设置Cookie的有效时间，那么，Cookie的有效时间等效于会话时间。\r\n\r\n## 21. const声明了数组，还能push元素吗，为什么？\r\n可以\r\n\r\n数组是引用类型，const声明的引用类型变量，不可以变的是变量引用始终指向某个对象，不能指向其他对象，但是所指向的某个对象本身是可以变的\r\n\r\n## 22. 如何检测数组和对象？\r\n* 方法1：通过 ES6 中的 Array.isArray 来识别\r\n```js\r\nconsole.log(Array.isArray([])) // true \r\nconsole.log(Array.isArray({})) // false\r\n```\r\n* 方法2：通过 instanceof 来识别\r\n```js\r\nconsole.log([] instanceof Array) // true \r\nconsole.log({} instanceof Array) // false\r\n```\r\n* 方法3：通过调用 constructor 来识别\r\n```js\r\nconsole.log([].constructor) // [Function: Array] \r\nconsole.log({}.constructor) // [Function: Object]\r\n```\r\n* 方法4：通过 Object.prototype.toString.call 方法来识别\r\n```js\r\nconsole.log(Object.prototype.toString.call([])) // [object Array] \r\nconsole.log(Object.prototype.toString.call({})) // [object Object]\r\n```\r\n\r\n## 23. 请简述 == 的机制\r\n-   `undefined == null`，结果是**true**。且它俩与所有其他值比较的结果都是**false**。\r\n-   `String == Boolean`，需要两个操作数同时转为Number。\r\n-   `String/Boolean == Number`，需要String/Boolean转为Number。\r\n-   `Object == Primitive`，需要Object转为Primitive(具体通过**valueOf**和**toString**方法)。\r\n\r\n## 24. js中的undefined和ReferenceError:xxx is not defined 有什么区别？\r\n-   **undefined**：当一个变量声明后，没有被赋值，那么它就是undefined类型。\r\n-   **ReferenceError**：当尝试引用一个未定义的变量/函数时，就会抛出ReferenceError。\r\n\r\n## 25. Math.ceil()、Math.round()、Math.floor() 三者的区别是什么？\r\n-   Math.ceil() 向上取整\r\n-   Math.round() 四舍五入\r\n-   Math.floor() 向下取整\r\n\r\n## 26. 解释下面代码的意图\r\n```js\r\nArray.prototype.slice.apply(arguments)\r\n```\r\narguments 为类数组对象，并不是真正的数组。\r\n\r\nslice可以实现数组的浅拷贝。\r\n\r\n由于 arguments不是真正的数组，所以没有slice方法，通过apply可以调用数组对象的slice方法，从而将arguments 类数组转换为数组。\r\n\r\n## 27. 直接在script标签写export为什么会报错？\r\n现代浏览器可以支持用 script 标签引入模块或者脚本，如果要引入模块，必须给 script 标签添加 type=“module”。如果引入脚本，则不需要 type。\r\n\r\n## 28. mouseover和mouseenter有什么区别？\r\n当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。\r\n\r\n由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。\r\n\r\n## 29. offsetWidth/offsetHeight，clientWidth/clientHeight与scrollWidth/scrollHeight的区别？\r\n\r\n**offsetWidth/offsetHeight** 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。\r\n\r\noffsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。\r\n\r\noffsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。\r\n\r\nclientTop 返回的是上边框的宽度。\r\n\r\nclientLeft 返回的左边框的宽度。\r\n\r\n**clientWidth/clientHeight** 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。\r\n\r\n**scrollWidth/scrollHeight** 返回值包含 content + padding + 溢出内容的尺寸。\r\n\r\nscrollTop 属性返回的是一个元素的内容垂直滚动的像素数。\r\n\r\nscrollLeft 属性返回的是元素滚动条到元素左边的距离。\r\n\r\n\r\n## 30. toPrecision、toFixed、Math.round 三者的区别\r\n-   toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。\r\n-   toFixed 是对小数点后指定位数取整，从小数点开始数起。\r\n-   Math.round 是将一个数字四舍五入到一个整数。\r\n\r\n## 31. 什么是Polyfill？\r\nPolyfill 指的是用于实现浏览器并不支持的原生 API 的代码。\r\n\r\n比如说 `querySelectorAll` 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。\r\n\r\n## 32. setTimeout为什么不能保证能够及时运行？\r\n>主线程从任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop。\r\n\r\nsetTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。\r\n\r\n浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。\r\n\r\n这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。\r\n\r\n## 33. JS中如何阻止事件冒泡和默认事件？\r\n1. **阻止事件的冒泡方法：event.stopPropagation()**\r\n\r\n不让事件向 document 上蔓延，但是默认事件仍然会执行，当你调用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，\r\n\r\n2. **阻止默认事件的方法：event.preventDefault()**\r\n\r\n比如在a标签的绑定事件上调用此方法，连接则不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；\r\n\r\n3. **return false**\r\n\r\n这个方法比较暴力，它会同时阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了`event.stopPropagation()`和`event.preventDefault()`\r\n\r\n## 34. 谈谈你对事件冒泡和捕获的理解\r\n事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。\r\n\r\n**事件冒泡**：\r\n微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。\r\n\r\n因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是p -> div -> body -> html -> document\r\n\r\n**事件捕获**：\r\n网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\r\n\r\n因此在事件捕获的概念下在p元素上发生click事件的顺序应该是document -> html -> body -> div -> p\r\n\r\n## 35. 什么是事件代理？\r\n事件代理（Event Delegation）也称之为事件委托。是JavaScript中绑定事件的常用技巧。\r\n\r\n顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。\r\n\r\n事件代理的原理是DOM元素的**事件冒泡**。\r\n\r\n一个事件触发后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。\r\n\r\n-   捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；\r\n-   目标阶段：在目标节点上触发，称为“目标阶段”\r\n-   冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层。\r\n\r\n**事件代理的优点：**\r\n* 可以大量节省内存占用，减少事件注册。\r\n* 可以实现当新增子对象时无需再次对其绑定（动态绑定事件）\r\n\r\n## 36. 浏览器为什么要有跨域限制？\r\n因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。\r\n\r\n如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：\r\n\r\n**如果没有 DOM 同源策略**，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：\r\n\r\n做一个假网站，里面用 iframe 嵌套一个银行网站 http://xxxbank.com 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://xxxbank.com  的 dom 节点，就可以拿到用户的账户密码了。\r\n\r\n\r\n**如果没有 XMLHttpRequest 同源策略**，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：\r\n\r\n用户登录了自己的银行页面 http://xxxbank.com，  该网站向用户的 cookie 中添加用户标识。用户浏览了恶意页面 http://evil.com， 执行了页面中的恶意  AJAX 请求代码。http://evil.com  向 http://xxxbank.com 发起 AJAX HTTP 请求，请求会默认把 http://xxxbank.com  对应 cookie 也同时发送过去。银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。而且由于 Ajax 在后台执行，用户无法感知这一过程。\r\n\r\n因此，有了浏览器同源策略，我们才能更安全的上网。\r\n\r\n## 37. XML和JSON有什么区别？\r\n**JSON**（JavaScript Object Notation）是一种轻量级的数据交换格式，它完全独立于语言。它基于JavaScript编程语言，易于理解和生成。\r\n\r\n**xml** 是可扩展标记语言，它定义了一组规则，用于以人类可读和机器可读的格式编码文档。XML的设计目标侧重于Internet上的简单性，通用性和可用性。它是一种文本数据格式，通过Unicode为不同的人类语言提供强大的支持。尽管XML的设计侧重于文档，但该语言被广泛用于表示任意数据结构，例如Web服务中使用的那些数据结构。\r\n\r\n以下是JSON和XML之间的一些区别：\r\n\r\n1、JSON是一种轻量级的数据交换格式；XML是可扩展标记语言。\r\n\r\n2、JSON是基于JavaScript语言；XML源自SGML。\r\n\r\n3、JSON是一种表示对象的方式；XML是一种标记语言，使用标记结构来表示数据项。\r\n\r\n4、JSON不提供对命名空间的任何支持；XML支持名称空间。\r\n\r\n5、JSON支持数组；XML不支持数组。\r\n\r\n6、XML的文件相对难以阅读和解释；JSON的文件非常易于阅读。\r\n\r\n7、JSON不使用结束标记；XML有开始和结束标签。\r\n\r\n8、JSON的安全性较低；XML比JSON更安全。\r\n\r\n## 38. null和undefined有什么区别？\r\n首先 `Undefined` 和 `null` 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\r\n\r\n1. `undefined` 代表的含义是未定义，一般变量声明了但还没有定义的时候会返回 undefined.\r\n\r\n3. `null` 代表的含义是空对象，主要用于赋值给一些可能会返回对象的变量，作为初始化。\r\n\r\n3. 当对`null`类型使用 typeof 进行判断时，会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\r\n4. 当对`undefined`类型使用 typeof 进行判断时，会返回`'undefined'`\r\n\r\n`undefined` 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\r\n\r\n## 39. 为什么JavaScript是单线程？\r\nJavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。\r\n\r\nJavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\r\n\r\n所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。\r\n\r\n为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\r\n\r\n## 40. “严格模式”是什么？\r\n除了正常运行模式，ECMAscript 5添加了第二种运行模式：\\\"严格模式\\\"（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。\r\n\r\n设立\\\"严格模式\\\"的目的，主要有以下几个：\r\n- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; \r\n- 消除代码运行的一些不安全之处，保证代码运行的安全；\r\n- 提高编译器效率，增加运行速度；\r\n- 为未来新版本的Javascript做好铺垫。\r\n\r\n\\\"严格模式\\\"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。\r\n\r\n另一方面，同样的代码，在\\\"严格模式\\\"中，可能会有不一样的运行结果；一些在\\\"正常模式\\\"下可以运行的语句，在\\\"严格模式\\\"下将不能运行。\r\n\r\n## 41. Babel是什么？\r\nBabel 是一个 JavaScript 编译器，同时也是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为**向后兼容**的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\r\n\r\n## 42. npm是什么？\r\nnpm是Node.js的包管理工具，它的诞生也极大的促进了前端的发展，在现代前端开发中都离不开npm的身影。\r\n常见的使用场景有以下几种：\r\n\r\n-   允许用户从NPM服务器下载别人编写的第三方包到本地使用。\r\n-   允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。\r\n-   允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。\r\n\r\n## 42. '1'.toString() 为什么不会报错？\r\n其实在这个语句运行的过程中做了这样几件事情：\r\n\r\n```js\r\nlet s = new Object('1'); \r\ns.toString(); \r\ns = null;\r\n```\r\n\r\n-   第一步: 创建Object类实例。注意为什么不是String？由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。\r\n-   第二步: 调用实例方法。\r\n-   第三步: 执行完方法立即销毁这个实例。\r\n\r\n整个过程体现了 `基本包装类型` 的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。\r\n\r\n## 43. WebSocket如何兼容低版本浏览器？\r\n-   Adobe Flash Socket；\r\n-   ActiveX HTMLFile (IE) ；\r\n-   基于 multipart 编码发送 XHR；\r\n-   基于长轮询的 XHR；\r\n\r\n## 44. 什么是跨域？\r\n跨域本质是浏览器基于**同源策略**的一种安全手段\r\n\r\n同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能\r\n\r\n所谓同源（即指在同一个域）具有以下三个相同点\r\n\r\n-   协议相同（protocol）\r\n-   主机相同（host）\r\n-   端口相同（port）\r\n\r\n反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域\r\n\r\n> 一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。\r\n\r\n## 45. JavaScript字符串常用的方法有哪些？\r\n1. **concat()**：用于将一个或多个字符串拼接成一个新字符串\r\n\r\n2. **slice()、substr()、substring()**：这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。\r\n3. **trim()、trimLeft()、trimRight()**：删除前、后或前后所有空格符，再返回新的字符串\r\n4. **repeat()**：接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果\r\n5. **padEnd()**：复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件\r\n6. **toLowerCase()、 toUpperCase()**：大小写转化\r\n7. **charAt()**：返回给定索引位置的字符，由传给方法的整数参数指定\r\n8. **indexOf()**：从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）\r\n9. **startWith()、includes()**：从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值\r\n10. **split**：把字符串按照指定的分割符，拆分成数组中的每一项\r\n11. **match**：接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组\r\n12. **replace**：接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）\r\n\r\n面试时能说几个是几个\r\n\r\n## 46. ES6 中数组做了哪些新扩展？\r\n点击前往：[# ES6中数组做了哪些新扩展？](https://juejin.cn/post/7157625988275240997)\r\n\r\n## 47. 如何判断当前脚本运行在浏览器还是Node中？\r\n通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。\r\n```js\r\nthis === window ? 'browser' : 'node';\r\n```\r\n\r\n## 48. 说说你对以下几个生命周期事件的理解？\r\n1. DOMContentLoaded\r\n2. load\r\n3. beforeunload\r\n4. unload\r\n\r\n点击前往：[# 浅析HTML页面的生命周期](https://juejin.cn/post/7157995514460373023)\r\n\r\n## 49. JavaScript中的变量提升是什么？\r\n函数在运行的时候，会首先创建执行上下文，然后将执行上下文入栈，然后当此执行上下文处于栈顶时，开始运行执行上下文。\r\n\r\n在创建执行上下文的过程中会做三件事：创建变量对象，创建作用域链，确定 this 指向，其中创建变量对象的过程中，首先会为 arguments 创建一个属性，值为 arguments，然后会扫描 function 函数声明，创建一个同名属性，值为函数的引用，接着会扫描 var 变量声明，创建一个同名属性，值为 undefined，这就是变量提升。\r\n\r\n## 50. null是对象吗？为什么？\r\nnull不是对象。\r\n\r\n虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。\r\n\r\n## 51. JavaScript本地存储的方式有哪些，有什么区别，以及有哪些应用场景？\r\njavaScript本地缓存的方式主要有以下四种：\r\n1. localStorage\r\n2. sessionStorage\r\n3. cookie\r\n4. indexedDB\r\n\r\n它们的区别和应用场景，点击前往：[# 关于JavaScript的本地存储方案](https://juejin.cn/post/7158272097897152525)\r\n\r\n## 52. typeof与instanceof的区别？\r\n首先，`typeof`与`instanceof`都是判断数据类型的方法，区别如下：\r\n\r\n1. `typeof`会返回一个变量的基本类型，`instanceof`返回的是一个布尔值\r\n\r\n3. `instanceof` 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型（除非自定义`instanceof`方法）\r\n4. 而`typeof` 也存在弊端，它虽然可以判断基础数据类型（`null` 除外），但是引用数据类型中，除了`function` 类型以外，其他的也无法判断\r\n\r\n可以看到，上述两种方法都有弊端，并不能满足所有场景的需求\r\n\r\n如果需要通用检测数据类型，可以采用`Object.prototype.toString`，调用该方法，统一返回格式`“[object Xxx]”`的字符串\r\n\r\n\r\n## 52. 谈谈你知道的DOM常见的操作\r\n点击前往：[# 面试官：谈谈你知道的DOM常见的操作](https://juejin.cn/post/7158617915053309988)\r\n\r\n## 53. ==和===的区别，分别在什么情况下使用？\r\n1. **== 相等**：先检查两个操作数数据类型，如果相同， 则进行`===`比较， 如果不同， 会进行一次类型转换， 转换成相同类型后再进行比较。比较规则如下：\r\n-   两个都为简单类型，字符串和布尔值都会转换成数值，再比较\r\n-   简单类型与引用类型比较，对象转化成其原始类型的值，再比较\r\n-   两个都为引用类型，则比较它们是否指向同一个对象\r\n-   `null` 和 `undefined` 相等\r\n-   存在 `NaN` 则返回 `false`\r\n\r\n\r\n2. **=== 全等**：即数据类型与值都必须相等。如果数据类型不一致，则返回false\r\n* `null` 和 `undefined` 比较，会返回`false`\r\n\r\n**使用场景：**\r\n除了在比较对象属性为`null`或者`undefined`的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）\r\n\r\n## 54. JavaScript中的数组有哪些常用的方法？\r\n1. 增加：push、unshift、splice、concat\r\n2. 删除：pop、shift、splice、slice\r\n3. 修改：splice\r\n4. 查找：indexOf、includes、find\r\n5. 排序：reverse、sort\r\n6. 转换：join\r\n7. 迭代：some、every、forEach、filter、map、reduce\r\n\r\n具体用法请前往：[# JavaScript数组常用方法大全](https://juejin.cn/post/7161232365971308575)\r\n\r\n## 55. ES6中对函数做了哪些拓展？\r\n1. 允许为函数的参数设置默认值，并且可以结合解构赋值使用；\r\n2. 函数具有`length`属性，返回没有指定默认值的参数个数；\r\n3. 函数具有`name`属性，返回该函数的函数名；\r\n4. 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错\r\n5. 新增“箭头函数”写法\r\n\r\n拓展：箭头函数写法有以下注意点\r\n-   函数体内的`this`指向外层做作用域\r\n-   不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误\r\n-   不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替\r\n-   不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数\r\n\r\n## 55. ES6中对象新增了哪些拓展？\r\n1. 当对象键名与对应值名相等的时候，可以进行简写 `const obj = { name }`\r\n2. 允许字面量定义对象时，将表达式放在括号内\r\n```js\r\nlet lastWord = 'last word';\r\n\r\nconst a = {\r\n  'first word': 'hello',\r\n  [lastWord]: 'world'\r\n};\r\n\r\na['first word'] // \\\"hello\\\"\r\na[lastWord] // \\\"world\\\"\r\na['last word'] // \\\"world\\\"\r\n```\r\n3. 在解构赋值中，未被读取的可遍历的属性，可以分配到指定的对象上面。注意：拓展运算符形式的解构赋值必须是最后一个参数，否则会报错\r\n```js\r\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\r\nx // 1\r\ny // 2\r\nz // { a: 3, b: 4 }\r\n```\r\n4. **ES6 一共有 5 种方法可以遍历对象的属性。**\r\n    -   `for...in`：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）\r\n\r\n\r\n    -   `Object.keys(obj)`：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名\r\n    -   `Object.getOwnPropertyNames(obj)`：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名\r\n    -   `Object.getOwnPropertySymbols(obj)`：返回一个数组，包含对象自身的所有 Symbol 属性的键名\r\n    -   `Reflect.ownKeys(obj)`：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\r\n  \r\n5. **对象新增的方法：**\r\n    * `Object.is()`：严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是`+0`不等于`-0`，二是`NaN`等于自身\r\n\r\n\r\n    * `Object.assign()`：方法用于对象的合并，将源对象`source`(第二个参数)的所有可枚举属性，复制到目标对象`target`(第一个参数)\r\n    * `Object.getOwnPropertyDescriptors()`：返回指定对象所有自身属性（非继承属性）的描述对象\r\n    * `Object.setPrototypeOf()`：方法用来设置一个对象的原型对象\r\n    * `Object.getPrototypeOf()`: 用于读取一个对象的原型对象\r\n    * `Object.keys()`: 返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组\r\n    * `Object.values()`: 返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组\r\n    * `Object.entries()`: 返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组\r\n    * `Object.fromEntries()`: 用于将一个键值对数组转为对象\r\n\r\n对象的方法具体使用可点击前往 [MDN-Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)\r\n\r\n## 56. var、let、const三者的区别？\r\n**1. var特点**\r\n-   声明作用域（函数作用域）\r\n-   变量提升\r\n-   可重复声明同个变量\r\n-   全局声明的变量会成为全局对象的属性\r\n\r\n**2. let特点**\r\n-   块级作用域\r\n-   不存在变量提升\r\n-   不允许重复声明\r\n-   防止变量泄露（for循环的迭代变量）\r\n\r\n**3. const特点**\r\n-   声明变量时，同时初始化\r\n-   块级作用域\r\n-   暂时性死区\r\n-   不可修改\r\n-   不允许重复声明\r\n-   不能用来声明迭代变量\r\n\r\n详细解析可点击前往：[# 面试官：你说说var、let、const三者的区别](https://juejin.cn/post/7153642896434921509)\r\n\r\n\r\n## 57. script标签放在header里和放在body底部有什么区别？\r\n1、浏览器是从上到下解析HTML的。  \r\n2、放在head里的js代码，会在body解析之前被解析；放在body底部的js代码，会在整个页面加载完成之后解析。\r\n\r\n* head 部分中的脚本: 需调用才执行的脚本或事件触发执行的脚本放在HTML的head部分中。当你把脚本放在head部分中时，可以保证脚本在任何调用之前被加载，\r\n\r\n* body 部分中的脚本: 当页面被加载时立即执行的脚本放在HTML的body部分。放在body部分的脚本通常被用来生成页面的内容。\r\n\r\n\r\n**脚本会阻塞页面的渲染**，所以推荐将其放在 body 底部，因为当解析到 script 标签时，通常页面的大部分内容都已经渲染完成，让用户马上能看到一个非空白页面。\r\n\r\n## 58. 什么是同步和异步？\r\n同步：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。\r\n\r\n异步：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理，这样就可以提高执行的效率了，即异步是我们发出的一个请求，该请求会在后台自动发出并获取数据，然后对数据进行处理，在此过程中，我们可以继续做其他操作，不管它怎么发出请求，不关心它怎么处理数据。\r\n\r\n## 59. 遍历数组的方法都有哪些？\r\nfor循环方法：`for`、`for...of`、`for...in`\r\n\r\n内置方法：some、every、forEach、filter、map、reduce\r\n\r\n具体用法请前往：[# JavaScript数组常用方法大全](#)\r\n\r\n## 60. 简单说说对web worker的了解\r\nWeb Workers 是在HTML5中出现的，它可以使一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞。\r\n\r\n它的作用就是给JS创造多线程运行环境，允许主线程创建`worker`线程，分配任务给后者，主线程运行的同时`worker`线程也在运行，相互不干扰，在`worker`线程运行结束后把结果返回给主线程。这样做的好处是主线程可以把计算密集型或高延迟的任务交给`worker`线程执行，这样主线程就会变得轻松，不会被阻塞或拖慢。这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。\r\n\r\n## 61. js实现的动画和CSS动画分别有什么优缺点？\r\n**1. JS 动画**\r\n\r\n**优点**\r\n\r\n-   控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。\r\n-   动画效果比`css3`动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有`js`动画才能完成\r\n-   `CSS3`有兼容性问题，而`JS`大多时候没有兼容性问题\r\n\r\n**缺点**\r\n\r\n-   代码的复杂度高于`CSS`动画\r\n-   `JavaScript`在浏览器的主线程中运行，而主线程中还有其它需要运行的`JavaScript`脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况\r\n\r\n**2. CSS动画**\r\n\r\n**优点**\r\n\r\n-   浏览器可以对动画进行优化\r\n-   代码相对简单,性能调优方向固定\r\n-   对于帧速表现不好的低版本浏览器，`CSS3`可以做到自然降级，而`JS`则需要撰写额外代码\r\n\r\n**缺点**\r\n\r\n-   运行过程控制较弱,无法附加事件绑定回调函数\r\n-   代码冗长，想用`CSS`实现稍微复杂一点动画,最后`CSS`代码都会变得非常笨重\r\n\r\n## 62. 前端实现动画有哪些方式？\r\n前端常用的动画实现方式有以下种：\r\n\r\n1.  css3的`transition` 属性\r\n2.  css3的`animation` 属性\r\n3.  原生JS动画\r\n4.  使用`canvas`绘制动画\r\n5.  SVG动画\r\n6.  Jquery的`animate`函数\r\n7.  使用gif图片\r\n\r\n-   **代码复杂度方面**，简单动画：`css`代码实现会简单一些，`js`复杂一些。 复杂动画的话：`css`代码就会变得冗长，`js`实现起来更优。\r\n-   **动画运行时，对动画的控制程度上**， `js` 比较灵活，能控制动画暂停，取消，终止等，`css`动画不能添加事件，只能设置固定节点进行什么样的过渡动画。\r\n-   **兼容方面**， `css` 有浏览器兼容问题，`js`大多情况下是没有的。\r\n-   **性能方面**， `css`动画相对于优一些，`css` 动画通过`GUI`解析，`js`动画需要经过`js`引擎代码解析，然后再进行 `GUI` 解析渲染。\r\n\r\n## 63. 说一说Cookie、SessionStorage、LocalStorage三者的区别？\r\n\r\n首先，Cookie、SessionStorage、 LocalStorage都是浏览器的本地存储。它们之前的区别可以从以下几个方面来说：\r\n\r\n1.  **写入方式**：cookie是由服务器端写入的，而SessionStorage、 LocalStorage都是由前端写入的\r\n\r\n2.  **生命周期**：cookie的生命周期是由服务器端在写入的时候就设置好的，LocalStorage是写入就一直存在，除非手动清除，SessionStorage是页面关闭的时候就会自动清除。\r\n3.  **存储大小**：cookie的存储空间比较小大概4KB，SessionStorage、 LocalStorage存储空间比较大，大概5M。\r\n4.  **数据共享**：三者数据共享都遵循同源原则，SessionStorage还限制必须是同一个页面。\r\n5.  **发送请求是否携带**：在前端给后端发送请求的时候会自动携带Cookie中的数据，但是SessionStorage、 LocalStorage不会。\r\n6.  **应用场景**：Cookie一般用于存储登录验证信息SessionID或者token，LocalStorage常用于存储不易变动的数据，减轻服务器的压力，SessionStorage可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能。\r\n\r\n**扩展**：从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比storage更好用的。其他情况下，尽量使用storage。\r\n\r\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了。\r\n\r\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来跨页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\r\n\r\n## 64. js中数组是如何在内存中存储的？\r\n数组不是以一组连续的区域存储在内存中，而是一种哈希映射的形式。它可以通过多种数据结构来实现，其中一种是链表。\r\n\r\njs分为基本类型和引用类型：\r\n\r\n-   基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，通过按值访问；\r\n-   引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用\r\n\r\n## 65. 如何检测浏览器版本？\r\n检测浏览器版本一共有两种方式：\r\n\r\n1. 一种是检测 `window.navigator.userAgent` 的值，但这种方式很不可靠，因为 `userAgent` 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。\r\n\r\n2. 第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 `ActiveXObject`。\r\n\r\n## 66. JavaScript中的错误有哪些类型？\r\n1. **Error**：`Error`是最基本的错误类型，其他的错误类型都继承自该类型。因此，所有错误的类型共享了一组相同的属性。 这个类型的错误很少见。一般使用开发人员自定义抛出的错误。\r\n\r\n2. **EvalError**：这个错误会在使用`eval()`函数发生异常时候抛出。\r\n3. **RangeError**：在数值超出相应范围时触发。\r\n4. **ReferenceError**：一般出现在变量找不到的情况时触发。\r\n5. **SyntaxError**：当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError。\r\n6. **TypeError**：这个错误在JavaScript中是经常遇到的，不管是初学者还是老手。在变量中保存着以外的类型时，或者在访问不存在的方法时。都会导致这种错误。但是归根结底还是由于在执行特定于类型的操作时，变量的类型并不符合要求所致。\r\n7. **URIError**：在使用encodeURI或者decodeURI因为URL格式不正确时，就会导致URIError错误。这种错误也很少见。\r\n\r\n## 67. ajax、fetch、axios有什么区别？\r\n**（1） AJAX**\r\n\r\n`Ajax` 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\r\n\r\n-   本身是针对MVC编程，不符合前端MVVM的浪潮\r\n-   基于原生XHR开发，XHR本身的架构不清晰\r\n-   不符合关注分离（Separation of Concerns）的原则\r\n-   配置和调用方式非常混乱，而且基于事件的异步模型不友好。\r\n\r\n**（2）Fetch**\r\n\r\n`fetch`号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。\r\n\r\nfetch的优点：\r\n\r\n-   语法简洁，更加语义化\r\n-   基于标准 Promise 实现，支持 async/await\r\n-   更加底层，提供的API丰富（request, response）\r\n-   脱离了XHR，是ES规范里新的实现方式\r\n\r\nfetch的缺点：\r\n\r\n-   fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\r\n-   fetch默认不会带cookie，需要添加配置项：fetch(url, {credentials: 'include'})\r\n-   fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\r\n-   fetch没有办法原生监测请求的进度，而XHR可以\r\n\r\n**（3）Axios**\r\n\r\n`Axios` 是一种基于Promise封装的HTTP客户端，其特点如下：\r\n\r\n-   浏览器端发起XMLHttpRequests请求\r\n-   node端发起http请求\r\n-   支持Promise API\r\n-   监听请求和返回\r\n-   对请求和返回进行转化\r\n-   取消请求\r\n-   自动转换json数据\r\n-   客户端支持抵御XSRF攻击\r\n\r\n## 68. for...in 和 for...of 有什么区别？\r\n`for…of` 是ES6新增的遍历方式，允许遍历一个含有`iterator`接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的`for…in`的区别如下：\r\n\r\n-   `for…of` 遍历获取的是对象的键值，for…in 获取的是对象的键名；\r\n-   `for…in` 会遍历对象的整个原型链，性能非常差不推荐使用，而 for…of 只遍历当前对象不会遍历原型链；\r\n-   对于数组的遍历，`for…in` 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，`for…of` 只返回数组的下标对应的属性值；\r\n\r\n总结：`for...in`循环主要是为了遍历对象而生，不适用于遍历数组；`for...of` 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\r\n\r\n## 69. 如果new一个箭头函数会怎么样？\r\n会直接报错。箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\r\n\r\n**new操作符的实现步骤如下：**\r\n\r\n1、创建一个空的简单JavaScript对象（即{}）；\r\n\r\n2、为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；\r\n\r\n3、将步骤1新创建的对象作为this的上下文 ；\r\n\r\n4、如果该函数没有返回对象，则返回this。\r\n\r\n**所以，上面的第二、三步，箭头函数都是没有办法执行的。**\r\n\r\n## 70. 检测数据类型的方式有哪些？\r\n**1. typeof**：其中数组、对象、null都会被判断为object，其他判断都正确。\r\n```js\r\nconsole.log(typeof 1);              // number\r\nconsole.log(typeof true);            // boolean\r\nconsole.log(typeof 'CoderBin');       // string\r\nconsole.log(typeof [1,2]);           // object    \r\nconsole.log(typeof function(){});     // function\r\nconsole.log(typeof {});             // object\r\nconsole.log(typeof undefined);       // undefined\r\nconsole.log(typeof null);           // object\r\n```\r\n**2. instanceof**：可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。\r\n```js\r\nconsole.log(1 instanceof Number);               // false\r\nconsole.log(true instanceof Boolean);            // false \r\nconsole.log('CoderBin' instanceof String);        // false \r\nconsole.log([1,2,3] instanceof Array);           // true\r\nconsole.log(function(){} instanceof Function);    // true\r\nconsole.log({} instanceof Object);              // true\r\n```\r\n可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\r\n\r\n**3. constructor** \r\n```js\r\nconsole.log((1).constructor === Number); // true\r\nconsole.log((true).constructor === Boolean); // true\r\nconsole.log(('CoderBin').constructor === String); // true\r\nconsole.log(([1,2]).constructor === Array); // true\r\nconsole.log((function() {}).constructor === Function); // true\r\nconsole.log(({}).constructor === Object); // true\r\n```\r\n**4. Object.prototype.toString.call()**： 使用 Object 对象的原型方法 `toString` 来判断数据类型：\r\n```js\r\nvar test = Object.prototype.toString;\r\nconsole.log(test.call(1));\r\nconsole.log(test.call(true));\r\nconsole.log(test.call('CoderBin'));\r\nconsole.log(test.call([1,2,3]));\r\nconsole.log(test.call(function(){}));\r\nconsole.log(test.call({}));\r\nconsole.log(test.call(undefined));\r\nconsole.log(test.call(null));\r\n\r\n// 结果如下：\r\n// [object Number]\r\n// [object Boolean]\r\n// [object String]\r\n// [object Array]\r\n// [object Function]\r\n// [object Object]\r\n// [object Undefined]\r\n// [object Null]\r\n```\r\n## 71. Object.is() 与比较操作符\\\"===\\\"、\\\"==\\\"的区别？\r\n-   使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\r\n\r\n-   使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\r\n-   使用 `Object.is` 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。\r\n\r\n## 72. isNaN 和 Number.isNaN 函数有什么区别？\r\n-   函数 `isNaN` 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 `NaN` 的判断。\r\n\r\n-   函数 `Number.isNaN` 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。\r\n\r\n**总结**：\r\n和全局函数 `isNaN()` 相比，`Number.isNaN()` 不会自行将参数转换成数字，只有在参数是值为 NaN 的数字时，才会返回 true。\r\n\r\n`Number.isNaN()` 方法确定传递的值是否为NaN，并且检查其类型是否为Number。它是原来的全局`isNaN()` 的更稳妥的版本。\r\n\r\n## 73. 谈谈你对浏览器中进程和线程的理解\r\n**进程和线程（一个进程中可以有多个线程）**\r\n\r\n* 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\r\n\r\n* 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\r\n\r\n进程之间互相独立。线程是不能单独存在的，它是由进程来启动和管理的。\r\n\r\n**进程和线程的关系**\r\n\r\n* 进程中任意一个线程执行出错，都会导致整个进程的崩溃\r\n* 线程之间共享进程中的数据\r\n* 当一个进程关闭之后，操作系统会回收进程所占用的内存\r\n* 进程之间的内容相互隔离\r\n* 一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，就需要使用用于进程间通信（IPC）的机制\r\n\r\n**浏览器是多进程的**\r\n\r\n一般每打开一个Tab页，就相当于创建了一个独立的浏览器进程。但有时会进行进程合并。\r\n\r\n## 74. 什么是尾调用优化和尾递归？\r\n点击前往：[# 关于 \\\"尾调用优化\\\" 的那些事儿 👏](https://juejin.cn/post/7147576731736473630)\r\n\r\n## 75. JS代码中的\\\"use strict\\\"是什么意思？\r\n`use strict` 是一种ECMAscript5添加的(严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。\r\n\r\n设立\\\"严格模式\\\"的目的，主要有以下几个:\r\n\r\n-   消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全;\r\n-   提高编译器效率，增加运行速度;\r\n-   为未来新版本的Javascript 做好铺垫。\r\n\r\n区别:\r\n\r\n-   禁止使用with语句。\r\n-   禁止this关键字指向全局对象。\r\n-   对象不能有重名的属性。\r\n\r\n## 76. Service worker是什么？\r\n`Srvice worker`是 [PWA](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps) 的重要组成部分，W3C 组织早在 2014 年 5 月就提出过 Service Worker 这样的一个 HTML5 API，主要用来做持久的离线缓存，也是Web Worker的升级版。\r\n\r\n`Service worker` (简称 SW) 是一个注册在指定源和路径下的事件驱动 Worker。它采用 JavaScript 控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。\r\n\r\n## 77. 如何判断一个对象是不是空对象？\r\n1. 使用 `Object.keys()` 将对象属性名组成数组，如果 `length` 为 `0` 表示空对象\r\n2. 使用 `JSON.stringify()` 将对象转成字符串，如果为 `{}` 则表示空对象\r\n```js\r\n// 方法 1 \r\nObject.keys(obj).length === 0 \r\n\r\n// 方法 2 \r\nJSON.stringify(obj) === '{}'\r\n```\r\n\r\n## 78. JSBridge是什么？\r\n`JSBridge` 是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。\r\n\r\n实际上，JSBridge 就像其名称中的Bridge的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间消息通信的通道，而且这个通信的通道是双向的。\r\n>* 双向通信的通道: JS 向 Native 发送消息: 调用相关功能、通知 Native 当前 JS 的相关状态等。\r\n>* Native 向 JS 发送消息: 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。\r\n\r\n## 79. [] == ![] 结果是什么？\r\n结果为 `true`\r\n\r\n在`==`(双等于) 中，左右两边都需要转换为数字然后进行比较。\r\n\r\n* `[]`转换为数字为`0`。\r\n\r\n* `![]` 首先是转换为布尔值，由于`[]`作为一个引用类型转换为布尔值为`true`, 因此`![]`为`false`，进而再转换成数字，变为`0`。 `0 == 0`， 结果为 `true`\r\n\r\n## 80. Object.is 和 === 有什么区别？\r\n`Object.is()` 在 `===`(严格等于)的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。\r\n\r\n## 81. instanceof 能否判断基本数据类型？\r\n能，但是需要自定义`instanceof`行为，例如：\r\n```js\r\nclass PrimitiveString {\r\n  static [Symbol.hasInstance](x) {\r\n    return typeof x === 'string'\r\n  }\r\n}\r\nconsole.log('CoderBin' instanceof PrimitiveString) // true\r\n```\r\n这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。\r\n\r\n## 82. typeof 能否正确判断类型？\r\n* 对于原始类型来说，除了判断 `null` 类型结果是`'object'`，其他的可以调用 `typeof` 方法显示正确的类型。\r\n\r\n* 但对于引用数据类型，除了函数之外，都会显示`'object'`。\r\n* 因此采用`typeof`判断对象数据类型是不合适的，采用`instanceof`会更好，`instanceof`的原理是基于原型链的查询，只要处于原型链中，判断永远为`true`\r\n\r\n## 83. 什么是BigInt?\r\n`BigInt` 是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对 大整数 执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。\r\n\r\n## 84. 0.1+0.2为什么不等于0.3?\r\n0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成 0.30000000000000004。\r\n\r\n## 85. 什么是防抖节流函数，并且说说它们的实现思路\r\n点击前往学习：[# 深入浅出防抖与节流函数](https://juejin.cn/post/7155657224549826597)\r\n\r\n## 86. 说说JavaScript中常见的几种内存泄漏的情况\r\n1. 以外的全局变量\r\n```js\r\nfunction foo(arg) {\r\n  bar = \\\"this is a hidden global variable\\\";\r\n}\r\n```\r\n没有使用声明关键字的变量会被当成全局变量\r\n\r\n2. 另一种意外的全局变量可能由 `this` 创建：\r\n```js\r\nfunction foo() {\r\n  this.variable = \\\"potential accidental global\\\";\r\n}\r\n// foo 调用自己，this 指向了全局对象（window）\r\nfoo();\r\n```\r\n上述使用严格模式，可以避免意外的全局变量\r\n\r\n3. 定时器也常会造成内存泄露\r\n```js\r\nlet someResource = getData()\r\nsetInterval(function() {\r\n  let node = document.getElementById('Node')\r\n  if (node) {\r\n    // 处理 node 和 someResource\r\n    node.innerHTML = JSON.stringify(someResource)\r\n  }\r\n}, 1000)\r\n```\r\n如果`id`为Node的元素从`DOM`中移除，该定时器仍会存在，同时，因为回调函数中包含对`someResource`的引用，定时器外面的`someResource`也不会被释放\r\n\r\n包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放\r\n```js\r\nfunction bindEvent() {\r\n  var obj = document.createElement('XXX')\r\n  var unused = function() {\r\n    console.log(obj, '闭包内引用obj obj不会被释放')\r\n  }\r\n  obj = null // 解决方法\r\n}\r\n```\r\n4. 没有清理对`DOM`元素的引用同样造成内存泄露\r\n```js\r\nconst refA = document.getElementById('refA')\r\ndocument.body.removeChild(refA) // dom删除了\r\nconsole.log(refA, 'refA') // 但是还存在引用能console出整个div 没有被回收\r\nrefA = null\r\nconsole.log(refA, 'refA') // 解除引用\r\n```\r\n包括使用事件监听`addEventListener`监听的时候，在不监听的情况下使用`removeEventListener`取消对事件监听\r\n\r\n## 87. 说说你对BOM的理解，以及常见的BOM对象有哪些？\r\n`BOM` (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象\r\n\r\n其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率\r\n\r\n**常见的BOM对象有：**\r\n\r\n1. `window`是BOM的核心对象，它表示浏览器的一个实例。在浏览器中，`window`对象有双重角色，即是浏览器窗口的一个接口，又是全局对象。因此所有在全局作用域中声明的变量、函数都会变成`window`对象的属性和方法\r\n\r\n2. `location`对象用于获取或设置窗体的 URL，并且可以用于解析 URL。\r\n3. `navigator` 对象主要用来获取浏览器的属性，区分浏览器类型。\r\n4. `screen`对象保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度\r\n5. `history`对象主要用来操作浏览器`URL`的历史记录，可以通过参数向前，向后，或者向指定`URL`跳转\r\n\r\n## 88. 正则表达式是什么，有哪些应用场景？\r\n正则表达式是一种用来匹配字符串的强有力的方法\r\n\r\n它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的\r\n\r\n在 `JavaScript`中，正则表达式也是对象，构建正则表达式有两种方式：\r\n1. 字面量创建，其由包含在斜杠之间的模式组成\r\n```js\r\nconst re = /\\\\d+/g;\r\n```\r\n2. 调用`RegExp`对象的构造函数\r\n```js\r\nconst re = new RegExp(\\\"\\\\\\\\d+\\\",\\\"g\\\");\r\n\r\nconst rul = \\\"\\\\\\\\d+\\\"\r\nconst re1 = new RegExp(rul,\\\"g\\\");\r\n```\r\n使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符需要使用`\\\\`进行转义\r\n\r\n**使用场景**： 验证手机号码，邮箱，用户名等等需要一定规则的字符就可以使用正则表达式去校验\r\n\r\n## 89. new操作符是什么，具体干了什么？\r\n在`JavaScript`中，`new`操作符用于创建一个给定构造函数的实例对象\r\n\r\n`new`关键字主要做了以下的工作：\r\n\r\n-   创建一个新的对象`obj`\r\n-   将对象与构建函数通过原型链连接起来\r\n-   将构建函数中的`this`绑定到新建的对象`obj`上\r\n-   根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理\r\n\r\n简单实现：\r\n```js\r\n// 实现new操作符\r\nfunction mynew(Func, ...args) {\r\n  // 1.创建一个新对象\r\n  const obj = {}\r\n  // 2.新对象原型指向构造函数原型对象\r\n  obj.__proto__ = Func.prototype\r\n  // 3.将构建函数的this指向新对象\r\n  let result = Func.apply(obj, args)\r\n  // 4.根据返回值判断\r\n  return result instanceof Object ? result : obj\r\n}\r\n```\r\n测试\r\n```js\r\nfunction Person(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(this.name)\r\n}\r\n\r\nlet p = mynew(Person, \\\"CoderBin\\\", 18)\r\nconsole.log(p) // Person {name: \\\"CoderBin\\\", age: 18}\r\np.say() // CoderBin\r\n```\r\n\r\n## 90. 谈谈你对this对象的理解\r\n函数的 `this` 关键字在 `JavaScript` 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别\r\n\r\n在绝大多数情况下，函数的调用方式决定了 `this` 的值（运行时绑定）\r\n\r\n`this` 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象\r\n\r\n点击前往学习：[# 一篇文章带你搞懂 this 的四个绑定规则 ✍](https://juejin.cn/post/7132032582832635934)\r\n\r\n## 91. 什么是作用域链？\r\n首先先来了解什么是作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合\r\n\r\n换句话说，作用域决定了代码区块中变量和其他资源的可见性\r\n我们一般将作用域分成：\r\n\r\n-   **全局作用域**：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问\r\n\r\n-   **函数作用域**：函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问\r\n-   **块级作用域**：ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量\r\n\r\n**什么是作用域链**：当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域\r\n\r\n如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错\r\n\r\n## 92. 谈谈JavaScript中的类型转换机制\r\n点击前往学习：[# 面试官：你说说JavaScript中类型的转换机制](https://juejin.cn/post/7156779680756924452)\r\n\r\n## 93. ES6中新增的Set、Map两种数据结构怎么理解？\r\n点击前往学习：[# 面试官：说说你对Set、Map的理解](https://juejin.cn/post/7156779680756924452)\r\n\r\n## 94. 说说对Websocket的了解\r\n\r\nHTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。\r\n\r\n**优点**：说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。\r\n\r\n-   支持双向通信，实时性更强。\r\n-   更好的二进制支持。\r\n-   较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。\r\n-   支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\r\n\r\n## 95. forEach有中断效果吗？如何中断forEach循环？\r\n在`forEach`中用`return`不会返回，函数会继续执行。\r\n**中断方法**\r\n-   使用`try`监视代码块，在需要中断的地方抛出异常。\r\n\r\n-   官方推荐方法（替换方法）：用`every`和`some`替代`forEach`函数。\r\n\r\n    -   `every` 在碰到`return false`的时候，终止循环。\r\n    -   `some` 在碰到`return true`的时候，终止循环。\r\n\r\n## 96. call、bind、apply三者的区别，如何实现？\r\n`call`、`apply`、`bind` 作用是改变函数执行时的上下文，简而言之就是改变函数运行时的`this`指向\r\n1. `call`方法的第一个参数是`this`的指向，后面传入的是一个**参数列表**。改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次\r\n\r\n2. `bind`方法和call很相似，第一参数是`this`的指向，后面传入的也是一个**参数列表**(但是这个参数列表可以分多次传入)。改变`this`指向后不会立即执行，而是返回一个永久改变`this`指向的函数\r\n\r\n3. `apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以**数组**的形式传入。改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次\r\n\r\n**三者区别总结：**\r\n-   三者都可以改变函数的`this`对象指向\r\n-   三者第一个参数都是`this`要指向的对象，如果没有这个参数或参数为`undefined`或`null`，则默认指向全局`window`\r\n-   三者都可以传参，但是`apply`是数组，而`call`是参数列表，且`apply`和`call`是一次性传入参数，而`bind`可以分为多次传入\r\n-   `bind`是返回绑定this之后的函数，`apply`、`call` 则是立即执行\r\n\r\n**如何实现，请点击前往：**\r\n\r\n[# 手写 call 方法 超级详细 ⚡⚡⚡](https://juejin.cn/post/7128028573520101390)\r\n\r\n[# 手写 bind 方法，超级详细 ⚡⚡⚡](https://juejin.cn/post/7128553917348053028)\r\n\r\n[# 手写 apply 方法 超级详细 ⚡⚡⚡](https://juejin.cn/post/7128213514006560775)\r\n\r\n## 97. JavaScript中如何实现继承？\r\nJavaScript实现继承有六种方法：原型链继承、盗用构造函数继承、组合继承、原型式继承、寄生式继承、寄生式组合继承\r\n\r\n点击前往学习：[# 面试官：你说说 js 中实现继承有哪几种方法？](https://juejin.cn/post/7144903568649093156)\r\n\r\n## 98. JavaScript中的原型，原型链分别是什么？\r\n**原型**：\r\nJavaScript` 常被描述为一种基于原型的语言——每个对象拥有一个原型对象\r\n\r\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾\r\n\r\n准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的`prototype`属性上，而非实例对象本身\r\n\r\n**原型链**：\r\n原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法\r\n\r\n在对象实例和它的构造器之间建立一个链接（它是`__proto__`属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法\r\n\r\n## 99. 如何判断页面是通过PC端还是移动端访问？\r\n1. 使用 `navigator.userAgent`，只要里面包含`mobi`、`android`、`iphone`等关键字，就可以认定是移动设备。这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器。\r\n\r\n2. 使用 `window.screen.width`，如果屏幕宽度小于500像素，就认为是手机。这个方法的缺点在于，如果手机横屏使用，就识别不了。\r\n3. 使用 `window.orientation`，侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。`window.orientation`属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回`undefined`。（注意：iPhone 的 Safari 浏览器不支持该属性。）\r\n4. 使用 `ontouchstart`事件，手机浏览器的 DOM 元素可以通过`ontouchstart`属性，为`touch`事件指定监听函数。桌面设备没有这个属性。\r\n5. 使用第三方的工具包，推荐`react-device-detect`，它支持多种粒度的设备侦测。\r\n    ```js\r\n    import {isMobile} from 'react-device-detect'; \r\n    if (isMobile) { \r\n      // 当前设备是移动设备 \r\n    }\r\n    ```\r\n## 100. 如何让Promise.all在抛出异常后依然有效？\r\n1. 在`promise.all`队列中，使用map每一个过滤每一个promise任务，其中任意一个报错后，return一个返回值，确保promise能正常执行走到`.then`中。\r\n```js\r\nconst p1 = new Promise((resolve, reject) => {\r\n  resolve('p1');\r\n});\r\nconst p2 = new Promise((resolve, reject) => {\r\n  resolve('p2');\r\n});\r\nconst p3 = new Promise((resolve, reject) => {\r\n  reject('p3');\r\n});\r\n\r\nPromise.all([p1, p2, p3].map(p => p.catch(e => `出错后返回的值：${e}` )))\r\n.then(values => {\r\n  console.log(values);\r\n}).catch(err => {\r\n  console.log(err);\r\n})\r\n```\r\n2. 使用 `Promise.allSettled` 替代 `Promise.all()`。\r\n\r\n> `Promise.allSettled()`方法返回一个promise，该promise在所有给定的promise已被解析或被拒绝后解析，并且每个对象都描述每个promise的结果。\r\n\r\n## 101. Promist.catch后面的.then还会执行吗？\r\n答案：**.then会继续执行**\r\n\r\n虽然**Promise**是开发过程中使用非常频繁的一个技术点，但是它的一些细节可能很多人都没有去关注过。我们都知道`.then`, `.catch`, `.finally`都可以链式调用，其本质上是因为返回了一个新的**Promise**实例。\r\n\r\ncatch的语法形式如下：\r\n```js\r\np.catch(onRejected);\r\n```\r\n**`.catch`只会处理`rejected`的情况，并且也会返回一个新的`Promise`实例。**\r\n\r\n`.catch(onRejected)`与`then(undefined, onRejected)`在表现上是一致的。\r\n\r\n事实上，catch(onRejected)从内部调用了then(undefined, onRejected)。\r\n\r\n-   如果`.catch(onRejected)`的`onRejected`回调中返回了一个状态为`rejected`的`Promise`实例，那么`.catch`返回的`Promise`实例的状态也将变成`rejected`。\r\n-   如果`.catch(onRejected)`的`onRejected`回调中抛出了异常，那么`.catch`返回的`Promise`实例的状态也将变成`rejected`。\r\n-   其他情况下，`.catch`返回的`Promise`实例的状态将是`fulfilled`。\r\n\r\n## 102. es5中的类和es6中的class有什么区别？\r\n在es5中主要是通过构造函数方式和原型方式来定义一个类，在es6中我们可以通过class来定义类。它们的区别有：\r\n\r\n1. es6的class类必须new调用，不能直接执行。\r\n\r\n2. class类不存在变量提升\r\n3. class类无法遍历它实例原型链上的属性和方法\r\n4. es6为new命令引入了一个`new.target`属性，它会返回new命令作用于的那个构造函数。如果不是通过new调用或`Reflect.construct()`调用的，`new.target`会返回undefined\r\n5. class类有static静态方法\r\n\r\n## 103. 简单说说前端路由？\r\n**概念**：前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。\r\n\r\n**使用场景**：在单页面应用，大部分页面结构不变，只改变部分内容的使用\r\n\r\n**优缺点**：\r\n* 优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户\r\n* 缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置\r\n\r\n**实现方式**：前端路由一共有两种实现方式，一种是通过 `hash` 的方式，一种是通过使用 `pushState` 的方式。\r\n\r\n## 104. 什么是点击穿透，如何解决？\r\n在发生触摸动作约300ms之后，移动端会模拟产生click动作，它底下的具有点击特性的元素也会被触发，这种现象称为点击穿透。\r\n\r\n**常见场景**\r\n1.  情景一：遮罩层点击穿透问题，点击遮罩层（mask）上的关闭按钮，遮罩层消失后发现触发了按钮下面元素的click事件。\r\n1.  情景二：跨页面点击穿透问题：如果按钮下面恰好是一个有href属性的a标签，那么页面就会发生跳转。\r\n1.  情景三：另一种跨页面点击穿透问题：这次没有mask了，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元素的click事件被触发了。\r\n1.  情景四：新页面中对应位置元素恰好是a标签，然后就发生连续跳转了。这种情况概率很低\r\n\r\n**发生的条件**\r\n-   上层元素监听了触摸事件，触摸之后该层元素消失\r\n-   下层元素具有点击特性（监听了click事件或默认的特性（a标签、input、button标签））\r\n\r\n**解决点击穿透的方法**\r\n1.  方法一：书写规范问题，不要混用touch和click。既然touch之后300ms会触发click，只用touch或者只用click就自然不会存在问题了。\r\n1.  方法二：吃掉（或者说是消费掉）touch之后的click，依旧用tap，只是在可能发生点击穿透的情形做额外的处理，拿个东西来挡住、或者tap后延迟350毫秒再隐藏mask、pointer-events、在下面元素的事件处理器里做检测（配合全局flag）等。\r\n\r\n## 105. 简单说说setTimeout的运行机制\r\n`setTimeout` 和 `setInterval` 的运行机制，其实就是将指定的代码移出本次执行，等到下一轮 **Event Loop** 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。\r\n\r\n这意味着，setTimeout指定的代码，必须等到本次执行的所有同步代码都执行完，才会执行。\r\n\r\n## 106. Promise.all和Promise.allSettled有什么区别？\r\n最大的区别：`Promise.allSettled`永远不会被**reject**。\r\n\r\n使用`Promise.all`时，一旦有一个promise出现了异常，被reject了，尽管能用catch捕获其中的异常，但你会发现其他执行成功的Promise的消息都丢失了。\r\n\r\n而`Promise.allSettled`不会有这种问题，我们只需专注在then语句里，当有promise被异常打断时，我们依然能妥善处理那些已经成功了的promise，不必全部重来。\r\n\r\n## 107. 简单说说浏览器的垃圾回收机制有哪些？\r\nJS会在创建变量时自动分配内存，在不使用的时候会自动周期性的释放内存，释放的过程就叫 \\\"垃圾回收\\\"。\r\n\r\n一方面自动分配内存减轻了开发者的负担，开发者不用过多的去关注内存使用，但是另一方面，正是因为是自动回收，所以如果不清楚回收的机制，会很容易造成混乱，而混乱就很容易造成\\\"内存泄漏\\\"。\r\n\r\n由于是自动回收，所以就存在一个 \\\"内存是否需要被回收的\\\" 的问题，但是这个问题的判定在程序中意味着无法通过某个算法去准确完整的解决，后面探讨的回收机制只能有限的去解决一般的问题。\r\n\r\n**回收算法**：垃圾回收对是否需要回收的问题主要依赖于对变量的判定是否可访问，由此衍生出两种主要的回收算法：\r\n\r\n-   标记清理\r\n-   引用计数\r\n\r\n**标记清理**：标记清理是js最常用的回收策略，2012年后所有浏览器都使用了这种策略，此后的对回收策略的改进也是基于这个策略的改进。其策略是：\r\n\r\n-   变量进入上下文，也可理解为作用域，会加上标记，证明其存在于该上下文；\r\n-   将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用；\r\n-   在此之后再被加上标记的变量标记为准备删除的变量，因为上下文中的变量已经无法访问它们；\r\n-   执行内存清理，销毁带标记的所有非活跃值并回收之前被占用的内存；\r\n\r\n局限：\r\n\r\n-   由于是从根对象(全局对象)开始查找，对于那些无法从根对象查询到的对象都将被清除\r\n-   回收后会形成内存碎片，影响后面申请大的连续内存空间\r\n\r\n**引用计数**：引用计数策略相对而言不常用，因为弊端较多。其思路是对每个值记录它被引用的次数，通过最后对次数的判断(引用数为0)来决定是否保留，具体的规则有：\r\n\r\n-   声明一个变量，赋予它一个引用值时，计数+1；\r\n-   同一个值被赋予另外一个变量时，引用+1；\r\n-   保存对该值引用的变量被其他值覆盖，引用-1；\r\n-   引用为0，回收内存；\r\n\r\n局限：\r\n\r\n最重要的问题就是，循环引用的问题\r\n```js\r\nfunction foo() {\r\n  let a = new Object()\r\n  let b = new Object()\r\n  a.c = b\r\n  b.c = a //互相引用\r\n}\r\n```\r\n根据之前提到的规则，两个都互相引用了，引用计数不为0，所以两个变量都无法回收。如果频繁的调用改函数，则会造成很严重的内存泄漏。\r\n\r\n## 108. 箭头函数中的this指向哪里？\r\n箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\r\n\r\n可以⽤Babel理解⼀下箭头函数:\r\n```js\r\n// ES6\r\nconst obj = {\r\n  getArrow() {\r\n    return () => {\r\n      console.log(this === obj)\r\n    }\r\n  }\r\n}\r\n```\r\n转换后：\r\n```js\r\n// ES5，由 Babel 转译\r\nvar obj = {\r\n  getArrow: function getArrow() {\r\n    var _this = this\r\n    return function() {\r\n      console.log(_this === obj)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 109. Object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么？\r\n**拓展运算符**\r\n```js\r\nlet obj = {\r\n  inObj: { a: 1, b: 2 }\r\n}\r\nlet newObj = { ...obj }\r\n\r\nnewObj.inObj.a = 2\r\nconsole.log(obj) // {inObj: {a: 2, b: 2}}\r\n```\r\n使用扩展运算符创建出新的对象，但是执行`newObj.inObj.a = 2`后，原对象的里面的值也被改变了\r\n\r\n**Object.assign()**\r\n```js\r\nlet obj = {\r\n  inObj: {a: 1, b: 2}\r\n}\r\nlet newObj = Object.assign({}, obj)\r\n\r\nnewObj.inObj.a = 2\r\nconsole.log(obj) // {inObj: {a: 2, b: 2}}\r\n```\r\n情况和扩展运算符一样，原对象里面的值也被改变了。\r\n\r\n**所以，两者都是浅拷贝。**\r\n\r\n扩展操作符（`…`）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。\r\n\r\n`Object.assign()`方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\r\n\r\n## 110. 浏览器一帧都会干些什么？\r\n我们都知道，页面的内容都是一帧一帧绘制出来的，浏览器刷新率代表浏览器一秒绘制多少帧。原则上说 1s 内绘制的帧数也多，画面表现就也细腻。目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的（16.6ms） 过程中浏览器又干了些什么呢？\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef7e5b4cd524f799462f9391f7d60a2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程：\r\n-   接受输入事件\r\n-   执行事件回调\r\n-   开始一帧\r\n-   执行 RAF (RequestAnimationFrame)\r\n-   页面布局，样式计算\r\n-   绘制渲染\r\n-   执行 RIC (RequestIdelCallback)\r\n\r\n第七步的 RIC 事件不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事而且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时。\r\n\r\n## 111. 说说Object.defineProperty与Proxy的区别？\r\n在 Vue2.x 的版本中，双向绑定是基于 `Object.defineProperty` 方式实现的。而 Vue3.x 版本中，使用了 ES6 中的 `Proxy` 代理的方式实现。\r\n\r\n1. 使用 `Object.defineProperty` 会产生三个主要的问题：\r\n\r\n-   不能监听数组的变化\r\n-   必须遍历对象的每个属性。可以通过 `Object.keys()` 来实现\r\n-   必须深层遍历嵌套的对象。通过递归深层遍历嵌套对象，然后通过 `Object.keys()` 来实现对每个属性的劫持\r\n\r\n2. 关于Proxy\r\n* Proxy 针对的整个对象，`Object.defineProperty` 针对单个属性，这就解决了需要对对象进行深度递归（支持嵌套的复杂对象劫持）实现对每个属性劫持的问题\r\n* Proxy 解决了 `Object.defineProperty` 无法劫持数组的问题\r\n* 比 `Object.defineProperty` 有更多的拦截方法，对比一些新的浏览器，可能会对 Proxy 针正对性的优化，有助于性能提升\r\n\r\n## 112. base64编码图片，为什么会让数据量变大？\r\nBase64编码的思想是是采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组。以3个字节为一组。按顺序排列24位数据，再把这24位数据分成4组，即每组6位。再在每组的的最高位前补两个0凑足一个字节。这样就把一个3字节为一组的数据重新编码成了4个字节。当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节。这时在最后一组填充1到2个0字节。并在最后编码完成后在结尾添加1到2个\\\"=\\\"。\r\n\r\n（ 注BASE64字符表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/）\r\n\r\n从以上编码规则可以得知，通过Base64编码，原来的3个字节编码后将成为4个字节，即字节增加了33.3%，数据量相应变大。所以20M的数据通过Base64编码后大小大概为20M*133.3%=26.67M。\r\n\r\n## 113. 虚拟DOM一定更快吗？\r\n**虚拟DOM／domDiff**\r\n\r\n我们常说的虚拟DOM是通过JS对象模拟出来的DOM节点，domDiff是通过特定算法计算出来一次操作所带来的DOM变化。react和vue中都使用了虚拟DOM，我们借着react聊聊虚拟DOM。\r\n\r\nreact中涉及到虚拟DOM的代码主要分为以下三部分，其中核心是第二步的domDiff算法：\r\n\r\n-   把render中的JSX(或者createElement这个API)转化成虚拟DOM\r\n-   状态或属性改变后重新计算虚拟DOM并生成一个补丁对象(domDiff)\r\n-   通过这个补丁对象更新视图中的DOM节点\r\n\r\n**虚拟DOM不一定更快**\r\n\r\n干前端的都知道DOM操作是性能杀手，因为操作DOM会引起页面的回流或者重绘。相比起来，通过多一些预先计算来减少DOM的操作要划算的多。\r\n\r\n但是，“使用虚拟DOM会更快”这句话并不一定适用于所有场景。例如：一个页面就有一个按钮，点击一下，数字加一，那肯定是直接操作DOM更快。使用虚拟DOM无非白白增加了计算量和代码量。即使是复杂情况，浏览器也会对我们的DOM操作进行优化，大部分浏览器会根据我们操作的时间和次数进行批量处理，所以直接操作DOM也未必很慢。\r\n\r\n那么为什么现在的框架都使用虚拟DOM呢？**因为使用虚拟DOM可以提高代码的性能下限，并极大的优化大量操作DOM时产生的性能损耗。** 同时这些框架也保证了，即使在少数虚拟DOM不太给力的场景下，性能也在我们接受的范围内。\r\n\r\n而且，我们之所以喜欢react、vue等使用了虚拟DOM框架，不光是因为他们快，还有很多其他更重要的原因。例如react对函数式编程的友好，vue优秀的开发体验等，目前社区也有好多比较这两个框架并打口水战的，我觉着还是在两个都懂的情况下多探究一下原理更有意义一些。\r\n\r\n## 114. html文档渲染过程，css文件和js文件的下载，是否会阻塞渲染？\r\n**CSS阻塞**\r\n* css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。因为 CSSOM Tree 要和 DOM Tree 合成 Render Tree 才能绘制页面。\r\n\r\n* css 文件没下载并解析完成之前，后续的 js 脚本不能执行。\r\n* css 文件的下载不会阻塞前面的 js 脚本执行。（所以在需要提前执行不操作 dom 元素的 js 时，不妨把 js 放到 css 文件之前。）\r\n\r\n**js阻塞**\r\n\r\njs 文件的下载和解析会阻塞 GUI 渲染进程，也就是会阻塞 DOM 和 CSS 的解析和渲染。\r\n\r\n* js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析\r\n* js 文件的下载不会阻塞前面 HTML 和 CSS 的解析（当js放在body底部时）\r\n\r\n## 115. JavaScript对象中，可枚举性（enumerable）是什么？\r\n可枚举性（enumerable）用来控制所描述的属性，是否将被包括在`for...in`循环之中（除非属性名是一个Symbol）。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。\r\n\r\n-   `for..in`循环\r\n-   `Object.keys`方法\r\n-   `JSON.stringify`方法\r\n\r\n```js\r\nvar o = { a: 1, b: 2 }\r\n\r\no.c = 3\r\n\r\n// 添加 d 属性，值为 4，将 enumerable 为设为 false\r\nObject.defineProperty(o, 'd', {\r\n  value: 4,\r\n  enumerable: false\r\n})\r\n\r\nconsole.log(o.d);\r\n\r\n// 下面的方法取不到 o.d 的值\r\n\r\nfor (var key in o) console.log(o[key])\r\n// 1\r\n// 2\r\n// 3\r\n\r\nconsole.log(Object.keys(o)) // [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\r\n\r\nconsole.log(JSON.stringify(o)); // => \\\"{a:1,b:2,c:3}\\\"\r\n```\r\n上面代码中，d 属性的`enumerable`为`false`，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但还是可以直接获取它的值。\r\n\r\n至于`for...in`循环和`Object.keys`方法的区别，在于前者包括对象继承自原型对象的属性，而后者只包括对象本身的属性。如果需要获取对象自身的所有属性，不管`enumerable`的值，可以使用`Object.getOwnPropertyNames`方法。\r\n\r\n可枚举属性是指那些内部 “可枚举” 标志设置为 true 的属性。对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true。但是对于通过 `Object.defineProperty` 等定义的属性，该标识值默认为 false。\r\n\r\n## 116. Object.create和new有什么区别？\r\njs中创建对象的方式一般有两种 `Object.create` 和 `new`\r\n```js\r\nconst Base = function() {}\r\nconst o1 = Object.create(Base)\r\nconst o2 = new Base()\r\n```\r\n在讲述两者区别之前，我们需要知道：\r\n\r\n-   构造函数Foo的原型属性`Foo.prototype`指向了原型对象。\r\n-   原型对象保存着实例共享的方法，有一个指针`constructor`指回构造函数。\r\n-   js中只有函数有 `prototype` 属性，所有的对象只有 **proto** 隐式属性。\r\n\r\n那这样到底有什么不一样呢？\r\n\r\n1. 先来看看 `Object.create` 的实现方式\r\n```js\r\nObject.create = function(o) {\r\n  var F = function() {}\r\n  F.prototype = o\r\n  return new F()\r\n}\r\n```\r\n可以看出来。`Object.create`是内部定义一个对象，并且让`F.prototype`对象 赋值为引进的对象/函数 o，并`return`出一个新的对象。\r\n\r\n2. 再看看 `const o2 = new Base()` 的时候，new做了什么。\r\n```js\r\nvar o1 = new Object();\r\no1.[[Prototype]] = Base.prototype;\r\nBase.call(o1);\r\n```\r\nnew做法是新建一个obj对象o1，并且让o1的`__proto__`指向了`Base.prototype`对象。并且使用 call 进行强转作用环境。从而实现了实例的创建。\r\n\r\n**区别**：看似是一样的。我们对原来的代码进行改进一下。\r\n```js\r\nvar Base = function () {\r\n  this.a = 2\r\n}\r\nvar o1 = new Base();\r\nvar o2 = Object.create(Base);\r\nconsole.log(o1.a); // 2\r\nconsole.log(o2.a); // undefined\r\n```\r\n可以看到Object.create 失去了原来对象的属性的访问。再进行下改造：\r\n```js\r\nvar Base = function() {\r\n  this.a = 2\r\n}\r\nBase.prototype.a = 3\r\nvar o1 = new Base()\r\nvar o2 = Object.create(Base)\r\nconsole.log(o1.a) // 2\r\nconsole.log(o2.a) // undefined\r\n```\r\n**总结**\r\n|比较   | new              | Object.create   |\r\n| :----: | :----------------: | :---------------: |\r\n| 构造函数 | 保留原构造函数属性        | 丢失原构造函数属性       |\r\n| 原型链  | 原构造函数prototype属性 | 原构造函数/（对象）本身    |\r\n| 作用对象 | function         | function和object\r\n\r\n## 117. 为什么部分请求中，参数需要使用encodeURIComponent进行转码？\r\n一般来说，URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。\r\n\r\n这是因为网络标准RFC 1738做了硬性规定：\r\n>\\\"...Only alphanumerics [0-9a-zA-Z], the special characters \\\"$-_.+!*'(),\\\" [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.\\\"\r\n\r\n这意味着，如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致\\\"URL编码\\\"成为了一个混乱的领域。有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？\r\n\r\n就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。\r\n\r\n## 118. 箭头函数和普通函数有什么区别？\r\n1. 语法更加简洁、清晰\r\n\r\n3. **箭头函数不会创建自己的this（重点！）**\r\n    >箭头函数不会创建自己的this，所以它没有自己的this，它只会从自己的作用域链的上一层继承this。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。\r\n4. **箭头函数继承而来的this指向永远不变（重点！）**\r\n6. **`.call()/.apply()/.bind()`无法改变箭头函数中this的指向**\r\n7. **箭头函数不能作为构造函数使用**\r\n8. **箭头函数没有自己的 `arguments`**。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。\r\n9. **箭头函数没有原型 `prototype`**\r\n10. **箭头函数不能用作 `Generator` 函数，不能使用 `yeild` 关键字**\r\n\r\n## 119. WebSocket中的心跳机制是为了解决什么问题？\r\n-   为了定时发送消息，使连接不超时自动断线，避免后端设了超时时间自动断线。所以需要定时发送消息给后端，让后端服务器知道连接还在通消息不能断。\r\n-   为了检测在正常连接的状态下，后端是否正常。如果我们发了一个定时检测给后端，后端按照约定要下发一个检测消息给前端，这样才是正常的。如果后端没有正常下发，就要根据设定的超时进行重连。\r\n\r\n## 120. async/await 和 Promise 有什么关系？\r\n**Promise**\r\n>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象\r\n\r\n**async/await**\r\n\r\nes2017的新语法，`async/await`就是generator + promise的语法糖\r\n\r\n`async/await` 和 Promise 的关系非常的巧妙，await必须在async内使用，并装饰一个Promise对象，async返回的也是一个Promise对象。\r\n\r\n`async/await`中的`return/throw`会代理自己返回的Promise的`resolve/reject`，而一个Promise的`resolve/reject`会使得await得到返回值或抛出异常。\r\n\r\n-   如果方法内无await节点\r\n\r\n    -   return 一个字面量则会得到一个`{PromiseStatus: resolved}`的Promise。\r\n    -   throw 一个Error则会得到一个`{PromiseStatus: rejected}`的Promise。\r\n\r\n-   如果方法内有await节点\r\n\r\n    -   `async`会返回一个`{PromiseStatus: pending}`的Promise（发生切换，异步等待Promise的执行结果）。\r\n    -   `Promise`的`resolve`会使得`await`的代码节点获得相应的返回结果，并继续向下执行。\r\n    -   `Promise`的`reject` 会使得`await`的代码节点自动抛出相应的异常，终止向下继续执行。\r\n\r\n## 121. Promise中，resolve后面的语句是否还会执行？\r\n会被执行。如果不需要执行，需要在 resolve 语句前加上 return。\r\n\r\n## 122. CSR和SSR分别是什么？\r\n**CSR**: 对于html的加载，以React为例，我们习惯的做法是加载js文件中的React代码，去生成页面渲染，同时，js也完成页面交互事件的绑定，这样的一个过程就是CSR（客户端渲染）。\r\n\r\n**SSR**: 但如果这个js文件比较大的话，加载起来就会比较慢，到达页面渲染的时间就会比较长，导致首屏白屏。这时候，SSR（服务端渲染）就出来了：**由服务端直接生成html内容返回给浏览器渲染首屏内容。**\r\n\r\n但是服务端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入js文件来辅助实现，我们把页面的展示内容和交互写在一起，让代码执行两次，这种方式就叫同构。\r\n\r\n**CSR和SSR的区别在于，最终的html代码是从客户端添加的还是从服务端。**\r\n\r\n## 123. 什么是内存泄漏，什么原因导致的？\r\n内存泄露的解释：程序中己动态分配的堆内存由于某种原因未释放或无法释放。\r\n-   根据JS的垃圾回收机制，当内存中引用的次数为0的时候内存才会被回收\r\n-   全局执行上下文中的对象被标记为不再使用才会被释放\r\n\r\n内存泄漏的几种场景：\r\n* 全局变量过多。**通常是变量未被定义或者胡乱引用了全局变量**\r\n* 闭包。 未手动解决必包遗留的内存引用。\r\n* 事件监听未被移除\r\n* 缓存。建议所有缓存都设置好过期时间。\r\n\r\n## 124. web常见的攻击方式有哪些？以及如何进行防御？\r\n常见的攻击方式有：XSS、CSRF、SQL注入\r\n\r\n查看详情，请点击前往：[# 知道了web的攻击方式，还不快防起来？](https://juejin.cn/post/7152359275854200868)\r\n\r\n## 125. 什么是微前端？\r\n微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。\r\n\r\n各个前端应用还可以独立运行、独立开发、独立部署。\r\n\r\n微前端不是单纯的前端框架或者工具，而是一套架构体系，\r\n\r\n\r\n>由于篇幅原因，下半部分内容将 `「2022」JavaScript最新高频面试题指南（下）` 发布。持续更新中...\r\n\r\n* * *\r\n\r\n> 每文一句：星星使天空绚烂夺目；知识使人增长才干。\r\n\r\n本次的分享就到这里，如果本章内容对你有所帮助的话欢迎**点赞+收藏**。文章有不对的地方欢迎指出，有任何疑问都可以在评论区留言。希望大家都能够有所收获，大家一起探讨、进步！\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783)***\r\n\r\n"
    },
    {
        "article_id": "7171259778188967943",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8826935781a4022bde454aa9d39f1d7~tplv-k3u1fbpfcp-watermark.image?",
        "title": "手撸一个Table组件(Table组件不过如此)",
        "preview": "组件库大家都不陌生，Table组件大家肯定更不陌生，没错，这次小编就带领大家实现一个比较基础的Table组件，相信你们点进来绝对有收获",
        "author": "小九九的爸爸",
        "view_count": 596,
        "collect_count": 11,
        "comment_count": 1,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/e45eec524b3d093f5fb3cb0a88c1a26d~300x300.image",
        "category": "前端",
        "content": "## 一、前言\r\n手写Table组件这个文章我一直都想写，今天终于得空来写它了。小编认为Table组件是组件库里\\\"较为复杂\\\"的一个组件，因为它的扩展性非常强，并且它的基础样式如何去写都非常考究，那么今天我就带大家来实现一个基础功能的table组件，废话不多bb，进入正题吧。\r\n\r\n## 二、实现哪些功能？\r\n* 最基础的table布局\r\n* 固定头\r\n* 固定列\r\n\r\n## 三、实现的效果\r\n\r\n![table组件1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f66f8290dc4c43e191f06f0257927b8b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n以及组件的使用方式期望是这样：\r\n\r\n```react\r\nconst column = [\r\n    { name: '序号', key: 'order', width: '100px', isFixed: true },\r\n    { name: '第二列', key: 'col2', width: '200px' },\r\n    { name: '第三列', key: 'col3', width: '300px' },\r\n    { name: '第四列', key: 'col4', width: '200px' },\r\n    { name: '第五列', key: 'col5', width: '500px' },\r\n    { name: '第六列', key: 'col6', width: '200px' },\r\n];\r\nconst data = [\r\n    { order: 1, col2: '1-2', col3: '1-3', col4: '1-4', col5: '1-5', col6: '1-6' },\r\n    { order: 2, col2: '2-2', col3: '2-3', col4: '2-4', col5: '2-5', col6: '2-6' },\r\n    { order: 3, col2: '3-2', col3: '3-3', col4: '3-4', col5: '3-5', col6: '3-6' },\r\n    { order: 4, col2: '4-2', col3: '4-3', col4: '4-4', col5: '4-5', col6: '4-6' },\r\n    { order: 5, col2: '5-2', col3: '5-3', col4: '5-4', col5: '5-5', col6: '5-6' }\r\n];\r\n<CustomTable  column = { column } data = { data } rowHeight = { '100px' } />\r\n```\r\n\r\n\r\n## 四、动手实现\r\n\r\n### 4.1、table组件的尺寸\r\n\r\n#### 4.1.1、如何定义table组件的宽？\r\n对于table组件来说，定义宽度有2种方式，一种是\\\"固定宽度布局\\\"，另一种是\\\"自由宽度布局\\\"。我们可以通过\\\"table-layout\\\"属性在这2种方式中做出选择。\r\n\r\n##### 4.1.1.1、**\\\"固定宽度布局\\\"**\r\n\r\n> 就是显示的定义table标签的宽度(即table-layout: fixed)，那么此时 `<table>` 的宽度 与 各列 `[td | th]` 的宽度的关系如下：\r\n> * table真实的width = Math.max(table.style.width, 各列宽度之和)\r\n> * 如果 table.style.width > 各列宽度之和，那么`二者之差再除以列数`得到的结果将增加到各列上。\r\n\r\n纸上得来终觉浅，我们来跑下代码加深一下上述节论的记忆(`以下均是react环境下的代码`)：\r\n\r\n```css\r\ntable {\r\n    table-layout: fixed;\r\n    border-collapse: collapse;\r\n    border-spacing: 0px;\r\n    width: 200px;\r\n}\r\n```\r\n\r\n```react\r\n<div className = 'yon-table-box'>\r\n    <table>\r\n        <colgroup>\r\n            <col style={{ width: '100px' }}>\r\n            <col style={{ width: '100px' }}>\r\n            <col style={{ width: '100px' }}>\r\n        <colgroup>\r\n        <thead>\r\n            <th>列1</th>\r\n            <th>列2</th>\r\n            <th>列3</th>\r\n        </thead>\r\n    </table>\r\n</div>\r\n```\r\n\r\n此时效果如下：\r\n\r\n![table2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2101a52597f54fdc91b25adbc4bbc24b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n此时我们再稍微改动下样式，css如下：\r\n\r\n```css\r\ntable {\r\n    table-layout: fixed;\r\n    width: 500px;\r\n    border-collapse: collspse;\r\n    border-spacing: 0px;\r\n}\r\n```\r\n\r\n效果如下：\r\n\r\n\r\n![table3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0e352711664d778a756815f6478279~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n此时我们发现，上述结论是对的。\r\n\r\n##### 4.1.1.2、\\\"自由宽度布局\\\"\r\n> 顾名思义，更容易实现这个等式 \\\"table.style.width == 各列宽度之和 + 边框 + 间距\\\"。通过设置 table-layout: auto 来触发。\r\n\r\n我们来跑下代码试一下：\r\n\r\n```css\r\ntable {\r\n    table-layout: auto;\r\n    border-collapse: collapse;\r\n    border-spacing: 0px;\r\n    width: auto;\r\n}\r\n```\r\n\r\n```react\r\n<div className = 'table-box'>\r\n    <table>\r\n        <colgroup>\r\n            <col style={{ width: '100px' }}>\r\n            <col style={{ width: '100px' }}>\r\n            <col style={{ width: '100px' }}>\r\n        </colgroup>\r\n        <thead>\r\n            <th>列1</th>\r\n            <th>列2</th>\r\n            <th>列3</th>\r\n        </thead>\r\n    </table>\r\n</div>\r\n```\r\n\r\n此时我们来看下效果：\r\n\r\n\r\n![table4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fff42ae0d941c1aa4da376eaf13983~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n##### 4.1.1.3、table宽度的最终选择\r\n\r\n经过上面2种布局的分析，我们决定选用\\\"自由宽度布局\\\"的方式定义table的宽度，此时咱们的CustomTable组件的代码如下：\r\n\r\n```css\r\n    .yon-table-box {\r\n        width: 100px;\r\n        height: 100px;\r\n        overflow: scroll;\r\n    }\r\n    table {\r\n        table-layout: auto;\r\n        table-collapse: collapse;\r\n        table-spacing: 0px;\r\n        width: auto;\r\n    }\r\n    th {\r\n        background: #f4f4f4;\r\n    }\r\n```\r\n\r\n```react\r\n    import React from 'react';\r\n    class CustomTable extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n        }\r\n        render (){\r\n            const { column } = this.props;\r\n            return <div className = 'yon-table-box'>\r\n                <div className = 'right'>\r\n                    <table>\r\n                        <colgroup>\r\n                            {\r\n                                column.map(colItem => {\r\n                                    return <col style={{ colItem.width }}>\r\n                                })\r\n                            }\r\n                        </colgroup>\r\n                        <thead>\r\n                            <tr>\r\n                                {\r\n                                    column.map(colItem => {\r\n                                        return <th>{ colItem.name }</th>\r\n                                    })\r\n                                }\r\n                            </tr>\r\n                        </thead>\r\n                    </table>\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\nTable的使用:\r\n\r\n```react\r\n    import React from 'react';\r\n    \r\n    const column = [\r\n        { name: '列1', key: 'col1', width: '100px' },\r\n        { name: '列2', key: 'col2', width: '200px' },\r\n        { name: '列3', key: 'col3', width: '300px' },\r\n    ];\r\n    \r\n    <CustomTable column = { column } />\r\n    \r\n```\r\n\r\n\r\n#### 4.1.2、如何定义table组件的高？\r\n\r\n定义table组件的行高度，这个就比较简单了，我们只需要保证 table.style.height = 'auto', 即可实现自定义行高，CustomTable组件的代码如下：\r\n\r\n```css\r\n    .yon-table-box {\r\n        width: 100px;\r\n        height: 100px;\r\n        overflow: scroll;\r\n    }\r\n    table {\r\n        table-layout: auto;\r\n        table-collapse: collapse;\r\n        table-spacing: 0px;\r\n        width: auto;\r\n        // 新增代码+++++++++++++++++++++\r\n        height: auto;\r\n    }\r\n    th {\r\n        background: #f4f4f4;\r\n    }\r\n    // 新增代码++++++++++++++++++++++++++\r\n    td {\r\n        background: #fff;\r\n        border-bottom: 1px solid rgb(208, 208, 208);\r\n    }\r\n```\r\n\r\n```react\r\n    import React from 'react';\r\n    class CustomTable extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n        }\r\n        render (){\r\n            const { column, data, rowHeight } = this.props;\r\n            return <div className = 'yon-table-box'>\r\n                <div className = 'right'>\r\n                    <table>\r\n                        <colgroup>\r\n                            {\r\n                                column.map(colItem => {\r\n                                    return <col style={{ colItem.width }}>\r\n                                })\r\n                            }\r\n                        </colgroup>\r\n                        <thead>\r\n                            <tr>\r\n                                {\r\n                                    column.map(colItem => {\r\n                                        return <th>{ colItem.name }</th>\r\n                                    })\r\n                                }\r\n                            </tr>\r\n                        </thead>\r\n                        <tbody>\r\n                            {\r\n                                // 新增代码+++++++++++++++++++++++++\r\n                                data.map(dataItem => {\r\n                                    return <tr>\r\n                                        {\r\n                                            column.map(colItem => {\r\n                                                return <td style={{ height: rowHeight }}>{dataItem[colItem.key]}</td>\r\n                                            })\r\n                                        }\r\n                                    </tr>\r\n                                })\r\n                            }\r\n                        </tbody>\r\n                    </table>\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\n好啦，此时咱们的第一个功能到这就算实现啦，如果你是一步一步跟下来的，那么此时的效果应该是这样的：\r\n\r\n\r\n![table6.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/008aad3e87e143fb915b0471fb08cb4c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n### 4.2、固定列\r\n\r\n我们先来看一下下面的图：\r\n\r\n\r\n![table7.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f372befb7c714eb5880d3c921d924dff~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n首先，根据目前实现的效果来看，我们可以得出以下信息：\r\n\r\n* 目前dom上就只有一个table，意味着 表头、表体是连着的，符合正常文档流所有的特点。\r\n* 红色框是我们想要固定的列。\r\n\r\n好，此时我们来想一下能够做到固定列（无非是2个div互不干扰呗）的方法有哪些？\r\n\r\n#### 4.2.1、方式一\r\n把一个table分为左右2个table，`并保证只有右侧的table局部滚动`，干掉父div的scroll。\r\n\r\n#### 4.2.2、方式二\r\n依旧是一个table分为左右2个table，`只是在不改变现在滚动的情况下`，给左侧的table新增一个\\\"sticky\\\"的粘性定位即可。\r\n\r\n#### 4.2.3、方式三\r\n利用js，监听scroll事件，在滚动的时候，利用transform属性，动态的设置translateX，来达到固定列的效果\r\n\r\n\r\n#### 4.2.3、固定列的最终选择\r\n\r\n> 这里我们选择 **方式二**。理由非常简单，改动量非常少的情况就可以实现，其他的2种情况的改动都挺大，但是也可以实现，下面我会把其他的2种方式的伪代码写出来供大家参考。\r\n\r\n* 方式一。其实这种方式更适合\\\"固定宽度布局\\\"的table，因为这种table的width是非常容易拿到的，你只需要保证列数过多的时候出现滚动条就可以（也仅仅是一行样式的问题）,伪代码如下：\r\n\r\n```react\r\n    import React from 'react';\r\n    \r\n    export default class App extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n        }\r\n        render (){\r\n            return <div style={{ display: 'flex' }}>\r\n                <!-- 左侧固定列 -->\r\n                <div className = 'left'>\r\n                    <table></table>\r\n                </div>\r\n                <!-- 右侧自由列 -->\r\n                <div className = 'right' style={{ overflow: 'scroll' }}>\r\n                    <table></table>\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n* 方式三。这种利用js的方式是最看重代码结构的，而且还会使你的代码变得非常臃肿（不利于拆分），它比较适用于下面的写法:\r\n\r\n```react\r\n    import React from 'react';\r\n    \r\n    // 大家看到这样的写法其实可能感觉不到什么，但是如果这样写的话，table组件的抽取将会异常困难。\r\n    class App extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n            this.leftTableRef = React.createRef();\r\n            this.scrollTableBox = React.createRef();\r\n        }\r\n        \r\n        scrollTable = () => {\r\n            // 保持左侧固定不动\r\n            this.leftTableRef.current.style.transform = `translateX(-${this.scrollTableBox.current.scrollLeft}`;\r\n        }\r\n        \r\n        render (){\r\n            return <div ref = { this.scrollTableBox } style={{ display: 'flex', overflow: 'scroll' }} onScroll = { () => this.scrollTable() }>\r\n                <!-- 左侧固定列table -->\r\n                <table ref={ this.leftTableRef }></table>\r\n                \r\n                <!-- 右侧自由列table -->\r\n                <table></table>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\n\r\n#### 4.2.4、固定列的最终代码\r\n\r\n```css\r\n    .yon-table-box {\r\n        width: 100px;\r\n        height: 100px;\r\n        overflow: scroll;\r\n    }\r\n    \r\n    table {\r\n        table-layout: auto;\r\n        table-collapse: collapse;\r\n        table-spacing: 0px;\r\n        width: auto;\r\n        // 新增代码+++++++++++++++++++++\r\n        height: auto;\r\n    } \r\n    th { \r\n        background: #f4f4f4;\r\n    } \r\n    // 新增代码++++++++++++++++++++++++++\r\n    td {\r\n        background: #fff;\r\n        border-bottom: 1px solid rgb(208, 208, 208);\r\n    }\r\n    // 新增代码++++++++++++++++++++++++++\r\n    .left {\r\n        position: sticky;\r\n        left: 0px;\r\n    }\r\n```\r\n\r\n```react\r\n    import React from 'react';\r\n    \r\n    class CustomTable extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n            this.state = {\r\n                // 固定列集合\r\n                fixedColumnArr : [];\r\n                // 自由列集合\r\n                notFixedColumnArr: [];\r\n            }\r\n        }\r\n        \r\n        componentDidMount(){\r\n            const { column } = this.props;\r\n            this.setState(state => {\r\n                return {\r\n                    // column配置项中，isFixed用于标识是否是固定列\r\n                    fixedColumnArr : column.filter(item => item.isFixed),\r\n                    notFixedColumnArr: column.filter(item => !item.isFixed)\r\n                }\r\n            })\r\n        }\r\n        \r\n        render (){\r\n            const { data, column, rowHeight } = this.props;\r\n            const { fixedColumnArr, notFixedColumnArr } = this.state;\r\n            return <div className = 'yon-table-box'>\r\n                {\r\n                   fixedColumnArr.length > 0  && <div className = 'left'>\r\n                       <table>\r\n                           <colgroup>\r\n                               {\r\n                                   fixedColumnArr.map(item => {\r\n                                       return <col style={{ minWidth: item.width, width: item.width }}>\r\n                                   })\r\n                               }\r\n                           </colgroup>\r\n                           <thead>\r\n                               <tr>\r\n                                   {\r\n                                       fixedColumnArr.map(item => {\r\n                                           return <th>{item.name}</th>\r\n                                       })\r\n                                   }\r\n                               </tr>\r\n                           </thead>\r\n                           <tbody>\r\n                               {\r\n                                   data.map(dataItem => {\r\n                                       return <tr>\r\n                                           {\r\n                                               fixedColumnArr.map(colItem => {\r\n                                                   return <td>{dataItem[colItem.key]}</td>\r\n                                               })\r\n                                           }\r\n                                       </tr>\r\n                                   })\r\n                               }\r\n                           </tbody>\r\n                       </table>\r\n                   </div>\r\n                }\r\n                <div className = 'right'>\r\n                    <!-- 跟left代码一样，只需要把 fixedColumnArr 换成 notFixedColumnArr 即可 -->\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\n\r\n\r\n### 4.3、固定头\r\n固定头的实现思路 其实和 固定列的思路是一样的，这里就不具体分析了，夜也深了，哈哈哈，这里我就偷点懒，给伪代码了:\r\n\r\n```react\r\n    import React from 'react';\r\n    \r\n    class CustomTable extends React.Component {\r\n        constructor(props){\r\n            super(props)\r\n            this.state = {\r\n                // 固定列集合\r\n                fixedColumnArr : [];\r\n                // 自由列集合\r\n                notFixedColumnArr: [];\r\n            }\r\n        }\r\n        \r\n        \r\n        render (){\r\n            const { data, column, rowHeight } = this.props;\r\n            return <div className = 'yon-table-box'>\r\n                // 整张表的头部（整个头部是需要sticky的）\r\n                <div className = 'top'>\r\n                    <div className = 'left'></div>\r\n                    <div className = 'right'></div>\r\n                </div>\r\n                // 整张表的body（左侧需要固定的body是需要sticky的）\r\n                <div className = 'bottom'>\r\n                    <div className = 'left'></div>\r\n                    <div className = 'right'></div>\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n```\r\n\r\n\r\n## 五、最后\r\n好啦，table组件这次就分享到这里了，文章里有讲的不对的地方，欢迎大家指正，如果大家对table组件的实现有什么好的想法，也欢迎评论留言，那么886~~~\r\n\r\n"
    },
    {
        "article_id": "7189164529430265912",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4e6c42b224845c698fdd98297b1f61d~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Express 入门指南（详细）",
        "preview": "网上相关的express教程资源比较少，官网文档光是UI界面就能劝退一波人，因此本篇文章较为详细的介绍了express的初步使用，希望能帮助到大家",
        "author": "敲代码的彭于晏",
        "view_count": 712,
        "collect_count": 8,
        "comment_count": 4,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/15f89bc2c9fddd1d0b1baf7f98a22850~300x300.image",
        "category": "前端",
        "content": "# 一、安装\r\n\r\n1. 安装node.js，准备node环境\r\n\r\n2. 创建新文件夹，运行 `npm init -y`  创建package.json  \r\n\r\n3. 运行 `yarn add nodemon -D`（自动重启工具）\r\n\r\n4. 在package.json的scripts中增加 `\\\"dev\\\":\\\"nodemon app.js\\\",`\r\n\r\n5. 运行 `yarn add express`  安装express\r\n\r\n6. 项目根目录新建 app.js\r\n\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst app = express();\r\n\r\napp.get(\\\"/\\\", (req, res) => {\r\n  res.send(\\\"Hello World\\\");\r\n});\r\n\r\napp.listen(4000, () => {\r\n  console.log(\\\"server is running\\\");\r\n});\r\n```\r\n\r\n运行 `npm run dev` ，访问localhost:4000可以看到hello world\r\n\r\n# 二、路由\r\n\r\n1. 项目根目录新建controllers文件夹，专门存放路由回调\r\n\r\n\r\n新建controllers/loginController.js，登录逻辑\r\n\r\n```js\r\nexports.register = function (req, res) {\r\n  res.send(\\\"Got a POST request\\\");\r\n}\r\n```\r\n\r\n新建controllers/userController.js，用户逻辑\r\n\r\n```js\r\nexports.list = function (req, res) {\r\n  res.json({\r\n    //发送json数据类型\r\n    list: [\r\n      {\r\n        name: \\\"12\\\",\r\n        id: 1,\r\n      },\r\n      {\r\n        name: \\\"1233\\\",\r\n        id: 2,\r\n      },\r\n    ],\r\n  });\r\n}\r\n\r\nexports.deleteUser = function (req, res) {\r\n  res.send(\\\"Got a DELETE request at /user\\\"); //发送各种类型的响应\r\n}\r\n```\r\n\r\n2. 项目根目录新建routes文件夹，专门存放路由\r\n\r\n新建routes/login.js，登录路由\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst loginController = require('../controllers/loginController');\r\n\r\nconst router = express.Router(); //模块化路由\r\n\r\nrouter.post(\\\"/register\\\", loginController.register);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n新建routes/user.js，用户路由\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst userController = require(\\\"../controllers/userController\\\");\r\n\r\nconst router = express.Router();\r\n\r\nrouter.get(\\\"/list\\\", userController.list);\r\n\r\nrouter.delete(\\\"/user\\\", userController.deleteUser);\r\n\r\nmodule.exports = router;\r\n```\r\n3. 新建routes/index.js，路由出口\r\n\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst userRouter = require(\\\"./user\\\");\r\nconst loginRouter = require(\\\"./login\\\");\r\n\r\nconst router = express.Router();\r\n\r\nrouter.use(\\\"/api\\\", userRouter); // 注入用户路由模块\r\nrouter.use(\\\"/api\\\", loginRouter); // 注入登录路由模块\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n4. 在app.js中引入\r\n\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst routes = require(\\\"./routes\\\"); //新增\r\nconst app = express();\r\n\r\napp.use(\\\"/\\\", routes); //新增\r\n\r\n//删除\r\n// app.get(\\\"/\\\", (req, res) => {\r\n//   res.send(\\\"Hello World\\\");\r\n// });\r\n\r\napp.listen(4000, () => {\r\n  console.log(\\\"server is running\\\");\r\n});\r\n```\r\n\r\n通过浏览器或postman 访问 http://localhost:4000/api/list 可以看到接口成功被调用\r\n\r\n将controllers逻辑与routes路由拆分开，目的是为了结构更加清晰，并且可以复用controller\r\n\r\n最终目录结构：\r\n\r\n![F0D363886E4243ED8861F429D4C3B7DA.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce14e80a31d14bec949bd1647817b645~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 三、托管静态文件\r\n\r\n新建public/images文件夹，存放一些图片，例如react.png\r\n\r\n在app.js中增加\r\n\r\n```js\r\n\r\nvar path = require('path');\r\n\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n```\r\n\r\n访问 http://localhost:4000/images/react.png 可以看到图片显示成功\r\n\r\n# 四、中间件\r\n\r\n中间件是个函数，有三个参数 req，res，next\r\n\r\n若非结束响应，中间件必须调用 next() 将控制传递给下一个中间件函数（否则请求将成为悬挂请求）\r\n\r\n## 1. 自定义全局中间件\r\n\r\n\r\n```js\r\n//在app.js中新增\r\nvar myLogger = function (req, res, next) {\r\n  console.log(\\\"LOGGED\\\");\r\n  next();\r\n};\r\n\r\napp.use(myLogger);\r\n\r\n//加在 app.use(\\\"/\\\", routes); 之前，在路由之前注册\r\n```\r\n\r\n访问：http://localhost:4000/api/list 可以看到终端打印了日志 LOGGED\r\n\r\n## 2. 路由中间件\r\n\r\n\r\n```js\r\n//在routes/login.js中新增\r\nfunction login_middleware(req, res, next) {\r\n  console.log(\\\"中间件1\\\");\r\n  next(); //传递给下一步\r\n}\r\n\r\nfunction login_params(req, res, next) {\r\n  let { name, password } = req.query;\r\n  if (!name || !password) {\r\n    //发送消息，结束响应，不需要再调用next\r\n    res.json({\r\n      message: \\\"参数校验失败\\\",\r\n    });\r\n  } else {\r\n    next();\r\n  }\r\n}\r\n\r\nrouter.post(\\\"/login\\\", [login_middleware, login_params], (req, res, next) => {\r\n  res.send(\\\"登录成功\\\");\r\n});\r\n```\r\n\r\n在postman中使用post访问：http://localhost:4000/api/login?name=1&password=2 ，请求成功，并可在终端中看到打印信息\r\n\r\n  \r\n这里为了方便演示，将回调函数和路由都放到了一起，实际工作中，可做上述的controllers与routes拆分处理\r\n\r\n  \r\n接下来介绍第三方中间件 body-parser\r\n\r\n# 五、body-parser\r\n\r\n上面的post请求参数是放在url上的，实际场景通常都在body上，而express直接通过req.body只能获取到undefined，因此需要 body-parser 第三方库\r\n\r\n1. 运行 `yarn add body-parser`\r\n\r\n2. 修改app.js\r\n\r\n\r\n```js\r\nconst bodyParser = require('body-parser'); \r\n\r\n// 解析application/x-www-form-urlencoded数据格式\r\napp.use(bodyParser.urlencoded({extended: true}));\r\n\r\n// 解析json数据格式\r\napp.use(bodyParser.json()); \r\n\r\n//解析 text/plain 数据格式\r\napp.use(bodyParser.text()); \r\n\r\n//加在 app.use(\\\"/\\\", routes); 之前，在路由之前注册\r\n```\r\n\r\n**提示：body-parser目前不支持解析contentType: multipart/form-data 的格式类型**\r\n\r\n3. 修改routes/login.js\r\n\r\n\r\n```js\r\nrouter.post(\\\"/login\\\", (req, res, next) => {\r\n  console.log(\\\"req\\\", req.body);\r\n  res.send(\\\"登录成功\\\");\r\n});\r\n```\r\n\r\n使用postman通过post请求x-www-form-urlencoded数据格式\r\n\r\n![7F764949937E4DFC913B83830E7443A6.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/591c457572654467a876375e86788f76~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n使用postman通过post请求json数据格式\r\n\r\n![1571BE93AB3F4E9BA8F490F27C87DA80.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0617369cb244ba98807a60db5cedff2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n注意：选完raw后，一定要将右侧的Text换成JSON\r\n\r\n\r\n在实际开发中，前端通过URLSearchParams发送x-www-form-urlencoded数据格式\r\n\r\n\r\n```js\r\nconst params = new URLSearchParams();\r\nparams.append('param1', 'value1');\r\nparams.append('param2', 'value2');\r\n```\r\n\r\n# 六、解决跨域 cors\r\n\r\n1. 安装 `yarn add cors`\r\n\r\n2. 修改app.js\r\n\r\n\r\n```js\r\n//新增\r\nconst cors = require('cors'); \r\n\r\napp.use(cors()); \r\n\r\n//加在 app.use(\\\"/\\\", routes); 之前，在路由之前注册\r\n```\r\n\r\n3. 最终app.js文件\r\n\r\n\r\n```js\r\nconst express = require(\\\"express\\\");\r\nconst bodyParser = require(\\\"body-parser\\\"); // 引入body-parser模块\r\nvar path = require(\\\"path\\\");\r\nconst cors = require(\\\"cors\\\");\r\n\r\nconst routes = require(\\\"./routes\\\");\r\n\r\nconst app = express();\r\n\r\napp.use(express.static(path.join(__dirname, \\\"public\\\")));\r\n\r\n// 解析form表单提交的数据application/x-www-form-urlencoded\r\napp.use(bodyParser.urlencoded({ extended: true })); \r\napp.use(bodyParser.json()); // 解析json数据格式\r\napp.use(bodyParser.text()); //解析 text/plain 数据格式\r\n\r\napp.use(cors()); // 注入cors模块解决跨域\r\n\r\napp.use(\\\"/\\\", routes);\r\n\r\napp.listen(4000, () => {\r\n  console.log(\\\"server is running port\\\");\r\n});\r\n```\r\n\r\n# 七、文件上传 multer\r\n\r\n1. 运行 `yarn add multer`\r\n\r\n2. 运行 `yarn add uuid`\r\n\r\n3. 新建util/upload.js\r\n\r\n\r\n```js\r\nconst fs = require(\\\"fs\\\");\r\nconst path = require(\\\"path\\\");\r\nconst multer = require(\\\"multer\\\");\r\nconst uuid = require(\\\"uuid\\\");\r\n\r\nconst memoryDest = path.join(__dirname, \\\"../public/images\\\");\r\n\r\nconst storage = multer.diskStorage({\r\n  // 文件存储位置\r\n  destination: (req, file, cb) => {\r\n    // 校验文件夹是否存在，如果不存在则创建一个\r\n    const isExists = fs.existsSync(memoryDest);\r\n    if (!isExists) {\r\n      fs.mkdirSync(memoryDest);\r\n    }\r\n    cb(null, memoryDest);\r\n  },\r\n  filename: (req, file, cb) => {\r\n    // 生成唯一文件名\r\n    const uid = uuid.v1();\r\n    // 获取文件扩展名\r\n    let ext = path.extname(file.originalname);\r\n    cb(null, uid + ext);\r\n  },\r\n});\r\n\r\n// 过滤文件\r\nfunction fileFilter(req, file, callback) {\r\n  if (!file) {\r\n    callback(null, false);\r\n  } else {\r\n    callback(null, true);\r\n  }\r\n}\r\nconst upload = multer({\r\n  storage: storage,\r\n  fileFilter: fileFilter,\r\n  limits: {\r\n    fileSize: 20 * 1024 * 1024,\r\n  },\r\n}).single(\\\"file\\\"); //上传的fieldname必须为file\r\n\r\nmodule.exports = upload;\r\n```\r\n\r\n4. 修改routes/user.js\r\n\r\n\r\n```js\r\nconst upload = require(\\\"../util/upload\\\");\r\n\r\nrouter.post(\\\"/upload\\\", upload, (req, res, next) => {\r\n  // 存储后的文件信息在 req.file 中，此时文件已经存储到本地了。\r\n  console.log(req.file);\r\n  res.send(\\\"success\\\");\r\n});\r\n```\r\n\r\n5. 前端代码\r\n\r\n注意：name=\\\"file\\\"必传，与上面single(\\\"file\\\")对应\r\n\r\n```js\r\n//ant组件\r\n<Upload\r\n  name=\\\"file\\\"\r\n  listType=\\\"picture-card\\\"\r\n  className=\\\"avatar-uploader\\\"\r\n  showUploadList={false}\r\n  action='http://127.0.0.1:4000/api/upload'\r\n>\r\n\r\n//Element组件\r\n<el-upload\r\nname=\\\"file\\\"\r\nclass=\\\"avatar-uploader\\\"\r\naction='http://127.0.0.1:4000/api/upload'\r\n:show-file-list=\\\"false\\\"\r\n></Upload>\r\n```\r\n\r\n# 八、连接数据库\r\n\r\n## 前提准备：\r\n\r\n1. 本地数据库安装\r\n\r\n该教程网上的资源比较多，可自行百度，如果有遇到麻烦的，可在评论区留言，我再更一篇安装本地数据库的教程\r\n\r\n2. 运行本地数据库并登录\r\n\r\n3. 修改本地数据库加密方式\r\n\r\n在cmd中运行\r\n\r\n`ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;`\r\n\r\n`ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';`\r\n\r\n`FLUSH PRIVILEGES;`\r\n\r\n4. 使用Navicat for MySQL新建连接\r\n\r\n\r\n![3381DBD42AF140C18DBDD3E5E70435C0.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acc87799ac2745e3ac60ffbc5c299d72~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n5. 新建数据库\r\n\r\n\r\n![8E6F99B2FC4A4BC0BAE9781E91189F1F.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/126c6c981fd6418bad5e5434ac160432~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n6. 新建一个user表\r\n\r\nid设为主键，并自动递增\r\n\r\n\r\n![企业微信截图_1674092074223.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c743fc7a27ea43e4a1c4ce6eaf8099b3~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n填一些数据\r\n\r\n\r\n![F7460A8FD2844E49ACDE200A57463519.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679b8f595ed54245abcbe5b94193baf2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n## express部分：\r\n\r\n1. 安装mysql：`yarn add mysql`\r\n\r\n2. 新建db/mysql.js 创建数据库连接池\r\n\r\n\r\n```js\r\nconst mysql = require(\\\"mysql\\\");\r\nconst pool = mysql.createPool({\r\n  connectionLimit: 10, //最大连接数，默认为10\r\n  host: \\\"localhost\\\", // 数据库服务器地址\r\n  port: 3306, //数据库端口\r\n  user: \\\"root\\\", // 数据库的用户名\r\n  password: \\\"123456\\\", // 数据库密码\r\n  database: \\\"manage\\\", // 数据库名\r\n});\r\n\r\nclass Mysql {\r\n  constructor() {}\r\n  query(sql) {\r\n    return new Promise((resolve, reject) => {\r\n      pool.getConnection(function (err, connection) {\r\n        if (err) {\r\n          reject(err);\r\n          throw err; // not connected!\r\n        }\r\n        connection.query(sql, function (error, results, fields) {\r\n          if (error) {\r\n            reject(err);\r\n            throw error;\r\n          }\r\n          connection.release(); //只是释放链接，在缓冲池，没有被销毁\r\n          resolve(results);\r\n        });\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = new Mysql();\r\n```\r\n\r\n3. 新建service/userService.js 存放sql语句，实现语句的复用\r\n\r\n\r\n```js\r\n//新增 \r\nexports.userAll = `SELECT * FROM user;`\r\n```\r\n\r\n4. 修改controllers/userController.js\r\n\r\n\r\n```js\r\n//新增\r\nexports.getuser = function (req, res) {\r\n  mysql.query(userService.userAll).then((data) => {\r\n    let jsonData = JSON.parse(JSON.stringify(data));\r\n    res.json({\r\n      data: jsonData,\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n5. 修改routes/user.js\r\n\r\n\r\n```js\r\n//新增\r\nrouter.get(\\\"/user/json\\\", userController.getuser);\r\n```\r\n\r\n使用浏览器或postman访问 http://localhost:4000/api/user/json 可以获取到数据\r\n\r\n# 九、express-jwt、jsonwebtoken\r\n\r\njsonwebtoken是用来生成token给客户端的，express-jwt是用来验证token的\r\n\r\n1. 安装：yarn add jsonwebtoken   yarn add express-jwt\r\n\r\n2. 修改routes/login.js 生成token\r\n\r\n\r\n```js\r\nconst jwt = require(\\\"jsonwebtoken\\\");\r\n\r\nrouter.post(\\\"/login\\\", (req, res, next) => {\r\n  let { username } = req.body;\r\n\r\n  // 登录成功，签发一个token并返回给前端\r\n  const token = jwt.sign(\r\n    // payload：签发的 token 里面要包含的一些数据\r\n    { username},\r\n    // 私钥\r\n    \\\"caowj\\\",\r\n    // 设置过期时间\r\n    { expiresIn: 60 * 60 * 24 } //1 day\r\n  );\r\n\r\n  res.json({\r\n    msg: \\\"登录成功\\\",\r\n    data: { token },\r\n  });\r\n});\r\n```\r\n3. 新建util/user-jwt.js 验证token\r\n\r\n\r\n```js\r\nvar { expressjwt: jwt } = require(\\\"express-jwt\\\");\r\n\r\n// 验证token是否过期\r\nconst jwtAuth = jwt({\r\n  secret: \\\"caowj\\\", //密匙\r\n  algorithms: [\\\"HS256\\\"], //签名算法\r\n}).unless({ path: [\\\"/api/login\\\", \\\"/api/register\\\"] }); // unless 设置jwt认证白名单\r\n\r\nmodule.exports = jwtAuth;\r\n```\r\n4. 修改routes/index.js 注入验证模块，并对错误进行处理\r\n\r\n\r\n```js\r\n//注入验证模块\r\nconst jwtAuth = require(\\\"../util/user-jwt\\\");\r\n\r\nrouter.use(jwtAuth); \r\n\r\nrouter.use(\\\"/api\\\", userRouter); // 注入用户路由模块\r\nrouter.use(\\\"/api\\\", loginRouter); // 注入登录路由模块\r\n\r\n// 自定义统一异常处理中间件，需要放在代码最后\r\nrouter.use((err, req, res, next) => {\r\n  // 自定义用户认证失败的错误返回\r\n  console.log(\\\"err===\\\", err);\r\n  if (err && err.name === \\\"UnauthorizedError\\\") {\r\n    const { status = 401, message } = err;\r\n    // 抛出401异常\r\n    res.status(status).json({\r\n      code: status,\r\n      msg: \\\"token失效，请重新登录\\\",\r\n      data: null,\r\n    });\r\n  } else {\r\n    const { output } = err || {};\r\n    // 错误码和错误信息\r\n    const errCode = (output && output.statusCode) || 500;\r\n    const errMsg =\r\n      (output && output.payload && output.payload.error) || err.message;\r\n    res.status(errCode).json({\r\n      code: errCode,\r\n      msg: errMsg,\r\n    });\r\n  }\r\n});\r\n```\r\n\r\n使用postman访问/api/login获取到token，这样在请求别的接口时，需要在请求头上将token加到authorization上\r\n\r\n```js\r\n//前端传的对应值以Bearer开头然后空一格，接近着是token值 \r\n\r\nauthorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6I\r\n```\r\n\r\n该设计方式与express-jwt源码有关，感兴趣的可以去阅读\r\n\r\n# 十、结尾\r\n\r\n本篇文章如果有不对或不详细的地方，欢迎在评论区留言，后续会继续更新这篇文章\r\n\r\n码字不易，点赞支持！！！\r\n\r\n最后，祝大家春节快乐~\r\n\r\n"
    },
    {
        "article_id": "7189919858195169340",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92ff4be29034b628d3a446b66ce7532~tplv-k3u1fbpfcp-watermark.image?",
        "title": "简述JavaScript异步函数 async/await",
        "preview": "ES7 引入的 async/await 是对 JavaScript 异步编程的一种改进，它提供了使用同步样式代码异步访问资源的选项，而不会阻塞主线程。但是，要很好地使用它有点棘手。",
        "author": "天行无忌",
        "view_count": 1523,
        "collect_count": 1,
        "comment_count": 2,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/ee5b3d33c959244bf7b70b28bb3a4d07~300x300.image",
        "category": "前端",
        "content": "ES7 引入的 `async/await` 是对 JavaScript 异步编程的一种改进，它提供了使用同步样式代码异步访问资源的选项，而不会阻塞主线程。但是，要很好地使用它有点棘手。在本文中，将从不同的角度探索 `async/await`，并展示如何正确有效地使用它们。\r\n\r\n### async/await 好处\r\n\r\n`async/await` 带来的最重要的好处就是同步编程风格，先来看一个例子。\r\n\r\n```\r\n// async/await\r\nconst getArticlesByAuthorWithAwait = async (authorId) => {\r\n    const articles = await articleModel.fetchAll();\r\n    return articles.filter((b) => b.authorId === authorId);\r\n};\r\n\r\n// promise\r\nconst getArticlesByAuthorWithPromise = (authorId) => {\r\n    return articleModel\r\n        .fetchAll()\r\n        .then((articles) => articles.filter((b) => b.authorId === authorId));\r\n};\r\n```\r\n\r\n很明显，`async/await` 版本比 `promise` 版本更容易理解。如果忽略 `await` 关键字，代码看起来就像任何其他同步语言，如 `Python`。\r\n\r\n同时 `async/await` 有原生浏览器支持，截至目前，所有主流浏览器都已全面支持异步功能。\r\n\r\n> 需要注意的是 `async/await` 在使用的过程中需要成对出现，如在函数里面要使用 `await` ，就必须将函数定义为 `async` 。\r\n\r\n### async/await 可能会产生误导\r\n\r\n有些文章将 `async/await` 与 `Promise` 进行比较，并声称它是 JavaScript 异步编程发展的下一代，这一点个人觉得有点误导，个人认为 `async/await` 是一种改进，一个语法糖，不会彻底改变编程风格。\r\n\r\n本质上，异步函数仍然是 `promises`，在正确使用异步函数之前，必须了解 `promises`。\r\n\r\n* [Promise.any\\\\(\\\\) 原理解析及使用指南](https://juejin.cn/post/7002490552818073637)\r\n* [Promise.all\\\\(\\\\) 原理解析及使用指南](https://juejin.cn/post/7003713678419705870)\r\n* [Promise.race\\\\(\\\\) 原理解析及使用指南](https://juejin.cn/post/7004786857389064205)\r\n* [Promise.allSettled\\\\(\\\\) 原理解析及使用指南](https://juejin.cn/post/7004089093407637540)\r\n\r\n### async/await 陷阱\r\n\r\n尽管 `await` 可以使代码看起来像同步的，但请记住它们仍然是异步的，必须注意避免过于顺序化。\r\n\r\n```\r\nconst getArticlesAndAuthor = async (authorId) => {\r\n    const articles = await articleModel.fetchAll();\r\n    const author = await authorModel.fetch(authorId);\r\n    return {\r\n        author,\r\n        articles: articles.filter((article) => article.authorId === authorId),\r\n    };\r\n};\r\n```\r\n\r\n这段代码在逻辑上看起来是正确的，然而这是回产生误解。\r\n\r\n1. `await articleModel.fetchAll()` 将等到 `fetchAll()` 返回。\r\n2. 然后 `await authorModel.fetch(authorId)` 将会被立即调用。\r\n\r\n### 错误处理\r\n\r\n使用 `promise`，异步函数有两个可能的返回值：`resolve` 和 `reject`，以用于正常情况使用 `.then()` 和异常情况使用`.catch()`。然而，`async/await` 错误处理就不太好，需要使用 `try...catch` 来捕获异常。\r\n\r\n```\r\nconst getArticlesByAuthorWithAwait = async (authorId) => {\r\n    try {\r\n        const articles = await articleModel.fetchAll();\r\n        return articles.filter((b) => b.authorId === authorId);\r\n    } catch (error) {\r\n        // 错误处理\r\n    }\r\n};\r\n```\r\n\r\n### 总结\r\n\r\n`async/await` 非常强大，但也有一些注意事项。但是如果正确使用它们，还是有助于使代码高效并且高可读。"
    },
    {
        "article_id": "7187270948515479609",
        "snapshot": "",
        "title": "通过js实现函数重载",
        "preview": "有的同学在开发中可能遇到过一个困扰，但是很少有人去解决这个问题，通过本文带你动手实现JavaScript函数重载，来解决这个这个你可能遇到的问题。",
        "author": "JiangHong",
        "view_count": 1193,
        "collect_count": 10,
        "comment_count": 7,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/946f9b02c4f571da1c4102fde3acabee~300x300.image",
        "category": "前端",
        "content": "#### 痛点\r\n有的同学在开发中可能遇到过一个困扰，但是很少有人去解决这个问题，我这用一个例子展现出来\r\n```javascript\r\nconst searcher = {};\r\nsearcher.findAll = () => {\r\n  console.log(\\\"查询所有用户\\\");\r\n};\r\nsearcher.findByName = (name) => {\r\n  console.log(\\\"按照用户名称查询\\\");\r\n};\r\nsearcher.findByFirstNameAndLastName = (firstName, lastName) => {\r\n  console.log(\\\"按照姓和名用户查询\\\");\r\n};\r\n```\r\n可以看到上方的`searcher`对象有三个方法，但是他的查询逻辑是不一样。\r\n`findAll`查询所有用户;`findByName`按照用户名查;`findByFirstNameAndLastName`是按照姓和名查询用户，结构上没任何问题，那问题在哪？，**恶心**因为都是在做查询，但又不得不给每一个函数取不同的名字，因为一旦重名就覆盖了，如果说他们能取一样的名字那该有多好\r\n```js\r\nsearcher.find = () => {\r\n  console.log(\\\"查询所有用户\\\");\r\n};\r\nsearcher.find = (name) => {\r\n  console.log(\\\"按照用户名称查询\\\");\r\n};\r\nsearcher.find = (firstName, lastName) => {\r\n  console.log(\\\"按照姓和名用户查询\\\");\r\n};\r\n```\r\n不传参数就是查所有用户\r\n```js\r\nsearcher.find()\r\n```\r\n给一个参数就是按照用户名来查询\r\n```js\r\nsearcher.find(\\\"aa\\\")\r\n```\r\n给两个参数就是按照用户的姓跟名来查询\r\n```js\r\nsearcher.find(\\\"aa\\\", \\\"bb\\\")\r\n```\r\n到用得时候也是非常的简单，也符合逻逻辑，这个就叫做函数重载</br>\r\n#### 函数重载\r\n函数重载是给函数取同一样的一个函数名，根据你传递不同的参数数量，分别去调用不同的函数\r\n**好处**就在于使用不同的逻辑产生的函数，给他们取一个相同的名字，这样在使用上我只需要记住这个一样的名字就可以了，而不用去记这三个不同的名字，他有效的降低调用函数时产生的心智负担。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20c7c3829234fb2a478f910c7b5c3da~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n但是JS不支持函数重载，所以说如果你写成已上的形式，无论你怎么调用，一定是调用最后一个函数，因为最后一个函数把前面的全部覆盖了</br>\r\n不传参数试一下，你看永远都是走最后一个函数的`log`\r\n```js\r\n    searcher.find() // 按照姓和名用户查询\r\n```\r\n#### 实现\r\n那有什么办法呢？在很早的时候jQuery之父John Resig 他就已经提出了一个想法，我们能不能实现一个方法来帮助我们在js中完成函数重载？</br>\r\n于是他想出了一个`addMethod`方法，就是当我要重载的时，我不直接去定义函数，因为直接定义函数就会出现一个永远只调用最后一个函数的问题，而调用`addMethod`来定义函数，把对象传进去，把函数的名字传进去，把函数的实现传进去，后面依次同理\r\n```js\r\naddMethod(searcher, 'find', () => {\r\n    console.log('查询所有用户')\r\n})\r\naddMethod(searcher, 'find', (name) => {\r\n    console.log('按照用户名称查询')\r\n})\r\naddMethod(searcher, 'find', (firstName, lastName) => {\r\n    console.log('按照姓和名用户查询')\r\n})\r\n```\r\n写成这种格式之后，后面调用`searcher.find()`就能够完成函数重载，问题是这个方法我们得要自己实现，那么如何来实现？ 这个方法他接受三个参数，如果你不加处理的话你可能写成下面函数一样，给对象加一个属性，这个属性等于一个函数，调用这个函数实际上就是在运行定义的实现函数`fn`，把`this`绑定带过去 然后把传递过来的`arguments`带过去\r\n```js\r\nfunction addMethod(object, name, fn) {\r\n  object[name] = function () {\r\n      fn.apply(this, arguments)\r\n  }\r\n}\r\n```\r\n仅仅这么些还是搞不定，因为每次调用`addMethod`最后一次调用一定会把object里面同一个属性给覆盖掉，那么如何处理？看下方代码\r\n```js\r\nfunction addMethod(object, name, fn) {\r\n  const old = object[name];\r\n  object[name] = function () {\r\n    if (arguments.length === fn.length) {\r\n      fn.apply(this, arguments);\r\n    } else if (typeof old === \\\"function\\\") {\r\n      old.apply(this, arguments);\r\n    }\r\n  };\r\n}\r\n```\r\n首先我不传参数走查询所有用户，传一个参数走按照用户名查询，传两个参数按照姓和名查询\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c290801af22c4cc8af7f5a21f438373a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n#### 方法执行分析\r\n直接看方法体有的同学可能不理解其中的巧妙，我来研究一下这个方法并记录一下执行规则</br>\r\n1. **第一次调用**： \r\n 通过 `old` 变量首先保存了之前成员的值，当然这一次保存由于是第一次调用，所以他是一个`undefined`\r\n 然后给`object[name]`赋值了一个新的函数，这个函数在运行的时候做了一个判断,当你传递的实参数量与你定义函数形参数量一致的时候就执行该函数由此可得：</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ad9efa3d084b9f9143431575ce5006~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2. **第二次调用**：关键是否则，判断一下`old`是否是函数，如果是那调用`old`就会执行上面第一次得出的逻辑，同理可得:</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b8bf037f9740b79ab2702e0d093ba9~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n4. **第三次调用**：同理可得：</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cacbdf0a6e2479e81ef8d8d28a62691~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n以上是一个注册的顺序，当我们调用时传递0个参数，他会从最后一个开始执行，当形参数量相等就会直接执行当前的方法，如果不相等就会执行`old`也就是上一个`find`的逻辑，类似于冒泡执行，等到执行到第一次注册的逻辑判断时形参数量相等了，就直接执行第一次注册的方法，执行打印 \\\"查询所有用户\\\"\r\n```js\r\nsearcher.find() // 查询所有用户\r\n```\r\n#### 总结\r\n其实就是用到了闭包，将闭包形成了闭包链把我们传递的方法依次注册。在调用的时候从最后一个有序的去找，用这种非常巧妙的方式，用极少的代码就实现了一个函数重载的效果，函数重载虽然说你不一定能用到，但是通过去解析这个`addMethod`，我们可以感受到有这么智慧的实现方案，肯定对你将来实现某一些东西的时候，有所启发。\r\n#### 参考视频\r\nhttps://v.douyin.com/kPtBbAn/\r\n"
    },
    {
        "article_id": "7189628190715805757",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de3436723ee4c81a78969bfdbe2c624~tplv-k3u1fbpfcp-watermark.image?",
        "title": "静态资源缓存利器——CDN",
        "preview": "结合云文档多版本快照的特性，引入CDN的方式对DB大文本内容读取进行优化，可以用非常低的成本改善现状",
        "author": "码bug的小砖家",
        "view_count": 973,
        "collect_count": 2,
        "comment_count": 2,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/5d592caf3091b27e4e0580a98761d36c~300x300.image",
        "category": "后端",
        "content": "---\r\nhighlight: a11y-dark\r\ntheme: cyanosis\r\n---\r\n# 项目背景\r\n我们这边有一个云文档的项目，为了让用户在编辑过程中的数据能够实时保存在云端，目前采用的是定时全文同步的方式对数据进行保存，在DB保存的是文档多个版本快照的内容。\r\n\r\n## 项目分析\r\n* 文档的文本内容大部分是kb级别大小的，目前直接保存到DB，不管是数据读取还是数据写入，对DB的I/O性能以及网络传输方面，都会产生较大的压力，能否通过一些小成本的改造进行优化呢？\r\n* 每个文档用户只要发生编辑，都会产生多个快照版本，且版本的数据是新增的，而不是更新，具备内容静态特性\r\n\r\n## 文本存储占用情况\r\n对线上数据进行抽样统计，得出大致的存储分布情况，可以看出目前大部分文档内容数据都小于64kb\r\n\r\n| 大小范围 | count | 比例 |\r\n| --- | --- | --- |\r\n| (0, 16kb] | 333172 | 34.34% |\r\n| (16kb, 64kb] | 620820 | 64% |\r\n| (64kb, +∞) | 16069 | 1.66% |\r\n\r\n\r\n# 优化方案\r\n目前针对这个业务场景，我们需要优化的问题有两个，一个是数据的存储，另一个是数据读取。由于篇幅原因，本文先针对数据读取进行优化，存储优化放到下一篇文章哦～\r\n\r\n对于数据读取的优化，我们很容易想到能否通过一些缓存机制来进行优化，且缓存的内容有两个很重要的特性：**大文本** & **静态数据**\r\n* 由于文档快照的数据记录并不会存在更新操作，更新内容会产生新的版本，可以认为一份文档的某一个版本的内容属于一个静态文件\r\n\r\n## CDN（内容分发网络）介绍\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7faddab3c174867bdda82119f83d202~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n[内容分发网络（CDN）](https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/)：是指一组分布在不同地理位置的服务器，协同工作以提供互联网内容的快速交付。\r\n* **缩短网站加载时间：** 通过边缘节点提供的就近访问，可以让访问者体验到更快的页面加载时间，一般来说，网站速度越快，用户停留的时间越长\r\n* **减少带宽成本：** 网站托管的带宽一般是有限的且成本较高，而CDN提供的带宽一般是没有上限且成本低廉的，而且通过就近访问，网络传输的距离也大大缩短，这也是减少带宽成本的原因之一\r\n* **增加内容可用性和冗余：** 大流量或硬件故障可能会扰乱正常的网站功能。由于 CDN 具有分布式特性，因此与许多源服务器相比，CDN 可以处理更多流量并更好地承受硬件故障\r\n* **改善网络安全性：** 增加了CDN之后，用户请求不会直接到业务后端，相当于多了一层代理，在CDN层面可以配置很多安全策略（如 DDoS 缓解、IP、referer 限制等）\r\n\r\n## 方案一：OSS + CDN\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b431d6e2d924b25a1b461d7c4b00ef2~tplv-k3u1fbpfcp-watermark.image?)\r\n### 优缺点分析\r\n* **优点：**\r\n    * 资源存储和数据库分离，释放db压力\r\n    * 资源存储和资源响应放到oss，减轻后端服务的压力\r\n* **缺点：**\r\n    * 后端改造成本大，需要关注哪些版本需要存储到oss（文档只有当前版本是可读的，其他版本只是用于文档修复，大部分时候用不上），做好新旧两种方式的兼容（数据落库、数据返回）\r\n    * oss并不适合存储海量小文件\r\n    * 引入新的依赖，服务的可用性会有所降低（存储服务、OSS），也需要做好重试机制\r\n\r\n### OSS存储小文件的弊端\r\n根据线上已有数据分析，98%的文本内容都是小于64kb的，这个范围对于OSS来说来说算是小文件，成本上没有很大的优势\r\n* OSS不适合存储海量小文件，存储利用率不高（<https://zhuanlan.zhihu.com/p/434780987>）\r\n* 小于64kb的文件对于OSS来说很难进行成本上的优化\r\n    * 如对文件进行生命周期管理，上传时间超过半年的由标准存储转为低频存储，而低频存储中不足64kb的文件按64kb进行收费\r\n        * ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/764c084f0c72429d9381635c6da03ad2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 方案二：DB + CDN ✅\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69cbe30ca3de45909b9905bacfe00d65~tplv-k3u1fbpfcp-watermark.image?)\r\n### 优缺点分析\r\n* **优点：**\r\n    * 改造成本很低，前后端逻辑上不会发生较大的变更，后端也不用关注引用版本的问题（只要文档版本被访问就自动缓存到CDN）\r\n    * 通过CDN缓存内容，可以提高资源的响应速度，也可以大大降低后台服务和db的压力\r\n* **缺点：**\r\n    * 现阶段大文本数据还是存储在MySQL，对数据库存储和后端服务有一定的压力\r\n        * 数据库存储压力\r\n            * 可以将文档快照表进行分库存储，避免查询和写入影响其他表\r\n            * 字段压缩技术\r\n        * 后端服务：在CDN没有命中缓存的情况下，会触发回源操作，此时后端服务需要读取大文本内容到缓存中，QPS大的情况下可能会导致服务异常\r\n            * 进行CDN缓存策略调优，提高缓存命中率\r\n            * 服务拆分部署\r\n\r\n## 结论\r\n优先考虑方案二，在返回文档内容前加一层CDN缓存即可\r\n* 按照目前线上小于64kb的文本内容分布（98%），以及正常文档合理的存储占用来看，这部分存储在数据库不会有很大的问题\r\n* 目前该服务还处于初步阶段，后期肯定会有很多需求是围绕文档内容展开的，后期的需求可能还需要进行二次重构，CDN的方式可以用最小成本达到可观的优化效果\r\n* CDN这种形式不一定是这个功能的最终形态，但这是可以在很长一段时间降低服务和db压力的最低成本的实现\r\n\r\n# CDN缓存优化\r\n增加缓存最主要的目的无非就是加快访问速度、降低源站压力，所以`缓存命中率`是我们比较关心的指标\r\n\r\n**示例：**\r\n* 假设content-url为：`https://{host}/doc-server/{docId}/{versionId}?expires={expires}&signature={sign}`\r\n    * /doc-server/{docId}/{versionId}：资源的path，可以唯一定位一个资源\r\n    * expires：过期时间戳（资源为临时授权访问，有时效性，起放盗链效果）\r\n    * signature：签名，防止篡改资源路径以及过期时间\r\n\r\n## 如何进行缓存优化？\r\nCDN 的缓存命中，我们简单理解就是一个类似 K-V 的映射关系，key为请求的 path+参数，value为对应的资源内容\r\n\r\n以上面示例举例：key为`/doc-server/{docId}/{versionId}?expires={expires}&signature={sign}` \r\n* /doc-server/{docId}/{versionId}：这部分为不变的内容，唯一确定一个资源，作为缓存的key没问题\r\n* expires & signature：过期时间戳以及签名参数并不影响资源内容本身，但却是经常变化的，会大大降低缓存命中\r\n\r\n进行分析之后，可以发现其实优化很简单，我们只要在CDN上配置 expires & signature 参数不参与缓存即可。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d5b5daccdc04d08b92067c17eb8a612~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n一般为了减少回源，我们会在CDN侧配置缓存时间为 7天+，但这又带来了一个问题，expires参数我们本意是临时授权（如2小时），但一旦内容被CDN缓存后，那这个校验就失效了，该链接就可以在CDN缓存失效前无限次访问到资源。\r\n\r\n## 如何解决CDN中链接过期但仍能访问资源的问题？\r\n造成该问题的本质原因就是CDN侧没有我们的 URL鉴权算法，它无法识别链接的有效性，在CDN第一次回源拉取资源的时候，由源站（即我们的后台服务）进行鉴权，之后资源缓存在CDN侧就失去了鉴权能力了\r\n* **方案一：** 使用CDN厂商提供的签名规则，不使用自定义鉴权算法\r\n    * 腾讯云：<https://cloud.tencent.com/document/product/228/30978#4.-.E6.8B.BC.E6.8E.A5-Authorization>\r\n    * 优点：\r\n        * CDN厂商会提供签名sdk，开发简单\r\n        * CDN侧就可以完成鉴权，处理性能高\r\n    * 缺点：\r\n        * 后端服务需要对接CDN的API，有一定的业务侵入\r\n        * 无法利用CDN无状态和易切换的天然优势，如当前CDN厂商出现异常，无法快速切换到其他CDN厂商（不利于降本和高可用）\r\n* **方案二：** 使用自定义鉴权算法，结合CDN的回源鉴权功能 ✅ \r\n    * 回源鉴权：在cdn层面配置鉴权服务器，用户请求到达cdn节点时，cdn节点会将用户的请求原封不动的转发给鉴权服务器，鉴权服务器可以根据请求参数给出鉴权结果 \r\n        * 文档：<https://developer.qiniu.com/fusion/3930/back-to-the-source-authentication>\r\n        * ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2207caaf1064466ba0b4b844ac53b608~tplv-k3u1fbpfcp-watermark.image?)\r\n    * 优点：\r\n        * 算法自定义，后期容易扩展一些业务特性的字段\r\n        * CDN接入规则统一，不会与单一CDN服务商耦合，可以快速进行CDN的切换 ✅\r\n    * 缺点：\r\n        * 回源鉴权需要从CDN通过http访问源站进行鉴权，中间有一定的额外耗时\r\n\r\n"
    },
    {
        "article_id": "7188067538423513144",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ecf2803bad44479ae6b29b1f8fe3bd~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Wasm+vue | 无服务端 录屏、转码、转GIF",
        "preview": "WebAssembly 无服务端实现本地视频转码、屏幕录制、录屏转码、录屏转GIF动图等操作。wasm 作为前端和计算机底层汇编语言直接打交道的媒介，在遇到媒体操作或者大型计算的时候能够以接近本地速度",
        "author": "suke",
        "view_count": 1119,
        "collect_count": 30,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/9cda32321f2b127f04533d1037e039e4~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: juejin\r\n---\r\n\r\n\r\n\r\n`wasm`,全称 `WebAssembly`，官网描述： 一种用于基于堆栈的虚拟机的二进制指令格式。`wasm`被设计为一个可移植的目标，用于编译`C/c++/Rust`等高级语言，支持在web上部署客户端和服务器应用程序。`wasm` 的开发者参考文档可以在 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) 找到。\r\n\r\n用大白话讲就是你用 `C/C++/Rust`等语言写的代码，编译后（这个文件一般以wasm结尾）得到汇编指令，然后通过`JavaScript` 相关 `API`配合将该文件加载到Web容器中，字面理解 `WebAssembly` 就是运行在 `Web 容器`里的 `Assembly`（汇编），你可以理解为一种技术就行，其他的不用纠结。\r\n既然要用它那必然是因为它有自己独特的优势：即提供了一种以接近本地速度在 Web 上运行以多种语言编写的代码的方法，尤其是涉及到 `CPU` 或者`GPU`计算的时候，比如：`媒体编解码`、`深度学习计算`、`图像处理`等场景。而本文中我们就以`媒体操作`为例，看看能玩出什么花样。\r\n\r\n## 演示\r\n\r\n[在线演示地址](https://lav.wangsrbus.cn/)\r\n> 宽带比较低，多等一会等wasm文件加载完毕即可体验哦。\r\n\r\n![GIF.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0cde8f667f94c80a64fa021f0a6a5fd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n## 预备知识\r\n\r\n 1.`wasm` 文件在浏览器中单独是无法玩的，既然是浏览器那必然离不开`JavaScript` 相关的 `API`，因为我们在使用现成的一些编译好的模块的时候一定会有初始化的步骤。\r\n\r\n2.对于 `WebAssembly` 而言，它最终成型的文件就是底层代码，既然是代码那就可以操作内存，相关内存限制为2-4G，[相关文档](https://v8.dev/blog/4gb-wasm-memory#:~:text=Thanks%20to%20recent%20work%20in%20Chrome%20and%20Emscripten%2C,That%E2%80%99s%20up%20from%20the%20previous%20limit%20of%202GB.),但是对于我们使用者而言，内存和我们自己的机器是相关的，如果你的电脑只有4G内存，而且因为其他的程序已经占用了大部分，那么对于wasm代码而言，可以操作的内存就很少了。\r\n\r\n## 实战\r\n\r\n这里我们用已经编译好的包 `FFmpeg.wasm` ,去实现我们Web端的媒体编辑，[FFmpeg官网地址](https://github.com/ffmpegwasm/ffmpeg.wasm)。\r\n首先我们了解下这个包能干什么？\r\n  - 浏览器内存中直接操作文件系统([文件系统接口文档](https://emscripten.org/docs/api_reference/Filesystem-API.html))。\r\n  - 支持原生 FFmpeg 的指令，重点。\r\n  - 编解码支持 h.265/264等，重点。\r\n  \r\n我们在本文中用到的就是前面2条，文件操作和FFmpeg原生指令执行，接下来看看我们要达成的目标。\r\n- 视频转码\r\n- 视频转Gif\r\n- 浏览器文件快捷操作\r\n  \r\n### wasm代码加载\r\n> 初始化加载实例并加载wasm代码文件，这里我们并没有看到怎么去加载wasm代码的，实际上我们使用的这个组件给我们封装好了，内部通过 `WebAssembly`模块的相关JavaScript的 API加载 wasm 汇编码然后去初始化。\r\n```\r\nconst ffmpeg = createFFmpeg({\r\n    log: true,//打开日志\r\n    progress:p=>{console.log(p)},//回调 展示进度\r\n    corePath: new URL('assets/f-core/ffmpeg-core.js', document.location).href,//本地离线wasm代码文件\r\n});\r\nasync function init(){\r\n    await ffmpeg.load();\r\n    console.log(\\\"ffmpeg loaded\\\")\r\n}\r\n```\r\n加载成功则如下显示：\r\n\r\n![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc57cbbe6df47cf9ea9f586f7f9d837~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 文件操作\r\n 因为涉及到转码，那么必然是要对浏览器产生的相关文件进行所谓的 “本地化”操作，拿到二进制流之后，通过文件系统的 API 去本地化到内存文件系统（MEMFS）中，这里的API并不是`FFmpeg.wasm`自己的，而是它去调用了[相关的API](https://emscripten.org/docs/api_reference/Filesystem-API.html)去实现了这个目的，详细的我们不再阐述，因为里面东西还是比较多的。\r\n\r\n以本文Demo操作为例\r\n\r\n- 获取文件二进制流\r\n\r\n```\r\n// file 可以为连接文件 也可以为 二进制的数据\r\nlet data = await fetchFile(this.file)\r\n\r\n```\r\n- 写入MEMFS\r\n  \r\n```\r\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.mp4\\\", data);\r\n\r\n```\r\n- 读取文件到浏览器中\r\n\r\n```\r\n//读取视频数据\r\nlet memfsData = ffmpeg.FS('readFile', 'suke.mp4');\r\n//创建虚拟URL\r\nthis.transcodeUrl = URL.createObjectURL(new Blob([memfsData.buffer], { type: \\\"video/mp4\\\" }));\r\n\r\n```\r\n- 文件系统中删除数据\r\n\r\n```\r\nffmpeg.FS('unlink', 'suke.mp4');\r\n\r\n```\r\n\r\n### 媒体操作\r\n将相关文件本地化到文件系统之后，我们就可以利用 ffmpeg的原生命令去执行转码操作，比如将mp4格式转为avi的\r\n\r\n```\r\n//本地化文件\r\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.file));\r\n//进行转码\r\nawait this.ffmpeg.run(\\\"-i\\\", \\\"suke.avi\\\", \\\"suke.mp4\\\");\r\n//转码完成后读取数据\r\nconst data = this.ffmpeg.FS(\\\"readFile\\\", \\\"suke.mp4\\\");\r\n//获取页面DOM实例，然后挂载虚拟URL\r\nconst video = document.getElementById('playerForTransf');\r\nthis.transcodeUrl = URL.createObjectURL(\r\n    new Blob([data.buffer], { type: \\\"video/mp4\\\" })\r\n);\r\nvideo.src = this.transcodeUrl\r\n```\r\n\r\n\r\n![2222.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee396d21b24342e0af7a5160969f761a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n### 视频转GIF\r\n\r\n这个操作实际上和上一步一样，都是执行的原生ffmpeg的命令，然后输出GIF文件，展示并下载\r\n\r\n```\r\n//GIF时长\r\nlet time = this.formForGifParams.time+\\\"\\\"\r\n//GIF的FPS\r\nlet fps = this.formForGifParams.fps\r\n//GIF的清晰度\r\nlet vh = this.formForGifParams.scale\r\nlet params = `fps=${fps},scale=${vh}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`\r\n//this.chunks 为本地录制屏幕的二进制数据 也可以和文件连接一样 本地化到文件系统中\r\nthis.ffmpeg.FS(\\\"writeFile\\\", \\\"out.mp4\\\", await fetchFile((this.chunks)));\r\n//转换为GIF操作\r\nawait this.ffmpeg.run(\\\"-t\\\", time, \\\"-i\\\", \\\"out.mp4\\\", \\\"-vf\\\",params, \\\"-loop\\\", \\\"0\\\" ,\\\"output.gif\\\");\r\n//读取GIF数据\r\nconst data = this.ffmpeg.FS(\\\"readFile\\\", \\\"output.gif\\\");\r\nconst image = document.getElementById('imagePre');\r\n//本地DOM实例中展示\r\nimage.src = URL.createObjectURL(\r\n    new Blob([data.buffer], { type: \\\"image/gif\\\" })\r\n);\r\n//操作完成后删除文件\r\nthis.ffmpeg.FS('unlink','out.mp4')\r\n```\r\n\r\n\r\n![333.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48b2fc4133254e8fbffbc1580a2a8123~tplv-k3u1fbpfcp-watermark.image?)\r\n### 获取录屏的二进制数据并本地化\r\n\r\n```\r\nasync function screenRecord(){\r\n    ElNotification({\r\n        title: '温馨提示',\r\n        message: '开始录屏，请选择要录制的窗口',\r\n        type: 'success',\r\n    })\r\n    stream = await navigator.mediaDevices.getDisplayMedia(mediaConstraints);\r\n    var options = {mimeType: recordMediaType};\r\n    mediaRecorder = new MediaRecorder(stream, options);\r\n    mediaRecorder.start();\r\n    //停止录屏后触发保存\r\n    mediaRecorder.ondataavailable = async function(e) {\r\n        console.log(\\\"data available\\\", e.data);\r\n        chunks.value = e.data\r\n        //这一步并不一定要在这里本地化到文件系统 等需要媒体操作的时候再进行最佳\r\n        this.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.chunks));\r\n\r\n    }\r\n    recordStatus.value = mediaRecorder.state\r\n}\r\n\r\n\r\n```\r\n\r\n### 获取摄像头录制的二进制数据并本地化\r\n\r\n```\r\nasync function localCamRecord(){\r\n    ElNotification({\r\n        title: '温馨提示',\r\n        message: '开始摄像头画面录制',\r\n        type: 'success',\r\n    })\r\n    stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\r\n    var options = {mimeType: recordMediaType};\r\n    mediaRecorder = new MediaRecorder(stream, options);\r\n    mediaRecorder.start();\r\n    //停止录屏后触发保存\r\n    mediaRecorder.ondataavailable = async function(e) {\r\n        console.log(\\\"data available\\\", e.data);\r\n        chunks.value = e.data\r\n        //同上 按照实际情况处理\r\n        this.ffmpeg.FS(\\\"writeFile\\\", \\\"suke.avi\\\", await fetchFile(this.chunks));\r\n    }\r\n    recordStatus.value = mediaRecorder.state\r\n}\r\n```\r\n\r\n\r\n## 完整代码\r\n\r\n[完整代码](https://gist.github.com/wangsrGit119/46380e8bedc48157037c4ca622b7f30e)\r\n\r\n\r\n\r\n## 最后\r\n\r\n- 上面涉及到了和摄像头、流媒体相关的，如果大家对WebRTC感兴趣的话可以看看掘金小册[使用WebRTC搭打造私有化直播会议系统](https://juejin.cn/book/7168418382318927880)\r\n- 有问题评论区一起讨论\r\n"
    },
    {
        "article_id": "7179571693176750137",
        "snapshot": "https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/939df20f6f0c4ee5ad3d2ed4435381f9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "程序员年底好找工作吗？",
        "preview": "到年底了除非必要不要辞职！除非必要不要辞职！除非必要不要辞职！ 重要的事情说三遍。 很多老哥问我：工作干不下去了，这会儿辞职找工作合适吗？今天就来为大家解答一下，为什么不要在年底辞职，找工作。 影响年",
        "author": "程序员范某",
        "view_count": 19376,
        "collect_count": 64,
        "comment_count": 86,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/1f62eb22d1e7014278c6cdfcbf010a13~300x300.image",
        "category": "代码人生",
        "content": "**到年底了除非必要不要辞职！除非必要不要辞职！除非必要不要辞职！**\r\n\r\n重要的事情说三遍。\r\n\r\n很多老哥问我：工作干不下去了，这会儿辞职找工作合适吗？今天就来为大家解答一下，为什么不要在年底辞职，找工作。\r\n\r\n影响年终最后一笔大钱\r\n----------\r\n\r\n大家要知道，年终奖一般是在年底或是在次年统一结算，如果你在这时候离职，新公司的年终奖拿不到，连原公司的年终奖也大概率不保了。  \r\n  \r\n一般年终奖会是1~3个月工资，某些效益好的大厂甚至会给到6个月的工资，如果你在这时候辞职，那不是妥妥的亏大了吗？\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ebd62b91f84c3c89fddb96a8c6d226~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n年前HC少，僧多粥少\r\n----------\r\n\r\n年终一般是公司进行年度结算的时候，除非有非常紧急或是突然的需求，否则不会增设HC，这时候就是一个僧多粥少的卖方市场，不利于你找工作，也不利于你找到好工作。\r\n\r\n不过优点是，如果这时候还在招人的公司，需求一般十分迫切，运气好的话也可以拿到好的offer，但我们没必要拿小概率去赌，对不对？\r\n\r\n经济下行，市场萎缩\r\n---------\r\n\r\n目前全球大多属于经济下行的状态，在这个情况下，大量招人的企业已经寥寥可数，而初创公司也各种裁员降薪，整个求职市场确实不太乐观，在这种情况下，盲目辞职可能会让你断了现金流，后悔不迭。\r\n\r\n**给大家的意见是：能苟着，就苟着吧！**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b79318e6a4a4fc58351caf57292b505~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n程序员在年前，如何自救？\r\n------------\r\n\r\n道理我都懂，但这个公司太操蛋，实在是干不下去了，该怎么办呢？这里给大家三点小建议，希望能帮到兄弟们！  \r\n  \r\n**a.初阶：态度积极，不要表现得孤僻和没干劲**。公司开人，先开的是能力一般的人，还是在公司传播负能量的人呢？据我所知，大多数选择的是后者，如果你的能力确实有限，那么我建议你在领导面前尽量表现得积极有干劲，所谓伸手不打笑脸人，至少你能保住工作。\r\n\r\n**b.进阶：揽有意义的活，为升职加薪做准备**。年终也是个考核期，如果你想趁此机会升职加薪，那么一定要在这个公司干出成果，公司一些你看好的项目，在自己的能力范围内可以去尝试一波，一来为你的简历添砖加瓦，二来也能让你切切实实的提升自己的技术水平。\r\n\r\n**c.高阶：成为有话语权的人，学会谈薪。**如果你在这个公司已经是一个有话语权的人，甚至是团队里不可或缺的存在，那就大胆点，学会谈薪，给大家分享我一个压箱底的谈薪技巧：  \r\n**首先，确定自己的核心需求**：升职？加薪？两者都要的情况下谁是首位？  \r\n**其次，了解自己在公司的地位**，是否有可以替代你的人？你的工资是否低于跟你差不多能力的人？是否有可谈的空间？  \r\n**再者，跟领导谈心**。套路是这样的：表达对公司的感谢，表示在这一年里学会了很多，获得了很多的成长，着重提一提自己的工作成果，简略提一下自己还可以进步的空间。跟领导说自己的困惑：感觉自己做了很多，却没有拿到相应的回报等。  \r\n**最后，跟公司表决心**：如果公司能给到自己xx的职位or薪资，你将会……（有计划/有阶段）去实现明年的目标。  \r\n  \r\n最后，再给大家传授一个小技巧：八小时内的收入难提升，八小时外的收入却大有可为。趁着年底没有太多的新需求新业务，去**程序员客栈、码市、devnors、程序邦**等程序员兼职外包平台做点项目，每个月补贴点家用，也能让自己过个好年。\r\n\r\n方法总比困难多，祝点赞的各位都能在年底收获一笔意料之外的大钱！\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491fd8b24f484df293fe60fea93595e0~tplv-k3u1fbpfcp-zoom-1.image)"
    },
    {
        "article_id": "7163081193603203109",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd827c55e55448c8dd96c63c0533313~tplv-k3u1fbpfcp-watermark.image?",
        "title": "我回来了",
        "preview": "直到现在，我一直相信着“只要技术可以，学历是不重要的”。这几个月去面试，现实狠狠给我打了一脸，HR看到大专，直接就下一个，不符合要求，尽管你的技术已达公司门槛，所以，大专真的是连门槛都过不了。",
        "author": "Dignity_呱",
        "view_count": 20222,
        "collect_count": 46,
        "comment_count": 168,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/5c6084ef8bfcf6e37087a1455a905668~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\nhighlight: arduino-light\r\n\r\n---\r\n\r\n## 前言\r\n\r\n- [常网IT](http://zhengzemin.cn:3000)（内含常用网站、IT知识、美食等主题，承诺一直维护放心收藏使用）戳我呀！\r\n- [常网IT源码](https://github.com/git-Dignity/vueAndTsAndKoa2)上线啦！\r\n\r\n---\r\n\r\n> 11.5，全国考试，发现竟与很多奶爸同考。\r\n\r\n![3.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02abae0233ad452e8395edeb4a53ce3d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n\r\n\r\n## 寒\r\n\r\n今年，已感受寒气的“寒”了，海底捞大学生活动改革，疫情常态化，开展刚结束的二十大，多亏考政治，对国家大事开始关注，对从封建社会走向社会主义现代化的过程有了一定的认识。大到国家，小到住的附近美食店铺倒闭。\r\n\r\n相信大家都知道很多大厂都在裁员，但其实小公司更是顶不住疫情的压力，所以，请大家先苟着吧，被叫“苟王”也算是已是识时务者为俊杰了。\r\n\r\n直到现在，我一直相信着“只要技术可以，学历是不重要的”。这几个月去面试，现实狠狠给我打了一脸，HR看到大专，直接就下一个，不符合要求，尽管你的技术已达公司门槛，所以，大专真的是连门槛都过不了。\r\n\r\n兄弟们，我先升为敬，我开始在升学历了😁，我也给各位大专生一个建议，去升学历吧，未来还很长，可能不止是IT这条路需要，日后若有其他好机会，就因你不是本科生，就白白浪费了机会，得不偿失了呀！\r\n\r\n还未读大学的年轻人，奉劝应重视学历，学历是一块敲门砖，不要以为有一技之长，就心高气傲，到时候连门槛都过不了。\r\n\r\n考试的时候，遇到形形色色的不同阶段的年龄，不希望年少不努力，有了家庭还要与年轻人一起去考试，年轻的时候，有时间就先为以后铺路吧。\r\n\r\n\r\n![2.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b83ebdbbf104b8fbb4f9dbafbda710b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 备\r\n\r\n这几个月一直在备考，在这期间，有学不下去，有浮躁过，有抱怨过怎么这么难，后面找对方法，如果你觉得你现在做的事情很费劲，那一定是方法不对。\r\n\r\n知道背后的原理，明白为何这处是如此，如果给你设计，你怎么设计，学会换位思考，便柳暗花明又一村。\r\n\r\n现在考完试了，突然一直在做的事情不用做了，不知所言，平时早上七点起来学习，上班交通期间碎片化学习，午休，下班交通时间，回到家，一点一点的时间捡起，日积月累，大体系也就啃下了。\r\n\r\n没有天资聪明，只有刻意练习。有人说牛顿好厉害啊，发现了万有引力，力的相互作用。那你可能不知道牛顿对知识有多疯狂，有一次，他去买菜的时候，穿着很随简，走在路上的时候，突然想起问题的方案，立马跑回家，拿起笔就赶紧记下来，牛顿有多专注，就有多被后人称赞。\r\n\r\n如果可以，希望考试能通过，明年不想回到熟悉的考场。主要是想给年轻人一个机会。（每年的名额都是有限的🍅）\r\n\r\n\r\n## 捡\r\n\r\n前几个月准备面试，系统的复习了一遍前端体系。发现复习的时候，之前懵懵懂懂的知识，突然就豁然开朗，更深入明白了一些Vue的一些原理，作者为何这样设计，用的时候为什么会出现这个问题，后面会慢慢总结输出文章。\r\n\r\n确实温故而知新，可以为师矣。每次重新看，总能看出之前不一样的角度。这可能就是随着实战经验越来越丰富，所悟到的广度不同吧，当然，我还是前端的学徒者，还要向各位大佬学习。\r\n\r\n\r\n![4.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d07d664b02bc48e790f6c31fb732254a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 天\r\n\r\n这两天广州海珠区好严重，海珠挺住！\r\n\r\n我天选打工人，旁边隔壁村封，我村依旧通罗马。可能知道我爱上班。\r\n\r\n\r\n## 避\r\n\r\n七八月的时候，趁着疫情还不严重的时候，打卡了一个外省贵州，选贵州是因为七八月的广东太热了，去贵州避暑，广东穿短袖，在贵州可以穿长袖了；广东40度，贵州20度。贵州给我的感觉很民族，少了些城市的喧嚣，有时候也要慢下来感受世界。\r\n\r\n\r\n梵天净土，鸿运金顶。\r\n\r\n佛光满天，万事顺遂。\r\n\r\n![5.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8cb9f0c855e45ffbac9ccbbc3dad3ab~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n## 后记\r\n\r\n不知道大家软考考的怎么样，相信考的都会，蒙的都对吧😋。\r\n\r\n希望后面的日子，不会像前半年一样，很多事情堆在一起，相信接下来也会花更多的时间输出文章，毕竟涨了一年的知识点，很想和大家擦出知识的火花。\r\n\r\n我会尽量保持输出文章，希望大家可以关注一下。\r\n\r\n共勉！\r\n\r\n🙋 已有很多此类文章，为何你还要写一遍呢？\r\n\r\n学习就好比是座山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。\r\n\r\n\r\n\r\n\r\n\r\n> 👍 如果对您有帮助，您的点赞是我前进的润滑剂。\r\n\r\n \r\n\r\n\r\n\r\n## 以往推荐\r\n\r\n [优化了三年经验者的Echarts卡顿](https://juejin.cn/post/7036177574514393119)\r\n\r\n [前端仔，快把dist部署到Nginx上](https://juejin.cn/post/7022812216848023560)\r\n \r\n [多图详解，一次性啃懂原型链（上万字）](https://juejin.cn/post/7010942653915201543)\r\n\r\n [老湿说的万物皆对象，你也信？](https://juejin.cn/post/6999452525703364622)\r\n\r\n [Vue-Cli3搭建组件库](https://juejin.cn/post/6890116253449453575)\r\n\r\n [Vue实现动态路由（和面试官吹项目亮点）](https://juejin.cn/post/6872344841293037582)\r\n\r\n [项目中你不知道的Axios骚操作（手写核心原理、兼容性）](https://juejin.cn/post/6863745313711226887)\r\n\r\n [VuePress搭建项目组件文档](https://juejin.cn/post/6854573219773415437)\r\n\r\n [vue-typescript-admin-template后台管理系统](https://juejin.cn/post/6844904115349241863)\r\n\r\n \r\n \r\n \r\n\r\n\r\n\r\n## 原文链接\r\n\r\n[https://juejin.cn/post/7163081193603203109/](https://juejin.cn/post/7163081193603203109/)\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "article_id": "7186041272858050620",
        "snapshot": "https://k8scat.com/images/2023-01-08-06-09-13.png",
        "title": "百度网盘竟会占用 ESC 键！",
        "preview": "百度网盘占用 `ESC` 键导致 Mac 上的所有软件无法直接使用 `ESC` 键，需要结合使用 `Fn + ESC` 两个键的方式实现原本 `ESC` 键的功",
        "author": "K8sCat",
        "view_count": 6504,
        "collect_count": 4,
        "comment_count": 3,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/4e05968826f11c599a9d294b6fbd793f~300x300.image",
        "category": "开发工具",
        "content": "\r\n百度网盘占用 `ESC` 键导致 Mac 上的所有软件无法直接使用 `ESC` 键，需要结合使用 `Fn + ESC` 两个键的方式实现原本 `ESC` 键的功能，比如在使用 `vim` 时将无法直接使用 `ESC` 退出编辑模式。\r\n\r\n<!--more-->\r\n\r\n### 排查问题\r\n\r\n这个问题困扰了我几天，由于不能直接使用 `ESC` 键打破了我长期一贯的使用方式，根本无法接受，迫使我花时间去排查导致这个问题的原因，最终定位到是百度网盘软件的问题。\r\n\r\n是因为无意之下在设置网盘的时候开启了 **快捷上传插件**：\r\n\r\n![](https://k8scat.com/images/2023-01-08-05-28-50.png)\r\n\r\n该功能在开启的时候会提示授权 **\\\"辅助功能\\\"** 权限，当时没多想，就直接给了权限，而正是因为这个权限，它才可以做到占用 `ESC` 键，\\\"辅助功能\\\"权限包含了键盘相关的配置能力：\r\n\r\n![](https://k8scat.com/images/2023-01-08-05-28-01.png)\r\n\r\n### 解决方式\r\n\r\n注意，仅仅是禁用 **快捷上传插件** 是不能彻底解决 `ESC` 键被占用的问题的，重启百度网盘也无济于事。\r\n\r\n如果还想用百度网盘的话，需要卸载网盘重新安装才行，卸载前建议先安装[腾讯柠檬清理工具](https://lemon.qq.com/)，这样在卸载的时候可以同时清理掉残留的一些文件。\r\n\r\n总结来说，后续需要多加关注软件获取的权限，以及出现问题时可以通过关闭某些软件来排查定位问题。\r\n\r\n\r\n## 文章说明\r\n\r\n原文地址: [百度网盘竟会占用 ESC 键！](https://k8scat.com/posts/tools/baidu-disk-occupied-esc-key/)，转载请标明来源。\r\n\r\n本文由 [Articli](https://github.com/k8scat/Articli.git) 工具自动发布。\r\n"
    },
    {
        "article_id": "7170850066473680927",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee6744e009e4fa2bfbf2b89ab15a78b~tplv-k3u1fbpfcp-watermark.image?",
        "title": "为什么我在公司里访问不了家里的电脑？",
        "preview": "上篇文章「为什么我们家里的IP都是192.168开头的？」提到，因为IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为局域网和广域网，将IP分为了私有IP和公网IP，一个局域网里",
        "author": "小白debug",
        "view_count": 14408,
        "collect_count": 230,
        "comment_count": 49,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/57eb1e789b5e8b164056a7294fd9fece~300x300.image",
        "category": "后端",
        "content": "\r\n> 本文为掘金社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n\r\n上篇文章[「为什么我们家里的IP都是192.168开头的？」](https://juejin.cn/post/7169388138383540238)提到，因为IPv4地址有限，最大42亿个。为了更好的利用这有限的IP数量，网络分为**局域网和广域网**，将IP分为了**私有IP和公网IP**，一个局域网里的N多台机器都可以**共用一个公网IP**，从而大大增加了\\\"可用IP数量\\\"。\r\n\r\n![收发数据就像收发快递](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f56dc9faae764062ba24d3ae399cb13d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当我们需要发送网络包的时候，在IP层，需要填入源IP地址，和目的IP地址，也就是对应快递的发货地址和收货地址。\r\n\r\n![IP报头里含有发送和接收IP地址](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fbcfc9ab9914f4bbbd3303b21d56488~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是我们家里的局域网内，基本上都用`192.168.xx.xx`这样的**私有IP**。\r\n\r\n如果我们在发送网络包的时候，这么填。对方在回数据包的时候该怎么回？毕竟千家万户人用的都是`192.168.0.1`，网络怎么知道该发给谁？\r\n\r\n所以肯定需要将这个`192.168.xx`**私有IP转换成公有IP**。\r\n\r\n因此在上篇文章最后，留了这么个问题。局域网内用的是私有IP，公网用的都是公有IP。一个局域网里的私有IP想访问局域网外的公有IP，必然要做个IP转换，这是在哪里做的转换呢？\r\n\r\n![私有IP和公有IP在哪进行转换](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47bfab3e32f24cc4b8bf4a696e21e81e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n答案是**NAT设备**，全称**N**etwork **A**ddress **T**ranslation，网络地址转换。基本上家用路由器都支持这功能。\r\n\r\n我们来聊下它是怎么工作的。\r\n\r\n### NAT的工作原理\r\n\r\n为了简单，我们假设你很富，你家里分到了一个公网IP地址 `20.20.20.20`，对应配到了你家自带NAT功能的**家用路由器上**，你家里需要上网的设备有很多，比如你的手机，电脑都需要上网，他们构成了一个**局域网**，用的都是**私有IP**，比如`192.168.xx`。其中你在电脑上执行`ifconfig`命令，发现家里的电脑IP是`192.168.30.5`。 你要访问的公网IP地址是`30.30.30.30`。\r\n\r\n于是就有下面这样一张图\r\n\r\n![内网IP访问公网IP](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4d4b6a2842478d837caca152823d9a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n当你准备发送数据包的时候，你的电脑内核协议栈就会构造一个IP数据包。这个IP数据包报头里的**发送端**IP地址填的就是`192.168.30.5`，**接收端**IP地址就是`30.30.30.30`。将数据包发到NAT路由器中。\r\n\r\n此时NAT路由器会将IP数据包里的**源IP地址**修改一下，私有IP地址`192.168.30.5`改写为公网IP地址`20.20.20.20`，这叫**SNAT**（**S**ource **N**etwork **A**ddress **T**ranslation，源地址转换）。并且还会在NAT路由器内部留下一条 `192.168.30.5 -> 20.20.20.20`的映射记录，这个信息会在后面用到。之后IP数据包经过公网里各个路由器的转发，发到了接收端`30.30.30.30`，到这里**发送流程**结束。\r\n\r\n![SNAT](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73e1a9caf8574c83bd167bc87237b38b~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果接收端处理完数据了，需要发一个响应给你的电脑，那就需要将**发送端**IP地址填上自己的`30.30.30.30`，将**接收端**地址填为你的公网IP地址`20.20.20.20`，发往NAT路由器。NAT路由器收到公网来的消息之后，会检查下自己之前留下的映射信息，发现之前留下了这么一条 `192.168.30.5 -> 20.20.20.20`记录，就会将这个数据包的**目的IP地址**修改一下，变成内网IP地址`192.168.30.5`, 这也叫`DNAT`（**D**estination **N**etwork **A**ddress **T**ranslation，目的地址转换）。 之后将其转发给你的电脑上。\r\n\r\n![DNAT](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b4cff8cea9e4823ab39c74ff37d9efc~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n整个过程下来，NAT悄悄的改了IP数据包的发送和接收端IP地址，但对真正的发送方和接收方来说，他们却**对这件事情，一无所知**。\r\n\r\n这就是NAT的工作原理。\r\n\r\n<br>\r\n\r\n### NAPT的原理\r\n\r\n到这里，相信大家都有一个很大的疑问。\r\n\r\n局域网里并不只有一台机器，局域网内  每台机器都在NAT下留下的映射信息都会是 `192.168.xx.xx -> 20.20.20.20`，发送消息是没啥事，但**接收**消息的时候就不知道该回给谁了。\r\n\r\n![NAT的问题](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a36c95dc0bb54f748e1ad759b185fbf3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这问题相当致命，因此**实际上大部分时候不会使用普通的NAT**。\r\n\r\n那怎么办呢？\r\n\r\n问题出在我们没办法区分内网里的多个网络连接。\r\n\r\n于是乎。\r\n\r\n我们可以**加入其他信息去区分内网里的各个网络连接，很自然就能想到端口。**\r\n\r\n但IP数据包（**网络层**）本身是没有端口信息的。常见的**传输层**协议TCP和UDP数据报文里才有**端口**的信息。\r\n\r\n![TCP报头有端口号](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b228a4bc90fd4376b0d2d864844e6c19~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n![UDP报头也有端口号](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b581ec0e12454fa86a38a5d39cb296~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n于是流程就变成了下面这样子。\r\n\r\n当你准备发送数据包的时候，你的电脑内核协议栈就会先构造一个TCP或者UDP数据报头，里面写入端口号，比如发送端口是`5000`，接收端口是`3000`，然后在这个基础上，加入IP数据报头，填入发送端和接收端的IP地址。\r\n\r\n那数据包长这样。\r\n\r\n![数据包的构成](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf46e3b3dabc42ec86fa01ffc4622132~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n假设，**发送端**IP地址填的就是`192.168.30.5`，**接收端**IP地址就是`30.30.30.30`。\r\n\r\n将数据包发到NAT路由器中。\r\n\r\n此时NAT路由器会将IP数据包里的**源IP地址和端口号**修改一下，从`192.168.30.5:5000`改写成`20.20.20.20:6000`。并且还会在NAT路由器内部留下一条 `192.168.30.5:5000 -> 20.20.20.20:6000`的映射记录。之后数据包经过公网里各个路由器的转发，发到了接收端`30.30.30.30:3000`，到这里**发送流程**结束。\r\n\r\n![NAPT发送数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5ab3e6ce5694a0d929467e5bd339b45~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n接收端响应时，就会在数据包里填入**发送端**地址是`30.30.30.30:3000`，将**接收端**是`20.20.20.20:6000`，发往NAT路由器。NAT路由器发现下自己之前留下过这么一条 `192.168.30.5:5000 -> 20.20.20.20:6000`的记录，就会将这个数据包的**目的IP地址和端口**修改一下，变回原来的`192.168.30.5:5000`。 之后将其转发给你的电脑上。\r\n\r\n![NAPT接收数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae48aebd46c24cb8a89117f73f5c2e66~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n如果局域网内有多个设备，他们就会映射到不同的公网端口上，毕竟端口最大可达65535，完全够用。这样大家都可以相安无事。\r\n\r\n像这种同时转换**IP和端口**的技术，就是**NAPT**（Network Address Port Transfer , **网络地址端口转换** ）。\r\n\r\n看到这里，问题就来了。\r\n\r\n那这么说**只有用到端口的网络协议才能被NAT识别出来并转发？**\r\n\r\n但这怎么解释`ping`命令？ping基于ICMP协议，而ICMP协议报文里并不带`端口`信息。我依然可以正常的ping通公网机器并收到回包。\r\n\r\n![ping报头](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aefa2adffd64e3582087a291b6c70e0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n事实上针对ICMP协议，NAT路由器做了特殊处理。ping报文头里有个`Identifier`的信息，它其实指的是放出ping命令的**进程id**。\r\n\r\n对NAT路由器来说，这个`Identifier`的作用就跟`端口`一样。\r\n\r\n另外，当我们去抓包的时候，就会发现有两个`Identifier`，一个后面带个`BE（Big Endian）`，另一个带个`LE（Little Endian）`。\r\n\r\n其实他们都是**同一个数值**，只不过**大小端不同**，读出来的值不一样。就好像同样的数字345，反着读就成了543。这是为了兼容不同操作系统（比如linux和Windows）下大小端不同的情况。\r\n\r\n![1667783441963](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad0e3a3e87744ee84fcdcdc7fcc7365~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 内网穿透是什么\r\n\r\n看到这里，我们大概也发现了。使用了NAT上网的话，前提得**内网机器主动请求公网IP**，这样NAT才能将内网的**IP端口**转成外网**IP端口**。\r\n\r\n反过来公网的机器想主动请求内网机器，就会被拦在NAT路由器上，此时由于NAT路由器并没有任何相关的IP端口的**映射记录**，因此也就不会转发数据给内网里的任何一台机器。\r\n\r\n举个现实中的场景就是，你在你家里的电脑上启动了一个HTTP服务，地址是192.168.30.5:5000，此时你在公司办公室里想通过手机去访问一下，却发现访问不了。\r\n\r\n那问题就来了，有没有办法让外网机器访问到内网的服务？\r\n\r\n有。\r\n\r\n大家应该听过一句话叫，\\\"**没有什么是加中间层不能解决的，如果有，那就再加一层**\\\"。\r\n\r\n放在这里，依然适用。\r\n\r\n说到底，因为NAT的存在，我们只能从内网主动发起连接，否则NAT设备不会记录相应的映射关系，没有映射关系也就不能转发数据。\r\n\r\n所以我们就在**公网上**加一台服务器x，并暴露一个访问域名，再让内网的服务**主动**连接服务器x，这样NAT路由器上就有对应的**映射关系**。接着，所有人都去访问服务器x，服务器x将数据转发给内网机器，再原路返回响应，这样数据就都通了。这就是所谓的**内网穿透**。\r\n\r\n像上面提到的服务器x，你也不需要自己去搭，已经有很多现成的方案，花钱就完事了，比如花某壳。\r\n\r\n![内网穿透](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acfea4e74fe24e2caa9c86b8258c6195~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n到这里，我们就可以回答文章标题的问题。\r\n\r\n**为什么我在公司里访问不了家里的电脑？**\r\n\r\n那是因为家里的电脑在局域网内，局域网和广域网之间有个NAT路由器。由于NAT路由器的存在，外网服务无法主动连通局域网内的电脑。\r\n\r\n#### 两个内网的聊天软件如何建立通讯\r\n\r\n好了，问题就叒来了。\r\n\r\n我家机子是在我们小区的局域网里，班花家的机子也是在她们小区的局域网里。都在局域网里，且NAT只能从内网连到外网，那我电脑上登录的QQ是怎么和班花电脑里的QQ连上的呢？\r\n\r\n![两个局域网内的服务无法直接连通](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7277608fb1304aa8969af41c072e3a70~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n上面这个问法其实是存在个误解，误以为两个qq客户端应用是直接建立连接的。\r\n\r\n然而实际上并不是，两个qq客户端之间还隔了一个服务器。\r\n\r\n![聊天软件会主动与公网服务器建立连接](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/762b85bf38dd488082e38429fc735d97~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n也就是说，两个在内网的客户端登录qq时都会**主动**向公网的聊天服务器建立连接，这时两方的NAT路由器中都会记录有相应的映射关系。当在其中一个qq上发送消息时，数据会先到服务器，再通过服务器转发到另外一个客户端上。反过来也一样，通过这个方式让两台内网的机子进行数据传输。\r\n\r\n#### 两个内网的应用如何直接建立连接\r\n\r\n上面的情况，是两个客户端通过**第三方服务器**进行通讯，但有些场景就是要**抛开第三端**，直接进行两端通信，比如P2P下载，这种该怎么办呢？\r\n\r\n这种情况下，其实也还是离不开第三方服务器的帮助。\r\n\r\n假设还是A和B两个**局域网内**的机子，A内网对应的NAT设备叫`NAT_A`，B内网里的NAT设备叫`NAT_B`，和一个第三方服务器`server`。\r\n\r\n流程如下。\r\n\r\n**step1和2**: A主动去连server，此时A对应的`NAT_A`就会留下A的内网地址和外网地址的**映射关系**，server也拿到了A对应的外网IP地址和端口。\r\n\r\n**step3和4**: B的操作和A一样，主动连第三方server，`NAT_B`内留下B的内网地址和外网地址的**映射关系**，然后server也拿到了B对应的外网IP地址和端口。\r\n\r\n**step5和step6以及step7**: 重点来了。此时server发消息给A，让A主动发`UDP`消息到B的外网IP地址和端口。此时NAT_B收到这个A的UDP数据包时，这时候**根据NAT_B的设置不同**，导致这时候**有可能**NAT_B能直接转发数据到B，那此时A和B就通了。但也**有可能不通**，直接丢包，不过丢包没关系，这个操作的**目的是**给NAT_A上留下**有关B的映射关系**。\r\n\r\n**step8和step9以及step10**: 跟step5一样熟悉的配方，此时server再发消息给B，让B主动发`UDP`消息到A的外网IP地址和端口。NAT_B上也留下了关于A到映射关系，这时候由于之前NAT_A上有过关于B的映射关系，此时NAT_A就能正常接受B的数据包，并将其转发给A。到这里A和B就能正常进行数据通信了。这就是所谓的**NAT打洞**。\r\n\r\n**step11**: 注意，之前我们都是用的**UDP数据包**，目的只是为了在两个局域网的NAT上**打个洞**出来，实际上大部分应用用的都是TCP连接，所以，这时候我们还需要在A主动向B发起TCP连接。到此，我们就完成了两端之间的通信。\r\n\r\n![NAT打洞](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e6017d99a24f7f9b856101602996df~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n这里估计大家会有疑惑。\r\n\r\n##### 端口已经被udp用过了，TCP再用，那岂不是端口重复占用（address already in use）？\r\n\r\n其实并不会，端口重复占用的报错**常见于**两个TCP连接在不使用`SO_REUSEADDR`的情况下，重复使用了某个IP端口。而UDP和TCP之间却不会报这个错。之所以会有这个错，主要是因为在一个linux内核中，内核收到网络数据时，会通过五元组（`传输协议，源IP，目的IP，源端口，目的端口`）去唯一确定数据接受者。当五元组都一模一样的时候，内核就不知道该把数据发给谁。而UDP和TCP之间\\\"传输协议\\\"不同，因此五元组也不同，所以也就不会有上面的问题。![五元组](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf913a60b03646a2b302803b5e3046d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n##### NAPT还分为好多种类型，上面的nat打洞方案，都能成功吗？\r\n\r\n关于NAPT，确实还细分为好几种类型，比如完全锥形NAT和限制型NAT啥的，但这并不是本文的重点。所以我就略过了。我们现在常见的都是锥形NAT。上面的打洞方案适用于大部分场景，这其中包括限制最多的**端口受限锥形NAT**。\r\n\r\n![1668247032737](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b6562c1506844799951df504982d46e~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n### 总结\r\n\r\n- IPV4地址有限，但通过NAT路由器，可以使得整个内网N多台机器，对外只使用一个公网IP，大大节省了IP资源。\r\n- 内网机子**主动**连接公网IP，中间的NAT会将内网机子的内网IP转换为公网IP，从而实现内网和外网的数据交互。\r\n- 普通的NAT技术，只会修改网络包中的发送端和接收端IP地址，当内网设备较多时，将有可能导致冲突。因此一般都会使用NAPT技术，同时修改发送端和接收端的**IP地址和端口**。\r\n- 由于NAT的存在，公网IP是无法访问内网服务的，但通过内网穿透技术，就可以让公网IP访问内网服务。一波操作下来，就可以在公司的网络里访问家里的电脑。\r\n\r\n最后留个问题，有了NAT之后，原本并不富裕的IPv4地址突然就变得非常够用了。\r\n\r\n那我们为什么还需要IPv6？\r\n\r\n另外IPv6号称地址多到每粒沙子都能拥有自己的IP地址，那我们还需要NAT吗？\r\n\r\n### 最后\r\n\r\n最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。\r\n\r\n我有个不成熟的请求。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6e079f472e146c18b4019448b6a8b99~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"\\\" width=\\\"30%\\\" />\r\n\r\n<br>\r\n\r\n**离开广东好长时间了，好久没人叫我靓仔了。**\r\n\r\n大家可以在**评论区**里，叫我一靓仔吗？\r\n\r\n最近评论区里叫我diao毛的兄弟越来越多了。\r\n\r\nso emo. 哪有什么diao毛，在你面前的，不过是一个漂泊在外，思念故乡的可怜打工人而已。\r\n\r\n所以。\r\n\r\n我这么善良质朴的愿望，能被满足吗？\r\n\r\n#### 别说了，一起在知识的海洋里呛水吧"
    },
    {
        "article_id": "7147529288164573192",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9891b64350d4a2d923e8101fc3fce16~tplv-k3u1fbpfcp-watermark.image?",
        "title": "用CSS给健身的女朋友做一个喝水记录本",
        "preview": "事情是这样的，由于七八月份的晚上时不时就坐在地摊上开始了喝酒撸串的一系列放肆的长肉肉项目。 这不，前段时间女朋痛下决心（心血来潮）地就去报了一个健身的私教班",
        "author": "dudoit",
        "view_count": 7527,
        "collect_count": 28,
        "comment_count": 30,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/8db9470e21a529407950829933d6c338~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: devui-blue\r\n---\r\n我报名参加金石计划1期挑战——瓜分10万奖池，这是我的第2篇文章，[点击查看活动详情](https://s.juejin.cn/ds/jooSN7t \\\"https://s.juejin.cn/ds/jooSN7t\\\")\r\n## 前言\r\n\r\n事情是这样的，由于七八月份的晚上时不时就坐在地摊上开始了喝酒撸串的一系列放肆的长肉肉项目。\r\n这不，前段时间女朋友痛下决心（心血来潮）地就去报了一个健身的私教班，按照教练给的饮食计划中，其中有一项是每天需要喝 2.6L 的水来促进体内的新陈代谢。\r\n作为伴侣肯定要十分支持的呀，不过因为平时工作也是十分费脑筋的，不会专门去记录每天喝了多少水，特别容易忘记。所以做了这个喝水记录本给她。\r\n\r\n## 开发需求\r\n\r\n整体的开发需求和前言里描述的差不多，整体功能拆分一下就非常清晰了。\r\n\r\n### 一、定义变量\r\n\r\n1. `大杯子`：我们需要一个**总量**目标，用于定义每天的计划值。\r\n2. `小杯子`：一个单次目标，我们不会一次接一大桶水来喝，即使用小杯子喝水时，**每个杯子**的刻度值。\r\n\r\n### 二、逻辑整合\r\n\r\n1. 点击每个小杯子时，从大杯子的总量中扣除小杯子的刻度并记录，对应UI水位升高。\r\n2. 首次点击小杯子时，**展示**百分率刻度值，提升水位。\r\n3. 当完成目标值后，**隐藏**剩余水量的文字。\r\n4. \\\"清空\\\"按钮，**消除本地记录值**，恢复UI水位，展示剩余量。\r\n\r\n## 创建流程和主要代码\r\n\r\n&emsp;此模块代码是应用于小程序使用的，所以代码部分使用wx框架。（下面有普通代码部分）\r\n\r\n### wxml\r\n\r\n构造整体布局，布局和制作大杯子和小杯子。\r\n\r\n在上一段`开发需求`部分中提到的隐藏内容时，注意不要使用 `wx:if` 直接删除整个标签，这样会导致画面跳动，无法实现动画的平滑过渡。\r\n\r\n**用三元运算符隐藏文字可以实现较好的过渡**\r\n\r\n```html\r\n<view class=\\\"body\\\">\r\n  <text class=\\\"h1\\\">喝水记录本</text>\r\n  <text class=\\\"h3\\\">今日目标: 2.6升 </text>\r\n\r\n  <view class=\\\"cup\\\">\r\n    <view class=\\\"remained\\\" style=\\\"height: {{remainedH}}px\\\">\r\n      <text class=\\\"span\\\">{{isRemained ? liters : ''}}</text>\r\n      <text class=\\\"small\\\">{{isRemained ? '剩余' : ''}}</text>\r\n    </view>\r\n\r\n    <view class=\\\"percentage\\\" style=\\\"{{percentageH}}\\\">{{isPercentage ? percentage : ''}}</view>\r\n  </view>\r\n\r\n  <text class=\\\"text\\\">请选择喝水的杯子</text>\r\n\r\n  <view class=\\\"cups\\\">\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"700\\\">700 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"400\\\">400 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"600\\\">600 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"500\\\">500 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"50\\\">50 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"100\\\">100 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"150\\\">150 ml</view>\r\n    <view class=\\\"cup cup-small\\\" bindtap=\\\"cups\\\" data-ml=\\\"300\\\">300 ml</view>\r\n  </view>\r\n\r\n  <view class=\\\"cancle\\\" bindtap=\\\"update\\\">清空</view>\r\n</view>\r\n```\r\n\r\n### wxss\r\n\r\ncss就是简单的画杯子和布局，值得说的就是往大杯子里加水的动画 `transition` 一下就可以了\r\n\r\n```css\r\n.body {\r\n  height: 108vh;\r\n  background-color: #3494e4;\r\n  color: #fff;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.h1 {\r\n  margin: 10px 0 0;\r\n}\r\n\r\n.h3 {\r\n  font-weight: 400;\r\n  margin: 10px 0;\r\n}\r\n\r\n.cup {\r\n  background-color: #fff;\r\n  border: 4px solid #144fc6;\r\n  color: #144fc6;\r\n  border-radius: 0 0 40px 40px;\r\n  height: 330px;\r\n  width: 150px;\r\n  margin: 30px 0;\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow: hidden;\r\n}\r\n\r\n.cup.cup-small {\r\n  height: 95px;\r\n  width: 50px;\r\n  border-radius: 0 0 15px 15px;\r\n  background-color: rgba(255, 255, 255, 0.9);\r\n  cursor: pointer;\r\n  font-size: 14px;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  margin: 5px;\r\n  transition: 0.3s ease;\r\n}\r\n\r\n.cup.cup-small.full {\r\n  background-color: #6ab3f8;\r\n  color: #fff;\r\n}\r\n\r\n.cups {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 280px;\r\n}\r\n\r\n.remained {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n  flex: 1;\r\n  transition: 0.3s ease;\r\n}\r\n\r\n.remained .span {\r\n  font-size: 20px;\r\n  font-weight: bold;\r\n}\r\n\r\n.remained .small {\r\n  font-size: 12px;\r\n}\r\n\r\n.percentage {\r\n  background-color: #6ab3f8;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-weight: bold;\r\n  font-size: 30px;\r\n  height: 0;\r\n  transition: 0.3s ease;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.text {\r\n  text-align: center;\r\n  margin: 0 0 5px;\r\n}\r\n\r\n.cancle {\r\n  cursor: pointer;\r\n}\r\n```\r\n\r\n### js\r\n\r\n逻辑注释写在了代码中\r\n\r\n```js\r\nPage({\r\n  data: {\r\n    liters: '2.6L',\r\n    isPercentage: true,\r\n    isRemained: true,\r\n    percentage: '',\r\n    percentageH: 'height: 0',\r\n    RemainedH: 0,\r\n    goal: 2600\r\n  },\r\n\r\n  // 每次进入页面后加载记录的值，执行动画\r\n  onShow() {\r\n    this.setData({ goal: Number(wx.getStorageSync('goal')) })\r\n    this.updateBigCup(2600 - this.data.goal)\r\n  },\r\n\r\n  // 点击小杯子时的触发逻辑\r\n  cups(data) {\r\n    const ml = Number(data.currentTarget.dataset.ml);\r\n    const goal = this.data.goal - ml;\r\n    const total = 2600 - goal;\r\n    this.setData({ goal })\r\n    wx.setStorageSync(\\\"goal\\\", goal);\r\n    this.updateBigCup(total)\r\n  },\r\n\r\n  // 更新 UI 数据\r\n  updateBigCup(total) {\r\n    const { goal } = this.data;\r\n    if (goal != 2600) {\r\n      this.setData({\r\n        isPercentage: true,\r\n        percentage: `${(total / 2600 * 100).toFixed(0)}%`,\r\n        percentageH: `height: ${total / 2600 * 330}px`\r\n      })\r\n    }\r\n\r\n    if (goal <= 0) {\r\n      this.setData({\r\n        remainedH: 0,\r\n        isRemained: false,\r\n      })\r\n    } else {\r\n      this.setData({\r\n        isRemained: true,\r\n        liters: `${goal / 1000}L`\r\n      })\r\n    }\r\n  },\r\n\r\n  // 清空记录值\r\n  update() {\r\n    wx.removeStorage({ key: 'goal' })\r\n    this.setData({\r\n      goal: 2600,\r\n      isPercentage: false,\r\n      isRemained: true,\r\n      remainedH: 0,\r\n      percentageH: 'height: 0px',\r\n      liters: '2.6L'\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n## 码上掘金\r\n\r\n&emsp; 上面的代码部分主要用于小程序使用，码上掘金可在网页中使用。\r\n\r\n[代码片段](https://code.juejin.cn/pen/7144898649163005987)\r\n\r\n## 结语\r\n\r\n&emsp; 感谢大家能看到这里！！本篇的代码本身没有什么技术含量，可能是比较会偏向实用性的一篇，对！是有一些的对吧！可以自己改装成Chrome插件使用会更方便更实用。啥？你问我为什么不直接写Chrome插件？有没有一种可能不是我不想，而是😭。\r\n\r\n&emsp; 好啦，如果你身边有健身的朋友也可以给他做一个哦~再次谢谢大家"
    },
    {
        "article_id": "7168475244099797029",
        "snapshot": "",
        "title": "项目重构，从零开始搭建一套新的后台管理系统",
        "preview": "应公司发展需求，我决定重构公司的后台管理系统，从提出需求建议到现在的实施，期间花了将近半个月的时间，决定把这些都记录下来。",
        "author": "田八",
        "view_count": 5742,
        "collect_count": 126,
        "comment_count": 19,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/6a646066de6c1376525669efb70295e9~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: juejin\r\nhighlight: a11y-dark\r\n---\r\n## 背景\r\n\r\n应公司发展需求，我决定重构公司的后台管理系统，从提出需求建议到现在的实施，期间花了将近半个月的时间，决定把这些都记录下来。\r\n\r\n之前的后台管理系统实在是为了实现功能而实现的，没有考虑到后期的扩展性，也没有考虑到后期的维护性，所以我下定决心，向领导提出了重构的建议，经过领导的同意，我开始了重构的工作。\r\n\r\n## 项目前身\r\n\r\n之前的后台管理系统是基于`ant design pro for vue`搭建的，我在开发的过程中，遇到了很多问题，比如：\r\n\r\n1. 项目功能模块没有统一规划。\r\n2. 项目的代码风格不统一，代码杂乱无章。\r\n3. 各种第三方库的依赖，有重复的，有无用的。\r\n4. 项目的目录结构不合理。\r\n5. 项目API接口没有统一规划。\r\n6. 项目的权限管理不明确，几乎无用。\r\n7. 等等等...\r\n\r\n当我接手这个项目的时候，我开发了两个大的功能模块，讲道理我这两个功能模块应该是强关联之前的某些功能的；\r\n\r\n但是因为这个项目就是为了满足当前的需求，根本就不给你扩展的机会，所以我开发的两个功能模块都是独立的，没有任何关联，造成了相当多的重复工作，但是又不得不重复。\r\n\r\n这就导致了后期的维护成本很高，因为我要维护的东西太多了，而且这些东西都是没有关联的，所以我决定重构这个项目。\r\n\r\n## 项目重构\r\n\r\n重构是一件很大的事情，当我提出重构的建议时，是确定了我手头上的工作已经完结，后续没有多少工作，所以不要有想法就提，要考虑到后续的工作量以及工作的优先级。\r\n\r\n### 项目规划\r\n\r\n当我决定重构这个项目的时候，我就开始了项目的规划，在开始之前我向领导提出了我的想法；\r\n\r\n领导肯定不会轻易的同意我的想法，所以我就开始整理项目当中的问题，写文档，画流程图，多次和领导沟通，最终领导同意了我的想法。\r\n\r\n我在争取领导的意见做了下面的准备：\r\n\r\n1. 老项目的整体流程我走了一遍，找我我觉得不合理的地方，以及可以优化的地方。\r\n2. 整理项目的功能模块，以及功能模块之间的关系。\r\n3. 整理我心中对这个项目的优化建议以及后续的规划。\r\n4. 画出我心中优化后的项目功能模块的流程图。\r\n5. 写出我优化项目需要时间的估算。\r\n6. 制订项目的开发计划，以及开发的功能模块优先级。\r\n\r\n上面的准备工作也是修修改改，大会小会开了很多次，最终的结果是领导同意了我的想法，我开始了项目的重构。\r\n\r\n### 技术选型\r\n\r\n在领导同意了我的想法之后，我就开始了项目重构前的准备，包括技术选型，项目的目录结构，以及项目的开发计划。\r\n\r\n技术选型沿用了之前的技术栈，但是会对一些技术进行升级迭代；\r\n\r\n1. 脚手架由`vue-cli`修改为`vite`。\r\n2. 前端框架由`vue2`修改为`vue3`。\r\n3. UI框架由`ant-design-vue`修改为`element-plus`。\r\n4. 状态管理由`vuex`修改为`pinia`。\r\n5. 路由由`vue-router`修改为`vue-router-next`。\r\n\r\n除了上述这些技术的升级迭代之外，还会规划一些代码规范，以及项目的目录结构。\r\n\r\n### 项目目录结构\r\n\r\n项目的目录结构以及文件名的命名规范是非常重要的，因为这些都是团队协作的基础，当然我也不会去弄一个很复杂的目录结构或者特立独行的文件名命名规范，我会根据团队或者业界的一些规范来进行规划。\r\n\r\n目录结构：\r\n\r\n```bash\r\n├── public\r\n│   └──  favicon.ico\r\n├── src\r\n│   ├── api                 # 接口请求\r\n│   │   ├── index.js\r\n│   │   └── user.js\r\n│   ├── assets              # 静态资源\r\n│   │   └── logo.png\r\n│   ├── components          # 公共组件\r\n│   │   └── Table           # 表格组件\r\n│   │       └── index.vue\r\n│   ├── layout              # 布局组件\r\n|   |   ├── components\r\n│   │   └── index.vue\r\n│   ├── pages               # 页面\r\n│   │   ├── index\r\n│   │   │   └── index.vue\r\n│   │   └── login\r\n│   │       └── index.vue\r\n│   ├── router              # 路由\r\n│   │   ├── index.js\r\n│   │   └── routes.js\r\n│   ├── store               # 状态管理\r\n│   │   ├── index.js\r\n│   │   └── modules\r\n│   │       └── user.js\r\n│   ├── styles              # 样式\r\n│   │   └── index.scss\r\n│   ├── utils               # 工具函数\r\n│   │   ├── index.ts\r\n│   │   └── request.ts\r\n│   ├── App.vue            # 入口组件\r\n│   └── main.js            # 入口文件\r\n├── .editorconfig          # 编辑器配置\r\n├── .env.development       # 开发环境变量\r\n├── .env.production        # 生产环境变量\r\n├── .eslintrc.json         # eslint配置\r\n├── .gitignore             # git忽略文件\r\n|── index.html             # 入口html文件\r\n├── package.json           # 依赖包\r\n├── README.md              # 项目说明\r\n└── vite.config.js         # vite配置\r\n```\r\n\r\n文件名命名规范：\r\n\r\n1. 文件名全部小写，多个单词用`_`连接，如：`user_info.js`。\r\n2. 组件命名大驼峰，如`TableComponent`。\r\n3. 一个功能模块一个文件夹，文件夹名全部小写，入口文件为`index.vue`。\r\n4. 公共组件放在`components`文件夹下，页面组件放在对应的页面文件夹下。\r\n5. 公共样式放在`styles`文件夹下，页面样式放在对应的页面文件夹下。\r\n6. 公共工具函数放在`utils`文件夹下，页面工具函数放在对应的页面文件夹下。\r\n7. 所有的请求接口放在`api`文件夹下，每个模块一个文件，入口文件为`index.js`。\r\n\r\n差不多久这么多吧，不需要那么严格，但是项目结构一定要整洁，不然后期维护起来会很麻烦。\r\n\r\n## 项目实战\r\n\r\n直接实战环节吧，不多说废话了。\r\n\r\n因为我的项目已经都配置好了，后面的讲解可能跨度比较大，所以就不按照流程一步一步的来，这次直接一步到位。\r\n\r\n首先附上我的`package.json`文件，\r\n\r\n```json\r\n{\r\n  \\\"name\\\": \\\"my-vue-app\\\",\r\n  \\\"private\\\": true,\r\n  \\\"version\\\": \\\"0.0.0\\\",\r\n  \\\"type\\\": \\\"module\\\",\r\n  \\\"scripts\\\": {\r\n    \\\"dev\\\": \\\"vite --mode development\\\",\r\n    \\\"build\\\": \\\"vite build --mode production\\\",\r\n    \\\"preview\\\": \\\"vite preview\\\"\r\n  },\r\n  \\\"dependencies\\\": {\r\n    \\\"@vueuse/core\\\": \\\"^9.5.0\\\",\r\n    \\\"axios\\\": \\\"^1.1.3\\\",\r\n    \\\"element-plus\\\": \\\"^2.2.22\\\",\r\n    \\\"pinia\\\": \\\"^2.0.24\\\",\r\n    \\\"vue\\\": \\\"^3.2.41\\\",\r\n    \\\"vue-router\\\": \\\"^4.1.6\\\"\r\n  },\r\n  \\\"devDependencies\\\": {\r\n    \\\"@babel/eslint-parser\\\": \\\"^7.19.1\\\",\r\n    \\\"@vitejs/plugin-legacy\\\": \\\"^2.3.1\\\",\r\n    \\\"@vitejs/plugin-vue\\\": \\\"^3.2.0\\\",\r\n    \\\"@vitejs/plugin-vue-jsx\\\": \\\"^2.1.1\\\",\r\n    \\\"consola\\\": \\\"^2.15.3\\\",\r\n    \\\"eslint\\\": \\\"^8.28.0\\\",\r\n    \\\"eslint-config-airbnb-base\\\": \\\"^15.0.0\\\",\r\n    \\\"eslint-plugin-import\\\": \\\"^2.26.0\\\",\r\n    \\\"eslint-plugin-vue\\\": \\\"^9.7.0\\\",\r\n    \\\"less\\\": \\\"^4.1.3\\\",\r\n    \\\"unplugin-vue-components\\\": \\\"^0.22.9\\\",\r\n    \\\"unplugin-vue-define-options\\\": \\\"^0.12.8\\\",\r\n    \\\"vite\\\": \\\"^3.2.3\\\",\r\n    \\\"vite-plugin-eslint\\\": \\\"^1.8.1\\\",\r\n    \\\"vite-plugin-style-import\\\": \\\"^2.0.0\\\"\r\n  }\r\n}\r\n```\r\n\r\n### 项目初始化\r\n\r\n我们使用`vite`来初始化项目，根据官网的提示，不同版本的`npm`安装命令不一样，直接上命令：\r\n\r\n```bash\r\n# npm 6.x\r\nnpm create vite@latest my-vue-app --template vue\r\n\r\n# npm 7+, extra double-dash is needed:\r\nnpm create vite@latest my-vue-app -- --template vue\r\n```\r\n\r\n安装完成后，进入项目目录，安装依赖，项目前期安装的并不用很多，就是`vue`全家桶：\r\n\r\n```bash\r\ncd my-vue-app\r\n\r\nnpm install vue vue-router@4 pinia axios element-plus -S\r\n```\r\n\r\n安装完成之后，我们需要在`main.js`中引入对应的依赖：\r\n\r\n```js\r\nimport {createApp} from \\\"vue\\\"; // 引入vue\r\nimport \\\"./styles/index.less\\\"; // 引入全局样式\r\nimport App from \\\"./App.vue\\\"; // 引入入口组件\r\nimport store from \\\"./store\\\"; // 引入状态管理\r\nimport router from \\\"./router\\\"; // 引入路由\r\n\r\nimport ElementPlus from \\\"element-plus\\\"; // 引入element-plus\r\nimport \\\"element-plus/dist/index.css\\\"; // 引入element-plus样式\r\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue' // 引入element-plus图标\r\n\r\n// 创建vue实例\r\nconst app = createApp(App); \r\n\r\n// 注册状态管理\r\napp.use(store); \r\n\r\n// 注册路由\r\napp.use(router); \r\n\r\n// 注册element-plus\r\napp.use(ElementPlus);\r\n\r\n// 注册element-plus图标\r\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\r\n  app.component(key, component)\r\n}\r\n\r\n// 挂载vue实例\r\napp.mount(\\\"#app\\\");\r\n```\r\n\r\n`main.js`中的代码比较多，我们一个一个的实现。\r\n\r\n#### 引入全局样式\r\n\r\n> 上面的`main.js`中，已经是全的了，所以后面讲的东西，都是在`main.js`中的，就不会讲引入了。\r\n\r\n我们在`src`目录下新建一个`styles`目录，然后在`styles`目录下新建一个`index.less`文件，这个就是全局样式文件，里面写入：\r\n\r\n```less\r\nhtml, body {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n```\r\n\r\n#### 引入状态管理\r\n\r\n我们在`src`目录下新建一个`store`目录，然后在`store`目录下新建一个`index.js`文件，这个文件就是状态管理文件，里面写入：\r\n\r\n```js\r\nimport {createPinia} from \\\"pinia\\\";\r\n\r\nconst pinia = createPinia();\r\n\r\nexport default pinia;\r\n```\r\n\r\n#### 引入路由\r\n\r\n我们在`src`目录下新建一个`router`目录，然后在`router`目录下新建一个`index.js`文件，这个文件就是路由文件，里面写入：\r\n\r\n```js\r\nimport {createRouter, createWebHashHistory} from \\\"vue-router\\\";\r\nimport routes from \\\"./routes\\\";\r\n\r\nconst router = createRouter({\r\n  history: createWebHashHistory(),\r\n  routes,\r\n});\r\n\r\nexport default router;\r\n```\r\n\r\n然后我们在`router`目录下新建一个`routes.js`文件，这个文件就是路由配置文件，里面写入：\r\n\r\n```js\r\nimport Layout from \\\"@/layout/index.vue\\\";\r\n\r\nconst routes = [\r\n  {\r\n    path: \\\"/\\\",\r\n    redirect: \\\"/index\\\",\r\n    component: Layout,\r\n    meta: {\r\n      title: \\\"首页\\\",\r\n    },\r\n    children: [\r\n      {\r\n        path: \\\"/index\\\",\r\n        name: \\\"Index\\\",\r\n        component: () => import(\\\"@/pages/index/index.vue\\\"),\r\n        meta: {\r\n          title: \\\"首页\\\",\r\n        },\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    path: \\\"/login\\\",\r\n    name: \\\"Login\\\",\r\n    meta: {\r\n      title: \\\"登录\\\",\r\n      keepAlive: true,\r\n      requireAuth: false\r\n    },\r\n    component: () => import(\\\"@/pages/login/index.vue\\\")\r\n  },\r\n];\r\n\r\nexport default routes;\r\n```\r\n\r\n#### 引入入口组件\r\n\r\n> 这个在创建项目的时候，已经创建好了，所以不用再创建了。\r\n\r\n我们在`src`目录下的`App.vue`文件，这个文件就是入口组件，里面写入：\r\n\r\n```vue\r\n<template>\r\n    <router-view/>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \\\"App\\\",\r\n};\r\n</script>\r\n\r\n<style lang=\\\"less\\\" scoped>\r\n</style>\r\n```\r\n\r\n#### 布局组件\r\n\r\n我们在`src`目录下新建一个`layout`目录，然后在`layout`目录下新建一个`Layout.vue`文件，这个文件就是布局组件，里面写入：\r\n\r\n```vue\r\n<template>\r\n  <el-container>\r\n    <el-aside width=\\\"260px\\\">\r\n      <right-panel/>\r\n    </el-aside>\r\n    <el-container>\r\n      <el-header height=\\\"64px\\\">\r\n        <header-panel/>\r\n      </el-header>\r\n      <el-main>\r\n        <router-view/>\r\n      </el-main>\r\n    </el-container>\r\n  </el-container>\r\n</template>\r\n\r\n<script>\r\nimport RightPanel from \\\"@/components/RightPanel/index.vue\\\";\r\nimport HeaderPanel from \\\"@/components/HeaderPanel/index.vue\\\";\r\nexport default {\r\n  name: \\\"Layout\\\",\r\n  components: {\r\n    RightPanel,\r\n    HeaderPanel\r\n  }\r\n};\r\n</script>\r\n\r\n<style lang=\\\"less\\\" scoped>\r\n</style>\r\n```\r\n\r\n#### 右侧面板组件\r\n\r\n我们在`src`目录下新建一个`components`目录，然后在`components`目录下新建一个`RightPanel`目录，然后在`RightPanel`目录下新建一个`index.vue`文件，这个文件就是右侧面板组件，里面写入：\r\n\r\n```vue\r\n<template>\r\n  <div class=\\\"right-panel-container\\\">\r\n    <el-menu\r\n        style=\\\"border: none;\\\"\r\n        background-color=\\\"#2a5eff\\\"\r\n        class=\\\"el-menu-vertical-demo\\\"\r\n        default-active=\\\"2\\\"\r\n        text-color=\\\"#fff\\\"\r\n        router\r\n    >\r\n      <menu-item v-for=\\\"route in routes\\\" :route=\\\"route\\\" :key=\\\"route.path\\\"/>\r\n    </el-menu>\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport { defineComponent, computed } from \\\"vue\\\";\r\nimport MenuItem from \\\"@/components/RightPanel/MenuItem.vue\\\";\r\nimport routes from \\\"@/router/routes.js\\\";\r\ndefineComponent({\r\n  components: {\r\n    MenuItem\r\n  }\r\n});\r\n\r\ncomputed({\r\n  routes: routes\r\n});\r\n\r\n</script>\r\n\r\n<style lang=\\\"less\\\" scoped>\r\n\r\n.right-panel-container {\r\n  width: 100%;\r\n  height: 100vh;\r\n  background-color: #2a5eff;\r\n  color: #fff;\r\n  overflow-y: auto;\r\n\r\n  :deep(.el-menu .el-sub-menu.is-active .el-sub-menu__title),\r\n  :deep(.el-menu .el-menu-item.is-active) {\r\n    background-color: var(--el-menu-hover-bg-color);\r\n    color: #52cca3;\r\n  }\r\n\r\n  :deep(.el-menu .el-menu-item.is-active) {\r\n    border-left: 3px solid #52cca3;\r\n  }\r\n\r\n  :deep(.el-sub-menu .el-menu) {\r\n    background-color: darken(#224bcc, 10%);\r\n  }\r\n\r\n}\r\n\r\n.right-logo-container {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 64px;\r\n\r\n  .right-logo {\r\n    height: 48px;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    margin: 0 8px;\r\n\r\n    img {\r\n      height: 48px;\r\n    }\r\n\r\n  }\r\n}\r\n\r\n</style>\r\n```\r\n\r\n#### 菜单组件\r\n\r\n在`RightPanel`目录下新建一个`MenuItem.vue`文件，这个文件就是菜单组件，里面写入：\r\n\r\n```vue\r\n<template>\r\n  <el-sub-menu v-if=\\\"route.children && route.children.length > 0\\\" :index=\\\"route.path\\\">\r\n    <template #title>\r\n      <span>{{ (route.meta || {title: route.path}).title }}</span>\r\n    </template>\r\n    <menu-item\r\n      v-for=\\\"item in route.children\\\"\r\n      :route=\\\"item\\\"\r\n      :key=\\\"item.path\\\"\r\n    />\r\n  </el-sub-menu>\r\n  <el-menu-item :index=\\\"route.path\\\" v-else>\r\n    <template #title>\r\n      <span>{{ (route.meta || {title: route.path}).title }}</span>\r\n    </template>\r\n  </el-menu-item>\r\n</template>\r\n\r\n<script setup>\r\nimport { defineProps } from \\\"vue\\\";\r\n\r\ndefineProps({\r\n  route: {\r\n    type: Object,\r\n    default: () => ({})\r\n  },\r\n});\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n#### 头部面板组件\r\n\r\n在`components`目录下新建一个`HeaderPanel`目录，然后在`HeaderPanel`目录下新建一个`index.vue`文件，这个文件就是头部面板组件，里面写入：\r\n\r\n```vue\r\n<template>\r\n<div class=\\\"header-panel-container\\\">\r\n  <div class=\\\"header-breadcrumb\\\">\r\n    <el-breadcrumb>\r\n      <el-breadcrumb-item :to=\\\"{ path: '/' }\\\">首页</el-breadcrumb-item>\r\n      <el-breadcrumb-item>活动管理</el-breadcrumb-item>\r\n      <el-breadcrumb-item>活动列表</el-breadcrumb-item>\r\n      <el-breadcrumb-item>活动详情</el-breadcrumb-item>\r\n    </el-breadcrumb>\r\n  </div>\r\n\r\n  <div class=\\\"header-operate\\\">\r\n    <el-icon><Bell /></el-icon>\r\n\r\n    <el-dropdown>\r\n      <span class=\\\"user-info\\\">\r\n        <el-avatar size=\\\"small\\\" src=\\\"avatar.png\\\"></el-avatar>\r\n        <span>admin</span>\r\n        <i class=\\\"el-icon-arrow-down el-icon--right\\\"></i>\r\n      </span>\r\n      <template #dropdown>\r\n        <el-dropdown-menu>\r\n          <el-dropdown-item>个人中心</el-dropdown-item>\r\n          <el-dropdown-item>切换账号</el-dropdown-item>\r\n          <el-dropdown-item>退出登录</el-dropdown-item>\r\n        </el-dropdown-menu>\r\n      </template>\r\n    </el-dropdown>\r\n  </div>\r\n</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \\\"HeaderPanel\\\"\r\n};\r\n</script>\r\n\r\n<style lang=\\\"less\\\" scoped>\r\n.header-panel-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: #fff;\r\n  color: #333;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 0 20px;\r\n  box-sizing: border-box;\r\n  border-bottom: 1px solid #ebeef5;\r\n\r\n  .header-operate {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n\r\n    :deep(.el-icon) {\r\n      font-size: 20px;\r\n      color: #333;\r\n      cursor: pointer;\r\n      padding: 10px;\r\n    }\r\n  }\r\n\r\n  .user-info {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    margin-left: 10px;\r\n    cursor: pointer;\r\n\r\n    span {\r\n      margin-left: 10px;\r\n    }\r\n  }\r\n}\r\n\r\n</style>\r\n```\r\n\r\n到此整个项目的基本框架就搭建完成了，以上是极简主义，没有多余的东西，只是一个最基本的框架，后面会慢慢完善。\r\n\r\n## vite 配置\r\n\r\n上面的准备只是项目结构的搭建，还需要配置一下`vite`，在项目根目录下新建一个`vite.config.js`文件，里面写入：\r\n\r\n```js\r\nimport { defineConfig } from 'vite';\r\nimport vue from '@vitejs/plugin-vue';\r\nimport * as path from 'path';\r\nimport {\r\n  createStyleImportPlugin,\r\n  ElementPlusResolve,\r\n} from 'vite-plugin-style-import'\r\nimport eslintPlugin from 'vite-plugin-eslint'\r\nimport vueJsx from '@vitejs/plugin-vue-jsx'\r\nimport legacy from '@vitejs/plugin-legacy'\r\nimport DefineOptions from 'unplugin-vue-define-options/vite'\r\n\r\n// https://vitejs.dev/config/\r\nexport default defineConfig({\r\n  resolve: {\r\n    //设置别名\r\n    alias: {\r\n      '@': path.resolve(__dirname, 'src')\r\n    }\r\n  },\r\n  build: {\r\n    target: 'es2015', // 默认 \\\"modules\\\"\r\n  },\r\n  plugins: [\r\n    vue(),\r\n    vueJsx({}),\r\n    createStyleImportPlugin({\r\n      resolves:[\r\n        ElementPlusResolve()\r\n      ],\r\n      libs: [\r\n        // 如果没有你需要的resolve，可以在lib内直接写，也可以给我们提供PR\r\n        {\r\n          libraryName: 'element-plus',\r\n          esModule: true,\r\n          resolveStyle: (name) => {\r\n            return `element-plus/lib/theme-chalk/${name}.css`\r\n          },\r\n          ensureStyleFile: true // 忽略文件是否存在, 导入不存在的CSS文件时防止错误。\r\n        },\r\n      ],\r\n    }),\r\n    eslintPlugin({\r\n      include: ['src/**/*.js', 'src/**/*.vue', 'src/*.js', 'src/*.vue']\r\n    }),\r\n    legacy({\r\n      targets: ['defaults', 'not IE 11'],\r\n    }),\r\n    DefineOptions(),\r\n  ],\r\n  server: {\r\n    port: 8080, //启动端口\r\n    hmr: {\r\n      host: '127.0.0.1',\r\n      port: 8080\r\n    },\r\n    // 设置 https 代理\r\n    proxy: {\r\n      '/api': {\r\n        target: 'your https address',\r\n        changeOrigin: true,\r\n        rewrite: (path) => path.replace(/^/api/, '')\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### 别名配置\r\n\r\n在`resolve`中配置别名，这样在引入文件的时候就可以使用`@`代替`src`，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  resolve: {\r\n    //设置别名\r\n    alias: {\r\n      '@': path.resolve(__dirname, 'src')\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n这样在引入文件的时候就可以使用`@`代替`src`，比如：\r\n\r\n```js\r\nimport HeaderPanel from '@/components/HeaderPanel.vue';\r\n```\r\n\r\n### vue 插件\r\n\r\n在`plugins`中配置`vue`插件，这样就可以在`vue`文件中使用`jsx`语法了，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  plugins: [\r\n    vue(),\r\n    vueJsx({}),\r\n  ]\r\n});\r\n```\r\n\r\n依赖：`@vitejs/plugin-vue`、`@vitejs/plugin-vue-jsx`\r\n\r\n### element-plus\r\n\r\n在`plugins`中配置`element-plus`，这样就可以在`vue`文件中使用`element-plus`了，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  plugins: [\r\n    createStyleImportPlugin({\r\n      resolves:[\r\n        ElementPlusResolve()\r\n      ],\r\n      libs: [\r\n        // 如果没有你需要的resolve，可以在lib内直接写，也可以给我们提供PR\r\n        {\r\n          libraryName: 'element-plus',\r\n          esModule: true,\r\n          resolveStyle: (name) => {\r\n            return `element-plus/lib/theme-chalk/${name}.css`\r\n          },\r\n          ensureStyleFile: true // 忽略文件是否存在, 导入不存在的CSS文件时防止错误。\r\n        },\r\n      ],\r\n    }),\r\n  ]\r\n});\r\n```\r\n\r\n依赖：`element-plus`、`vite-plugin-style-import`\r\n\r\n### eslint\r\n\r\n`eslint`先需要初始化，执行`npx eslint -init`，然后根据提示选择配置，最后在`plugins`中配置`eslint`，这样就可以在`vue`文件中使用`eslint`了，比如：\r\n\r\n然后在`plugins`中配置`eslint`，这样就可以在`vue`文件中使用`eslint`了，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  plugins: [\r\n    eslintPlugin({\r\n      include: ['src/**/*.js', 'src/**/*.vue', 'src/*.js', 'src/*.vue']\r\n    }),\r\n  ]\r\n});\r\n```\r\n\r\n`eslint`还需要配置`eslintConfig`，在第一步的时候你应该已经自己选择好了，这里就不再赘述了，我的项目中是选择生成`.eslintrc.js`文件，所以在项目根目录下会生成`.eslintrc.json`文件。\r\n\r\n依赖：`vite-plugin-eslint`\r\n\r\n### 兼容性\r\n\r\n在`plugins`中配置`legacy`，这样就可以在`vue`文件中使用`es6`语法了，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  plugins: [\r\n    legacy({\r\n      targets: ['defaults', 'not IE 11'],\r\n    }),\r\n  ]\r\n});\r\n```\r\n\r\n依赖：`@vitejs/plugin-legacy`\r\n\r\n### 环境变量\r\n\r\n环境变量不需要配置，直接在根目录下创建`.env`文件，然后在`vue`文件中使用`process.env`就可以了，比如：\r\n\r\n```\r\nVTIE_APP_BASE_URL=http://localhost:8080\r\n```\r\n\r\n```js\r\nconsole.log(import.meta.env.VTIE_APP_BASE_URL);\r\n```\r\n\r\n注意：`VITE_`是固定的，后面的`APP_BASE_URL`是自定义的，可以随意命名，必须得带`VITE_`前缀，否则会被忽略。\r\n\r\n### 代理配置\r\n\r\n在`server`中配置代理，这样在开发环境中就可以使用代理，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n server: {\r\n    port: 8080, //启动端口\r\n    hmr: {\r\n      host: '127.0.0.1',\r\n      port: 8080\r\n    },\r\n    // 设置 https 代理\r\n    proxy: {\r\n      '/api': {\r\n        target: 'your https address',\r\n        changeOrigin: true,\r\n        rewrite: (path) => path.replace(/^/api/, '')\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n这样在开发环境中就可以使用代理。\r\n\r\n### 打包配置\r\n\r\n在`build`中配置打包，这样在打包时就可以使用打包配置，比如：\r\n\r\n```js\r\nexport default defineConfig({\r\n  build: {\r\n    target: 'es2015', // 默认 \\\"modules\\\"\r\n  },\r\n});\r\n```\r\n\r\n这里指示`vite`打包时使用`es2015`语法，而不是`es6`语法。\r\n\r\n自此整个项目的配置就完成了，接下来就可以按照自己的需求进行开发了。\r\n\r\n## 总结\r\n\r\n根据实际情况来进行技术选型以及架构的搭建，这样才能更好的满足业务需求，提高开发效率。\r\n\r\n我上面并没有上什么高级或者特别的技术，没有上`TypeScript`，没有上`prettier`，也没有规范提交的`commitizen`；\r\n\r\n如果是自己的项目，我随便玩我会考虑上，但是团队项目终究是要考虑团队的，它不是最好的，但是它是最合适的。\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\r\n"
    },
    {
        "article_id": "7156102433581383716",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c927ba5b9224f0ca38924b1bead3e4e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "手把手教学，使用 Rust + WASM 进行 Web 开发",
        "preview": "背景 WebAssembly（wasm）是一个简单的机器模型和可执行格式，具有广泛的规范。它被设计为便携、紧凑，代码执行能够达到接近本机原生指令的执行速度。 作为一种编程语言，WebAssembly ",
        "author": "JohnnyPan",
        "view_count": 3211,
        "collect_count": 62,
        "comment_count": 16,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/8ae2b192e21d5e9cd6e1a2d950b58b54~300x300.image",
        "category": "前端",
        "content": "> 文章同步发布于本人博客，[戳这里](https://pzij.github.io/blog/rust-wasm-for-web)\r\n> \r\n## 背景\r\n\r\nWebAssembly（WASM）是一个简单的机器模型和可执行格式，具有广泛的规范。它被设计为便携、紧凑，代码执行能够达到接近本机原生指令的执行速度。\r\n\r\n作为一种编程语言，WebAssembly 由两种格式组成，它们以不同的方式表示相同的结构：\r\n- 后缀为 `.wat` 的文本格式（称为“WebAssembly Text”），可以被人类理解，使用 [S-表达式](https://zh.wikipedia.org/wiki/S-%E8%A1%A8%E8%BE%BE%E5%BC%8F)。\r\n- 后缀为 `.wasm` 的二进制格式是较低级别的，人无法读懂，它旨在供 wasm 虚拟机直接使用。\r\n\r\n作为参考，下面是一个在 JS 中调用两数求和 WASM 函数的例子：\r\n\r\n```js\r\nconst wasmInstance = new WebAssembly.Instance(wasmModule, {});\r\nconst { addTwo } = wasmInstance.exports;\r\nfor (let i = 0; i < 5; i++) {\r\n  console.log(addTwo(i, i));\r\n}\r\n/**\r\n * output:\r\n * 0\r\n * 2\r\n * 4\r\n * 6\r\n * 8\r\n **/\r\n```\r\n\r\n`addTwo` 函数本身是由其他语言编写而成的，并且被编译成了 `.wat` 格式。以下是这个 `addTwo` 求和函数的 `.wat` 文件：\r\n\r\n```wat\r\n(module\r\n  (func (export \\\"addTwo\\\") (param i32 i32) (result i32)\r\n    local.get 0\r\n    local.get 1\r\n    i32.add))\r\n```\r\n\r\n> 可以通过这个网站将 `.wat` 生成对应的二进制 `.wasm` 文件：[wat2wasm demo](https://webassembly.github.io/wabt/demo/wat2wasm/)\r\n\r\n## 环境配置\r\n\r\n1. 安装 [rust 工具链](https://www.rust-lang.org/tools/install)（`rustup`，`rustc`，`cargo`）\r\n2. 安装 [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/)，一个构建、测试和发布 WASM 的 Rust CLI 工具，我们将使用 `wasm-pack` 相关的命令来构建 WASM 二进制内容。\r\n3. npm，JS 包管理器\r\n\r\n如果不安装 wasm-pack，使用打包工具 `webpack` 加上 `@wasm-tool/wasm-pack-plugin` 插件也能构建 WASM，后文会详细介绍。\r\n\r\n> Tips：安装 [cargo-generate](https://github.com/cargo-generate/cargo-generate)，能够使用现有的 git 仓库生成一个新的 Rust 项目： `cargo install cargo-generate`\r\n\r\n## 快速入门\r\n\r\n### 项目初始化\r\n\r\n首先我们执行 `cargo new wasm-demo` 初始化 Rust 项目，新建一个名为 `wasm-demo` 的文件夹（也可以选一个你喜欢的文件夹名），自动生成配置文件 `Cargo.toml`，结构如下。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c6527aa05242f89cf3e6b63bd1f8d2~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 配置包文件\r\n\r\n我们可以在 `Cargo.toml` 文件中加上下列代码并保存，保存之后 Cargo 会自动下载依赖。\r\n\r\n- `cdylib` 用来指明库的类型。\r\n- `wasm-bindgen` 是一个简化 Rust WASM 与 JS 之间交互的库。\r\n    - 它能够将如 DOM 操作、console.log 和 performance 等 JS 相关 API 暴露给 Rust 使用\r\n    - 它能够将 Rust 功能导出到 JS 中，如类、函数等\r\n\r\n```TOML\r\n[lib]\r\ncrate-type = [\\\"cdylib\\\"]\r\n\r\n[dependencies]\r\nwasm-bindgen = \\\"0.2.83\\\"\r\n```\r\n\r\n### 编写代码\r\n\r\n接着开始编写一些简单的 Rust 代码。将模板文件中的 `src/main.rs` 改成 `src/lib.rs`，里面写上一个求斐波那契数列的 Rust 函数。需要加上`#[wasm_bindgen]`标注告诉 wasm-pack 需要将这个函数编译成 wasm 可执行文件。\r\n\r\n```rust\r\nuse wasm_bindgen::prelude::*; // 用于加载 Prelude（预导入）模块\r\n\r\n#[wasm_bindgen]\r\npub fn fib(n: u32) -> u32 {\r\n    if n == 0 || n == 1 {\r\n        return 1;\r\n    }\r\n    fib(n - 1) + fib(n - 2)\r\n}\r\n\r\n```\r\n\r\n当前目录应该长这样：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f303627174104ca09db1fb7caa420487~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nRust 中包管理系统将 crate 包分为二进制包（Binary）和库包（Library）两种，二者可以在同一个项目中[同时存在](https://dev.to/yjdoc2/make-a-combined-library-and-binary-project-in-rust-d4f)。\r\n \r\n二进制包：\r\n- `main.rs` 是二进制项目的入口\r\n-  二进制项目可直接执行\r\n-  一个项目中二进制包可以有多个，所以在 Cargo.toml 中通过双方括号标识 `[[bin]]`\r\n \r\n库包：\r\n- `lib.rs` 是库包的入口。\r\n- 库项目不可直接执行，通常用来作为一个模块被其他项目引用。\r\n- 一个项目中库包仅有1个，在 Cargo.toml 中通过单方括号标识 `[lib]`\r\n\r\n因为我们这里希望将 WASM 转为一个可以在 JS 项目中使用的模块，所以需要使用库包 `lib.rs` 的命名。\r\n\r\n### 执行编译\r\n\r\n只需要执行我们之前安装的 wasm-pack 即可将刚刚的 Rust 代码转换成能够被 JS 导入的模块。\r\n\r\n```bash\r\nwasm-pack build\r\n```\r\n\r\n编译完成后，我们会发现根目录下多了一个 `pkg/` 文件夹，里面就是我们的 WASM 产物所在的 npm 包了。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3269892162f3491b94d0e2715f491875~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n包的入口文件是不带 `_bg` 的 `.js` 文件，即 `wasm_demo2.js`。\r\n\r\n`wasm_demo2.js` 的内容如下：\r\n\r\n```js\r\nimport * as wasm from \\\"./wasm_demo2_bg.wasm\\\";\r\nexport * from \\\"./wasm_demo2_bg.js\\\";\r\n```\r\n\r\n`wasm_demo2_bg.js` 的内容如下：\r\n\r\n```js\r\nimport * as wasm from './wasm_demo2_bg.wasm';\r\n\r\n/**\r\n* @param {number} n\r\n* @returns {number}\r\n*/\r\nexport function fib(n) {\r\n    const ret = wasm.fib(n);\r\n    return ret >>> 0;\r\n}\r\n```\r\n\r\n`wasm_demo2.d.ts` 的内容如下：\r\n\r\n```ts\r\n/* tslint:disable */\r\n/* eslint-disable */\r\n/**\r\n* @param {number} n\r\n* @returns {number}\r\n*/\r\nexport function fib(n: number): number;\r\n\r\n```\r\n\r\n> 可以看到，wasm-pack 打包不仅输出一个 ESM 规范的模块，而且还支持自动生成 d.ts 文件，对模块的使用者非常友好。\r\n\r\n### 使用 WASM 包\r\n\r\n下面我们就新建一个 html 页面去调用刚刚生成的模块。在根目录下生成 `index.html`，并输入以下内容。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\\\"en\\\">\r\n<head>\r\n    <meta charset=\\\"UTF-8\\\">\r\n    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\r\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\r\n    <title>Rust WASM demo</title>\r\n    <script>\r\n        /**\r\n         * 1. 通过使用 instantiateStreaming 调用流式实例化\r\n         **/\r\n        WebAssembly.instantiateStreaming(fetch(\\\"./pkg/wasm_demo2.wasm\\\")).then((obj) => {\r\n            const fib = obj.instance.exports.fib;\r\n            const out = fib(20);\r\n            console.log(\\\"rust output: \\\", out);\r\n        })\r\n        \r\n        /**\r\n         * 2. 不通过流式调用，直接读取二进制文件并对字节进行实例化\r\n         **/\r\n        fetch(\\\"./pkg/wasm_demo2.wasm\\\")\r\n        .then(res => res.arrayBuffer())\r\n        .then(bytes => WebAssembly.instantiate(bytes))\r\n        .then(results => {\r\n            const fib = results.instance.exports.fib;\r\n            const out = fib(20);\r\n            console.log(\\\"rust output: \\\", out);\r\n        })\r\n\r\n    </script>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n如上所示，可以通过流式与非流式两种原生 JS API 方式进行 `.wasm` 二进制文件的模块实例化。\r\n\r\n接下来编写一个简单的服务 `server.js`：\r\n\r\n```js\r\nconst http = require('http');\r\nconst fs = require('fs');\r\n\r\nconst reqListener = function(req, res) {\r\n    f = req.url === '/' ? 'index.html' : './pkg/wasm_demo2_bg.wasm';\r\n    if (f === './pkg/wasm_demo2_bg.wasm') {\r\n        res.setHeader('Content-type', 'application/wasm')\r\n      }\r\n      res.writeHead(200)\r\n      return fs.createReadStream(f).pipe(res)\r\n}\r\n\r\nconst server = http.createServer(reqListener);\r\nserver.listen(8081);\r\nconsole.log('listening: http://localhost:8081')\r\n```\r\n\r\n开启服务：\r\n\r\n```bash\r\nnode server.js\r\n```\r\n\r\n打开 html 页面 http://localhost:8081/ ，在控制台可看到两份 `fib(20)` 的结果被打印出来了。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d2f43d4d034ba7b0cd60e2307463ed~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 进阶用法\r\n\r\n### 配合 Webpack 使用\r\n\r\n使用 Webpack + wasm-pack 插件的方式构建和测试，可以直接通过 npm scripts 运行代码，像前端开发一样调试。\r\n\r\n用 `npm init -y` 新建一个项目，在 `package.json` 中新增如下代码：\r\n```json\r\n...\r\n  \\\"scripts\\\": {\r\n    \\\"build\\\": \\\"webpack\\\",\r\n    \\\"serve\\\": \\\"webpack serve\\\"\r\n  },\r\n  \\\"devDependencies\\\": {\r\n    \\\"@wasm-tool/wasm-pack-plugin\\\": \\\"1.5.0\\\",\r\n    \\\"html-webpack-plugin\\\": \\\"^5.3.2\\\",\r\n    \\\"text-encoding\\\": \\\"^0.7.0\\\",\r\n    \\\"webpack\\\": \\\"^5.49.0\\\",\r\n    \\\"webpack-cli\\\": \\\"^4.7.2\\\",\r\n    \\\"webpack-dev-server\\\": \\\"^3.11.2\\\"\r\n  },\r\n  ...\r\n```\r\n\r\n执行 `npm i` 安装依赖。\r\n\r\n新建 `index.js` 文件，作为 WASM 模块的执行文件。在里面写入如下内容：\r\n\r\n```js\r\n// 因为 webpack 的 bug（webpack/webpack#6615），这里暂时只能使用动态导入 import\r\nconst rust = import('./pkg');\r\n\r\nrust.then(m => {\r\n    const out = m.fib(20);\r\n    console.log(\\\"rust output: \\\", out);\r\n}).catch(console.error)\r\n```\r\n\r\n新建 `webpack.config.js` 文件，并进行如下配置：\r\n\r\n```js\r\nconst path = require('path');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst webpack = require('webpack');\r\nconst WasmPackPlugin = require(\\\"@wasm-tool/wasm-pack-plugin\\\"); // 赋予 webpack 处理 wasm 能力的插件\r\n\r\n/**\r\n * @type import('webpack').Configuration\r\n */\r\nmodule.exports = {\r\n    entry: './index.js',\r\n    devServer: {\r\n        port: '8082'\r\n    },\r\n    output: {\r\n        path: path.resolve(__dirname, 'dist'),\r\n        filename: 'index.js',\r\n    },\r\n    plugins: [\r\n        new HtmlWebpackPlugin(),\r\n        new WasmPackPlugin({\r\n            crateDirectory: path.resolve(__dirname, \\\".\\\")\r\n        }),\r\n        // Have this example work in Edge which doesn't ship `TextEncoder` or\r\n        // `TextDecoder` at this time. 处理浏览器兼容问题\r\n        new webpack.ProvidePlugin({\r\n          TextDecoder: ['text-encoding', 'TextDecoder'],\r\n          TextEncoder: ['text-encoding', 'TextEncoder']\r\n        })\r\n    ],\r\n    mode: 'development',\r\n    experiments: {\r\n        asyncWebAssembly: true // 打开异步 WASM 功能\r\n   }\r\n};\r\n```\r\n\r\n执行 `npm run build` 构建出 WASM 二进制产物。\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac188d2836145829682f962c84429c4~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n执行 `npm run serve` 即可进行开发，在浏览器的控制台中实时看到对应 `fib(20)` 的结果。我们可以在 `index.js` 中更改传入的参数，并查看控制台的新输出结果。\r\n\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c74f7c5cff4661b55104ba0982fc5a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n总结就是，使用 webpack 能够帮助能够更加高效地进行 Rust WASM 应用的开发和调试。\r\n\r\n这一块借助了 webpack-dev-server 的 HMR 模块实现热更新：\r\n1. 打包时将一块 webpack 脚本代码（JSONP 脚本）打包到客户端应用中。\r\n2. 当本地 `lib.rs` 文件发生变化时，服务端 webpack-dev-server 通过 websocket 通知客户端应用代码中的 webpack 脚本代码，客户端向服务端请求最新编译好的 wasm 模块\r\n3. 新的 WASM 模块以 JSONP 的方式从服务端传输到客户端\r\n4. 通过 webpack 重写的 `__webpack_require__` 方法获取到新模块并加载、包裹、运行和缓存，实现模块的热替换。\r\n\r\n### Rust 操纵 DOM\r\n\r\n实现一个求斐波那契数的应用，如下所示：\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8401845ba8424b8d806a3cf34e0923a3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n\r\n需要先安装一个叫 `web-sys` 的 Crate，它为 Rust 提供了控制 DOM 的能力，在 `Cargo.toml` 中新增依赖：\r\n\r\n```toml\r\n[dependencies.web-sys]\r\nversion = \\\"0.3.4\\\"\r\nfeatures = [ 'Document', 'Element', 'HtmlElement', 'Node', 'Window', 'HtmlInputElement']\r\n```\r\n\r\n> `features` 需要开发者手动地声明需要使用到的模块，这样做的好处有二：一是避免不同模块下的 `features` 名字发生冲突；二是条件编译各个依赖中的特性，对不使用的 `features` 不编译。\r\n\r\n在 `lib.rs` 函数中新增 `init()` 函数，用于生成 DOM 节点、挂载监听器并挂载 DOM 节点。\r\n\r\n```rust\r\n\r\n// start 标识 init() 在 WASM 加载时自动执行\r\n#[wasm_bindgen(start)]\r\npub fn init() -> Result<(), JsValue> {\r\n    // 使用 web_sys 的 window 全局对象\r\n    let window = web_sys::window().expect(\\\"不存在全局 window 对象\\\");\r\n    let document = window.document().expect(\\\"需要在 window 上存在 document\\\");\r\n    let body = document.body().expect(\\\"document 中需要存在一个 body\\\");\r\n\r\n    // 生成 dom 元素\r\n    let input = document\r\n        .create_element(\\\"input\\\")?\r\n        .dyn_into::<web_sys::HtmlInputElement>()?;\r\n    let btn = document.create_element(\\\"button\\\")?;\r\n    btn.set_text_content(Some(&\\\"点击计算斐波那契数\\\"));\r\n    let out = document.create_element(\\\"h3\\\")?;\r\n    let input = Rc::new(input); // 为了不违背“一个变量只能有一个所有者”的规则，需要使用 Rc 包裹 input 元素，方便在闭包中拿到并使用它的值\r\n    let out = Rc::new(RefCell::new(out)); // 因为需要改变 out 元素的 textContent，需要使用 RefCell 包裹方便去在闭包中把它当做可变变量来改变它\r\n    {\r\n        let out = out.clone(); // 复制一份智能指针\r\n        let input = input.clone();\r\n        // 使用到 wasm_bindgen::closure::Closure，它的作用是打通 Rust 中的闭包和 JS 中的闭包\r\n        let closure = Closure::<dyn Fn()>::new(move || {\r\n            let val = input.value();\r\n            let num = val.parse::<u32>().unwrap();\r\n            let res = fib(num);\r\n            out.borrow_mut()\r\n                .set_text_content(Some(res.to_string().as_str())); // 在这里使用 borrow_mut 把 out 当做可变变量获取出来，并设置 textContent\r\n        });\r\n\r\n        btn.add_event_listener_with_callback(\\\"click\\\", closure.as_ref().unchecked_ref())?; // 挂载事件监听器，将闭包函数先转换为 JS 值，再跳过类型判断，再作为回调函数传给 btn\r\n        closure.forget(); // 释放 Rust 对这片堆内存的管理，交给 JS 的 GC 去回收\r\n    }\r\n\r\n    body.append_child(&input)?;\r\n    body.append_child(&btn)?;\r\n    body.append_child(&out.borrow())?; // 挂载 DOM 元素节点\r\n    Ok(())\r\n}\r\n```\r\n\r\n上述 `init()` 添加了 `#[wasm_bindgen(start)]` 宏标注，`init()` 函数会在 WASM 模块初始化时自动执行。因此不再需要更改 `index.js` 文件。\r\n\r\n直接运行服务：\r\n\r\n```bash\r\nnpm run serve\r\n```\r\n\r\n打开 http://localhost:8082/ ，成功！\r\n\r\n打开检查，我们可以发现 `body` 上正确地挂载了 DOM 元素。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/055d7fc6faf443c298d98c1799f6842d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 性能指标\r\n\r\n我们先在 `lib.rs` 中加上以下代码，允许 Rust 代码中调用 `console.log` 。\r\n\r\n```rust\r\n#[wasm_bindgen]\r\nextern \\\"C\\\" {\r\n    #[wasm_bindgen(js_namespace = console)]\r\n    fn log(s: &str); // 将 js 命名空间中的 console.log 方法定义在 Rust 中\r\n}\r\n\r\n// 定义 console.log! 宏\r\nmacro_rules! console_log {\r\n    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))\r\n}\r\n```\r\n\r\n接着，在刚刚的求斐波那契数的应用中加上 `performance` API 相关的代码。\r\n\r\n在 `Cargo.toml` 中加上 Performance 的 features：\r\n\r\n```toml\r\n[dependencies.web-sys]\r\nversion = \\\"0.3.4\\\"\r\nfeatures = [\r\n  'Document',\r\n  'Element',\r\n  'HtmlElement',\r\n  'Node',\r\n  'Window',\r\n  'Performance', // 加上这一行\r\n  'HtmlInputElement'\r\n]\r\n```\r\n\r\n将求斐波那契数应用中的 `closure` 方法进行如下重写：\r\n\r\n```rust\r\nlet closure = Closure::<dyn Fn()>::new(move || {\r\n    let performance = window\r\n        .performance()\r\n        .expect(\\\"performance should be available\\\"); // 获取 window.performance\r\n\r\n    let val = input.value();\r\n    let num = val.parse::<u32>().unwrap();\r\n    let start = performance.now(); // 调用 performance.now() 获取当前时间\r\n    console_log!(\\\"the start time (in ms) is {}\\\", start);\r\n    let res = fib(num);\r\n    let end = performance.now();\r\n    console_log!(\\\"the end time (in ms) is {}\\\", end);\r\n    console_log!(\\\"delta (in ms) is {}\\\", end-start);\r\n    out.borrow_mut()\r\n        .set_text_content(Some(res.to_string().as_str()));\r\n});\r\n```\r\n\r\n运行服务器：\r\n```bash\r\nnpm run serve\r\n```\r\n\r\n现在在控制台就能够看到执行运算的耗时了。\r\n\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e5a10842de41929b2d101f2313c27b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 执行运算的[录屏](https://recordit.co/muajFCjHAR)\r\n\r\n性能比较：\r\n\r\n| fib(n) |  10    |   20   |   30   |   35   |   40   |   45   |\r\n| ------ | ------ | ------ | ------ | ------ | ------ | ------ |\r\n| wasm   |  0.30  |  0.90  |  69.90 | 726.59 |  8018  | 90918.79 |\r\n| js     |  0.19  |  0.80  |  67.70 | 753.20 |  8061  | 91794.70 |\r\n\r\n可以看到，*在 n 不大的场景下，WASM 的耗时比纯 JS 还要长*，这是因为浏览器需要在 VM 容器中对 WASM 模块进行实例化，可能这一部分会消耗相当的时间，导致性能不如纯 JS 的执行。随着运算规模变大，WASM 的优化越来越明显。\r\n\r\n## 总结\r\n\r\nWASM 从 2017 年 3 月推出以来，已然成了 Web 开发的未来发展趋势之一。\r\n\r\n本文不仅介绍了 WASM 的背景、环境配置、Rust 项目初始化、编译和使用 WASM 等基本用法，还通过一个简单的应用介绍了 WASM 与 webpack 配合开发、与 DOM 之间交互以及性能指标分析等进阶用法。\r\n\r\n\r\n## 参考资料\r\n- [Rust and WebAssembly](https://rustwasm.github.io/docs/book/introduction.html)\r\n- [hello-world](https://rustwasm.github.io/wasm-bindgen/examples/hello-world.html)\r\n- [Using the WebAssembly JavaScript API](https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API)\r\n- [Closure in wasm_bindgen::closure - Rust (rustwasm.github.io)](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)\r\n- [start - The `wasm-bindgen` Guide (rustwasm.github.io)](https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html)\r\n- [Make a Combined Library and Binary Project in Rust - DEV Community 👩‍💻👨‍💻](https://dev.to/yjdoc2/make-a-combined-library-and-binary-project-in-rust-d4f)\r\n"
    },
    {
        "article_id": "7171274503152992287",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d158b670810c4830a267fc2d21abcf7e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "实现一个靠谱好用的全屏组件，顺手入门 Headless 组件",
        "preview": "聊聊一个使用频率还挺高的组件——全屏组件，顺便了解下什么是 Headless 组件，并尝试动手将一个普通组件改造成 Headless 组件。",
        "author": "Tusi",
        "view_count": 2196,
        "collect_count": 63,
        "comment_count": 5,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/5cdce3dcf685b7b55f5727ffca322944~300x300.image",
        "category": "前端",
        "content": "> 本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！\r\n>\r\n> 专栏上篇文章传送门：[衍生需求：按钮集成图标组件 & 图标选择器](https://juejin.cn/post/7166029886128128014)\r\n> \r\n> 本节涉及的内容源码可在[vue-pro-components c5 分支](https://github.com/cumt-robin/vue-pro-components/tree/c5)找到，欢迎 star 支持！\r\n\r\n# 前言\r\n\r\n本文是 [基于Vite+AntDesignVue打造业务组件库](https://juejin.cn/column/7140103979697963045 \\\"https://juejin.cn/column/7140103979697963045\\\") 专栏第 6 篇文章【实现一个靠谱好用的全屏组件，顺手入门 Headless 组件】，聊聊一个使用频率还挺高的组件——全屏组件，顺便了解下什么是 Headless 组件，并尝试动手将一个普通组件改造成 Headless 组件。\r\n\r\n# 全屏组件\r\n\r\n我们在项目中或多或少会用到进出全屏的功能，这样可以最大化利用可视区域，但是，实现一个完善的全屏功能并不简单。\r\n\r\n首先，各浏览器内核对于全屏 API 的实现不一样，你可能会看到诸如`requestFullscreen`, `webkitRequestFullScreen`, `mozRequestFullScreen`, `msRequestFullscreen`之类的进入全屏的方法，退出全屏的方法也不例外。\r\n\r\n其次，各浏览器中能用来判断全屏状态的属性和方法也不尽相同，比如`document.fullscreenElement`, `document.webkitFullscreenElement`等等，甚至有的情况下用`document.fullscreenElement`也无法准确反映全屏的状态，比如你在 Chrome, Edge, Firefox 等浏览器中通过 F11 按键进入全屏后，`document.fullscreenElement`的值会是`null`，并且`fullscreenchange`事件也不会触发；而通过调用`requestFullscreen()` API 进入全屏后，`document.fullscreenElement`的值就是正确的。\r\n\r\n对于做项目的开发者们来说，这种不一致就让人很恼火，因为我们仅靠`document.fullscreenElement`并不能确保在界面上可以反馈正确的状态，此时我们需要寻找一种方法 hack，解决这种不一致问题。\r\n\r\n![全屏状态不一致.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b576d07532684e308e6ca2ef86b51854~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n全屏/退出全屏的触发方式比较多，可能有通过按键`F11`, `ESC`等触发，也有可能通过监听某个界面元素的交互事件并结合全屏 API 触发，这会让全屏的状态判断变得更复杂。\r\n\r\n为了解决这些问题，我们有必要把这些繁琐和不确定性集中处理掉，对外提供干净、简洁、一致的 API。那么我们要做哪些事情呢？我想大概有以下几点：\r\n\r\n- 检测当前环境是否允许/支持全屏能力（对应`fullscreenEnabled`）。\r\n- 提供进入/退出全屏的 API（名字可以是`enterFullscreen`, `exitFullscreen`）。\r\n- 提供统一的判断全屏状态的方法（名字可以是`isFullscreen`）。\r\n- 提供获取全屏元素的方法（名字可以是`getFullscreenElement`）。\r\n- 提供监听/取消监听全屏事件的能力（名字可以是`subscribeFullscreenChange`, `unsubscribeFullscreenChange`）\r\n\r\n## 检测当前环境是否允许/支持全屏能力\r\n\r\n由于浏览器厂商的具体实现差异，可能会出现部分浏览器不支持全屏 API的情况，或者有提供某种配置或开关，能够做到启用/禁用全屏特性。因此最保险的做法是：在我们使用全屏 API 之前，做一次全屏特性支持度检测。\r\n\r\n检测的逻辑并不复杂，只要将标准的`fullscreenEnabled`用上，同时将浏览器前缀考虑在内即可。\r\n\r\n```\r\n/**\r\n * @description 判断浏览器当前状态是否允许启用全屏特性\r\n */\r\nexport function isFullscreenEnabled(): boolean {\r\n    return !!(document.fullscreenEnabled || document.webkitFullScreenEnabled || document.mozFullScreenEnabled || document.msFullScreenEnabled);\r\n}\r\n```\r\n\r\n## TypeScript 类型扩展\r\n\r\n但是我们可以发现，在使用 TypeScript 编写这部分代码时，IDE 会在类型上给我们抛出错误信息，这是因为标准的`lib.dom.d.ts`中没有声明带有各个浏览器前缀的 API，所以是不能直接用`webkitFullScreenEnabled`, `mozFullScreenEnabled`等方法的。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4752a67e24b43df866a4a0550370a09~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n而为了照顾各种浏览器，我们又不得不写这些兼容代码。因此，我们需要对`interface Document`做一些扩展，使得扩展出来的类型能够支持调用`webkitFullScreenEnabled`等方法。\r\n\r\n考虑到`document`对象是浏览器运行时的全局属性，第一种做法是直接在`global`上扩展`Document`接口。\r\n\r\n```\r\ndeclare global {\r\n    interface Document {\r\n        webkitFullScreenEnabled?: boolean\r\n        mozFullScreenEnabled?: boolean\r\n        msFullScreenEnabled?: boolean\r\n    }\r\n}\r\n```\r\n\r\n在`.ts`文件中，通过`declare global`可以扩展全局类型，再依靠`interface`的 Merge 能力，我们就能对`Document`接口进行扩展，补充一些运行时特有的属性或方法。此时，我们可以观察到类型错误信息已经不存在。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8cb3b7ef4f4bf695596282c18d9abb~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n另一种做法是定义一个子类型（SubType）继承`Document`接口，我们把这个子类型命名为`EnhancedDocument`，再对这个子类型做扩展，接着用类型断言将`document`对象断言为`EnhancedDocument`类型。\r\n\r\n```\r\ninterface EnhancedDocument extends Document {\r\n    webkitFullScreenEnabled?: boolean\r\n    mozFullScreenEnabled?: boolean\r\n    msFullScreenEnabled?: boolean\r\n}\r\n```\r\n\r\n> Sometimes you will have information about the type of a value that TypeScript can’t know about.\r\n\r\n类型断言是一个从抽象到更具体的做法，有时候我们能知道一些 TypeScript 无法感知的类型信息。在 TypeScript 层面，它认为 document 就是 Document 类型，这是因为 TypeScript 无法确定具体的运行时环境是什么样的。而作为开发者，我们很清楚，当代码在浏览器执行时，它可能会有`webkitFullScreenEnabled`或`mozFullScreenEnabled`等可选属性（取决于浏览器实现），所以断言为`EnhancedDocument`类型也是合理的。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f7202f76494d1b873a3ac330baee6e~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 进入/退出全屏\r\n\r\n对于进入全屏而言，触发的目标元素可能是`document.body`，也可能是具体的某一个页面元素。考虑到调用[requestFullscreen](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen)会返回一个 Promise，我们可以将`enterFullscreen`封装为一个异步函数。\r\n\r\n```typescript\r\n/**\r\n * 进入全屏\r\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/requestFullScreen\r\n * @param {EnhancedHTMLElement} [element=document.body] - 全屏目标元素，默认是 body\r\n * @param {FullscreenOptions} options - 全屏选项\r\n */\r\nexport async function enterFullscreen(element: EnhancedHTMLElement = document.body, options?: FullscreenOptions) {\r\n    try {\r\n        if (element.requestFullscreen) {\r\n            await element.requestFullscreen(options)\r\n        } else if (element.webkitRequestFullScreen) {\r\n            await element.webkitRequestFullScreen()\r\n        } else if (element.mozRequestFullScreen) {\r\n            await element.mozRequestFullScreen()\r\n        } else if (element.msRequestFullscreen) {\r\n            await element.msRequestFullscreen()\r\n        } else {\r\n            throw new Error('该浏览器不支持全屏API')\r\n        }\r\n    } catch (err) {\r\n        console.error(err)\r\n    }\r\n}\r\n```\r\n\r\n退出全屏有一点不一样，因为退出全屏的 API 只在 Document 接口中有定义，这一点可以参考[Fullscreen API Standard](https://fullscreen.spec.whatwg.org/)。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e93d27f61fb406d808abfc56e76756b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n退出全屏的代码封装如下：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d87e8050f64712acd95c050c832f59~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n其中有一个`webkitExitFullscreen`和`webkitCancelFullScreen`让我迷惑了一会，最后从 WebKit JS 的文档中了解到已经不建议使用`webkitCancelFullScreen`了。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc5e4fc5bf584541bc293575e2679f28~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n为了避免写太多`as`类型断言，这里通过一个变量`doc`接收了`document`的值，同时将`doc`的类型声明为`EnhancedDocument`。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246d56ac93444015b20aa284776596fe~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n从类型兼容的角度看，`EnhancedDocument`是`Document`的子类型，一个父类型的值（document）赋给一个子类型的变量（doc）看起来似乎不是类型安全的，但是实际赋值过程中并没有报类型错误，这似乎有违我之前的认知。\r\n\r\n> 你可以把狗赋值给动物类型，但是不能把动物赋值给狗类型。这就符合类型安全。\r\n\r\n仔细观察后，我发现这是因为`EnhancedDocument`扩展的属性都是可选的，这种时候，TypeScript 会认为`EnhancedDocument`和`Document`是互相兼容的。从类型的使用上来看也是安全的，如果你要用到可选属性，必然少不了要用到类型守卫。\r\n\r\n一旦我们给`EnhancedDocument`增加一个必选属性，这种赋值就违背类型兼容了。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dd8694be445461380bdd7a926a315d8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 获取全屏元素\r\n\r\n获取全屏元素也只能通过`document`上的`fullscreenElement`属性取得，这在标准中也有定义。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c61d88b6e0794b578b74b24181be9f9c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n代码相对简单，封装如下：\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f50fffe124f445bcbcd134690f2867f8~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 判断全屏状态\r\n\r\n标准中没有告诉我们怎么判断全屏状态，但是我们可以在【获取全屏元素】的基础上得到启发。如果通过`getFullscreenElement`函数得到的结果不是`null`，就可以认为当前是全屏状态。\r\n\r\n```\r\n/**\r\n * @description 判断当前是否是全屏状态\r\n */\r\nexport function isFullscreen(): boolean {\r\n    return !!getFullscreenElement() || window.innerHeight === window.screen.height\r\n}\r\n```\r\n\r\n为了确保准确性，我还加了一个或的逻辑（判断视口高度和屏幕高度是否一致）。\r\n\r\n## 监听/取消监听全屏事件\r\n\r\n事件监听也不复杂，主要是将参数的支持做好，并且把浏览器兼容性考虑在内。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de4c561199e4e189ac0f433b87b2221~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae42722df02e43548e9c37a783fd89ae~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 全屏状态一致性问题\r\n\r\n前面介绍了好几个应用层面的 API，但是我们还遗漏了一个重要问题，就是在上文中提到的 F11 按键和调用 API 的不一致问题，这会导致我们在获取全屏元素和判断全屏状态时都有可能出错。\r\n\r\n我的做法是：既然 F11 的行为与预期不一致，那我就将 F11 按键逻辑优化一下，禁止其默认行为（进入全屏），并根据当前是否是全屏状态调用`enterFullscreen()`或者`exitFullscreen()`。这样一来，就能保证进入全屏的入口都是通过 API 触发的，从而保证全屏状态的一致性。\r\n\r\n```\r\n/**\r\n * 阻止F11按键的默认行为，并根据当前的全屏状态调用进入/退出全屏，\r\n * 解决通过F11按键和API两种方式进入全屏时出现的状态不一致问题。\r\n */\r\nexport function patchF11DefaultAction(): void {\r\n    window.addEventListener('keydown', (e) => {\r\n        // https://w3c.github.io/uievents-code/\r\n        if (e.code === 'F11') {\r\n            e.preventDefault()\r\n            if (isFullscreen()) {\r\n                exitFullscreen()\r\n            } else {\r\n                enterFullscreen()\r\n            }\r\n        }\r\n    })\r\n}\r\n```\r\n\r\n如果您想了解全屏API更细致的内容，可以查阅[Fullscreen API Standard](https://fullscreen.spec.whatwg.org/)。\r\n\r\n## 封装为 Vue 组件\r\n\r\n对基础的全屏API做了封装后，我们就可以在此基础上封装一个全屏业务组件了。\r\n\r\n核心逻辑不复杂，主要是：\r\n\r\n- 根据当前是否是全屏状态，在 UI 上提供进入/退出全屏的能力。\r\n- 在适当的时机检查全屏状态，比如挂载/全屏事件触发后。\r\n- 提供函数类型的属性`getElement`，让调用者可以自由选择进入全屏的目标元素。之所以提供函数类型的`getElement`，是为了兼容 dom 异步挂载的情况。\r\n\r\n由于不同的项目可能对全屏这块的 UI 实现有不同的要求，这里就不细说了，唯一要注意的是全屏态的叠加问题，如果你希望控制 top layer 的叠加问题，就需要在逻辑中控制好进出全屏的顺序问题（比如先退出，再进入，保证只有一个全屏 layer）。注意看 body 和 div 标签右侧的 top-layer。\r\n\r\n![全屏top-layer叠加.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92d1dee78cc420da19fa7efe8a47e35~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n如果你想要了解组件的具体实现，可以前往[源码](https://github.com/cumt-robin/vue-pro-components/blob/c5/packages/vue-pro-components/src/fullscreen/fullscreen.vue)查看。\r\n\r\n# Headless 组件\r\n\r\nHeadless 组件的概念可以类比于 Headless 浏览器，其核心是一种重逻辑、轻 UI 的思想。\r\n\r\n> 引用 TanStack Table 给出的介绍：\r\n>\r\n> **Headless UI** is a term for libraries and utilities that provide the logic, state, processing and API for UI elements and interactions, but **do not provide markup, styles, or pre-built implementations**.\r\n\r\n虽然各大流行组件库都提供了较为通用的样式，并且也能通过覆盖样式支持一定程度上的定制。但是，这种 UI 范式也很难满足复杂的定制需求，我们可能会有这样的困惑：\r\n\r\n- 明明逻辑很相似，我却无法复用这个组件，需要改源码或者重新开发一个新组件。\r\n- 这个组件很契合我的需求，需求做到一半时发现：就差一个 div 不能定制了，其他的都满足需求......\r\n- 本来 2 人天的需求，因为某个 UI 组件不可控，直接导致人天翻倍。\r\n\r\n对于业务开发者来说，我们可能会提出这样的诉求：组件库能不能在提供一套 UI 实现的同时，把组件的所有状态和 API 都开放出来，让我们有自行实现 UI 渲染的可能性呢？这在某种程度上和 Headless 组件的理念不谋而合。\r\n\r\n## 我对 Headless 的理解\r\n\r\n介绍 Headless 组件的文章也有不少了，这里简单谈谈我对 Headless 组件的一点粗浅的理解和看法。\r\n\r\n在我看来，Headless 组件适合的场景是：\r\n\r\n- 组件逻辑相对简单，但是 UI 通用性不强，经常需要根据业务需求定制 UI 的场景。\r\n- 组件逻辑很复杂，需要通过抽象来实现复用，但是服务的上层通常不是具体的业务项目，大概率是组件库。\r\n- 跨框架复用，状态和逻辑用纯 js 管理，上层应用再针对框架去做适配层。\r\n\r\n举实际的例子说明下：\r\n\r\n场景1：我要实现一个全屏组件，但是有的业务项目希望全屏组件**对应的 UI 是一个按钮**，有的业务项目希望是一个**图标**，有的希望是**图标 + 文字**，甚至有更多可能性......虽然在 UI 方面有**多样性**的需求，但是**底层逻辑都是一样或类似**的，无非就是控制进出全屏、监听全屏的状态等。这种时候，提供一个可复用的 Hook 或者 Headless 组件是值得考虑的。\r\n\r\n场景2；我所在的公司是字节挑逗（瞎编的），公司有两个子品牌，一个是 dy，一个是 tt，两个团队都有一套组件库，都实现了比较复杂的 Table, Form 等组件，并且都服务了很多个上层业务，可能从直观上看，两套组件库主要是 UI 长得有点不一样，但是底层逻辑差不多。此时，我希望**两个品牌方团队能共用一套逻辑实现组件库，将关键逻辑下沉**。那么 Headless 组件可能是一个解决方案。\r\n\r\n场景3：我所在的公司是字节挑逗，公司的前端框架既有 Vue，也有 React，在这两套框架之上，都实现了对应的组件库，此时我想把逻辑下沉实现更大程度复用，**状态和逻辑不再依赖任何框架**（纯 js 撸一套，可能再用个类封装下），而在具体的框架之上再做**适配**工作（将**底层封装好的状态和逻辑**与**框架中的状态/属性/事件等概念**结合起来）。当然，这**也适用于跨平台的场景**。\r\n\r\nHeadless 是**直接服务业务方**，还是**服务特定框架下的 UI 组件库**，亦或是**对接框架或平台的适配层**，都是有可能的，这需要结合实际场景来考虑。Headless 不是万能和普适的，但确实给我们提供了一个新的值得探索的思路。\r\n\r\n## 开发一个 Headless 组件\r\n\r\n虽然 Headless 组件也火了一段时间了，但是目前在社区中还没有形成对 Headless 的共识，没有一个我们公认为**最佳实践**的做法。我们的第一个问题可能是：我开发的 Headless 组件要对外输出什么内容？是一个组件，还是一段逻辑？\r\n\r\n从 Headless 组件的中心思想——**逻辑层与表现层解耦**（具体表现为：内部封装状态和逻辑，对外支持 UI 的高度定制化）来看，这似乎与 Render Props / 作用域插槽 / Hooks 等概念有一定的相似性。如果要跨框架或者跨平台，Headless 组件可能也是纯 JS 的。这就决定了 Headless 组件并不是拘泥于某一种特定的形式，从现在社区中有的一些产品中，我们也能看出一些端倪。\r\n\r\n- 比如 Semi Design 就将一个组件分为了 Foundation 和 Adapter 部分，Foundation 负责实现组件通用的 JS 逻辑，Adapter 则是针对各个前端框架的适配层。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ceb99297116455dbefb606c33151456~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- [React Hook Form](https://react-hook-form.com/)也是一种 Headless 的实现，其在 Hook 内部把表单的核心逻辑都实现了，对外提供了状态，方法等，你只要拿着暴露出来的状态和 API，与视图做交互即可，这样一来，你可以在表单 UI 的实现上发挥充分的想象力，而不是局限于修改 css 或者拿着几个有限的 Render Props 做定制。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d6f64d2a7054410b9cfbadd8e22f8f1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n- 还有直接挂上 Headless 招牌的 TanStack Table。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41dff1655b43428487658d602cf33b8a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\nTanStack Table 在底层用纯 JS 实现了通用的 core 核心，并在上层提供了各大前端框架的 Adapter，当然你也可以选择直接用它的核心模块`createTable`。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dadf25bf144b4415a2970574a7356189~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n以 Vue 为例，对外提供的`useVueTable`就是将`createTable`核心与 Vue 的各个 API 做了 binding。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd87d88ebf414a56b4203bc79041716c~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n你可能会认为这跟 Hooks 之类的没有区别，这无可厚非，它们确实很相似。不过换个角度看，你可以认为 Hooks 之类的技术底座，是实现 Headless 组件的一种方式或者途径，但是它们并不是严格意义上的一回事。\r\n\r\n以我们目前实现的这个全屏组件而言，其实它最适合的 Headless 形式是 Hook。首先，我做的这个组件库是面向 Vue 框架的，并不需要像 Semi Design 或者 TanStack Table 这类方案一般提供 JS 层面的抽象。因此，我们借助 Vue Composition API，就能很快抽象出一个可复用的 Headless 组件，这样一来，业务方基于此就能很快定制出自己想要的 UI 效果。\r\n\r\n> 说了一圈，好像又陷入僵局了。额，Headless 可以是 Hook，也可以不是，不要纠结。\r\n\r\n那么我们就以这个全屏组件为例说说，怎么做一个 Headless 组件。\r\n\r\n不管 UI 怎么变，其实只关注两个事情：\r\n\r\n- 当前是否为全屏状态\r\n- 切换全屏状态的 API\r\n\r\n所以，我们可以把逻辑抽象成这样，对外只暴露`isTargetFullscreen`和`toggleFullscreen`即可：\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3354dcf7e0cf4aedb5a5fe5c9753989a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样一来，我们封装的全屏组件就能以这个 Hook 为基础简化：\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b767f1ce324c86a81ddacbdeff054f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n同时，外部也可以直接使用`@vue-pro-components/headless`提供的`useFullscreen`能力，实现 UI 自主可控（比如用一个开关组件承载全屏能力）。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04511af35001421aa86ed567adb7cc86~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n![useFullscreen.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e721d092d0f4552ad069cd8b24d4df5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 结语\r\n\r\n本文和前2篇文章都聚焦于**怎么实现基础的复杂度不高的业务组件**，看起来可能有点枯燥乏味，但也是为了**打个基础，引导部分还不太熟悉组件开发的读者慢慢进入状态，掌握组件开发的一些基本思想**。实际上，**开发组件**和**发布可用的组件**之间还**隔着一条鸿沟**，这就是从开发环境到生产环境必经的路，也是组件库研发过程中最复杂的部分。要越过这条鸿沟，就必须掌握一些工程化能力。如果您对我的专栏感兴趣，欢迎您[订阅关注本专栏](https://juejin.cn/column/7140103979697963045 \\\"https://juejin.cn/column/7140103979697963045\\\")，接下来可以一同探讨和交流组件库开发过程中遇到的问题。"
    },
    {
        "article_id": "7175917144025071673",
        "snapshot": "",
        "title": "超详细的ChatGPT注册教程来了",
        "preview": "一、 背景 最近一周，大家都在讨论ChatGPT，一些主流的技术社区更是将ChatGPT吹的神乎其技，那ChatGPT是什么呢？又能给我们带来哪些变化呢？。带着这些问题，我打算先注册并使用 ChatG",
        "author": "xiangzhihong",
        "view_count": 13551,
        "collect_count": 23,
        "comment_count": 4,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ae3b5ed78812b766bd8f5f82a5ee8128~300x300.image",
        "category": "人工智能",
        "content": "# 一、 背景\r\n\r\n最近一周，大家都在讨论ChatGPT，一些主流的技术社区更是将ChatGPT吹的神乎其技，那ChatGPT是什么呢？又能给我们带来哪些变化呢？。带着这些问题，我打算先注册并使用 ChatGPT，供想要体验 ChatGPT 的小伙伴们参考。\r\n\r\n首先，我们来了解下什么是ChatGPT，以及它的诞生背景。根据维基百科的官方解释：ChatGPT是由OpenAI开发的一个人工智能聊天机器人程序，于2022年11月30日推出。该程序使用基于GPT-3.5架构的大型语言模型并通过强化学习进行训练。ChatGPT 使用基于人类反馈的强化学习进行训练，这种方法通过人类干预以增强机器学习的效果，从而获得更为逼真的结果。其使用基于GPT-3.5架构的语言模型。在训练过程中，人类训练师扮演着用户与人工智能助手的角色。模型在Microsoft Azure的超级计算机上训练，并通过近端策略优化算法（proximal policy optimization）进行微调。这种策略优化算法比信任域策略优化（trust region policy optimization）算法更为高效。\r\n\r\n\r\n# 二、注册 ChatGPT\r\n\r\n要注册使用 ChatGPT，我们需要准备以下内容：\r\n\r\n-   能够访问Google的全局代理，推荐美国节点；\r\n-   一个邮箱用于注册，如Gmail, Outlook ；\r\n-   一个国外手机号，如果没有可以使用sms-activate.org；\r\n\r\n## 2.1 注册短信平台\r\n\r\n由于ChatGPT的注册需要用到国外的手机号接收验证码，如果没有的话可以开发sms-activate.org网站注册一个账号。\r\n\r\n \r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6643263b9a4c6697c1b8097f5fb12d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n由于每次接收验证码都要收取10.5卢布，大约1.2 人民币，如果你的账号没有钱，可以点击右上角余额进行充值。sms-activate支持的充值方式又很多，我们滑到支付宝选择支付宝充值。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9a506b454a4f398932b110435a0a68~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 2.2 注册OpenAI\r\n\r\n回到主界面，然后在搜索框中输入OpenAI，如下图所示。\r\n\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c309c1a2c9b645b98f079ed1b7c4276e~tplv-k3u1fbpfcp-watermark.image?)\r\n \r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de63502db5a347e59659ca4a0829d557~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后，点击小黄车即可购买，购买成功后，我们需要将手机号复制出来供后面使用。\r\n\r\n \r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e85c427aca14c2883a7e704c14c05c1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n有了手机号之后，我们就可以注册OpenAI账号了。打开<https://beta.openai.com/signup>链接，然后开始注册。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ac97b695d74813a083e71b957d1d62~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n然后，我们选择选择刚刚注册的国家为印度，将刚刚注册的手机号复制过去，记得去掉国家号，此处是91。最近评论区有留言说选择印度可能会失败了，建议换成印尼🇮🇩/巴西🇧🇷/泰国🇹🇭试试。\r\n\r\n \r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582fb915e5284f898dcc09b8487770ca~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n回到之前获取手机号的界面，会出现短信，复制短信验证码即可。之后你就可以愉快的和ChatGPT聊天啦，快去试试吧。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68c80a0d5bc942bab3d1e826b40c5a0d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n# 三、体验ChatGPT\r\n\r\n我们打开<https://beta.openai.com/overview>官网链接。然后在顶部选择某个话题，点击的【 Try it】按钮，就可以开始与 ChatGPT 聊天啦！\r\n \r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/641f5283a95a48d3b0ec672cc4073bd7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2b5cf436934bb2b217211445cb4d82~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n简单的体验了一下ChatGPT，发现还是挺好玩的，大家不妨试一试。并且随着ChatGPT的大热，最近一款名为 Glow 的 AI 聊天应用上线 App store，被称为 ChatGPT 的国产平替。据介绍，Glow 基于 AIGC 技术打造，希望给那些无聊、焦虑或者需要被倾听的人，提供一个随时有认真回复的智能体。"
    },
    {
        "article_id": "7159042278252609550",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479192aa76cb452d8767f24aa20537b0~tplv-k3u1fbpfcp-watermark.image?",
        "title": "2022高频前端面试题合集之JavaScript篇（下）",
        "preview": "近期整理了一下高频的前端面试题，分享给大家一起来学习。如有问题，欢迎指正！ 欢迎大家关注该专栏：点赞👍 + 收藏🤞 前端面试题系列文章： 【1】2022高频前端面试题——HTML篇 【2】2022高频",
        "author": "法医",
        "view_count": 1620,
        "collect_count": 87,
        "comment_count": 5,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/ccf5b399305a43fb8c51d0ba1ee9cf31~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: fancy\r\nhighlight: atom-one-dark\r\n---\r\n\r\n近期整理了一下高频的前端面试题，分享给大家一起来学习。如有问题，欢迎指正！\r\n\r\n欢迎大家关注该专栏：点赞👍 + 收藏🤞\r\n\r\n#### 前端面试题系列文章：\r\n\r\n【1】[2022高频前端面试题——HTML篇](https://juejin.cn/post/7095899257072254989)\r\n\r\n【2】[2022高频前端面试题——CSS篇 ](https://juejin.cn/post/7098689890933538853)\r\n\r\n【3】[ 2022高频前端面试题合集之JavaScript篇（上）](https://juejin.cn/post/7153593226526457887)\r\n\r\n【4】[ 2022高频前端面试题合集之JavaScript篇（中）](https://juejin.cn/post/7155647370233905188)\r\n\r\n\r\n\r\n# *JavaScript* 面试题汇总（下篇）\r\n\r\n\r\n\r\n### 201. 冒泡排序的思路，不用 *sort*\r\n\r\n> 参考答案：\r\n>\r\n> 示例代码如下：\r\n>\r\n> ```js\r\n> var examplearr = [8, 94, 15, 88, 55, 76, 21, 39];\r\n> function sortarr(arr) {\r\n>     for (i = 0; i < arr.length - 1; i++) {\r\n>         for (j = 0; j < arr.length - 1 - i; j++) {\r\n>             if (arr[j] > arr[j + 1]) {\r\n>                 var temp = arr[j];\r\n>                 arr[j] = arr[j + 1];\r\n>                 arr[j + 1] = temp;\r\n>             }\r\n>         }\r\n>     }\r\n>     return arr;\r\n> }\r\n> sortarr(examplearr);\r\n> console.log(examplearr); // [8, 15, 21, 39, 55, 76, 88, 94]\r\n> ```\r\n\r\n\r\n\r\n### 202. *symbol* 用途\r\n\r\n> 参考答案：\r\n>\r\n> 可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗?我没想出其他的用处就直接答我不知道了，还可以利用 symbol 不会被常规的方法(除了 Object.getOwnPropertySymbols 外)遍历到，所以可以用来模拟私有变量。\r\n>\r\n> 主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。\r\n>\r\n> Symbol.for() 可以在全局访问 symbol\r\n\r\n\r\n\r\n### 203. 什么是函数式编程，应用场景是什么\r\n\r\n> 参考答案：\r\n>\r\n> 函数式编程和面向对象编程一样，是一种编程范式。强调执行的过程而非结果，通过一系列的嵌套的函数调用，完成一个运算过程。\r\n>  它主要有以下几个特点：\r\n>\r\n> 1. 函数是\\\"一等公民\\\"：函数优先，和其他数据类型一样。\r\n> 2. 只用\\\"表达式\\\"，不用\\\"语句\\\"：通过表达式（*expression*）计算过程得到一个返回值，而不是通过一个语句（*statement*）修改某一个状态。\r\n> 3. 无副作用：不污染变量，同一个输入永远得到同一个数据。\r\n> 4. 不可变性：前面一提到，不修改变量，返回一个新的值。\r\n>\r\n> 函数式编程的概念其实出来也已经好几十年了，我们能在很多编程语言身上看到它的身影。比如比较纯粹的 *Haskell*，以及一些语言开始逐渐成为多范式编程语言，比如 *Swift*，还有 *Kotlin，Java，Js* 等都开始具备函数式编程的特性。\r\n>\r\n> **函数式编程在前端的应用场景**\r\n>\r\n> - *Stateless components*：*React* 在 *0.14* 之后推出的无状态组件\r\n> - *Redux*\r\n>\r\n> **函数式编程在后端的应用场景**\r\n>\r\n> - *Lambda* 架构\r\n\r\n\r\n\r\n### 204. 事件以及事件相关的兼容性问题\r\n\r\n> 参考答案：\r\n>\r\n> 事件最早是在 *IE3* 和  *Navigator2* 中出现的，当时是作为分担服务器运算负担的一种手段。要实现和网页的互动，就需要通过 *JavaScript* 里面的事件来实现。\r\n>\r\n> 每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测这些事件，然后对此作出响应。从而形成一种交互。\r\n>\r\n> 当我们绑定事件时，需要遵循事件三要素\r\n>\r\n> - 事件源：是指那个元素引发的事件。比如当你点击图标的时候，会跳转到百度首页。那么这个图标就是事件源。\r\n> - 事件：事件是指执行的动作。例如，点击，鼠标划过，按下键盘，获得焦点。\r\n> - 事件驱动程序：事件驱动程序即执行的结果。例如，当你点击图标的时候，会跳转到百度首页。那么跳转到百度首页就是事件的处理结果。\r\n>\r\n> ```js\r\n> 事件源.事件 = function() {\r\n>     事件处理函数\r\n> }\r\n> ```\r\n>\r\n\r\n\r\n\r\n\r\n### 205. *JS* 小数不精准，如何计算\r\n\r\n> 参考答案：\r\n>\r\n> 方法一：指定要保留的小数位数(0.1+0.2).toFixed(1) = 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不同浏览器对toFixed的计算结果也存在差异。\r\n>\r\n> 方法二：把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。 \r\n\r\n\r\n\r\n### 206. 写一个 *mySetInterVal(fn, a, b)*，每次间隔 *a,a+b,a+2b* 的时间，然后写一个 *myClear*，停止上面的 *mySetInterVal*\r\n\r\n> 参考答案：\r\n>\r\n> 该题的思路就是每一次在定时器中重启定时器并且在时间每一次都加 *b*，并且要把定时器返回回来，可以作为*myClear*的参数。\r\n>\r\n> 代码如下：\r\n>\r\n> ```js\r\n> var mySetInterVal = function (fn, a, b) {\r\n>   var timer = null;\r\n>   var settimer = function (fn, a, b) {\r\n>     timer = setTimeout(() => {\r\n>       fn();\r\n>       settimer(fn, a + b, b);\r\n>     }, a);\r\n>   }\r\n>   settimer(fn, a, b);\r\n>   return timer;\r\n> }\r\n> \r\n> var timer = mySetInterVal(() => { console.log('timer') }, 1000, 1000);\r\n> var myClear = function (timer) {\r\n>   timer && clearTimeout(timer);\r\n> }\r\n> ```\r\n\r\n\r\n\r\n### 207. 合并二维有序数组成一维有序数组，归并排序的思路\r\n\r\n> 参考答案：\r\n>\r\n> 示例代码如下：\r\n>\r\n> ```js\r\n> function merge(left, right) {\r\n>     let result = []\r\n>     while (left.length > 0 && right.length > 0) {\r\n>         if (left[0] < right[0]) {\r\n>             result.push(left.shift())\r\n>         } else {\r\n>             result.push(right.shift())\r\n>         }\r\n>     }\r\n>     return result.concat(left).concat(right)\r\n> }\r\n> function mergeSort(arr) {\r\n>     if (arr.length === 1) {\r\n>         return arr\r\n>     }\r\n>     while (arr.length > 1) {\r\n>         let arrayItem1 = arr.shift();\r\n>         let arrayItem2 = arr.shift();\r\n>         let mergeArr = merge(arrayItem1, arrayItem2);\r\n>         arr.push(mergeArr);\r\n>     }\r\n>     return arr[0]\r\n> }\r\n> \r\n> let arr1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 2, 3], [4, 5, 6]];\r\n> let arr2 = [[1, 4, 6], [7, 8, 10], [2, 6, 9], [3, 7, 13], [1, 5, 12]];\r\n> console.log(mergeSort(arr1))\r\n> console.log(mergeSort(arr2))\r\n> ```\r\n\r\n\r\n\r\n### 208. 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\r\n\r\n> 参考答案：\r\n>\r\n> 首先，我们肯定需要封装一个函数，而这个函数接收一个字符串作为参数，返回不含有重复字符的子串长度。来看下面的示例：\r\n>\r\n> 示例 1:\r\n>\r\n> 输入: “abcabcbb”\r\n> 输出: 3\r\n> 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\r\n>\r\n> 示例 2:\r\n>\r\n> 输入: “bbbbb”\r\n> 输出: 1\r\n> 解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。\r\n>\r\n> 示例 3:\r\n>\r\n> 输入: “pwwkew”\r\n> 输出: 3\r\n> 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。\r\n> 请注意，你的答案必须是 子串 的长度，“pwke” 是一个子序列，不是子串。\r\n>\r\n> 示例代码：\r\n>\r\n> ```js\r\n> var lengthOfLongestSubstring = function (s) {\r\n>     var y = [];\r\n>     var temp = [];\r\n>     var maxs = 0;\r\n>     if (s == \\\"\\\") {\r\n>         return 0;\r\n>     }\r\n>     if (s.length == 1) {\r\n>         return 1;\r\n>     }\r\n>     for (var i = 0; i < s.length; i++) {\r\n>         if (temp.includes(s[i])) {\r\n> \r\n>             y.push(temp.length);\r\n>             temp.shift();\r\n>             continue;\r\n>         } else {\r\n>             temp.push(s[i])\r\n>             y.push(temp.length);\r\n>         }\r\n> \r\n>     }\r\n>     for (var j = 0; j < y.length; j++) {\r\n>         if (maxs <= y[j]) {\r\n>             maxs = y[j]\r\n>         }\r\n>     }\r\n>     return maxs;\r\n> };\r\n> // 测试\r\n> console.log(lengthOfLongestSubstring('abcabcbb')); // 3\r\n> console.log(lengthOfLongestSubstring('bbbbb')); // 1\r\n> console.log(lengthOfLongestSubstring('pwwkew')); // 3\r\n> \r\n> ```\r\n\r\n\r\n\r\n### 209. 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）(滴滴 *2020*)\r\n\r\n> 参考答案：\r\n>\r\n> 本道题目是一道考察算法的题目，主要是考察编程基本功和一定的想像力。\r\n>\r\n> 具体的实现如下：\r\n>\r\n> ```js\r\n> function fun(total, n) {\r\n>     //先对整个数组进行排序\r\n>     total.sort((a, b) => a - b);\r\n> \r\n>     //求和\r\n>     var sum = 0;\r\n>     for (var i = 0; i < total.length; i++) {\r\n>         sum += total[i];\r\n>     }\r\n> \r\n>     var avg = Math.ceil(sum / n);\r\n> \r\n>     //结果数组\r\n>     var result = []; //长度为n\r\n> \r\n>     for (var i = 0; i < n; i++) {\r\n>         result[i] = [total.pop()];\r\n>         result[i].sum = result[i][0];\r\n> \r\n>         //组成一个分数组\r\n>         while (result[i].sum < avg && total.length > 0) {\r\n>             for (var j = 0; j < total.length; j++) {\r\n>                 if (result[i].sum + total[j] >= avg) {\r\n>                     result[i].push(total[j]);\r\n>                     result[i].sum += total[j];\r\n>                     break;\r\n>                 }\r\n>             }\r\n> \r\n>             if (j == total.length) {\r\n>                 result[i].push(total.pop());\r\n>                 result[i].sum += result[i][result[i].length - 1];\r\n>             } else {\r\n>                 //从数组中移除此元素\r\n>                 total.splice(j, 1);\r\n>             }\r\n>         }\r\n> \r\n>         sum -= result[i].sum;\r\n>         avg = Math.ceil(sum / (n - 1 - i));\r\n> \r\n>     }\r\n>     return result;\r\n> }\r\n> \r\n> // 测试\r\n> var arr = [11, 42, 23, 4, 5, 6, 4, 5, 6, 11, 23, 42, 56, 78, 90];\r\n> console.log(fun(arr, 3));\r\n> // [\r\n> //     [ 90, 56, sum: 146 ],\r\n> //     [ 78, 42, 11, sum: 131 ],\r\n> //     [ 42, 23, 23, 11, 6, 6, 5, 5, 4, 4, sum: 129 ]\r\n> // ]\r\n> ```\r\n\r\n\r\n\r\n### 210. 手写发布订阅（头条2020）\r\n\r\n> 参考答案：\r\n>\r\n> 示例代码如下：\r\n>\r\n> ```html\r\n> <body>\r\n>     <div id=\\\"app\\\">\r\n>         <p>this is a test</p>\r\n>         {{msg}}<input type=\\\"text\\\" v-model=\\\"msg\\\">{{msg}}\r\n>     </div>\r\n>     <script src=\\\"./index.js\\\"></script>\r\n>     <script>\r\n>         const vm = new Vue({\r\n>             el : '#app',\r\n>             data : {\r\n>                 msg : ''\r\n>             }\r\n>         });\r\n>     </script>\r\n> </body>\r\n> ```\r\n>\r\n> ```js\r\n> /*\r\n>     1. 创建 Vue 构造函数\r\n>         在 Vue 构造函数中，调用了 observer 函数，该函数的作用就是对数据进行劫持\r\n>         劫持具体要做的事儿：复制一份数据，但是不是单纯的复制，而是增加了 getter、setter\r\n>     2. 书写 compile 函数。该函数主要作用于模板，从模板里面要提取信息\r\n>         提取的东西主要有两个：{{}}  和 v-model\r\n>     3. 创建发布者 Dep 的构造函数，如果数据发生变化，发布者就会遍历内部的数组（花名册），通知订阅者修改数据\r\n>     4. 创建订阅者 Watcher 的构造函数，如果有数据的变化，发布者就会通知订阅者，订阅者上面存在 update 方法，会进行修改\r\n>  */\r\n> \r\n> function Vue(options){\r\n>     // this 代表 Vue 的实例对象，本例中就是 vm\r\n>     // options.data 这就是实际的数据 {msg : 'xiejie'}\r\n>     observer(this,options.data);\r\n>     this.$el = options.el;\r\n>     compile(this);\r\n> }\r\n> \r\n> // 用于对模板进行信息提取，主要提取 {{}}  和 v-model，然后进行一些操作\r\n> // {{ }} 会成为观察者，v-model 所对应的控件来绑定事件\r\n> function compile(vm){\r\n>     var el = document.querySelector(vm.$el); // el 所对应的值为 <div id=\\\"app\\\">...</div>\r\n>     var documentFragment = document.createDocumentFragment(); // 创建了一个空的文档碎片\r\n>     var reg = /\\\\{\\\\{(.*)\\\\}\\\\}/; // 创建正则表达式 匹配 {{ }}\r\n>     while(el.childNodes[0]){\r\n>         var child = el.childNodes[0]; // 将第一个子节点存储到 child\r\n>         if(child.nodeType == 1){\r\n>             // 如果能够进入此 if，说明该节点是一个元素节点\r\n>             for(var key in child.attributes){\r\n>                 // 遍历该元素节点的每一个属性，拿到的就是 type=\\\"text\\\" v-model=\\\"msg\\\"\r\n>                 var attrName = child.attributes[key].nodeName; // 获取属性名  type、v-model\r\n>                 if(attrName === 'v-model'){\r\n>                     var vmKey = child.attributes[key].nodeValue; // 先获取属性值，也就是 msg\r\n>                     // 为该节点，也就是 <input type=\\\"text\\\" v-model=\\\"msg\\\"> 绑定一个 input 事件\r\n>                     child.addEventListener('input', function (event) {\r\n>                         vm[vmKey] = event.target.value; // 获取用户输入的值，然后改变 vm 里面的 msg 属性对应的值，注意这里会触发 setter\r\n>                     })\r\n>                 }\r\n>             }\r\n>         }\r\n>         if(child.nodeType == 3){\r\n>             // 如果能进入此 if，说明该节点是一个文本节点\r\n>             if(reg.test(child.nodeValue)){\r\n>                 // 如果能够进入到此 if，说明是 {{ }}，然后我们要让其成为订阅者\r\n>                 var vmKey = RegExp.$1; // 获取正则里面的捕获值，也就是 msg\r\n>                 // 实例化一个 Watcher（订阅者），接收 3 个参数：Vue 实例，该文本节点，捕获值 msg\r\n>                 new Watcher(vm, child, vmKey);\r\n>             }\r\n>         }\r\n>         documentFragment.appendChild(el.childNodes[0]); // 将第一个子节点添加到文档碎片里面\r\n>     }\r\n>     // 将文档碎片中节点重新添加到 el，也就是 <div id=\\\"app\\\"></div> 下面\r\n>     el.appendChild(documentFragment);\r\n> }\r\n> \r\n> // 新建发布者构造函数\r\n> function Dep() {\r\n>     // 将观察者添加到发布者内部的数组里面\r\n>     // 这样以便于通知所有的观察者去更新数据\r\n>     this.subs = [];\r\n> }\r\n> \r\n> Dep.prototype = {\r\n>     // 将 watcher 添加到发布者内置的数组里面\r\n>     addSub: function (sub) {\r\n>         this.subs.push(sub);\r\n> \r\n>     },\r\n>     // 遍历数组里面所有的 watcher，通知它们去更新数据\r\n>     notify: function () {\r\n>         this.subs.forEach(function (sub) {\r\n>             sub.update();\r\n>         })\r\n>     }\r\n> }\r\n> \r\n> // 新建观察者 Watcher 构造函数\r\n> // 接收 3 个参数：Vue 实例，文本节点 {{ msg }} 以及捕获内容 msg\r\n> function Watcher(vm, child, vmKey) {\r\n>     this.vm = vm; // vm \r\n>     this.child = child; // {{ msg }}\r\n>     this.vmKey = vmKey; // msg\r\n>     Dep.target = this; // 将该观察者实例对象添加给 Dep.target\r\n>     this.update(); // 执行节点更新方法\r\n>     Dep.target = null; // 最后清空 Dep.target\r\n> }\r\n> Watcher.prototype = {\r\n>     // 节点更新方法\r\n>     update: function () {\r\n>         // 相当于：{{ msg }}.nodeValue = this.vm['msg']\r\n>         // 这样就更新了文本节点的值，由于这里在获取 vm.msg，所以会触发 getter\r\n>         this.child.nodeValue = this.vm[this.vmKey];\r\n>     }\r\n> }\r\n> \r\n> // 该函数的作用是用于数据侦听\r\n> function observer(vm,obj){\r\n>     var dep = new Dep(); // 新增一个发布者:发布者的作用是告诉订阅者数据已经更改\r\n>     // 遍历数据\r\n>     for(var key in obj){\r\n>         // 将数据的每一项添加到 vm 里面，至此，vm 也有了每一项数据\r\n>         // 但是不是单纯的添加，而是设置了 getter 和 setter\r\n>         // 在获取数据时触发 getter，在设置数据时触发 setter\r\n>         Object.defineProperty(vm, key, {\r\n>             get() {\r\n>                 console.log(\\\"触发get了\\\");\r\n>                 // 触发 getter 时，将该 watcher 添加到发布者维护的数组里面\r\n>                 if (Dep.target) {\r\n>                     dep.addSub(Dep.target); // 往发布者的数组里面添加订阅者\r\n>                 }\r\n>                 console.log(dep.subs);\r\n>                 return obj[key];\r\n>             },\r\n>             set(newVal) {\r\n>                 console.log(\\\"触发set了\\\");\r\n>                 obj[key] = newVal;\r\n>                 dep.notify(); // 发布者发出消息，通知订阅者修改数据\r\n>             }\r\n>         });\r\n>     }\r\n> }\r\n> ```\r\n\r\n\r\n\r\n### 211. 手写用 *ES6proxy* 如何实现 *arr[-1]* 的访问（滴滴2020）\r\n\r\n> 参考答案：\r\n>\r\n> 示例代码如下：\r\n>\r\n> ```js\r\n> const proxyArray = arr => {\r\n>     const length = arr.length;\r\n>     return new Proxy(arr, {\r\n>         get(target, key) {\r\n>             key = +key;\r\n>             while (key < 0) {\r\n>                 key += length;\r\n>             }\r\n>             return target[key];\r\n>         }\r\n>     })\r\n> };\r\n> var a = proxyArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);\r\n> console.log(a[1]);  // 2\r\n> console.log(a[-10]);  // 9\r\n> console.log(a[-20]);  // 8\r\n> ```\r\n\r\n\r\n\r\n### 212. 下列代码执行结果\r\n\r\n```js\r\nconsole.log(1);\r\nsetTimeout(() => {\r\n    console.log(2);\r\n    process.nextTick(() => {\r\n        console.log(3);\r\n    });\r\n    new Promise((resolve) => {\r\n        console.log(4);\r\n        resolve();\r\n    }).then(() => {\r\n        console.log(5);\r\n    });\r\n});\r\nnew Promise((resolve) => {\r\n    console.log(7);\r\n    resolve();\r\n}).then(() => {\r\n    console.log(8);\r\n});\r\nprocess.nextTick(() => {\r\n    console.log(6);\r\n});\r\nsetTimeout(() => {\r\n    console.log(9);\r\n    process.nextTick(() => {\r\n        console.log(10);\r\n    });\r\n    new Promise((resolve) => {\r\n        console.log(11);\r\n        resolve();\r\n    }).then(() => {\r\n        console.log(12);\r\n    });\r\n});\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 1\r\n> 7\r\n> 6\r\n> 8\r\n> 2\r\n> 4\r\n> 3\r\n> 5\r\n> 9\r\n> 11\r\n> 10\r\n> 12\r\n\r\n\r\n\r\n### 213. Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\r\n\r\n> 参考答案：\r\n>\r\n> Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。\r\n\r\n\r\n\r\n### 214. 事件是如何实现的？(字节2020)\r\n\r\n> 参考答案：\r\n>\r\n> 基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。\r\n>\r\n> 比如点击按钮，这是个事件(Event)，而负责处理事件的代码段通常被称为事件处理程序(Event Handler)，也就是「启动对话框的显示」这个动作。\r\n>\r\n> 在 Web 端，我们常见的就是 DOM 事件：\r\n>\r\n> - DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。\r\n> - DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件\r\n> - DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件\r\n\r\n\r\n\r\n### 215. 下列代码执行结果\r\n\r\n```js\r\nPromise.resolve().then(() => {\r\n    console.log(0);\r\n    return Promise.resolve(4);\r\n}).then((res) => {\r\n    console.log(res)\r\n})\r\n\r\nPromise.resolve().then(() => {\r\n    console.log(1);\r\n}).then(() => {\r\n    console.log(2);\r\n}).then(() => {\r\n    console.log(3);\r\n}).then(() => {\r\n    console.log(5);\r\n}).then(() =>{\r\n    console.log(6);\r\n})\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 0\r\n> 1\r\n> 2\r\n> 3\r\n> 4\r\n> 5\r\n> 6\r\n\r\n> 解析：\r\n>\r\n> 照着代码，我们先来看初始任务。\r\n>\r\n> - （初始任务）第一部分 Promise.resolve() 返回 「Promise { undefined }」。\r\n>\r\n> - （同任务，下同）继续调用 then，then 发现「Promise { undefined }」已解决，直接 enqueue 包含 console.log(0);return Promise.resolve(4) 的任务，之后返回新的「Promise { \\\\<pending> }」（设为 promise0）。被 enqueue 的任务之后会引发 promise0 的 resolve/reject，详见 追加任务一 的 2. 3. 。\r\n>\r\n> - 继续调用 promise0 上的 then，第二个 then 发现 promise0 还在 pending，因此不能直接 enqueue 新任务，而是将包含 console.log(res) 回调追加到 promise0 的 PromiseFulfillReactions 列表尾部，并返回新的「Promise { <pending> }」（设为 promiseRes）（该返回值在代码中被丢弃，但不影响整个过程）。\r\n>\r\n> - 第二部分 Promise.resolve().then... 同理，只有包含 console.log(1) 的任务被 enqueue。中间结果分别设为 promise1（=Promise.resolve().then(() => {console.log(1);})）, promise2, promise3, promise5, promise6。当前任务执行完毕。\r\n>\r\n> 此时，任务列队上有两个新任务，分别包含有 console.log(0);return Promise.resolve(4) 和 console.log(1) 。我们用 「Job { ??? }」来指代。\r\n>\r\n> 接下来，「Job { console.log(0);return Promise.resolve(4) }」先被 enqueue，所以先运行「Job { console.log(0);return Promise.resolve(4) }」。\r\n>\r\n> - （追加任务一）此时「0」被 console.log(0) 输出。Promise.resolve(4) 返回已解决的「Promise { 4 }」，然后 return Promise.resolve(4) 将这个「Promise { 4 }」作为最开始的 Promise.resolve().then（对应 promise0）的 onfulfill 处理程序（即 then(onfulfill, onreject) 的参数 onfulfill）的返回值返回。\r\n>\r\n> - （同任务，下同）onfulfill 处理程序返回，触发了 promise0 的 Promise Resolve Function（以下简称某 promise（实例）的 resolve）。所谓触发，其实是和别的东西一起打包到「Job { console.log(0);return Promise.resolve(4) }」当中，按流程执行，onfulfill 返回后自然就到它了。（onfulfill 抛异常的话会被捕获并触发 reject，正常返回就是 resolve。）\r\n>\r\n> - promise0 的 resolve 检查 onfulfill 的返回值，发现该值包含**可调用的**「then」属性。这是当然的，因为是「Promise { 4 }」。无论该 Promise 实例是否解决，都将 enqueue 一个新任务包含调用该返回值的 then 的任务（即规范中的 NewPromiseResolveThenableJob(promiseToResolve, thenable, then)）。而这个任务才会触发后续操作，在本例中，最终会将 promise0 的 PromiseFulfillReactions （其中有包含 console.log(res) 回调）再打包成任务 enqueue 到任务列队上。当前任务执行完毕。\r\n>\r\n> 此时，任务列队上还是有两个任务（一进一出），「Job { console.log(1) }」和「NewPromiseResolveThenableJob(promise0, 「Promise { 4 }」, 「Promise { 4 }」.then)」。接下来执行「Job { console.log(1) }」。\r\n>\r\n> - （追加任务二）「1」被输出。\r\n>\r\n> - （同任务，下同）onfulfill 处理程序返回 undefined。（JavaScript 的函数默认就是返回 undefined。）\r\n>\r\n> - promise1 的 resolve 发现 undefined 连 Object 都不是，自然不会有 then，所以将 undefined 作为 promise1 的解决结果。即 promise1 从「Promise { \\\\<pending> }」变为 「Promise { undefined }」（fulfill）。\r\n>\r\n> - resolve 继续查看 promise1 的 PromiseFulfillReactions。（reject 则会查看 PromiseRejectReactions。）有一个之前被 promise1.then 调用追加上的包含 console.log(2) 的回调。打包成任务入列。（如有多个则依次序分别打包入列。）当前任务执行完毕。\r\n>\r\n> 此时，任务列队上仍然有两个任务（一进一出）。「NewPromiseResolveThenableJob(...)」和 「Job { console.log(2) }」。执行「NewPromiseResolveThenableJob(...)」。\r\n>\r\n> - （追加任务三）调用 「Promise { 4 }」的 then。这个调用的参数（处理程序 onfulfill 和 onreject） 用的正是 promise0 的 resolve 和 reject。\r\n>\r\n> - 由于「Promise { 4 }」的 then 是标准的，行为和其他的 then 一致。（可参见初始任务的步骤 2. 。）它发现「Promise { 4 }」已解决，结果是 4。于是直接 enqueue 包含 promise0 的 resolve 的任务，参数是 4。理论上同样返回一个「Promise { <pending> }」，由于是在内部，不被外部观察，也不产生别的影响。）当前任务执行完毕。\r\n>\r\n> 此时，任务列队上依旧有两个任务（一进一出）。「Job { console.log(2) }」和 「Job { promise0 的 resolve }」。执行「Job { console.log(2) }」。\r\n>\r\n> - （追加任务四）过程类似「Job { console.log(1) }」的执行。「2」被输出。「Job { console.log(3) }」入列。其余不再赘述。当前任务执行完毕。\r\n>\r\n> 此时，任务列队上依然有两个任务（一进一出）。「Job { promise0 的 resolve }」和「Job { console.log(3) }」。执行「Job { promise0 的 resolve }」。\r\n>\r\n> - （追加任务五）promise0 的 resolve 查看 PromiseFulfillReactions 发现有被 promise0.then 追加的回调。打包成任务入列。该任务包含 console.log(res)，其中传递 promise0 解决结果 4 给参数 res。当前任务执行完毕。\r\n>\r\n> 此时，任务列队上还是两个任务（一进一出）。「Job { console.log(3) }」和「Job { console.log(res) }」。\r\n>\r\n> - （追加任务六）输出「3」。「Job { console.log(5) }」入列。\r\n>\r\n> 此时，任务列队上还是两个任务（一进一出）。「Job { console.log(res) }」和「Job { console.log(5) }」。\r\n>\r\n> - （追加任务七）输出「4」。由于 promiseRes 没有被 then 追加回调。就此打住。\r\n>\r\n> 此时，任务列队上终于不再是两个任务了。下剩「Job { console.log(5) }」。\r\n>\r\n> - （追加任务八）输出「5」。「Job { console.log(6) }」入列。\r\n>\r\n> 最后一个任务（追加任务九）输出「6」。任务列队清空。\r\n>\r\n> 因此，输出的顺序是「0 1 2 3 4 5 6」。\r\n>\r\n> 总结一下，除去初始任务，总共 enqueue 了 9 个任务。其中，第一串 Promise + then... enqueue 了 4 个。第二串 Promise + then... enqueue 了 5 个。分析可知，每增加一个 then 就会增加一个任务入列。\r\n>\r\n> 而且，第一串的 return Promise.resolve(4) 的写法额外 enqueue 了 2 个任务，分别在 promise0 的 resolve 时（追加任务一 3.）和调用「Promise { 4 }」的 then 本身时（追加任务三 2.）。\r\n>\r\n> 根据规范，它就该这样。说不上什么巧合，可以算是有意为之。处理程序里返回 thenable 对象就会导致增加两个任务入列。\r\n\r\n\r\n\r\n### 216. 判断数组的方法，请分别介绍它们之间的区别和优劣\r\n\r\n> 参考答案：\r\n>\r\n> 方法一：**instanceof 操作符判断**\r\n>\r\n> **用法：arr instanceof Array**\r\n>\r\n> **instanceof 主要是用来判断某个实例是否属于某个对象**\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(arr instanceof Array); // true\r\n> ```\r\n>\r\n> 缺点：instanceof是判断类型的prototype是否出现在对象的原型链中，但是对象的原型可以随意修改，所以这种判断并不准确。并且也不能判断对象和数组的区别\r\n>\r\n> 方法二：**对象构造函数的 constructor判断**\r\n>\r\n> **用法：arr.constructor === Array**\r\n>\r\n> **Object的每个实例都有构造函数 constructor，用于保存着用于创建当前对象的函数**\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(arr.constructor === Array); // true\r\n> ```\r\n>\r\n> 方法三：**Array 原型链上的 isPrototypeOf**\r\n>\r\n> **用法：Array.prototype.isPrototypeOf(arr**)\r\n>\r\n> **Array.prototype  属性表示 Array 构造函数的原型**\r\n>\r\n> 其中有一个方法是 isPrototypeOf() 用于测试一个对象是否存在于另一个对象的原型链上。\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(Array.prototype.isPrototypeOf(arr)); // true\r\n> ```\r\n>\r\n> 方法四：**Object.getPrototypeOf**\r\n>\r\n> **用法：Object.getPrototypeOf(arr) === Array.prototype**\r\n>\r\n> **Object.getPrototypeOf() 方法返回指定对象的原型**\r\n>\r\n> 所以只要跟Array的原型比较即可\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(Object.getPrototypeOf(arr) === Array.prototype); // true\r\n> ```\r\n>\r\n> 方法五：**Object.prototype.toString**\r\n>\r\n> **用法：Object.prototype.toString.call(arr) === '[object Array]'**\r\n>\r\n> 虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(Object.prototype.toString.call(arr) === '[object Array]'); // true\r\n> ```\r\n>\r\n> 缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]\r\n>\r\n> 方法六：**Array.isArray**\r\n>\r\n> **用法：Array.isArray(arr)**\r\n>\r\n> **ES5中新增了Array.isArray方法,IE8及以下不支持**\r\n>\r\n> Array.isArray ( arg )\r\n> isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 \\\"Array\\\", 返回布尔值 true；否则它返回 false。\r\n>\r\n> ```js\r\n> let arr = [];\r\n> console.log(Array.isArray(arr)); // true\r\n> ```\r\n>\r\n> 缺点：Array.isArray是ES 5.1推出的，**不支持IE6~8**，所以在使用的时候需要注意兼容性问题。\r\n\r\n\r\n\r\n### 217. JavaScript 中的数组和函数在内存中是如何存储的？\r\n\r\n> 参考答案：\r\n>\r\n> 在 *JavaScript* 中，数组不是以一段连续的区域存储在内存中，而是一种哈希映射的形式存储在堆内容里面。它可以通过多种数据结构实现，其中一种是链表。如下图所示：\r\n>\r\n> <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491b8660eb1c4601a2b82488135f2969~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20210818205006459\\\" style=\\\"zoom:50%;\\\" />\r\n>\r\n> JavaScript 中的函数是存储在堆内存中的，具体的步骤如下：\r\n>\r\n> 1. 开辟堆内存（*16* 进制得到内存地址）\r\n> 2. 声明当前函数的作用域（函数创建的上下文才是他的作用域，和在那执行的无关）\r\n> 3. 把函数的代码以字符串的形式存储在堆内存中（函数再不执行的情况下，只是存储在堆内存中的字符串）\r\n> 4. 将函数堆的地址，放在栈中供变量调用（函数名）\r\n\r\n\r\n\r\n### 218. *JavaScript* 是如何运行的？解释型语言和编译型语言的差异是什么？\r\n\r\n> 参考答案：\r\n>\r\n> 关于第一个问题，这不是三言两语或者几行文字就能够讲清楚的，这里放上一篇博文地址：\r\n>\r\n> *https://segmentfault.com/a/1190000019530109*\r\n>\r\n> 第二个问题：解释型语言和编译型语言的差异是什么？\r\n>\r\n> 电脑能认得的是二进制数，不能够识别高级语言。所有高级语言在电脑上执行都需要先转变为机器语言。但是高级语言有两种类型：编译型语言和解释型语言。常见的编译型语言语言有C/C++、Pascal/Object 等等。常见的解释性语言有python、JavaScript等等。\r\n>\r\n> 编译型语言先要进行编译，然后转为特定的可执行文件，这个可执行文件是针对平台的（CPU类型），可以这么理解你在PC上编译一个C源文件，需要经过预处理，编译，汇编等等过程生成一个可执行的二进制文件。当你需要再次运行改代码时，不需要重新编译代码，只需要运行该可执行的二进制文件。优点，编译一次，永久执行。还有一个优点是，你不需要提供你的源代码，你只需要发布你的可执行文件就可以为客户提供服务，从而保证了你的源代码的安全性。但是，如果你的代码需要迁移到linux、ARM下时，这时你的可执行文件就不起作用了，需要根据新的平台编译出一个可执行的文件。这也就是多个平台需要软件的多个版本。缺点是，跨平台能力差。\r\n>\r\n> 解释型语言需要一个解释器，在源代码执行的时候被解释器翻译为一个与平台无关的中间代码，解释器会把这些代码翻译为及其语言。打个比方，编译型中的编译相当于一个翻译官，它只能翻译英语，而且中文文章翻译一次就不需要重新对文章进行二次翻译了，但是如果需要叫这个翻译官翻译德语就不行了。而解释型语言中的解释器相当于一个会各种语言的机器人，而且这个机器人回一句一句的翻译你的语句。对于不同的国家，翻译成不同的语言，所以，你只需要带着这个机器人就可以。解释型语言的有点是，跨平台，缺点是运行时需要源代码，知识产权保护性差，运行效率低。\r\n\r\n\r\n\r\n### 219. 列举你所了解的编程范式？\r\n\r\n> 参考答案：\r\n>\r\n> 编程范式 *Programming paradigm* 是指计算机中编程的典范模式或方法。\r\n>\r\n> 常见的编程范式有：函数式编程、程序编程、面向对象编程、指令式编程等。\r\n>\r\n> 不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的，如 *Smalltalk* 和 *Java* 支持面向对象编程。而 *Haskell* 和 *Scheme* 则支持函数式编程。现代编程语言的发展趋势是支持多种范型，例如 *ES* 支持函数式编程的同时也支持面向对象编程。\r\n\r\n\r\n\r\n### 220. 什么是面向切面（AOP）的编程？\r\n\r\n> 参考答案：\r\n>\r\n> **什么是AOP？**\r\n>\r\n> AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。\r\n>\r\n>  \r\n>\r\n> **AOP能给我们带来什么好处？**\r\n>\r\n> AOP的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 \r\n>\r\n>  \r\n>\r\n> **JavaScript实现AOP的思路？**\r\n>\r\n> 通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，下面我用扩展 Function.prototype 来做到这一点。 \r\n>\r\n> 主要就是两个函数，在Function的原型上加上before与after，作用就是字面的意思，在函数的前面或后面执行，相当于**无侵入**把一个函数插入到另一个函数的前面或后面，应用得当可以很好的实现代码的解耦，js中的代码实现如下：\r\n>\r\n> ```js\r\n> //Aop构造器\r\n> function Aop(options){\r\n>     this.options = options\r\n> }\r\n> //业务方法执行前钩子\r\n> Aop.prototype.before = function(cb){\r\n>     cb.apply(this)\r\n> }\r\n> //业务方法执行后钩子\r\n> Aop.prototype.after = function(cb){\r\n>     cb.apply(this)\r\n> }\r\n> //业务方法执行器\r\n> Aop.prototype.execute = function(beforeCb,runner,afterCb){\r\n>     this.before(beforeCb)\r\n>     runner.apply(this)\r\n>     this.after(afterCb)\r\n> }\r\n> \r\n> var aop = new Aop({\r\n>     afterInfo:'执行后',\r\n>     runnerInfo:'执行中',\r\n>     beforeInfo:'执行前'\r\n> })\r\n> \r\n> var beforeCb = function(){\r\n>     console.log(this.options.beforeInfo)\r\n> }\r\n> var afterCb = function(){\r\n>     console.log(this.options.afterInfo)\r\n> }\r\n> var runnerCb = function(){\r\n>     console.log(this.options.runnerInfo)\r\n> }\r\n> \r\n> aop.execute(beforeCb,runnerCb,afterCb)\r\n> ```\r\n>\r\n> 应用的一些例子：\r\n>\r\n> 1. 为 *window.onload* 添加方法，防止 *window.onload* 被二次覆盖\r\n> 2. 无侵入统计某个函数的执行时间\r\n> 3. 表单校验\r\n> 4. 统计埋点\r\n> 5. 防止 *csrf* 攻击\r\n\r\n\r\n\r\n### 221. *JavaScript* 中的 *const* 数组可以进行 *push* 操作吗？为什么？\r\n\r\n> 参考答案：\r\n>\r\n> 可以进行 *push* 操作。虽然 *const* 表示常量，但是当我们把一个数组赋值给 *const* 声明的变量时，实际上是把这个数组的地址赋值给该变量。而 *push* 操作是在数组地址所指向的堆区添加元素，地址本身并没有发生改变。\r\n>\r\n> 示例代码：\r\n>\r\n> ```js\r\n> const arr = [1];\r\n> arr.push(2);\r\n> console.log(arr); // [1, 2]\r\n> ```\r\n\r\n\r\n\r\n### 222. JavaScript 中对象的属性描述符有哪些？分别有什么作用？\r\n\r\n> 参考答案：\r\n>\r\n> 从*ES5*开始，添加了对对象**属性描述符**的支持。现在*JavaScript*中支持 *4* 种属性描述符:\r\n>\r\n> - **configurable:** 当且仅当该属性的*configurable*键值为*true*时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。\r\n> - **enumerable:** 当且仅当该属性的*enumerable*键值为*true*时，该属性才会出现在对象的枚举属性中。\r\n> - **value:** 该属性对应的值。可以是任何有效的 *JavaScript* 值（数值，对象，函数等）。\r\n> - **writable:** 当且仅当该属性的*writable*键值为*true*时，属性的值，也就是上面的value，才能被赋值运算符改变。\r\n\r\n\r\n\r\n### 223. *JavaScript* 中 *console* 有哪些 *api* ?\r\n\r\n> 参考答案：\r\n>\r\n> **console.assert(expression, object[, object...])**\r\n>\r\n> 接收至少两个参数，第一个参数的值或返回值为`false`的时候，将会在控制台上输出后续参数的值。\r\n>\r\n> **console.count([label])**\r\n>\r\n> 输出执行到该行的次数，可选参数 label 可以输出在次数之前。\r\n>\r\n> **console.dir(object)**\r\n>\r\n> 将传入对象的属性，包括子对象的属性以列表形式输出。\r\n>\r\n> **console.error(object[, object...])**\r\n>\r\n> 用于输出错误信息，用法和常见的`console.log`一样，不同点在于输出内容会标记为错误的样式，便于分辨。\r\n>\r\n> **console.group**\r\n>\r\n> 这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个`console.group()`会增加一层嵌套，相反要减少一层嵌套可以使用`console.groupEnd()`方法。\r\n>\r\n> **console.info(object[, object...])**\r\n>\r\n> 此方法与之前说到的`console.error`一样，用于输出信息，没有什么特别之处。\r\n>\r\n> **console.table()**\r\n>\r\n> 可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。\r\n>\r\n> **console.log(object[, object...])**\r\n>\r\n> 输入一段 *log* 信息。\r\n>\r\n> **console.profile([profileLabel])**\r\n>\r\n> 这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及`console.profile()`方法我们可以很方便地监控运行性能。\r\n>\r\n> **console.time(name)**\r\n> 计时器，可以将成对的`console.time()`和`console.timeEnd()`之间代码的运行时间输出到控制台上，`name`参数可作为标签名。\r\n>\r\n> **console.trace()**\r\n>\r\n> `console.trace()`用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，`console.trace()`方法可以将函数的被调用过程清楚地输出到控制台上。\r\n>\r\n> **console.warn(object[, object...])**\r\n>\r\n> 输出参数的内容，作为警告提示。\r\n\r\n\r\n\r\n\r\n\r\n### 225. *Object.defineProperty* 有哪几个参数？各自都有什么作用\r\n\r\n> 参考答案：\r\n>\r\n> 在 *JavaScript* 中，通过 *Object.defineProperty* 方法可以设置对象属性的特性，选项如下：\r\n>\r\n> - *get*：一旦目标属性被访问时，就会调用相应的方法\r\n> - *set*：一旦目标属性被设置时，就会调用相应的方法\r\n> - *value*：这是属性的值，默认是 *undefined*\r\n> - *writable*：这是一个布尔值，表示一个属性是否可以被修改，默认是 *true*\r\n> - *enumerable*：这是一个布尔值，表示在用 *for-in* 循环遍历对象的属性时，该属性是否可以显示出来，默认值为 *true*\r\n> - *configurable*：这是一个布尔值，表示我们是否能够删除一个属性或者修改属性的特性，默认值为 *true*\r\n\r\n\r\n\r\n### 226. *Object.defineProperty* 和 *ES6* 的 *Proxy* 有什么区别？\r\n\r\n> 参考答案：\r\n>\r\n> ##### 1、*Object.defineproperty*\r\n>\r\n> 可以用于监听对象的数据变化\r\n>\r\n> 语法： ***Object.defineproperty(obj, key, descriptor)***\r\n>\r\n> ```javascript\r\n> let obj = {\r\n>     age: 11\r\n> }\r\n> let value = 'xiaoxiao';\r\n> //defineproperty 有 gettter 和 setter\r\n> Object.defineproperty(obj, 'name', {\r\n>     get() {\r\n>         return value\r\n>     },\r\n>     set(newValue) {\r\n>         value = newValue\r\n>     }\r\n> })\r\n> obj.name = 'pengpeng';\r\n> ```\r\n>\r\n> 此外 还有以下配置项 ：\r\n>\r\n> - *configurable*\r\n> - *enumerable*\r\n> - *value*\r\n>\r\n> 缺点：\r\n>\r\n> 1. 无法监听数组变化\r\n>\r\n> 2. 只能劫持对象的属性，属性值也是对象那么需要深度遍历\r\n>\r\n> ##### 2、*proxy* ：可以理解为在被劫持的对象之前 加了一层拦截\r\n>\r\n> ```javascript\r\n> let proxy = new Proxy({}, {\r\n>     get(obj, prop) {\r\n>         return obj[prop]\r\n>     },\r\n>     set(obj, prop, val) {\r\n>         obj[prop] = val\r\n>     }\r\n> })\r\n> ```\r\n>\r\n> - *proxy* 返回的是一个新对象， 可以通过操作返回的新的对象达到目的\r\n> - *proxy* 有多达 *13* 种拦截方法\r\n>\r\n> **总结：**\r\n>\r\n> - *Object.defineProperty* 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应\r\n> - *Object.defineProperty* 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。*Proxy* 可以劫持整个对象，并返回一个新的对象。\r\n> - *Proxy* 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\r\n\r\n\r\n\r\n### 227. *intanceof* 操作符的实现原理及实现\r\n\r\n> 参考答案：\r\n>\r\n> *instanceof* 主要作用就是判断一个实例是否属于某种类型\r\n>\r\n> 例如：\r\n>\r\n> ```js\r\n> let Dog = function(){}\r\n> let tidy = new Dog()\r\n> tidy instanceof Dog //true\r\n> ```\r\n>\r\n> *intanceof* 操作符实现原理\r\n>\r\n> ```js\r\n> function wonderFulInstanceOf(instance, constructorFn) { \r\n>     let constructorFnProto = constructorFn.prototype; // 取右表达式的 prototype 值，函数构造器指向的function \r\n>     instanceProto = instance.__proto__; // 取左表达式的__proto__值，实例的__proto__\r\n>     while (true) {\r\n>     \\tif (instanceProto === null) {\r\n>             return false;\\t\r\n>         }\r\n>         if (instanceProto === constructorFnProto) {\r\n>             return true;\\t\r\n>         } \r\n>         instanceProto = instanceProto.__proto__ \r\n>     }\r\n> }\r\n> ```\r\n>\r\n> 其实 *instanceof* 主要的实现原理就是只要 *constructorFn* 的 *prototype* 在*instance*的原型链上即可。\r\n>\r\n> 因此，*instanceof* 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 *prototype*，如果查找失败，则会返回 *false*，告诉我们左边变量并非是右边变量的实例。\r\n\r\n\r\n\r\n### 228. 强制类型转换规则？\r\n\r\n> 参考答案：\r\n>\r\n> 首先需要了解隐式转换所调用的函数。\r\n>\r\n> 当程序员显式调用 Boolean(value)、Number(value)、String(value) 完成的类型转换，叫做显示类型转换。\r\n>\r\n> 当通过 new Boolean(value)、new Number(value)、new String(value) 传入各自对应的原始类型的值，可以实现“装箱”，将原始类型封装成一个对象。\r\n>\r\n> 其实这三个函数不仅仅可以当作构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转化成原始类型的值：\r\n>\r\n> ```javascript\r\n> Boolean('sdfsd');  //  true\r\n> Number(\\\"23\\\");  //  23\r\n> String({a:24});  //  \\\"[object Object]\\\"\r\n> ```\r\n>\r\n> 其实这三个函数用于类型转换的时候，调用的就是 js 内部的 *ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )* 方法，从而达到显式转换的效果。\r\n\r\n\r\n\r\n### 229. *Object.is*( ) 与比较操作符 “===”、“==” 的区别\r\n\r\n> 参考答案：\r\n>\r\n> == (或者 !=) 操作在需要的情况下自动进行了类型转换。=== (或 !==)操作不会执行任何转换。\r\n>\r\n> ===在比较值和类型时，可以说比==更快。\r\n>\r\n> 而在*ES6*中，*Object.is*( ) 类似于 ===，但在三等号判等的基础上特别处理了 *NaN* 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 *Object.is(NaN, NaN)* 会返回 *true*。\r\n\r\n\r\n\r\n### 230. `+` 操作符什么时候用于字符串的拼接？\r\n\r\n> 参考答案：\r\n>\r\n> 在有一边操作数是字符串时会进行字符串拼接。\r\n>\r\n> 示例代码：\r\n>\r\n> ```js\r\n> console.log(5 + '5', typeof (5 + '5')); // 55  string\r\n> ```\r\n\r\n\r\n\r\n### 231. *object.assign* 和扩展运算法是深拷贝还是浅拷贝\r\n\r\n> 参考答案：\r\n>\r\n> 这两个方式都是浅拷贝。\r\n>\r\n> 在拷贝的对象只有一层时是深拷贝，但是一旦对象的属性值又是一个对象，也就是有两层或者两层以上时，就会发现这两种方式都是浅拷贝。\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 233. 如果 *new* 一个箭头函数的会怎么样\r\n\r\n> 参考答案：\r\n>\r\n> 会报错，因为箭头函数无法作为构造函数。\r\n\r\n\r\n\r\n### 234. 扩展运算符的作用及使用场景\r\n\r\n> 参考答案：\r\n>\r\n> 扩展运算符是三个点(...)，主要用于展开数组，将一个数组转为参数序列。\r\n>\r\n> 扩展运算符使用场景：\r\n>\r\n> - 代替数组的 *apply* 方法\r\n> - 合并数组\r\n> - 复制数组\r\n> - 把 *arguments* 或 *NodeList* 转为数组\r\n> - 与解构赋值结合使用\r\n> - 将字符串转为数组\r\n\r\n\r\n\r\n### 235. *Proxy* 可以实现什么功能？\r\n\r\n> 参考答案：\r\n>\r\n> *Proxy* 是 *ES6* 中新增的一个特性。*Proxy* 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。\r\n>\r\n> *Proxy* 在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。\r\n>\r\n> 使用 *Proxy* 的好处是对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 *Proxy* 来做。从而达到关注点分离，降级对象复杂度的目的。\r\n>\r\n> *Proxy* 的基本语法如下：\r\n>\r\n> ```javascript\r\n> var proxy = new Proxy(target, handler);\r\n> ```\r\n>\r\n> 通过构造函数来生成 *Proxy* 实例，构造函数接收两个参数。*target* 参数是要拦截的目标对象，*handler* 参数也是一个对象，用来定制拦截行为。\r\n>\r\n> *Vue 3.0* 主要就采用的 *Proxy* 特性来实现响应式，相比以前的 *Object.defineProperty* 有以下优点：\r\n>\r\n> - 可以劫持整个对象，并返回一个新的对象\r\n> - 有 *13* 种劫持操作\r\n\r\n\r\n\r\n### 236. 对象与数组的解构的理解\r\n\r\n> 参考答案：\r\n>\r\n> 解构是 *ES6* 的一种语法规则，可以将一个对象或数组的某个属性提取到某个变量中。\r\n>\r\n> 解构对象示例：\r\n>\r\n> ```js\r\n> //  var/let/const{属性名}=被解构的对象\r\n> const user = {\r\n>     name: \\\"abc\\\",\r\n>     age: 18,\r\n>     sex: \\\"男\\\",\r\n>     address: {\r\n>         province: \\\"重庆\\\",\r\n>         city: \\\"重庆\\\"\r\n>     }\r\n> }\r\n> let { name, age, sex, address} = user;\r\n> console.log(name, age, sex, address);\r\n> ```\r\n>\r\n> 解构数组示例：\r\n>\r\n> ```js\r\n> const [a, b, c] = [1, 2, 3];\r\n> ```\r\n\r\n\r\n\r\n### 237. 如何提取高度嵌套的对象里的指定属性？\r\n\r\n> 参考答案：\r\n>\r\n> 一般会使用递归的方式来进行查找。下面是一段示例代码：\r\n>\r\n> ```js\r\n> function findKey(data, field) {\r\n>     let finding = '';\r\n>     for (const key in data) {\r\n>         if (key === field) {\r\n>             finding = data[key];\r\n>         }\r\n>         if (typeof (data[key]) === 'object') {\r\n>             finding = findKey(data[key], field);\r\n>         }\r\n>         if (finding) {\r\n>             return finding;\r\n>         }\r\n>     }\r\n>     return null;\r\n> }\r\n> // 测试\r\n> console.log(findKey({\r\n>     name: 'zhangsan',\r\n>     age: 18,\r\n>     stuInfo: {\r\n>         stuNo: 1,\r\n>         classNo: 2,\r\n>         score: {\r\n>             htmlScore: 100,\r\n>             cssScore: 90,\r\n>             jsScore: 95\r\n>         }\r\n>     }\r\n> }, 'cssScore')); // 90\r\n> ```\r\n\r\n\r\n\r\n### 238. *Unicode、UTF-8、UTF-16、UTF-32* 的区别？\r\n\r\n> 参考答案：\r\n>\r\n> *Unicode* **为世界上所有字符都分配了一个唯一的数字编号**，这个编号范围从 *0x000000* 到 *0x10FFFF* (十六进制)，有 *110* 多万，每个字符都有一个唯一的 *Unicode* 编号，这个编号一般写成 *16* 进制，在前面加上 U+。例如：“马”的 *Unicode* 是 *U+9A6C*。\r\n> *Unicode* 就相当于一张表，建立了字符与编号之间的联系。\r\n>\r\n> <img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3797ac582384f339790c8d9a9ea2326~tplv-k3u1fbpfcp-zoom-1.image\\\" alt=\\\"image-20210817160125144\\\" style=\\\"zoom:50%;\\\" />\r\n>\r\n> ***Unicode* 本身只规定了每个字符的数字编号是多少，并没有规定这个编号如何存储。**\r\n>\r\n> 那我们可以直接把 *Unicode* 编号直接转换成二进制进行存储，怎么对应到二进制表示呢？\r\n>\r\n> *Unicode* 可以使用的编码有三种，分别是：\r\n>\r\n> - *UFT-8*：一种变长的编码方案，使用 *1~6* 个字节来存储；\r\n> - *UFT-32*：一种固定长度的编码方案，不管字符编号大小，始终使用 *4* 个字节来存储；\r\n> - *UTF-16*：介于 *UTF-8* 和 *UTF-32* 之间，使用 *2* 个或者 *4* 个字节来存储，长度既固定又可变。\r\n\r\n\r\n\r\n### 239. 为什么函数的 *arguments* 参数是类数组而不是数组？如何遍历类数组?\r\n\r\n> 参考答案：\r\n>\r\n> 首先了解一下什么是数组对象和类数组对象。\r\n>\r\n> 数组对象：使用单独的变量名来存储一系列的值。从 *Array* 构造函数中继承了一些用于进行数组操作的方法。\r\n>\r\n> 例如：\r\n>\r\n> ```js\r\n> var mycars = new Array();\r\n> mycars[0] = \\\"zhangsan\\\";\r\n> mycars[1] = \\\"lisi\\\";\r\n> mycars[2] = \\\"wangwu\\\";\r\n> ```\r\n>\r\n> 类数组对象：**对于一个普通的对象来说，如果它的所有 property 名均为正整数，同时也有相应的length属性，那么虽然该对象并不是由Array构造函数所创建的，它依然呈现出数组的行为，在这种情况下，这些对象被称为“类数组对象”。**\r\n>\r\n> **两者区别**\r\n>\r\n> - 一个是对象，一个是数组\r\n>\r\n> - 数组的*length*属性，当新的元素添加到列表中的时候，其值会自动更新。类数组对象的不会。\r\n>\r\n> - 设置数组的*length*属性可以扩展或截断数组。\r\n>\r\n> - 数组也是*Array*的实例可以调用*Array*的方法，比如*push、pop*等等\r\n>\r\n> 所以说*arguments*对象不是一个 *Array* 。它类似于*Array*，但除了*length*属性和索引元素之外没有任何*Array*属性。\r\n>\r\n> 可以使用 *for...in* 来遍历 *arguments* 这个类数组对象。\r\n\r\n\r\n\r\n### 240. *escape、encodeURI、encodeURIComponent* 的区别\r\n\r\n> 参考答案：\r\n>\r\n> *escape* 除了 *ASCII* 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对 *URL* 编码，最好不要使用此方法。\r\n>\r\n> *encodeURI* 用于编码整个 *URI*，因为 *URI* 中的合法字符都不会被编码转换。\r\n>\r\n> *encodeURIComponent* 方法在编码单个*URIComponent*（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个 *URL*。\r\n\r\n\r\n\r\n### 241. *use strict* 是什么意思 ? 使用它区别是什么？\r\n\r\n> 参考答案：\r\n>\r\n>  *use strict* 代表开启严格模式，这种模式使得 *Javascript* 在更严格的条件下运行，实行更严格解析和错误处理。\r\n>\r\n> 开启“严格模式”的优点：\r\n>\r\n> - 消除 *Javascript* 语法的一些不合理、不严谨之处，减少一些怪异行为;\r\n> - 消除代码运行的一些不安全之处，保证代码运行的安全；\r\n> - 提高编译器效率，增加运行速度；\r\n> - 为未来新版本的 *Javascript* 做好铺垫。\r\n\r\n\r\n\r\n### 242. *for...in* 和 *for...of* 的区别\r\n\r\n> 参考答案：\r\n>\r\n> *JavaScript* 原有的 *for...in* 循环，只能获得对象的键名，不能直接获取键值。*ES6* 提供 *for...of* 循环，允许遍历获得键值。\r\n>\r\n> 例如：\r\n>\r\n> ```js\r\n> var arr = ['a', 'b', 'c', 'd'];\r\n> \r\n> for (let a in arr) {\r\n>   console.log(a); // 0 1 2 3\r\n> }\r\n> \r\n> for (let a of arr) {\r\n>   console.log(a); // a b c d\r\n> }\r\n> ```\r\n\r\n\r\n\r\n### 243. *ajax、axios、fetch* 的区别\r\n\r\n> 参考答案：\r\n>\r\n> *ajax* 是指一种创建交互式网页应用的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。\r\n>\r\n> 使用 *ajax* 发送请求是依靠于一个对象，叫 *XmlHttpRequest* 对象，通过这个对象我们可以从服务器获取到数据，然后再渲染到我们的页面上。现在几乎所有的浏览器都有这个对象，只有 *IE7* 以下的没有，而是通过 *ActiveXObject* 这个对象来创建的。\r\n>\r\n> *Fetch* 是 *ajax* 非常好的一个替代品，基于 *Promise* 设计，使用 *Fetch* 来获取数据时，会返回给我们一个 *Pormise* 对象，但是 *Fetch* 是一个低层次的 *API*，想要很好的使用 *Fetch*，需要做一些封装处理。\r\n>\r\n> 下面是 *Fetch* 的一些缺点\r\n>\r\n> - *Fetch* 只对网络请求报错，对 *400，500* 都当做成功的请求，需要封装去处理\r\n> - *Fetch* 默认不会带 *cookie*，需要添加配置项。\r\n> - *Fetch* 不支持 *abort*，不支持超时控制，使用 *setTimeout* 及 *Promise.reject* 的实现超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。\r\n> - *Fetch* 没有办法原生监测请求的进度，而 *XHR* 可以。\r\n>\r\n> *Vue2.0* 之后，*axios* 开始受到更多的欢迎了。其实 *axios* 也是对原生 *XHR* 的一种封装，不过是 *Promise* 实现版本。它可以用于浏览器和 *nodejs* 的 *HTTP* 客户端，符合最新的 *ES* 规范。\r\n\r\n\r\n\r\n### 244. 下面代码的输出是什么？（ *D* ）\r\n\r\n```javascript\r\nfunction sayHi() {\r\n  console.log(name);\r\n  console.log(age);\r\n  var name = \\\"Lydia\\\";\r\n  let age = 21;\r\n}\r\n\r\nsayHi();\r\n```\r\n\r\n- A: *Lydia* 和 *undefined*\r\n- B: *Lydia* 和 *ReferenceError*\r\n- C: *ReferenceError* 和 *21*\r\n- D: *undefined* 和 *ReferenceError*\r\n\r\n> **分析：**\r\n>\r\n> 在 *sayHi* 函数内部，通过 *var* 声明的变量 *name* 会发生变量提升，*var name* 会提升到函数作用域的顶部，其默认值为 *undefined*。因此输出 *name* 时得到的值为 *undefined*；\r\n>\r\n> *let* 声明的 *age* 不会发生变量提升，在输出 *age* 时该变量还未声明，因此会抛出 *ReferenceError* 的报错。\r\n\r\n\r\n\r\n### 245. 下面代码的输出是什么？（ *C* ）\r\n\r\n```javascript\r\nfor (var i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1);\r\n}\r\n\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 1);\r\n}\r\n```\r\n\r\n- A: *0 1 2* 和 *0 1 2*\r\n- B: *0 1 2* 和 *3 3 3*\r\n- C: *3 3 3* 和 *0 1 2*\r\n\r\n> 分析：\r\n>\r\n> *JavaScript* 中的执行机制，*setTimeout* 为异步代码，因此在 *setTimeout* 执行时，*for* 循环已经执行完毕。\r\n>\r\n> 第一个 *for* 循环中的变量 *i* 通过 *var* 声明， 为全局变量，因此每一次的 *i++* 都会将全局变量 *i* 的值加 *1*，当第一个 *for* 执行完成后 *i* 的值为 *3*。所以再执行 *setTimeout* 时，输出 *i* 的值都为 *3*；\r\n>\r\n> 第二个 *for* 循环中的变量 *i* 通过 *let* 声明，为局部变量，因此每一次 *for* 循环时都会产生一个块级作用域，用来存储本次循环中新产生的 *i* 的值。当循环结束后，*setTimeout* 会沿着作用域链去对应的块级作用域中寻找对应的 *i* 值。\r\n\r\n\r\n\r\n### 246. 下面代码的输出是什么？（ *B* ）\r\n\r\n```javascript\r\nconst shape = {\r\n  radius: 10,\r\n  diameter() {\r\n    return this.radius * 2;\r\n  },\r\n  perimeter: () => 2 * Math.PI * this.radius\r\n};\r\n\r\nshape.diameter();\r\nshape.perimeter();\r\n```\r\n\r\n- A: *20* 和 *62.83185307179586*\r\n- B: *20* 和 *NaN*\r\n- C: *20* 和 *63*\r\n- D: *NaN* 和 *63*\r\n\r\n> **分析：**\r\n>\r\n> *diameter* 作为对象的方法，其内部的 *this* 指向调用该方法的对象，因此 *this.raduus* 获取到的是 *shape.radius* 的值 *10*，再乘以 *2* 输出的值即为 *20*；\r\n>\r\n> *perimeter* 是一个箭头函数，其内部的 *this* 应该继承声明时所在上下文中的 *this*，在这里即继承全局的 *this*，因此 *this.radius* 值的为 *undefined*，*undefined* 与数值相乘后值为 *NaN*。\r\n\r\n\r\n\r\n### 247. 下面代码的输出是什么？（ *A* ）\r\n\r\n```\r\n+true;\r\n!\\\"Lydia\\\";\r\n```\r\n\r\n- A: *1* 和 *false*\r\n- B: *false* 和 *NaN*\r\n- C: *false* 和 *false*\r\n\r\n> **分析：**\r\n>\r\n> 一元加号会将数据隐式转换为 *number* 类型，*true* 转换为数值为 *1*；\r\n>\r\n> 非运算符 *!* 会将数据隐式转换为 *boolean* 类型后进行取反，*\\\"Lydia\\\"* 转换为布尔值为 *true*，取反后为 *false*。\r\n\r\n\r\n\r\n### 248. 哪个选项是不正确的？（ *A* ）\r\n\r\n```javascript\r\nconst bird = {\r\n  size: \\\"small\\\"\r\n};\r\n\r\nconst mouse = {\r\n  name: \\\"Mickey\\\",\r\n  small: true\r\n};\r\n```\r\n\r\n- A: *mouse.bird.size*\r\n- B: *mouse[bird.size]*\r\n- C: *mouse[bird[\\\"size\\\"]]*\r\n- D: 以上选项都对\r\n\r\n> **分析：**\r\n>\r\n> *mouse* 对象中没有 *bird* 属性，当访问一个对象不存在的属性时值为 *undefined*，因此 *mouse.bird* 的值为 *undefined*，而 *undefined* 作为原始数据类型没有 *size* 属性，因此再访问 *undefined.size* 时会报错。\r\n\r\n\r\n\r\n### 249. 下面代码的输出是什么？（ *A* ）\r\n\r\n```javascript\r\nlet c = { greeting: \\\"Hey!\\\" };\r\nlet d;\r\n\r\nd = c;\r\nc.greeting = \\\"Hello\\\";\r\nconsole.log(d.greeting);\r\n```\r\n\r\n- A: *Hello*\r\n- B: *undefined*\r\n- C: *ReferenceError*\r\n- D: *TypeError*\r\n\r\n> **分析：**\r\n>\r\n> 在 *JavaScript* 中，复杂类型数据在进行赋值操作时，进行的是「引用传递」，因此变量 *d* 和 *c* 指向的是同一个引用。当 *c* 通过引用去修改了数据后，*d* 再通过引用去访问数据，获取到的实际就是 *c* 修改后的数据。\r\n\r\n\r\n\r\n### 250. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nlet a = 3;\r\nlet b = new Number(3);\r\nlet c = 3;\r\n\r\nconsole.log(a == b);\r\nconsole.log(a === b);\r\nconsole.log(b === c);\r\n```\r\n\r\n- A: *true*  *false*  *true*\r\n- B: *false*  *false*  *true*\r\n- C: *true*  *false*  *false*\r\n- D: *false*  *true*  *true*\r\n\r\n> **分析：**\r\n>\r\n> *new Number()* 是 *JavaScript* 中一个内置的构造函数。变量 *b* 虽然看起来像一个数字，但它并不是一个真正的数字：它有一堆额外的功能，是一个对象。\r\n>\r\n> == 会触发隐式类型转换，右侧的对象类型会自动转换为 *Number* 类型，因此最终返回 *true*。\r\n>\r\n> === 不会触发隐式类型转换，因此在比较时由于数据类型不相等而返回 *false*。\r\n\r\n\r\n\r\n### 251. 下面代码的输出是什么？（ *D* ）\r\n\r\n```js\r\nclass Chameleon {\r\n  static colorChange(newColor) {\r\n    this.newColor = newColor;\r\n  }\r\n\r\n  constructor({ newColor = \\\"green\\\" } = {}) {\r\n    this.newColor = newColor;\r\n  }\r\n}\r\n\r\nconst freddie = new Chameleon({ newColor: \\\"purple\\\" });\r\nfreddie.colorChange(\\\"orange\\\");\r\n```\r\n\r\n- A: *orange*\r\n- B: *purple*\r\n- C: *green*\r\n- D: *TypeError* \r\n\r\n> **分析**：\r\n>\r\n> *colorChange* 方法是静态的。 静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。 由于 *freddie* 是一个子级对象，函数不会传递，所以在 *freddie* 实例上不存在 *colorChange* 方法：抛出*TypeError*。\r\n\r\n\r\n\r\n### 252. 下面代码的输出是什么？（ *A* ）\r\n\r\n```js\r\nlet greeting;\r\ngreetign = {}; // Typo!\r\nconsole.log(greetign);\r\n```\r\n\r\n- A: *{}*\r\n- B: *ReferenceError: greetign is not defined*\r\n- C: *undefined*\r\n\r\n> **分析：**\r\n>\r\n> 控制台会输出空对象，因为我们刚刚在全局对象上创建了一个空对象！\r\n>\r\n> 当我们错误地将 *greeting* 输入为 *greetign* 时，*JS* 解释器实际上在浏览器中将其视为 *window.greetign = {}*。\r\n\r\n\r\n\r\n### 253. 当我们执行以下代码时会发生什么？（ *A* ）\r\n\r\n  ```js\r\nfunction bark() {\r\n  console.log(\\\"Woof!\\\");\r\n}\r\n\r\nbark.animal = \\\"dog\\\";\r\n  ```\r\n\r\n  - A 什么都不会发生\r\n  - B: *SyntaxError. You cannot add properties to a function this way.*\r\n  - C: *undefined*\r\n  - D: *ReferenceError*\r\n\r\n  > **分析：**\r\n  >\r\n  > 因为函数也是对象！（原始类型之外的所有东西都是对象）\r\n  >\r\n  > 函数是一种特殊类型的对象，我们可以给函数添加属性，且此属性是可调用的。\r\n\r\n\r\n\r\n### 254. 下面代码的输出是什么？（ *A* ）\r\n\r\n```js\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n}\r\n\r\nconst member = new Person(\\\"Lydia\\\", \\\"Hallie\\\");\r\nPerson.getFullName = () => this.firstName + this.lastName;\r\n\r\nconsole.log(member.getFullName());\r\n```\r\n\r\n- A: *TypeError*\r\n- B: *SyntaxError*\r\n- C: *Lydia Hallie*\r\n- D: *undefined*  *undefined*\r\n\r\n> **分析：**\r\n>\r\n> *Person.getFullName* 是将方法添加到了函数身上，因此当我们通过实例对象 *member* 去调用该方法时并不能找到该方法。\r\n\r\n\r\n\r\n### 255. 下面代码的输出是什么？（ *A* ）\r\n\r\n```js\r\nfunction Person(firstName, lastName) {\r\n  this.firstName = firstName;\r\n  this.lastName = lastName;\r\n}\r\n\r\nconst lydia = new Person(\\\"Lydia\\\", \\\"Hallie\\\");\r\nconst sarah = Person(\\\"Sarah\\\", \\\"Smith\\\");\r\n\r\nconsole.log(lydia);\r\nconsole.log(sarah);\r\n```\r\n\r\n- A: *Person { firstName: \\\"Lydia\\\", lastName: \\\"Hallie\\\" }* 和 *undefined*\r\n- B: *Person { firstName: \\\"Lydia\\\", lastName: \\\"Hallie\\\" }* 和 *Person { firstName: \\\"Sarah\\\", lastName: \\\"Smith\\\" }*\r\n- C: *Person { firstName: \\\"Lydia\\\", lastName: \\\"Hallie\\\" }* 和 *{}*\r\n- D: *Person { firstName: \\\"Lydia\\\", lastName: \\\"Hallie\\\" }* 和 *ReferenceError*\r\n\r\n> **分析：**\r\n>\r\n> *lydia* 是调用构造函数后得到的实例对象，拥有 *firstName* 和 *lastName* 属性；\r\n>\r\n> *sarah* 是调用普通函数后得到的返回值，而 *Person* 作为普通函数没有返回值；\r\n\r\n\r\n\r\n### 256. 事件传播的三个阶段是什么？（ *D* ）\r\n\r\n- A: 目标 > 捕获 > 冒泡\r\n- B: 冒泡 > 目标 > 捕获\r\n- C: 目标 > 冒泡 > 捕获\r\n- D: 捕获 > 目标 > 冒泡\r\n\r\n\r\n\r\n### 257. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\n\r\nsum(1, \\\"2\\\");\r\n```\r\n\r\n- A: *NaN*\r\n- B: *TypeError*\r\n- C: *\\\"12\\\"*\r\n- D: *3*\r\n\r\n> **分析：**\r\n>\r\n> 任意数据类型在跟 *String* 做 + 运算时，都会隐式转换为 *String* 类型。\r\n>\r\n> 即 *a* 所对应的 *Number* 值 *1*，被隐式转换为了 *String* 值 \\\"1\\\"，最终字符串拼接的到 \\\"12\\\"。  \r\n\r\n\r\n\r\n### 258. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nlet number = 0;\r\nconsole.log(number++);\r\nconsole.log(++number);\r\nconsole.log(number);\r\n```\r\n\r\n- A: *1  1  2*\r\n- B: *1  2  2*\r\n- C: *0  2  2*\r\n- D: *0  1  2*\r\n\r\n> **分析：**\r\n>\r\n> ++ 后置时，先输出，后加 *1*；++ 前置时，先加 *1*，后输出；\r\n>\r\n> 第一次输出的值为 0，输出完成后 *number* 加 *1* 变为 *1*。\r\n>\r\n> 第二次输出，*number* 先加 *1* 变为 *2*，然后输出值 *2*。\r\n>\r\n> 第三次输出，*number* 值没有变化，还是 *2*。\r\n\r\n\r\n\r\n### 259. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nfunction getPersonInfo(one, two, three) {\r\n  console.log(one);\r\n  console.log(two);\r\n  console.log(three);\r\n}\r\n\r\nconst person = \\\"Lydia\\\";\r\nconst age = 21;\r\n\r\ngetPersonInfo`${person} is ${age} years old`;\r\n```\r\n\r\n- A: *Lydia*   *21*   *[\\\"\\\", \\\"is\\\", \\\"years old\\\"]*\r\n- B:  *[\\\"\\\", \\\"is\\\", \\\"years old\\\"]*  *Lydia*   *21*\r\n- C:  *Lydia*  *[\\\"\\\", \\\"is\\\", \\\"years old\\\"]*    *21*\r\n\r\n> **分析：**\r\n>\r\n> 如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！\r\n\r\n\r\n\r\n### 260. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nfunction checkAge(data) {\r\n  if (data === { age: 18 }) {\r\n    console.log(\\\"You are an adult!\\\");\r\n  } else if (data == { age: 18 }) {\r\n    console.log(\\\"You are still an adult.\\\");\r\n  } else {\r\n    console.log(`Hmm.. You don't have an age I guess`);\r\n  }\r\n}\r\n\r\ncheckAge({ age: 18 });\r\n\r\n```\r\n\r\n- A: *You are an adult!*\r\n- B: *You are still an adult.*\r\n- C: *Hmm.. You don't have an age I guess*\r\n\r\n> **分析：**\r\n>\r\n> 在比较相等性时，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。\r\n>\r\n> *data* 和条件中的 *{ age: 18 }* 两个不同引用的对象，因此永远都不相等。\r\n\r\n\r\n\r\n### 261. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nfunction getAge(...args) {\r\n  console.log(typeof args);\r\n}\r\n\r\ngetAge(21);\r\n```\r\n\r\n- A: *\\\"number\\\"*\r\n- B: *\\\"array\\\"*\r\n- C: *\\\"object\\\"*\r\n- D: *\\\"NaN\\\"*\r\n\r\n> **分析：**\r\n>\r\n> *ES6* 中的不定参数（…*args*）返回的是一个数组。\r\n>\r\n> *typeof* 检查数组的类型返回的值是 *object*。\r\n\r\n\r\n\r\n### 262. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nfunction getAge() {\r\n  \\\"use strict\\\";\r\n  age = 21;\r\n  console.log(age);\r\n}\r\n\r\ngetAge();\r\n```\r\n\r\n- A: *21*\r\n- B: *undefined*\r\n- C: *ReferenceError*\r\n- D: *TypeError*\r\n\r\n> **分析：**\r\n>\r\n> *\\\"use strict\\\"* 严格模式中，使用未声明的变量会引发报错。\r\n\r\n\r\n\r\n### 263. 下面代码的输出是什么？（ *A* ）\r\n\r\n```js\r\nconst sum = eval(\\\"10*10+5\\\");\r\n```\r\n\r\n- A: *105*\r\n- B: *\\\"105\\\"*\r\n- C: *TypeError*\r\n- D: *\\\"10\\\\*10+5\\\"*\r\n\r\n> **分析：**\r\n>\r\n> *eval* 方法会将字符串当作 *JavaScript* 代码进行解析。\r\n\r\n\r\n\r\n### 264. *cool_secret* 可以访问多长时间？（ *B* ）\r\n\r\n```js\r\nsessionStorage.setItem(\\\"cool_secret\\\", 123);\r\n```\r\n\r\n- A：永远，数据不会丢失。\r\n- B：用户关闭选项卡时。\r\n- C：当用户关闭整个浏览器时，不仅是选项卡。\r\n- D：用户关闭计算机时。\r\n\r\n> **分析：**\r\n>\r\n> *sessionStorage* 是会话级别的本地存储，当窗口关闭，则会话结束，数据删除。\r\n\r\n\r\n\r\n### 265. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nvar num = 8;\r\nvar num = 10;\r\n\r\nconsole.log(num);\r\n```\r\n\r\n- A: *8*\r\n- B: *10*\r\n- C: *SyntaxError*\r\n- D: *ReferenceError*\r\n\r\n> **分析：**\r\n>\r\n> *var* 声明的变量允许重复声明，但后面的值会覆盖前面的值。\r\n\r\n\r\n\r\n### 266. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nconst obj = { 1: \\\"a\\\", 2: \\\"b\\\", 3: \\\"c\\\" };\r\nconst set = new Set([1, 2, 3, 4, 5]);\r\n\r\nobj.hasOwnProperty(\\\"1\\\");\r\nobj.hasOwnProperty(1);\r\nset.has(\\\"1\\\");\r\nset.has(1);\r\n```\r\n\r\n- A: *false*  *true*  *false*  *true*\r\n- B: *false*  *true*  *true*  *true*\r\n- C: *true*  *true*  *false*  *true*\r\n- D: *true*  *true*  *true*  *true*\r\n\r\n\r\n\r\n### 267. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nconst obj = { a: \\\"one\\\", b: \\\"two\\\", a: \\\"three\\\" };\r\nconsole.log(obj);\r\n```\r\n\r\n- A: *{ a: \\\"one\\\", b: \\\"two\\\" }*\r\n- B: *{ b: \\\"two\\\", a: \\\"three\\\" }*\r\n- C: *{ a: \\\"three\\\", b: \\\"two\\\" }*\r\n- D: *SyntaxError*\r\n\r\n> **分析：**\r\n>\r\n> 如果对象有两个具有相同名称的键，则后面的将替前面的键。它仍将处于第一个位置，但具有最后指定的值。\r\n\r\n\r\n\r\n### 268. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nfor (let i = 1; i < 5; i++) {\r\n  if (i === 3) continue;\r\n  console.log(i);\r\n}\r\n```\r\n\r\n- A: *1  2*\r\n- B: *1  2  3*\r\n- C: *1  2  4*\r\n- D: *1  3  4*\r\n\r\n> **分析：**\r\n>\r\n> 当 *i* 的值为 *3* 时，进入 *if* 语句执行 *continue*，结束本次循环，立即进行下一次循环。\r\n\r\n\r\n\r\n### 269. 下面代码的输出是什么？（ *A* ）\r\n\r\n```js\r\nString.prototype.giveLydiaPizza = () => {\r\n  return \\\"Just give Lydia pizza already!\\\";\r\n};\r\n\r\nconst name = \\\"Lydia\\\";\r\n\r\nname.giveLydiaPizza();\r\n```\r\n\r\n- A: *\\\"Just give Lydia pizza already!\\\"*\r\n- B: *TypeError: not a function*\r\n- C: *SyntaxError*\r\n- D: *undefined*\r\n\r\n> **分析：**\r\n>\r\n> *String* 是一个内置的构造函数，我们可以为它添加属性。 我们给它的原型添加了一个方法。 原始类型的字符串自动转换为字符串对象，由字符串原型函数生成。 因此，所有字符串（字符串对象）都可以访问该方法！\r\n>\r\n> 当使用基本类型的字符串调用 *giveLydiaPizza* 时，实际上发生了下面的过程：\r\n>\r\n> - 创建一个 *String* 的包装类型实例\r\n> - 在实例上调用 *substring* 方法\r\n> - 销毁实例\r\n\r\n\r\n\r\n### 270. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nconst a = {};\r\nconst b = { key: \\\"b\\\" };\r\nconst c = { key: \\\"c\\\" };\r\n\r\na[b] = 123;\r\na[c] = 456;\r\n\r\nconsole.log(a[b]);\r\n```\r\n\r\n- A: *123*\r\n- B: *456*\r\n- C: *undefined*\r\n- D: *ReferenceError*\r\n\r\n> **分析：**\r\n>\r\n> 当 *b* 和 *c* 作为一个对象的键时，会自动转换为字符串，而对象自动转换为字符串化时，结果都为 *[Object object]*。因此 *a[b]* 和 *a[c]* 其实都是同一个属性 *a[\\\"Object object\\\"]*。\r\n>\r\n> 对象同名的属性后面的值会覆盖前面的，因此最终 *a[\\\"Object object\\\"]* 的值为 *456*。\r\n\r\n\r\n\r\n### 271. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nconst foo = () => console.log(\\\"First\\\");\r\nconst bar = () => setTimeout(() => console.log(\\\"Second\\\"));\r\nconst baz = () => console.log(\\\"Third\\\");\r\n\r\nbar();\r\nfoo();\r\nbaz();\r\n```\r\n\r\n- A: *First*  *Second*  *Third*\r\n- B: *First*  *Third*  *Second*\r\n- C: *Second*  *First*  *Third*\r\n- D: *Second*  *Third*  *First*\r\n\r\n> **分析：**\r\n>\r\n> *bar* 函数中执行的是一段异步代码，按照 *JavaScript* 中的事件循环机制，主线程中的所有同步代码执行完成后才会执行异步代码。因此 *\\\"Second\\\"* 最后输出。\r\n\r\n\r\n\r\n### 272. 单击按钮时 *event.target* 是什么？（ *C* ）\r\n\r\n```html\r\n<div onclick=\\\"console.log('first div')\\\">\r\n  <div onclick=\\\"console.log('second div')\\\">\r\n    <button onclick=\\\"console.log('button')\\\">\r\n      Click!\r\n    </button>\r\n  </div>\r\n</div>\r\n```\r\n\r\n- A: *div* 外部\r\n- B: *div* 内部\r\n- C: *button*\r\n- D: 所有嵌套元素的数组\r\n\r\n> **分析：**\r\n>\r\n> *event.target* 指向的是事件目标，即触发事件的元素。因此点击 *\\\\<button>* 触发事件的也就是  *\\\\<button>*。\r\n\r\n\r\n\r\n### 273. 单击下面的 *html* 片段打印的内容是什么？（ *A* ）\r\n\r\n```html\r\n<div onclick=\\\"console.log('div')\\\">\r\n  <p onclick=\\\"console.log('p')\\\">\r\n    Click here!\r\n  </p>\r\n</div>\r\n```\r\n\r\n- A: *p*  *div*\r\n- B: *div*  *p*\r\n- C: *p*\r\n- D: *div*\r\n\r\n> **分析：**\r\n>\r\n> *onclick* 绑定的事件为冒泡型事件。因此当点击 *p* 标签时，事件会从事件目标开始依次往外触发。\r\n\r\n\r\n\r\n### 274. 下面代码的输出是什么？（ *D* ）\r\n\r\n```js\r\nconst person = { name: \\\"Lydia\\\" };\r\n\r\nfunction sayHi(age) {\r\n  console.log(`${this.name} is ${age}`);\r\n}\r\n\r\nsayHi.call(person, 21);\r\nsayHi.bind(person, 21);\r\n```\r\n\r\n- A: *undefined is 21*   *Lydia is 21*\r\n- B: *function*   *function*\r\n- C: *Lydia is 21*   *Lydia is 21*\r\n- D: *Lydia is 21*   *function*\r\n\r\n> **分析：**\r\n>\r\n> *call* 和 *bind* 都可以修改 *this* 的指向，但区别在于 *call* 方法会立即执行，而 *bind* 会返回一个修改后的新函数。\r\n\r\n\r\n\r\n### 275. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nfunction sayHi() {\r\n  return (() => 0)();\r\n}\r\n\r\ntypeof sayHi();\r\n```\r\n\r\n- A: *\\\"object\\\"*\r\n- B: *\\\"number\\\"*\r\n- C: *\\\"function\\\"*\r\n- D: *\\\"undefined\\\"*\r\n\r\n> **分析：**\r\n>\r\n> *return* 后是一个 *IIFE*，其返回值是 *0*，因此 *sayHi* 函数中返回的是一个 *0*。*typeof* 检测 *sayHi* 返回值类型即为 *number*。\r\n\r\n\r\n\r\n### 276. 下面这些值哪些是假值？（ *A* ）\r\n\r\n```js\r\n0;\r\nnew Number(0);\r\n(\\\"\\\");\r\n(\\\" \\\");\r\nnew Boolean(false);\r\nundefined;\r\n```\r\n\r\n- A: *0*   *\\\"\\\"*    *undefined*\r\n- B: *0*   *new Number(0)*   *\\\"\\\"*   *new Boolean(false)*   *undefined*\r\n- C: *0*   *\\\"\\\"*   *new Boolean(false)*   *undefined*\r\n- D: 所有都是假值。\r\n\r\n> **分析：**\r\n>\r\n> *JavaScript* 中假值只有 *6* 个：*false*、*\\\"\\\"*、*null*、*undefined*、*NaN*、*0*\r\n\r\n\r\n\r\n### 278. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\nconsole.log(typeof typeof 1);\r\n```\r\n\r\n- A: *\\\"number\\\"*\r\n- B: *\\\"string\\\"*\r\n- C: *\\\"object\\\"*\r\n- D: *\\\"undefined\\\"*\r\n\r\n> 分析：\r\n>\r\n> *typeof 1* 返回 *\\\"number\\\"*，*typeof \\\"number\\\"* 返回 *\\\"string\\\"*\r\n\r\n\r\n\r\n### 279. 下面代码的输出是什么？（ *C* ）\r\n\r\n```js\r\nconst numbers = [1, 2, 3];\r\nnumbers[10] = 11;\r\nconsole.log(numbers);\r\n```\r\n\r\n- A: *[1, 2, 3, 7 x null, 11]*\r\n- B: *[1, 2, 3, 11]*\r\n- C: *[1, 2, 3, 7 x empty, 11]*\r\n- D: *SyntaxError*\r\n\r\n> **分析：**\r\n>\r\n> 当你为数组中的元素设置一个超过数组长度的值时，*JavaScript* 会创建一个名为“空插槽”的东西。 这些位置的值实际上是 *undefined*，但你会看到类似的东西：\r\n>\r\n> ```\r\n> [1, 2, 3, 7 x empty, 11]\r\n> ```\r\n>\r\n> 这取决于你运行它的位置（每个浏览器有可能不同）。\r\n\r\n\r\n\r\n### 280. 下面代码的输出是什么？（ *A* ） \r\n\r\n```js\r\n(() => {\r\n  let x, y;\r\n  try {\r\n    throw new Error();\r\n  } catch (x) {\r\n    (x = 1), (y = 2);\r\n    console.log(x);\r\n  }\r\n  console.log(x);\r\n  console.log(y);\r\n})();\r\n\r\n```\r\n\r\n- A: *1*   *undefined*   *2*\r\n- B: *undefined*   *undefined*   *undefined*\r\n- C: *1*   *1*   *2*  \r\n- D: *1*   *undefined*   *undefined*\r\n\r\n> **分析：**\r\n>\r\n> *catch* 块接收参数 *x*。当我们传递参数时，这与变量的 *x* 不同。这个变量 *x* 是属于 *catch* 作用域的。\r\n>\r\n> 之后，我们将这个块级作用域的变量设置为 *1*，并设置变量 *y* 的值。 现在，我们打印块级作用域的变量 *x*，它等于 *1*。\r\n>\r\n> 在*catch* 块之外，*x* 仍然是 *undefined*，而 *y* 是 *2*。 当我们想在 *catch* 块之外的 *console.log(x)* 时，它返回*undefined*，而 *y* 返回 *2*。\r\n\r\n### 281. *JavaScript* 中的所有内容都是…（ *A* ）\r\n\r\n- A：原始或对象\r\n- B：函数或对象\r\n- C：技巧问题！只有对象\r\n- D：数字或对象\r\n\r\n> 分析：\r\n>\r\n> *JavaScript* 只有原始类型和对象。\r\n\r\n\r\n\r\n### 282. 下面代码的输出是什么?\r\n\r\n```js\r\n[[0, 1], [2, 3]].reduce(\r\n  (acc, cur) => {\r\n    return acc.concat(cur);\r\n  },\r\n  [1, 2]\r\n);\r\n```\r\n\r\n- A: *[0, 1, 2, 3, 1, 2]*\r\n- B: *[6, 1, 2]*\r\n- C: *[1, 2, 0, 1, 2, 3]*\r\n- D: *[1, 2, 6]*\r\n\r\n> **分析：**\r\n>\r\n> *[1,2]* 是我们的初始值。 这是我们开始执行 *reduce* 函数的初始值，以及第一个 *acc* 的值。 在第一轮中，*acc* 是 *[1,2]*，*cur* 是 *[0,1]*。 我们将它们连接起来，结果是 *[1,2,0,1]*。\r\n>\r\n> 然后，*acc* 的值为 *[1,2,0,1]*，*cur* 的值为 *[2,3]*。 我们将它们连接起来，得到 *[1,2,0,1,2,3]*。\r\n\r\n\r\n\r\n### 283. 下面代码的输出是什么？（ *B* ）\r\n\r\n```js\r\n!!null;\r\n!!\\\"\\\";\r\n!!1;\r\n```\r\n\r\n- A: *false*   *true*   *false*\r\n- B: *false*   *false*   *true*\r\n- C: *false*   *true*   *true*\r\n- D: *true*   *true*   *false*\r\n\r\n> **分析：**\r\n>\r\n> *null* 是假值。 *!null* 返回 *true*。 *!true* 返回 *false*。\r\n>\r\n> *\\\"\\\"* 是假值。 *!\\\"\\\"* 返回 *true*。 *!true* 返回 *false*。\r\n>\r\n> *1* 是真值。 *!1* 返回 *false*。 *!false* 返回 *true*。\r\n\r\n\r\n\r\n### 284. *setInterval* 方法的返回值什么？（ *A* ）\r\n\r\n```js\r\nsetInterval(() => console.log(\\\"Hi\\\"), 1000);\r\n```\r\n\r\n- A：一个唯一的 *id*\r\n- B：指定的毫秒数\r\n- C：传递的函数\r\n- D：*undefined*\r\n\r\n> **分析：**\r\n>\r\n> 它返回一个唯一的 *id*。 此 *id* 可用于使用 *clearInterval()* 函数清除该定时器。\r\n\r\n\r\n\r\n### 285. 下面代码的返回值是什么？（ *A* ）\r\n\r\n```js\r\n[...\\\"Lydia\\\"];\r\n```\r\n\r\n- A: *[\\\"L\\\", \\\"y\\\", \\\"d\\\", \\\"i\\\", \\\"a\\\"]*\r\n- B: *[\\\"Lydia\\\"]*\r\n- C: *[[], \\\"Lydia\\\"]*\r\n- D: *[[\\\"L\\\", \\\"y\\\", \\\"d\\\", \\\"i\\\", \\\"a\\\"]]*\r\n\r\n> **分析：**\r\n>\r\n> 字符串是可迭代的。 扩展运算符将迭代的每个字符映射到一个元素。\r\n\r\n\r\n\r\n### 286. *document.write* 和 *innerHTML* 有哪些区别？\r\n\r\n> 参考答案：\r\n>\r\n> *document.write* 和 *innerHTML* 都能将 *HTML* 字符串解析为 *DOM* 树，再将 *DOM* 树插入到某个位置，但两种在执行细节上还是有许多不同。\r\n>\r\n> 1）*write()* 方法存在于 *Document* 对象中，*innerHTML* 属性存在于 *Element* 对象中；\r\n>\r\n> 2）*document.write* 会将解析后的 *DOM* 树插入到文档中调用它的脚本元素的位置，而 *innerHTML* 会将 *DOM* 树插入到指定的元素内；\r\n>\r\n> 3）*document.write* 会将多次调用的字符串参数自动连接起来，*innerHTML* 要用赋值运算符 *\\\"+=\\\"* 拼接；\r\n>\r\n> 4）只有当文档还在解析时，才能使用 *document.write*，否则 *document.write* 的值会将当前文档覆盖掉，而 *innerHTML* 属性则没有这个限制；\r\n\r\n> 注：也可以参阅前面第 *157* 题答案\r\n\r\n\r\n\r\n### 287. 假设有两个变量 *a* 和 *b*，他们的值都是数字，如何在不借用第三个变量的情况下，将两个变量的值对调？\r\n\r\n> 参考答案：\r\n>\r\n> 方法一：\r\n>\r\n> ```js\r\n> a = a + b;\r\n> b = a - b;\r\n> a = a - b; \r\n> ```\r\n>\r\n> 方法二（*ES6* 中的解构）：\r\n>\r\n> ```js\r\n> [a, b] = [b, a]\r\n> ```\r\n\r\n\r\n\r\n### 288. 前端为什么提倡模块化开发？\r\n\r\n> 参考答案：\r\n>\r\n> 模块化能将一个复杂的大型系统分解成一个个高内聚、低耦合的简单模块，并且每个模块都是独立的，用于完成特定的功能。模块化后的系统变得更加可控、可维护、可扩展，程序代码也更简单直观，可读性也很高，有利于团队协作开发。*ES6* 模块化的出现，使得前端能更容易、更快速的实现模块化开发。\r\n\r\n\r\n\r\n### 289. 请解释 *JSONP* 的原理，并用代码描述其过程。\r\n\r\n> 参考答案：\r\n>\r\n> *JSONP（JSON with padding）*是一种借助 *\\\\<script>* 元素实现跨域的技术，它不会使用 *XHR* 对象。之所以能实现跨域，主要是因为 *\\\\<script>* 元素有以下两个特点：\r\n>\r\n> 1）它的 *src* 属性能够访问任何 *URL* 资源，不会受同源策略的限制；\r\n>\r\n> 2）如果访问的资源包含 *JavaScript* 代码，那么在下载下来后会自动执行；\r\n>\r\n> *JSONP* 就是基于这两点，再与服务器配合来实现跨域请求的，它的执行步骤可分为以下 *6* 步：\r\n>\r\n> 1）定义一个回调函数；\r\n>\r\n> 2）用 *DOM* 方法动态创建一个 *\\\\<script>* 元素；\r\n>\r\n> 3）通过 *\\\\<script>* 元素的 *src* 属性指定要请求的 *URL*，并且将回调函数的名称作为一个参数传递过去；\r\n>\r\n> 4）将 *\\\\<script>* 元素插入到当前文档中，开始请求；\r\n>\r\n> 5）服务器接收到传递过来的参数，然后将回调函数和数据以调用的形式输出；\r\n>\r\n> 6）当 *\\\\<script>* 元素接收到响应中的脚本代码后，就会自动的执行它们；\r\n\r\n\r\n\r\n### 290. 列举几种 *JavaScript* 中数据类型的强制转换和隐式转换。\r\n\r\n> 参考答案：\r\n>\r\n> 强制转换：\r\n>\r\n> - 转换为 *number*：*parseInt()*、*parseFloat()*、*Number()*\r\n> - 转换为 *string*：*String()*、*toString()*\r\n> - 转换为 *boolean*：*Boolean()*\r\n>\r\n> 隐式转换：\r\n>\r\n> - 隐式转换为 *number*：算术运算/比较运算，例如加、减、乘、除、相等（==）、大于、小于等；\r\n> - 隐式转换为 *string*：与字符串拼接，例如 + \\\"\\\"；\r\n> - 隐式转换为 *boolean*：逻辑运算，例如或（||）、与（&&）、非（!）；\r\n\r\n\r\n\r\n### 291. 分析以下代码的执行结果并解释为什么。\r\n\r\n```js\r\nvar a = {n: 1};\r\nvar b = a;\r\na.x = a = {n: 2};\r\n\r\nconsole.log(a.x) \\t\r\nconsole.log(b.x)\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 运行结果：\r\n>\r\n> *undefined*、*{n: 2}*\r\n>\r\n> 分析：\r\n>\r\n> 首先，*a* 和 *b* 同时引用了 *{n: 1}* 对象，接着执行到 *a.x = a = {n: 2}* 语句，虽然赋值是从右到左执行，但是点（.）的优先级比赋值符（=）要高，所以这里首先执行 *a.x*，相当于为 *a*（或者 *b*）所指向的 *{n:1}* 对象新增了一个属性 *x*，即此时对象将变为 *{n: 1; x: undefined}*。然后按正常情况，从右到左进行赋值，此时执行 *a = {n: 2}* 的时候，a的引用改变，指向了新对象 *{n: 2}*，而 *b* 依然指向的是旧对象 *{n: 1; x: undefined}*。之后再执行 *a.x = {n: 2}* 的时候，并不会重新解析一遍 *a*，而是沿用最初解析 *a.x* 时候的 *a*，即旧对象 *{n: 1; x: undefined}*，故此时旧对象的 *x* 的值变为*{n: 2}*，旧对象为 *{n: 1; x: {n: 2}}*，它依然被 *b* 引用着。 \r\n>\r\n> 最后，*a* 指向的对象为  *{n: 2}*，*b* 指向的对象为 *{n: 1; x: {n: 2}}*。因此输出 *a.x* 值为 *undefined*，输出 *b.x* 值为 *{n: 2}*。\r\n\r\n\r\n\r\n### 292. 分析以下代码的执行结果并解释为什么。\r\n\r\n```js\r\n// example 1\r\nvar a = {}, b = '123', c = 123;  \r\na[b] = 'b';\r\na[c] = 'c';  \r\nconsole.log(a[b]);\r\n\r\n// example 2\r\nvar a = {}, b = Symbol('123'), c = Symbol('123');  \r\na[b] = 'b';\r\na[c] = 'c';  \r\nconsole.log(a[b]);\r\n\r\n// example 3\r\nvar a = {}, b = {key:'123'}, c = {key:'456'};  \r\na[b] = 'b';\r\na[c] = 'c';  \r\nconsole.log(a[b]);\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 运行结果：\r\n>\r\n> *example 1*：*c*\r\n>\r\n> *example 2*：*b*\r\n>\r\n> *example 3*：*c*\r\n>\r\n> 分析：\r\n>\r\n> 这题考察的是对象的键名的转换。\r\n>\r\n> - 对象的键名只能是字符串和 *Symbol* 类型。\r\n> - 其他类型的键名会被转换成字符串类型。\r\n> - 对象转字符串默认会调用 *String* 方法。\r\n>\r\n> 因此 *example 1* 中 *c* 作为键名后也是 *'123'*，直接覆盖 *a[b]* 的值；而 *example 2* 中，*Symbol* 作为 *ES6* 中新增的基本数据类型，它的特点就是唯一，*Symbol()* 方法生成的值都是唯一的，里面的参数不会影响结果。因此在 *example 2* 中 *b* 和 *c* 是两个不同的键名；*example 3* 中，对象不能作为键名，因此 *b* 和 *c* 都会通过 *String()* 方法转为字符串 *[object Object]*。\r\n\r\n\r\n\r\n### 293. 下面的代码打印什么内容？为什么？\r\n\r\n```js\r\nvar b = 10;\r\n(function b() {\r\n  b = 20;\r\n  console.log(b)\r\n})()\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 运行结果：\r\n>\r\n> *function b() { b = 20; console.log(b) }*\r\n> 分析：\r\n>\r\n> 当 *JavaScript* 解释器遇到非匿名立即执行函数（题目中的 *b*）时，会创建一个辅助的特定对象，然后将函数名称当作这个对象的属性，因此函数内部可以访问到 *b*，但是这个值又是只读的，所以对他的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。\r\n\r\n\r\n\r\n### 294. 下面代码中，*a* 在什么情况下会执行输出语句打印 *1* ？\r\n\r\n```js\r\nvar a = ?;\r\nif(a == 1 && a == 2 && a == 3){\r\n \\tconsole.log(1);\r\n}\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 分析：\r\n>\r\n> 这道题考查的知识点是：相等运算符（==）在作比较时会进行隐式转换，而如果操作数是引用类型，则会调用 *toString()* 或 *valueOf()* 方法对引用类型数据进行隐式转换。\r\n>\r\n> ```js\r\n> // 方法一：利用 toString()\r\n> let a = {\r\n>   i: 1,\r\n>   toString () {\r\n>     return a.i++;\r\n>   }\r\n> }\r\n> if(a == 1 && a == 2 && a == 3) {\r\n>   console.log('1');\r\n> }\r\n> \r\n> // 方法二：利用 valueOf()\r\n> let a = {\r\n>   i: 1,\r\n>   valueOf () {\r\n>     return a.i++\r\n>   }\r\n> }\r\n> if(a == 1 && a == 2 && a == 3) {\r\n>   console.log('1');\r\n> }\r\n> \r\n> // 方法三：利用数组（这个是真的骚）\r\n> var a = [1,2,3];\r\n> a.join = a.shift;\r\n> if(a == 1 && a == 2 && a == 3) {\r\n>   console.log('1');\r\n> }\r\n> \r\n> // 方法四：利用 Symbol\r\n> let a = {[Symbol.toPrimitive]: ((i) => () => ++i) (0)};\r\n> if(a == 1 && a == 2 && a == 3) {\r\n>   console.log('1');\r\n> }\r\n> ```\r\n>\r\n> 方法一和方法二没啥解释的了，解释下方法三和方法四。\r\n>\r\n> 方法三：\r\n>\r\n> *a.join = a.shift* 的目的是将数组的 *join* 方法替换成 *shift* 方法。因为数组在参与相等比较时也会通过 *toString()* 将数组转为字符串，而该字符串实际上是数组中每个元素的 *toString()* 返回值经调用 *join()* 方法拼接（由逗号隔开）组成。现在我们将 *join()* 方法替换为了 *shift()* 方法，也就意味着数组在通过 *toString()* 隐式转换后，得到是 *shift()* 的返回值，每次返回数组中的第一个元素，而原数组删除第一个值，正好可以使判断成立。\r\n>\r\n> 方法四：\r\n>\r\n> *ES6* 中提供了 *11* 个内置的 *Symbo* 值，指向语言内部使用的方法。*Symbol.toPrimitive* 就是其中一个，它指向一个方法，当该对象被转为原始类型的值时，会调用这个方法，并返回该对象对应的原始类型值。这里就是改变这个属性，把它的值改为一个闭包返回的函数。\r\n\r\n\r\n\r\n### 295. 介绍前端模块化的发展。\r\n\r\n> 参考答案：\r\n>\r\n> - *IIFE*：使用自执行函数来编写模块化（特点：在一个单独的函数作用域中执行代码，避免变量冲突）。\r\n>\r\n>   ```js\r\n>   (function(){\r\n>     return { data:[] }\r\n>   })()\r\n>   ```\r\n>\r\n> - *AMD*：使用 *requireJS* 来编写模块化（特点：依赖必须提前声明好）。\r\n>\r\n>   ```js\r\n>   define('./index.js',function(code){\r\n>   \\t// code 就是index.js 返回的内容\r\n>   })\r\n>   ```\r\n>\r\n> - *CMD*：使用 *seaJS* 来编写模块化（特点：支持动态引入依赖文件）。\r\n>\r\n>   ```js\r\n>   define(function(require, exports, module) {  \r\n>     var indexCode = require('./index.js');\r\n>   });\r\n>   ```\r\n>\r\n> - *CommonJS*：*nodejs* 中自带的模块化。\r\n>\r\n>   ```js\r\n>   var fs = require('fs');\r\n>   ```\r\n>\r\n> - *UMD*：通用模块规范，整合了 *AMD* 和 *CommonJS* 模块化。\r\n>\r\n>   ```js\r\n>   (function (global, factory) {\r\n>     if (typeof exports === 'object' && typeof module !== undefined) { //检查CommonJS是否可用\r\n>       module.exports = factory(require('jquery'));\r\n>     } else if (typeof define === 'function' && define.amd) {      //检查AMD是否可用\r\n>       define('toggler', ['jquery', factory])\r\n>     } else {       //两种都不能用，把模块添加到JavaScript的全局命名空间中。\r\n>       global.toggler = factory(global, factory);\r\n>     }\r\n>   })(this, function ($) {\r\n>     function init() {\r\n>   \r\n>     }\r\n>     return {\r\n>       init: init\r\n>     }\r\n>   });\r\n>   ```\r\n>\r\n> - *webpack(require.ensure)*：*webpack 2.x* 版本中的代码分割。\r\n>\r\n> - *ES Modules*： *ES6* 引入的模块化，支持 *import* 来引入另一个 *js* 。\r\n\r\n\r\n\r\n### 296. 请指出 *document.onload* 和 document.ready 两个事件的区别\r\n\r\n> 参考答案：\r\n>\r\n> 页面加载完成有两种事件：一是 *ready*，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；二是 *onload*，指示页面包含图片等文件在内的所有元素都加载完成。\r\n\r\n\r\n\r\n### 297. 表单元素的*readonly* 和 *disabled* 两个属性有什么区别？\r\n\r\n> 参考答案：\r\n>\r\n> - *readonly*：\r\n>   - 不可编辑，但可以选择和复制；\r\n>   - 值可以传递到后台；\r\n> - disabled：\r\n>   - 不能编辑，不能复制，不能选择；\r\n>   - 值不可以传递到后台；\r\n\r\n\r\n\r\n### 298. 列举几种你知道的数组排序的方法。\r\n\r\n> 参考答案：\r\n>\r\n> ```js\r\n> // 方法一：选择排序\r\n> let ary = [5, 7, 8, 11, 3, 6, 4];\r\n> for (let i = 0; i < ary.length - 1; i++) {\r\n>   for (let j = i + 1; j < ary.length; j++) {\r\n>     if (ary[i] < ary[j]) {\r\n>       [ary[i], ary[j]] = [ary[j], ary[i]];\r\n>     }\r\n>   }\r\n> }\r\n> ```\r\n>\r\n> ```js\r\n> // 方法二：冒泡排序\r\n> let ary = [5, 7, 8, 11, 3, 6, 4];\r\n> for (let i = 1; i < ary.length; i++) { \r\n>   for (let j = 0; j < ary.length - i; j++) {  \r\n>     if (ary[j] < ary[j + 1]) {\r\n>       [ary[j], ary[j + 1]] = [ary[j + 1], ary[j]]\r\n>     }\r\n>   }\r\n> }\r\n> ```\r\n\r\n\r\n\r\n### 299. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\r\n\r\n> 参考答案：\r\n>\r\n> - 客户区坐标：鼠标指针在可视区中的水平坐标 (*clientX*) 和垂直坐标 (*clientY*)；\r\n> - 页面坐标：鼠标指针在页面布局中的水平坐标 (*pageX*) 和垂直坐标 (*pageY*)；\r\n> - 屏幕坐标：设备物理屏幕的水平坐标 (*screenX*) 和垂直坐标 (*screenY*)；\r\n\r\n\r\n\r\n### 300. 如何编写高性能的 *JavaScript*？\r\n\r\n>参考答案：\r\n>\r\n>- 遵循严格模式：\\\"use strict\\\"\r\n>- 将 *JavaScript* 本放在页面底部，加快渲染页面\r\n>- 将 *JavaScript* 脚本将脚本成组打包，减少请求\r\n>- 使用非阻塞方式下载 *JavaScript* 脚本\r\n>- 尽量使用局部变量来保存全局变量\r\n>- 尽量减少使用闭包\r\n>- 使用 *window* 对象属性方法时，省略 *window*\r\n>- 尽量减少对象成员嵌套\r\n>- 缓存 *DOM* 节点的访问\r\n>- 通过避免使用 *eval()* 和 *Function()* 构造器\r\n>- 给 *setTimeout()* 和 *setInterval()* 传递函数而不是字符串作为参数\r\n>- 尽量使用直接量创建对象和数组\r\n>- 最小化重绘 (*repaint*) 和回流 (*reflow*)\r\n\r\n\r\n\r\n### 301. 下面的代码输出什么？\r\n\r\n```js\r\nvar a = function () { return 5 }\r\na.toString = function () { return 3 }\r\nconsole.log(a + 7);\r\n```\r\n\r\n> 参考答案：\r\n>\r\n> 10\r\n>\r\n> 因为会自动调用 a 函数的 *toString* 方法。\r\n\r\n**注：**   至此，JavaScript 内容就整理完了，目前正在整理关于网络方面的，大家可以期待一下。欢大家迎关注我哈😂，点击链接即可关注  [法医](https://juejin.cn/user/1574156383557255)，大家认真看哦，奥利给！💪"
    },
    {
        "article_id": "7182585412508975165",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1631626368d434da32c8bd74322248c~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Vue3 如何实现一个带遮罩的 dialog 对话框",
        "preview": "今天在项目中遇到了很多很多需要弹出一个对话框的场景，由于之前全都是通过 **v-if** 来控制这个组件的显示与否，这样就造成了很多页面莫名多出了很多不相关的代码，极度不优雅。所以我尝试去实现了一个函",
        "author": "韩振方",
        "view_count": 3320,
        "collect_count": 83,
        "comment_count": 22,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/ea2374c3b31d36e72ae7206dddb80331~300x300.image",
        "category": "前端",
        "content": "---\r\ntheme: mk-cute\r\n---\r\n\r\n开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第7天，[点击查看活动详情](https://juejin.cn/post/7167294154827890702 \\\"https://juejin.cn/post/7167294154827890702\\\")\r\n\r\n**前言：** 今天在项目中遇到了很多很多需要弹出一个对话框的场景，由于之前全都是通过 **v-if** 来控制这个组件的显示与否，这样就造成了很多页面莫名多出了很多不相关的代码，极度不优雅。所以我尝试去实现了一个函数式调用的 **dialog** 组件，感觉在简单的场景下还是比较好用的，特来分享一下这个思路。🎁\r\n\r\n![a.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b277152071bf439ab69079a008c426ce~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n---\r\n\r\n## 一. 前期准备\r\n\r\n你需要创建两个文件来和我一起完成这个函数式调用的 **dialog** ，\r\n`Dialog.vue` 和 `dialogCreator.ts`。</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c3378ee55a4a31819d16ba5c2fd569~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 二. dialog 遮罩的样式\r\n\r\n1. 我的组件样式是采用 `UnoCss` 的写法，是将样式内嵌在标签的`class` 属性里。和大家在 `Style` 标签里写是一模一样的效果，大家不用特别担心样式写法的问题，样式和本文主要内容没有任何直接的关系。\r\n\r\n2. 这里我们选择先写一个遮罩，关于遮罩的关键点其实就是需要设置一个带一点点透明度的背景，我选择了 `rgba(0,0,0,0.4)` ，也就是带 `0.4` 透明度的纯黑背景颜色。</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b0be5999050473fbc7ebf63d9d44fc0~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n在这里我们需要特别注意，由于我们的遮罩是会出现在“其它页面之上”的，所以我们需要给整个组件外部设置一个 `absolute` 来使它独立于其它页面，为了防止某些边界情况，需要设置 `z-index:9999` 来保证这个页面会在整个应用之上。整体效果如下：</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/510b9bf8460f4d169cc69255a52ec4f6~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n## 三. dialog 对话框的样式\r\n\r\n1. 关于 **dialog** 对话框的样式这里我们不统一设置，但是我们组件至少需要包含三个主要元素。一个 **Header** 区域,一个 **content** 区域，最后一个**取消按钮和确定按钮的区域。**\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0febd0ffb35042e98edcc4f449ef8dcd~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2. 在这里你可以先把文字都暂时写成固定值，到后面我会解释如何通过 **props** 动态的传递这些值。\r\n\r\n## 四. h 函数和 render 函数的用法\r\n\r\n1. 让我们打开之前准备的 `dialogCreator.ts` 文件，引入我们刚刚编写的 `Dialog` 组件，一会儿我们就需要用到它了。</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89ea97c785454aa3a300c8d8d234d305~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2. 在此之前我们还需要引入两位老朋友 `h`，函数和 `render` 函数。在这里看过我之前[《如何创建一个全局搜索框🔍》](https://juejin.cn/post/7170345858938961957) 和[《如何创建一个 Toast》](https://juejin.cn/post/7141697183597723679) 这两篇文章的朋友一定不会陌生这两个函数的意义，但为了照顾新朋友我还是会大概讲解一下这两个函数的主要用途的。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33085a08fd1f421ea534a77ea3fc5bac~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n3. 我相信大家对 **Vue** 渲染组件的流程有一个大概的认知，**Vue** 是先构建出 **虚拟dom** 然后再根据 **虚拟dom** 去渲染出 **真实dom**的。\r\n\r\n4. 在这里我们需要清晰的知道， **Vue** 给我们提供的的 `template` 标签仅仅只是一个让我们可以用熟悉的 **html** 标签书写 **虚拟dom** 的语法糖而已。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfae338ad0664a4b897a434b0831f195~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n是的，你没有听错，它仅仅只是一个语法糖而已，它底层是会被编译成用 `h` 函数创造出的 **虚拟dom** 在这里从而引出官方解释。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3aae5e171924a6fb835ddf7095d0644~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n5. 那么上文官方提到的渲染函数又是什么呢？其实就是刚刚我们提到的 `h` 函数。`h()` 函数更准确名字其实应该是 `createVnode()`，和它的英文翻译是一一对应的，**创建虚拟Dom。** </br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/460f1b68d35548729ec8483bdc82f431~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n6. 这个函数具体该如何使用呢？我们从实战去理解，让我们继续编写我们的 `DialogCreator` 类，我们创建两个函数，一个控制 **dialog** 的出现叫做 `present` 方法，另一个控制 **dialog** 的消失，叫做 `dismiss` 方法。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3196f681c05740a190d1461965f9d8d7~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n7. 这里马上就要用到刚刚提到的 `h` 函数。`h` 函数的第一个参数可以接收一个组件作为实参，并且返回这个组件的 **虚拟dom** 给我们。所以我们可以按照下面的写法拿到我们所需要的 **Dialog** 组件的 **虚拟dom**。</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088b9f825a014dc09acf7dc6ea2de7ec~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n8. 拿到 **虚拟dom** 有什么用呢？这里需要引入我们的第二个关键函数 `render` 函数。我们需要知道，我们目前只拿到了一个游离于 **真实dom节点** 之外的一个“**假的dom**”节点，你需要告诉它该渲染到哪里。什么意思呢？打开我们的 `main.ts` 文件。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777b4679143648389de26a09871ec4bd~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n千万不要忘记这个 `#app` 是什么。</br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0b641f76a04f1a8c71fbc991a628e5~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n它就是我们全局唯一的 **真实dom** ，一个朴实无华的一个 **id** 叫做 **app** 的 **真实dom。**\r\n\r\n9. 然后我们观察我们 `render` 函数可以接收的参数类型是什么，看下图我画黄色线的地方，看到什么惊喜了吗？第一个参数是一个 `vnode`。</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec69c2df8a184150993e4a34cfbbf215~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n什么？`vnode`，我刚刚不才通过 `h(Dialog)` 函数拿到了一个 `vnode` 吗？没错，聪明的你应该能猜到下面的写法了。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/430b1b497908451e8c0d8821adb6079d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n10. **emm** 但是好像在报错，我们看一下错误信息。（这里我们忽略第三个参数，只考虑两个参数即可。）</br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4926c7868eb48b79b2922c67b990f99~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n🤔，这个 **container** 参数的类型是一个 `element` 或者 `ShadomRoot`，这又是什么鬼呢？我们继续点击 `render` 函数，进入它的定义，发现 **container**  原来最终是一个 `HostElement` 类型。看来这个搞清楚这个 `HostElement` 是关键。 </br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88213fe40d4649a1b5ee6ed85f7db575~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n11. 在这里我们转变一下思路，我们反向推断 `HostElement` 是个什么。让我们再次打开 `main.ts` 文件，这次我们跳进 `mount` 函数的定义，就是下面黄色圈圈圈起来的这个函数。</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23458e039b894985885886fda4f3bd57~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n你看到了什么？</br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8e7e0ebb994828875744ed95099fe7~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n没错很熟悉的几个单词 `HostElement` ，注意，你千万不要觉得这个 `HostElement` 是什么很神奇的元素，让我们回想一下 `mount` 函数的参数是什么来着？</br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4851d0b77ccd42dbbdaef829afde860b~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n没错，还是那个普普通通的，一个叫做 `app` 的全局的**真实dom**。</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04dd82c1afbb456394acd109056da12d~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n12. 由此我们可以反向推断出，`render` 函数需要一个 **真实dom** 来包裹我们的**虚拟dom**。生产出一个 **真实dom** 还不容易吗？我们直接调取 `js` 的方法，`createElement(‘div’)` 来生产一个普通的 `div` 元素用来包裹我们的**虚拟dom。**\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29484fcc6f9f44478eb965cc545e05a0~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 五. 完善 DialogCreator 类\r\n\r\n1. 现在也告诉了**虚拟Dialog** 组件该放在哪里了，接下来就需要将我们的 `containerEl` 放在正确的位置，放在哪里呢？由于我们的 `dialog` 出现的情况一般都是最顶层。提醒你一下，别忘了我们所有其它页面都是被放到了 `id为 app` 的 `div` 标签里。那么为了保证它绝对出现在最顶层而不被其它页面遮挡的这种情况发生，那我们延伸一下思路，如果让我们的 `Dialog` 成为 `body` 标签的第一个子元素，并且由于之前我们给 `Dialog` 组件设置了 `absolute` 属性，那么它就会正好浮现在我们所有页面之上，由于它脱离了文档流，那么它的出现就不会影响我们其它页面的布局</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff24d8b302d4730b66a20e6e88ac1f1~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n2. 思路有了，这还不简单吗？如何成为 `body` 的第一个子元素就是基础方法了，这里就不过多解释了。\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b6502394f174f4495e3cf2f562e8fdf~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n3. 而让元素消失的方法就更简单了，合适的时机移除这个 **dom** 元素即可。</br>\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c81572e0fa1649498bf68cd5dba9028f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n4. 让我们测试一下是否可行，我们随便在哪一个页面里去调用我们的 `DialogCreator` 类调用 **new** 生成一个 `Dialog` 实例。然后随便写两个按钮去调用这两个方法测试一下。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/298226c56e16421db55dee0bd908f7d5~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n效果如下：</br>\r\n![啊.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24a3255e0ed44ca8a3d4c1d701b98f4c~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n但是由于我们的“遮罩”挡住了我们的按钮，所以目前为止我们暂时点击不了消失按钮。别着急，我们一步一步尝试优化现在的代码。\r\n\r\n## 六. 神奇的 h 函数\r\n\r\n1. 目前我们的 `dialog` 已经可以出现到我们的页面了，但是现在它的内容都是写死的，不灵活，我们需要按照不同的场景传递不同的文字该如何实现呢？这里又需要请出我们的老朋友，`h` 函数。\r\n\r\n2. 这里我先抛出概念，等等我们一步一步验证。\r\n> `h` 函数是可以接收第二个参数的，并且第二个参数的值将被转换成 props 传递给我们的组件。\r\n\r\n3. 让我们回到 `dialogCreator.ts` 文件。我们声明一个类型，准备作为 `DialogCreator` 内部 `constructor` 参数的类型。</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d56e11b8c94adf88e659082f0eeebd~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n并且声明两个类的属性 `title` 和 `content` 来准备做为 `props` 传递给我们的 `Dialog.vue` 组件。 </br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51efc783ca1f43d180944b403b15d7ea~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n4. 我们现在还缺少一个关键的东西，就是**取消按钮**和**确定按钮**的函数，我们一并声明。（这里需要注意，一般取消按钮就是关闭 dialog 对话框的功能，也就是类本身的 **dismiss** 方法，所以我们不需要用户额外提供取按钮的函数，只需要提供确定时的回调函数即可。）</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1395895c3b8e49a484e05e5e88b1778a~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n这里需要读者仔细品味上图代码的含义。</br>\r\n\r\n5. 接下来我们就需要传递 `this.option` 给 `h` 函数即可。<br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f49bb45c42e47a097161fb33daf9950~tplv-k3u1fbpfcp-watermark.image?)<br>\r\n报错了没关系，是因为我们还没有在 `Dialog.vue` 组件内部定义 `Props`。<br>\r\n\r\n6. 让我们分别从 `dialogCreator.ts` 文件导出这个 `DialogPropsType` 类型，再从 `Dialog.vue` 引入这个类型用来定义 **props** 即可。<br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58563dc7811849ef86b8945ed854eae4~tplv-k3u1fbpfcp-watermark.image?)<br>\r\n随即可以看到我们刚刚到报错消失了，说明我们的思路是没问题的。<br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db98417698a4b61944bd264e382a24e~tplv-k3u1fbpfcp-watermark.image?)<br>\r\n\r\n## 七. 改造 Dialog.vue 组件\r\n\r\n1. 我们先将之前固定写死的，`title` 部分和 `content` 部分替换成我们声明的 **props** 里的 `title` 和 `content`。\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/127faeb88f0e443095a0c6b428c12bc5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n2. 然后别忘了我们 `props` 还存放着《确定》和《取消》的的方法。取出来分别放置在这两个按钮身上。\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1ec7dc9538f460e87a374dfc058b962~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n3. 随便找一个其它页面，测试刚刚的 `DialogCreator` 类，内容我就随便自己写了</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c95f3b67086a468993ff82dcd20a2c0c~tplv-k3u1fbpfcp-watermark.image?)\r\n我们测试一下：</br>\r\n![啊.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9532e727d0e432ea1847d7a6e305bec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 八. 遮罩的关闭效果\r\n\r\n1. 现在我们点击**遮罩**是没办法关闭 **dialog** 的，效果如下：</br>\r\n![a.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4537a8312f8a4785b9f8e9dc51a3b3a0~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n2. 造成这种情况的原因也很简单，因为我们的遮罩没有点击事件，怎么办呢？非常非常简单，给遮罩添加取消 `cancelBtn` ，也就是 **dismiss** 方法不就可以了吗？</br>\r\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f1489cfef94e55a9b420dfd9d771a3~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n测试一下，现在点击遮罩已经可以正常关闭 **dialog** 了。</br>\r\n![啊.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68708102f09f43b7af6c3b5cf9a7dcfc~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 九. 修复冒泡造成的 Bug\r\n\r\n1. 目前看起来功能已经很棒了，但是目前的代码会造成一个严重的 `bug`，我们在点击 `dialog` 本身的时候，由于事件冒泡，会错误的触发遮罩层的方法。</br>\r\n![a.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb0770551d6f414fa98f02a1c3c69154~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n2. 我们验证一下，我们随便编写一个函数，然后绑定到 `dialog` 组件上。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce9fa7e5b5084e5486760b9423c50751~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n注意：这里的 `dialog` 指的是中间的那个实实在在的对话框本身，不是指整个组件。</br>\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af023ef146e542f289d8b3f7ce2fd357~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22fbffbe98a64f159558e479c512a164~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n3. 然后给 `cancelBtn` 也加一行 `console.log` 测试一下。</br>\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ac1719a1b84a2b9fb08182dadef9d4~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n效果如下：</br>\r\n![a.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7faaffaa3ca4f709d633b42ed0ae848~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n\r\n4. 解决方法简单的出乎你的意料，让我们回到中间的 `diaolog` 身上，仅仅只需要绑定一个空的 `click` 函数，然后加上修饰符 `stop` 即可。\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b4cd1eada84d86b551e22ad2db7c97~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n5. 效果如下，可以看到，现在点击 `dialog` 已经不会错误的关闭整个 对话框了。</br>\r\n![QQ20221229-225519-HD.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75c2b0668dd144669769c8b347f9e00e~tplv-k3u1fbpfcp-watermark.image?)</br>\r\n至此我们的 `dialog` 组件已经可以在绝大部分场景下使用了。🎁～\r\n\r\n## 总结\r\n\r\n目前的代码只是一个很粗糙的实现，更加具体实用的功能还需读者根据自己项目的需求自行完成。下面是 `DialogCreator.ts` 文件的代码。读者可根据需要自行查阅。\r\n```ts\r\nimport Dialog from \\\"./Dialog.vue\\\";\r\n\r\nimport { h, render } from \\\"vue\\\";\r\n\r\ninterface DialogType {\r\n  title: string;\r\n  content: string;\r\n  confirmBtn: () => void;\r\n}\r\n\r\nexport interface DialogPropsType extends DialogType {\r\n  closeBtn: () => void;\r\n}\r\nexport class DialogCreator {\r\n  containerEl: HTMLDivElement;\r\n  option: DialogPropsType;\r\n  constructor(option: DialogType) {\r\n    this.containerEl = document.createElement(\\\"div\\\");\r\n    this.option = { ...option, closeBtn: this.disMiss.bind(this) };\r\n  }\r\n\r\n  present() {\r\n    const vnode = h(Dialog, this.option);\r\n    render(vnode, this.containerEl);\r\n    document.body.insertBefore(this.containerEl, document.body.firstChild);\r\n  }\r\n\r\n  disMiss() {\r\n    render(null, this.containerEl);\r\n    document.body.removeChild(this.containerEl);\r\n  } //dialog 消失的方法\r\n}\r\n\r\n```"
    },
    {
        "article_id": "7188851834704887845",
        "snapshot": "",
        "title": "线程局部变量的实现 ThreadLocal",
        "preview": "前言 离职回老家，实在太无聊，于是乎给自己整了一套台式机配置，总价 1W+，本以为机器到位后可以打打游戏，学学技术打发无聊的时光。但是我早已不是从前那个少年了，打 Dota 已经找不到大学时巅峰的自己",
        "author": "暮色妖娆丶",
        "view_count": 1681,
        "collect_count": 23,
        "comment_count": 2,
        "avatar": "https://p26-passport.byteacctimg.com/img/user-avatar/b4394a5e892573b30cca50c2415f8269~300x300.image",
        "category": "后端",
        "content": "## 前言\r\n\r\n离职回老家，实在太无聊，于是乎给自己整了一套台式机配置，总价 1W+，本以为机器到位后可以打打游戏，学学技术打发无聊的时光。但是我早已不是从前那个少年了，打 Dota 已经找不到大学时巅峰的自己，当年我一手 SF 真的是打遍天下无敌手......，和朋友打 LOL 又没有精力去学一个新的游戏，贼坑。。。\r\n\r\n<div align=center>\r\n    <img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6abaed15e39483689e3e9d80ccdbbd8~tplv-k3u1fbpfcp-watermark.image?\\\">\r\n</div>\r\n\r\n\r\n学技术又不想学，太懒了！！！于是乎，写文章吧...正好年后找工作用得上！今天我们来谈一谈 Java 中存储线程局部变量的类 `ThreadLocal` 。\r\n\r\n## ThreadLocal 介绍\r\n\r\n> This class provides thread-local variables.  These variables differ from\r\n  their normal counterparts in that each thread that accesses one (via its\r\n  {@code get} or {@code set} method) has its own, independently initialized\r\n  copy of the variable.  {@code ThreadLocal} instances are typically private\r\n  static fields in classes that wish to associate state with a thread (e.g.,\r\n  a user ID or Transaction ID)\r\n\r\n上面这段是该类的注释：该提供线程局部变量。这些变量不同于它们正常的对应变量，因为每个通过 `get()、set()` 访问 `ThreadLocal` 变量的线程都有自己的、独立初始化的变量副本。`ThreadLocal` 实例通常是类中的私有静态字段，希望将状态与线程关联(例如，用户ID或事务ID)。\r\n\r\n**简单来说它的作用是作为一个数据结构，可以为每个线程分别存储他们私有的数据**。我们可以暂时简单理解为下面这张图（实际上这个图是错的）\r\n\r\n\r\n<div align=center>\r\n    <img src=\\\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f900915395b42d8ab8334eb66db5f44~tplv-k3u1fbpfcp-watermark.image?\\\">\r\n</div>\r\n\r\n后面我们会详细介绍它的设计原理。\r\n\r\n### 常用 API\r\n\r\n\r\n| 方法 | 作用 |\r\n| --- | --- |\r\n| public ThreadLocal() | 实例化对象 |\r\n| ThreadLocal.withInitial(Supplier\\\\<? extends S> supplier ) | 实例化对象并赋予它每个线程初始值 |\r\n| public void set(T value) | 设置当前线程绑定的变量 |\r\n| public T get() | 获取当前线程绑定的变量 |\r\n| public void remove() | 移除当前线程绑定的变量 |\r\n\r\n\r\n## ThreadLocal 使用场景\r\n\r\n### Spring 事务管理器\r\n\r\n在 Spring 事务实现中，`TransactionSynchronizationManager` 类中声明了多个 `ThreadLocal` 类型的成员变量用以将事务执行过程中各种上下文信息绑定到当前线程，包括当前事务连接对象、是否可读、事务名称、隔离级别等\r\n\r\n```\r\npublic abstract class TransactionSynchronizationManager {\r\n\r\n   private static final ThreadLocal<Map<Object, Object>> resources = new NamedThreadLocal<>(\\\"Transactional resources\\\");\r\n\r\n   private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations = new NamedThreadLocal<>(\\\"Transaction synchronizations\\\");\r\n\r\n   private static final ThreadLocal<String> currentTransactionName = new NamedThreadLocal<>(\\\"Current transaction name\\\");\r\n\r\n   private static final ThreadLocal<Boolean> currentTransactionReadOnly = new NamedThreadLocal<>(\\\"Current transaction read-only status\\\");\r\n\r\n   private static final ThreadLocal<Integer> currentTransactionIsolationLevel = new NamedThreadLocal<>(\\\"Current transaction isolation level\\\");\r\n\r\n   private static final ThreadLocal<Boolean> actualTransactionActive = new NamedThreadLocal<>(\\\"Actual transaction active\\\");\r\n   //......\r\n  }\r\n```\r\n\r\n### SpringMVC 存储上下文 Request 数据\r\n\r\n`RequestContextHolder` 这个类是 `SpringMVC` 中提供的持有上下文 `Request` 的一个类，内部实现就是有两个 `ThreadLocal` 属性去存储请求对象数据。\r\n\r\n```\r\nprivate static final ThreadLocal<RequestAttributes> requestAttributesHolder =\r\n      new NamedThreadLocal<>(\\\"Request attributes\\\");\r\n\r\nprivate static final ThreadLocal<RequestAttributes> inheritableRequestAttributesHolder =\r\n      new NamedInheritableThreadLocal<>(\\\"Request context\\\");\r\n```\r\n以便于我们在业务代码中在没有 `HttpServletRequest` 对象的位置也可以通过 `ThreadLocal` 获取请求头等信息，比如我前面一篇关于 `OpenFeign` 向下游传递 `header` 的文章就用到了它。\r\n\r\n### PageHelper 分页的实现\r\n之前流行的分页插件之一 `PageHelper` 其分页原理也是通过 `ThreadLocal` 实现，我们使用它进行分页时只需要在代码中调用静态方法\r\n\r\n```\r\nPageHelper.startPage(pageNum,pageSize);\r\n```\r\n接下来的第一条 SQL 就会自动进行分页，其实原理就是它将分页参数封装到一个 `Page` 对象中，然后将 `Page` 放进 `ThreadLocal` 中以达到 web 环境中多个线程互相分页不影响，后面就是都雷同的 SQL 拼接了。\r\n\r\n\r\n### 存储用户身份信息\r\n在很久之前我们用户登录信息的存储通常都是在 `Session` 中，后来大多是逐渐用 `ThreadLocal` 去代替从 `Session` 获取用户登录信息了。首先我们在用户每次请求需要授权的接口时，会让用户携带请求头 `token` ，后端在拦截器中拿到这个 `token` 去 `redis` 查询用户信息，或者如果这个 `token` 是 `jwt` 的话，直接解析它得到用户信息然后放进 `ThreadLocal`。\r\n\r\n```\r\n@Override\r\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {\r\n    String header = request.getHeader(\\\"x-auth-token\\\");\r\n    //如果你的实现是 token 唯一字符串，从 Redis 拿用户信息\r\n    User user = redisTemplate.opsForValue().get(header);\r\n    //如果你的实现是 token 是jwt，那直接解析 jwt 拿到用户信息\r\n    //.......\r\n    if (user != null) {\r\n        CurrentUser.set(user);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n@Override\r\npublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n    CurrentUser.clear();//请求结束之后不要忘记清除\r\n}\r\n\r\n```\r\n`CurrentUser` 类\r\n```\r\npublic class CurrentUser {\r\n    public static final ThreadLocal<User> USER_THREAD_LOCAL = new ThreadLocal<>();\r\n\r\n    public static void set(User user){\r\n        USER_THREAD_LOCAL.set(user);\r\n    }\r\n\r\n    public static User get(){\r\n        return USER_THREAD_LOCAL.get();\r\n    }\r\n\r\n    public static void clear(){\r\n        USER_THREAD_LOCAL.remove();\r\n    }\r\n}\r\n```\r\n这样我们在任何地方只要使用  `CurrentUser.get()` 就能轻松获取到当前登录用户。\r\n\r\n以上就是几个 `ThreadLocal` 常见的场景，其核心理念就是利用  `ThreadLocal` 的线程隔离特性。\r\n\r\n\r\n## ThreadLocal 和 synchronized\r\n\r\n值得注意的是 `ThreadLocal` 在解决线程安全问题上提供了一种不同于传统并发安全的解决思路，传统的 `synchronized` 或者 `Lock` 类是出于并发操作时让多个线程排队去访问共享数据，但是这样的弊端就是会造成锁竞争，这是以时间换空间。\r\n\r\n而 `ThreadLocal` 将这个问题换了一个角度看待，既然并发安全的问题原因是因为多个线程共享一份数据，那么我现在就让每个线程都拥有一份独立数据，它们各自操作自己私有的本地变量，这样就不会有并发安全问题，也没有锁竞争.但是每个线程都要维护一份数据，会有额外的内存开销，这是以空间换时间。\r\n\r\n\r\n实际项目中我们应该用哪种方式，最终还是取决于业务场景更适合哪一种。\r\n\r\n## 线程隔离的原理\r\n\r\n### ThreadLocal.set(T value) 源码解读\r\n前面说了一些使用场景，这里我们探究一下 `ThreadLocal` 是如何实现线程隔离的。这里我们写个极致简单的例子\r\n\r\n```\r\nThreadLocal<User> local = ThreadLocal.withInitial(User::new);\r\nnew Thread(() -> local.set(new User())).start();\r\n```\r\n\r\n这个例子只有两行代码，我们来看 `local.set(T value)` 方法的源码\r\n\r\n```\r\npublic void set(T value) {\r\n    Thread t = Thread.currentThread();\r\n    ThreadLocalMap map = getMap(t);\r\n    if (map != null) {\r\n        map.set(this, value);\r\n    } else {\r\n        createMap(t, value);\r\n    }\r\n}\r\n```\r\n代码很简单，首先拿到当前线程，然后根据当前线程拿到一个 `Map` 数据结构，将我们传进来的值设置到这个 `Map` 中，那么重点就在这个 `getMap()` 中，查看其源码\r\n\r\n```\r\nThreadLocalMap getMap(Thread t) {\r\n    return t.threadLocals;\r\n}\r\n```\r\n我们发现这个代码就更简单了，直接返回了当前线程的一个成员变量，`Thread` 类中是这样定义的\r\n\r\n```\r\npublic class Thread implements Runnable {\r\n    //...\r\n    ThreadLocal.ThreadLocalMap threadLocals = null;\r\n    //...\r\n }\r\n```\r\n从这里就可以明白它是如何实现线程隔离的，我们设置的值全都放进了当前线程对象的一个成员变量中存着呢，那当然是线程隔离的，你在哪个线程中去 `set()`，那就会保存到哪个线程对象的成员变量中。\r\n\r\n接着我们再看这行代码 `map.set(this, value);`，很重要，这里的 `this` 是什么？是当前的 `ThreadLocal<Integer> local; `对象，也就是说我们 `set()` 的值实际上是以当前方法的调用者 `local` 为 `key`，传入的值为 `value` 保存起来的键值对。简单的理解为下图\r\n\r\n\r\n![QQ图片20230111210016.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a6c9fcc6f745e0a8d3bee01851947d~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们对于 `ThreadLocal` 的操作其实是对 `Thread` 的成员变量 `threadLocals` 进行操作。那么这个时候我们就要改变一下固有的思维，因为在正常的思维中，我们看到这行代码 `local.set(new User());`\r\n脑海中浮现的第一印象都是向 `local` 的成员变量中进行一个数据的赋值，然而在 `ThreadLocal` 的实现中，这行代码的意思是将 `ThreadLocal` 作为 `key`，传入的值作为 `value` 存入到当前 `Thread` 对象的一个成员变量中。\r\n\r\n### ThreadLocalMap\r\n\r\n上面我们看到了 `Thread` 类中的成员变量是 `ThreadLocalMap` 类型的，`ThreadLocal、Thread、ThreadLocalMap` 三者的类图关系为\r\n\r\n\r\n![QQ图片20230115192343.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a267ac374bf49d58e67d97b205fff23~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n首先由于我们程序中可能会声明多个 `ThreadLocal` 对象，那么自然用于存放的数据结构就需要类似集合，需要一个线程可以存储多个以 `ThreadLocal` 为 `key` 数据，考虑到查询的时间复杂度以及各方面综合考虑，`Map` 结构再适合不过。\r\n\r\n`ThreadLocalMap` 是 `ThreadLocal` 的一个静态内部类，它的内部又声明了一个静态内部类 `Entry` 来实现 K/V，这一点类似于 `HashMap`。\r\n\r\n```\r\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\r\n    /** The value associated with this ThreadLocal. */\r\n    Object value;\r\n\r\n    Entry(ThreadLocal<?> k, Object v) {\r\n        super(k);\r\n        value = v;\r\n    }\r\n}\r\n```\r\n不同的是这里的 `Entry` 是 弱引用 `WeakReference` 的子类，那么在了解弱引用之后我们会发现在特定的场景下，如果不这么设计可能造成内存泄漏。 \r\n\r\n## 弱引用\r\n在分析内存泄漏之前我们必须知道 `Jvm` 中几种引用类型以及它们的特点。这里不详细介绍，只说结论\r\n\r\n\r\n| 引用类型 | 回收机制 |\r\n| --- | --- |\r\n| 强引用 | 我们程序中声明的对象其引用都是强引用，只要其不指向 null ，GC 时候就不会被回收，即使内存溢出 |\r\n| 软引用 | 使用 SoftReference 类构造一个软引用，与强引用的区别是当内存不足，GC 会回收软引用指向的对象|\r\n| 弱引用 | 使用 WeakReference 类构造一个弱引用，与软引用的区别是，只要触发 GC 就会回收弱引用指向的对象|\r\n\r\n上面的结论都可以通过简单的代码来验证，这里我们主要介绍结论。\r\n\r\n\r\n## 内存泄漏\r\n\r\n### 内存泄漏与内存溢出\r\n\r\n- 内存溢出 —— 程序中真的内存不够用了。\r\n- 内存泄漏 —— 由于代码问题导致程序中本该被释放的内存没有被释放，最终造成 “内存不够用” 的假象。\r\n\r\n### 内存图\r\n\r\n这里我们通过上面的两行样例代码。\r\n\r\n```\r\nThreadLocal<User> local = ThreadLocal.withInitial(User::new);\r\nnew Thread(() -> local.set(new User())).start();\r\n```\r\n\r\n结合分析 `ThreadLocalMap、Thread、ThreadLocal` 的源码可以得到一张完整的内存图。\r\n\r\n\r\n\r\n![QQ图片20230112113507.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee70828306fe48d89eafac9b5a00ad37~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n值得注意的是我们是没有办法直接声明弱引用的，必须通过 `WeakReference` 去包裹一个对象持有弱引用，以下面代码为例\r\n\r\n```\r\nWeakReference<User> wr = new WeakReference<>(new User());\r\n```\r\n它在内存中是这样的\r\n\r\n\r\n![QQ图片20230112112042.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e019ff3b4559454eb8981d6cba72476b~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n所以完整的内存图应该能够理解。\r\n\r\n\r\n### 为什么需要弱引用\r\n\r\n使用反证法，假设我们的  `Entry` 不用弱引用，那么会出现这样的情况，我们声明出来的 `ThreadLocal` 对象，如果我们不想用它了或者说在程序中它的生命周期结束了（实际上这种场景很少，一般来说我们的 `ThreadLocal` 对象都是以 `static final` 的形式定义在全局，这里只是存在这个可能），想让 GC 回收掉它占用的内存，那么我们只需要让没有引用指向它即可 ，也就是将 `1号线` 干掉。\r\n\r\n但是由于 `ThreadLocalMap` 里面也有持有我们声明的 `ThreadLocal` 对象的强引用，如果我们想要回收的话就必须把这里的强引用也干掉，最好的方法是使用 `remove()` 方法移除。否则就需要干掉线程里面的 \r\n`ThreadLocal.ThreadLocalMap threadLocals = null;` 这个属性，想要干掉这个属性就得等线程销毁，然而实际业务中有的线程是 `24h` 不间断执行的，也有的线程是位于线程池要被复用的，所以只要有一个线程不销毁，这个 `ThreadLocal` 对象就不会被回收，这就会产生内存泄漏。\r\n\r\n但是如果这里 `Entry` 的 `key` 是弱引用，只要我们将 `1号线` 干掉，下次 GC 的时候发现这个 `ThreadLocal ` 对象只有一个 `2号线` 弱引用指向它，就会将它回收掉。\r\n\r\n```\r\npublic static void function1() {\r\n    ThreadLocal<User> local = ThreadLocal.withInitial(User::new);\r\n    local.set(new User());\r\n    local.get();\r\n    new Thread(() -> {\r\n        local.set(new User());\r\n        User user = local.get();\r\n        while (true) {\r\n            Thread.sleep(1000);\r\n            System.out.println(\\\"测试\\\");\r\n        }\r\n    }).start();\r\n}\r\n```\r\n上面这段代码如果 `Entry` 是强引用，当 `function1()` 结束之后 `local` 指向的内存不会被回收，如果是弱引用，就会被回收。\r\n\r\n### remove() 防止内存泄漏\r\n`ThreadLocal` 为了防止内存泄漏，已经用弱引用帮我们解决了一大隐患，难道使用弱引用就能完全避免内存泄漏吗？并不是，还有一种情况，接着上面的章节，当我们 GC 将弱引用指向的 `ThreadLocal` 内存回收之后， `ThreadLocalMap` 里面的 `Entry` 的 `key` 就变成 `null` 了，这样我们就无法访问到它原先对应的 `value`，所以这个 `value` 将不会被回收，这才是实际场景中真正的内存泄漏问题。\r\n\r\n所以我们在用完之后一定需要手动的调用 `remove()` 清除当前线程的局部变量值，也就是将对应的 `Entry（K/V）` 删掉，这样即使后来 `ThreadLocal` 对象被回收，也不会造成内存泄漏问题。\r\n\r\n值得注意的是我们观察 `set()、get()` 源码会发现它其实都调用了一个方法\r\n\r\n```\r\nprivate int expungeStaleEntry(int staleSlot) {\r\n//......\r\n    if (k == null) {\r\n        e.value = null;\r\n        tab[i] = null;\r\n        size--;\r\n    }\r\n//......\r\n}\r\n```\r\n在每次操作的时候都会判断是否存在 `key` 为 `null` 的键值对，如果存在就会删掉，以此来尽量的避免内存泄漏的问题，那这是不是意味着即使我们不手动 `remove()` 也可以呢？其实不然，因为实际业务中可能会出现长时间不调用 `set()、get()` 方法的情况，所以当后面的流程里不再需要使用这个值得时候，手动 `remove()` 是一个好习惯，也是阿里巴巴规范里面的一个强制规定。\r\n\r\n### remove() 防止数据错乱\r\n\r\n实际 Web 项目中我们很多场景都会用到线程池，当用完之后将线程对象归还到线程池，如果没有 `remove()` ，下个请求到来，这个线程被复用时发现这个数据已经存在了，就直接拿过来用了，这个问题是很严重的，因为相当于一个线程用了另一个线程的数据，这会造成严重的业务 bug 。\r\n\r\n## 结语\r\n\r\n### 如果这篇文章对你有帮助，记得点赞加关注！你的支持就是我继续创作的动力！\r\n"
    },
    {
        "article_id": "7189314053955649573",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31862da80499464c970f11ad521fc0d9~tplv-k3u1fbpfcp-watermark.image?",
        "title": "Go语言进阶之并发编程 ｜ 青训营笔记",
        "preview": "这是我参与「第五届青训营 」伴学笔记创作活动的第 2 天 并发编程 并发与并行的区别 协程Goroutine",
        "author": "啵啵肠",
        "view_count": 1366,
        "collect_count": 3,
        "comment_count": 0,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/0de6e7c19aacf1d70c9fc6bc41710c4d~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: nico\r\n---\r\n**这是我参与「第五届青训营 」伴学笔记创作活动的第 2 天**\r\n\r\n## 前言\r\n\r\n> 记录加入青训营的每一天的日笔记\r\n\r\n## 并发编程\r\n\r\n### 并发与并行的区别\r\n\r\n> 并发：多线程程序在一个核的CPU上运行\r\n>\r\n> 并行：多线程程序在多个核的CPU上运行\r\n>\r\n> **Go可以充分发挥多核优势 高效运行**\r\n\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb8dae1624b4919a3e99a33288e25ea~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n\r\n### 协程Goroutine\r\n\r\n> 协程：用户态，轻量级线程 栈MB级别\r\n>\r\n> 线程：内核态，线程跑多个协程，栈KB级别\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beb9588743024e8dac01e7aba52bdc48~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n线程的创建、切换、停止较大地占用系统资源\r\n\r\n协程的创建和调度由Go语言进行完成\r\n\r\n通过开启协程快速打印hello goroutine案例：\r\n\r\n```\r\npackage concurrence\r\n​\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"time\\\"\r\n)\r\n​\r\nfunc hello(i int) {\r\n    println(\\\"hello goroutine : \\\" + fmt.Sprint(i))\r\n}\r\n​\r\nfunc HelloGoRoutine() {\r\n    for i := 0; i < 5; i++ {\r\n        // go关键字作为创建协程的关键字\r\n        go func(j int) {\r\n            hello(j)\r\n        }(i)\r\n    }\r\n    // 保证子协程运行完前主线程不退出\r\n    time.Sleep(time.Second)\r\n}\r\n```\r\n\r\n### CSP（communicating sequential processes）并发模型\r\n\r\n不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。\r\n\r\n> Do not communicate by sharing memory; instead, share memory by communicating. “不要以共享内存的方式来通信，相反，要通过通信来共享内存。”\r\n\r\n### Channel 缓冲通道\r\n\r\n> 创建方式：\r\n>\r\n> make(chan 元素类型, [缓冲大小])\r\n>\r\n> 通道是用来传递数据的一个**数据结构**，可以用于两个goroutine之间，通过传递一个指定类型的值来同步运行和通讯。\r\n>\r\n> 操作符`<-`用于指定通道的**方向**，实现发送or接收\r\n>\r\n> 若未指定方向，则为**双向通道**\r\n\r\n-   无缓冲通道 make(chan int)\r\n-   有缓冲通道 make(chan int, 2)\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b350fc4a28e94bb7a58c06418ffadb5f~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n\r\n通过两个Channel通道完成数字平方任务案例：\r\n\r\n```\r\npackage concurrence\r\n​\r\nfunc CalSquare() {\r\n    src := make(chan int)\r\n    dest := make(chan int, 3)\r\n    go func() {\r\n        defer close(src)\r\n        for i := 0; i < 10; i++ {\r\n            src <- i\r\n        }\r\n    }()\r\n    go func() {\r\n        defer close(dest)\r\n        for i := range src {\r\n            dest <- i * i\r\n        }\r\n    }()\r\n    for i := range dest {\r\n        //复杂操作\r\n        println(i)\r\n    }\r\n}\r\n```\r\n\r\n注意：\r\n\r\n-   如果通道不带缓冲，发送方会阻塞直到**接收方从通道中接收了值**。如果通道带缓冲，发送方则会阻塞直到发送的值**被拷贝到缓冲区内**；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\r\n-   上述代码中之所以能够顺利从通道接收到数据，是因为每次遍历之前都通过关闭对应的通道后再进行的遍历接受数据\r\n\r\n### 并发安全Lock\r\n\r\n若采用共享内存实现通信，则会出现多个Goroutine同时操作一块内存资源的情况，这种情况会发生竞态问题（数据竞态）\r\n\r\n#### Mutex互斥锁解决数据竞争\r\n\r\n> 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。\r\n\r\n```\r\npackage concurrence\r\n​\r\nimport (\r\n    \\\"sync\\\"\r\n    \\\"time\\\"\r\n)\r\n​\r\nvar (\r\n    x    int64\r\n    lock sync.Mutex\r\n)\r\n​\r\nfunc addWithLock() {\r\n    for i := 0; i < 2000; i++ {\r\n        lock.Lock()\r\n        x += 1\r\n        lock.Unlock()\r\n    }\r\n}\r\nfunc addWithoutLock() {\r\n    for i := 0; i < 2000; i++ {\r\n        x += 1\r\n    }\r\n}\r\n​\r\nfunc Add() {\r\n    x = 0\r\n    for i := 0; i < 5; i++ {\r\n        go addWithoutLock()\r\n    }\r\n    time.Sleep(time.Second)\r\n    println(\\\"WithoutLock:\\\", x)\r\n    x = 0\r\n    for i := 0; i < 5; i++ {\r\n        go addWithLock()\r\n    }\r\n    time.Sleep(time.Second)\r\n    println(\\\"WithLock:\\\", x)\r\n}\r\n​\r\nfunc ManyGoWait() {\r\n    var wg sync.WaitGroup\r\n    wg.Add(5)\r\n    for i := 0; i < 5; i++ {\r\n        go func(j int) {\r\n            defer wg.Done()\r\n            hello(j)\r\n        }(i)\r\n    }\r\n    wg.Wait()\r\n}\r\n```\r\n\r\n使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；\r\n\r\n当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。\r\n\r\n#### WaitGroup解决数据竞争\r\n\r\n> Go语言中除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务 WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。\r\n\r\n```\r\npackage concurrence\r\n​\r\nimport (\r\n    \\\"fmt\\\"\r\n    \\\"sync\\\"\r\n)\r\n​\r\nfunc HelloPrint(i int) {\r\n    fmt.Println(\\\"Hello WaitGroup :\\\", i)\r\n}\r\n​\r\nfunc ManyGoWait() {\r\n    var wg sync.WaitGroup\r\n    wg.Add(5)\r\n    for i := 0; i < 5; i++ {\r\n        go func(j int) {\r\n            defer wg.Done()\r\n            HelloPrint(j)\r\n        }(i)\r\n    }\r\n    wg.Wait()\r\n}\r\n​\r\nfunc main() {\r\n    ManyGoWait()\r\n}\r\n```\r\n\r\n## 小结\r\n\r\n今天学习到的内容还需要进一步的消化，我也是打算将并发编程这一块的内容熟悉透彻了再进行下一部分的课程学习。如果笔记中有错误的地方也希望掘友们可以及时的提出纠正。\r\n"
    },
    {
        "article_id": "7189802094713372730",
        "snapshot": "",
        "title": "借助 Elastic 8.6 版加速根本原因分析和缩短响应时间",
        "preview": "今天，我们很高兴地宣布，全球领先的搜索驱动型解决方案平台的最新版 Elastic 8.6 正式全面上线。 Elastic 8.6 版为 Elastic Search Platform 及其三个内置解决",
        "author": "Elasticsearch",
        "view_count": 804,
        "collect_count": 0,
        "comment_count": 0,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/3298f2149155cd4fce1f6942122778a3~300x300.image",
        "category": "后端",
        "content": "![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22619ede40444c6f9d18fafa66532a22~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n今天，我们很高兴地宣布，全球领先的搜索驱动型解决方案平台的最新版 Elastic 8.6 正式全面上线。\r\n\r\nElastic 8.6 版为 Elastic Search Platform 及其三个内置解决方案（Elastic 企业搜索、Elastic 可观测性和 Elastic 安全）引入了一系列新功能。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26962f9da3f64abdb21ab744cf80b19d~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n新增功能\r\n----\r\n\r\n[Elastic 企业搜索](https://www.elastic.co/cn/enterprise-search \\\"Elastic 企业搜索\\\")是通过 Elasticsearch 实现强大的现代搜索和发现体验的黄金标准，可让您随时随地搜索任何内容。\r\n\r\n*   在 Elastic 8.6 版中，Elastic 企业搜索引入了新的工具，可用于跨搜索索引实施和管理自然语言处理 (NLP)，既能加快创造价值的时间又能提高搜索结果的质量。此外，Elastic 8.6 版通过提供定制化筛选功能，让用户在从 MongoDB 采集数据时能够实施更多控制和精确度，并通过适用于网络驱动器的全新开源连接器，让整体采集的灵活性得到进一步提高。  \r\n      \r\n    [进一步了解](https://www.elastic.co/cn/blog/whats-new-elastic-enterprise-search-8-6-0 \\\"进一步了解 \\\") Elastic 8.6 版在哪些方面改进了 Elastic 企业搜索。\r\n\r\n[Elastic 可观测性](https://www.elastic.co/cn/observability \\\"Elastic 可观测性\\\")是部署最为广泛的解决方案，用于将指标、日志和痕迹转换为行之有效的 IT 见解，让您能够实现对整个数字生态系统的一体化可观测性。\r\n\r\n*   Elastic 8.6 版新增 OpsGenie 连接器，精简了 Elastic 可观测性通过告警工作流端到端管理事件的流程。此外，精心设计的新工作流可用于识别应用程序依赖项引起的性能或可用性问题，从而缩短根本原因分析的时间。  \r\n      \r\n    [进一步了解](https://www.elastic.co/cn/blog/whats-new-elastic-observability-8-6-0 \\\"进一步了解 \\\") Elastic 8.6 版在哪些方面改进了 Elastic 可观测性。\r\n\r\n[Elastic 安全](https://www.elastic.co/cn/security \\\"Elastic 安全\\\")集 SIEM、Endpoint Security 和云安全于一体，可帮助从业人员利用云技术所带来的规模快速防御、检测和应对威胁。\r\n\r\n*   在 Elastic 8.6 版中，Elastic 安全提高了调查效率并缩短了 SIEM、云端和终端之间的事件响应时间，从而增强勒索软件防护、改进分析师工作流和改善终端检测。  \r\n      \r\n    [进一步了解](https://www.elastic.co/cn/blog/whats-new-elastic-security-8-6-0 \\\"进一步了解 \\\") Elastic 8.6 版在哪些方面改进了 Elastic 安全。\r\n\r\nElastic 的搜索驱动型解决方案均基于一个统一的堆栈（即 [Elastic Stack](https://www.elastic.co/cn/elastic-stack?elektra=whats-new-elastic-8-4-0-blog \\\"Elastic Stack\\\")）构建而成，通过 [Elastic Cloud](https://www.elastic.co/cn/cloud/ \\\"Elastic Cloud\\\") 在 AWS、Microsoft Azure 和 Google Cloud 上以托管服务的形式提供。升级到 Elastic 8.6 版后，您将可以：\r\n\r\n*   **节省空间** — 这要归功于时间序列索引和新聚合带来的存储效率\r\n*   **缩短提供见解及解决问题的时间** — 这要得益于临时数据视图、新的（前面提到的）OpsGenie 连接器，以及大量告警和案例协作工作流的增强\r\n\r\n[进一步了解](https://www.elastic.co/cn/blog/whats-new-elasticsearch-kibana-cloud-8-6-0 \\\"进一步了解 \\\") Elastic 8.6 版在哪些方面改进了 Elastic Stack 和 Elastic Cloud。\r\n\r\n即刻体验\r\n----\r\n\r\n准备好开始体验了吗？将数据转化为行之有效的见解从未如此简单。Elastic 8.6 版现已[在 Elastic Cloud 上正式推出](https://cloud.elastic.co/registration?elektra=whats-new-elastic-8-6-0-blog \\\"在 Elastic Cloud 上正式推出\\\")，这是唯一一个在最新版中纳入所有新功能的托管型 Elasticsearch 服务。 \r\n\r\n_本博文所描述的任何特性或功能的发布及上市时间均由 Elastic 自行决定。当前尚未发布的任何功能或特性可能无法按时提供或根本不会提供。_"
    },
    {
        "article_id": "7187612956132606009",
        "snapshot": "",
        "title": "@所有青训营同学，快来领取你的专属徽章~",
        "preview": "青训营专属徽章已上线掘金社区，一份佩戴指南请注意查收哦~ 🔮 领取条件：报名第五届青训营活动且获得入营资格的同学",
        "author": "青训营官方账号",
        "view_count": 16965,
        "collect_count": 4,
        "comment_count": 39,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/de432cd6200bc3d3f7d633a3ccd528d8~300x300.image",
        "category": "阅读",
        "content": "# 🔮 一枚专属徽章\r\n\r\n🔔 青训营专属徽章已上线掘金社区，一份佩戴指南请注意查收哦~\r\n\r\n# 🔮 领取指南 - 掘金\r\n\r\n**领取条件：** 报名第五届青训营活动且获得入营资格的同学\r\n\r\n**注：** 领取的账号为报名青训营时的掘金账号哦~\r\n\r\n## **领取方式 - 掘金 Web 端**\r\n\r\n1.  浏览器打开掘金 https://juejin.cn\r\n2.  进入个人主页 - “获得徽章”\r\n3.  跳转掘金徽章墙，就可以自动触发徽章弹窗啦~\r\n\r\n![个人主页.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a878560230f4195a42a149aa6b02f02~tplv-k3u1fbpfcp-watermark.image?)![徽章列表.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f9c74d364348f7a974ae56b83ef3c1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## **领取方式 - **掘金 APP****\r\n\r\n1.  打开掘金 APP  [青训营专属渠道，点击下载掘金 APP](https://z.juejin.cn/tLEm?scheme=snssdk2606://?gd_label=click_schema_lhft_31972909a&needlaunchlog=1&schemeParams=%7B%22inviter_id%22%3A%223386151545092589%22%2C%22zlink_id%22%3A%22-%22%7D&schemeParams={\\\"inviter_id\\\":\\\"3386151545092589\\\",\\\"zlink_id\\\":\\\"tLEm\\\"})\r\n2.  进入个人主页 - “徽章”\r\n3.  跳转掘金徽章墙，就可以看到徽章啦~\r\n\r\n\r\n|  |  |  |\r\n| --- | --- | --- |\r\n| ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a14953530cb41caac925b57b75350b6~tplv-k3u1fbpfcp-watermark.image?) | ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3debe909bd7049389c43e69bf10bbad2~tplv-k3u1fbpfcp-watermark.image?) | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92e073336b284ff9a6e44e2f5f146551~tplv-k3u1fbpfcp-watermark.image?) |\r\n\r\n戴上徽章，创造属于你和青训营一起努力的记忆 💗\r\n\r\n# Q&A\r\n\r\n**Q：进入个人主页没有徽章怎么办？**  \r\n\r\n1.  先在[掘金](https://juejin.cn/)->我的报名检查是否有第五届青训营报名信息\r\n\r\n    a. 如没有，先回忆自己是否有其他掘金账号（更换登录方式）\r\n    b. 如有，直接看徽章部分，佩戴徽章\r\n\r\n2.  检查自己的账号有没有绑定手机号，确认有绑定手机号，接下来，查看自己的掘金 uid：（可打开掘金 - 个人主页获取，例如：个人主页链接为：\r\n[https://juejin.cn/user/3386151545092589](https://juejin.cn/user/3386151545092589) 则 uid 为 3386151545092589）\r\n\r\n3. 如果还是没有徽章，请填写青训营飞书群群公告中的问卷，我们会在3个工作日内处理~（未匹配到将不做处理）"
    },
    {
        "article_id": "7186577378439594043",
        "snapshot": "https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/677413dbef754887a6769295f471436e~tplv-k3u1fbpfcp-watermark.image?",
        "title": "到底什么样的 REST 才是最佳 REST？",
        "preview": "说起 REST API，小伙伴们多多少少都有听说过，但是如果让你详细介绍一下什么是 REST，估计会有很多人讲不出来，或者只讲出来其中一部分。 今天松哥就来和大家一起来聊一聊到底什么是 REST，顺便",
        "author": "江南一点雨",
        "view_count": 4759,
        "collect_count": 19,
        "comment_count": 1,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/36a25da34c9847b5a627cc949204f715~300x300.image",
        "category": "后端",
        "content": "说起 REST API，小伙伴们多多少少都有听说过，但是如果让你详细介绍一下什么是 REST，估计会有很多人讲不出来，或者只讲出来其中一部分。\r\n\r\n今天松哥就来和大家一起来聊一聊到底什么是 REST，顺便再来看下 Spring HATEOAS 的用法。\r\n\r\n## 1. REST 成熟模型\r\n\r\n首先关于 REST，有一个大佬 Leonard Richardson 为 REST 定义了一个成熟度模型，他一共定义了四个不同的层次，分别如下：\r\n\r\n1. Level0：Web 服务单纯的使用 HTTP 作为数据传输方式，本质上就是远程方法调用，常见的 SOAP 和 RPC 基本上都属于这一类。\r\n2. Level1：在这一级别上，引入了资源的概念，服务端的每一个资源，都有一个对应的操作地址。\r\n3. Level2：在这一级别上，我们引入了不同的 HTTP 请求方法来描述不同的操作，例如 GET 表示查询、POST 表示插入、PUT 表示更新、DELETE 表示删除，并且使用 HTTP 的状态码来表示不同的响应结果。一般来说，大家在日常的接口开发中，基本上都能做到这一层级。但是这还不是最佳结果。\r\n4. Level3：按照 Leonard Richardson 的意思，这一层级的 REST 基于 HATEOAS（Hypertext As The Engine Of Application State），在这一级别上，除了返回资源的 JSON 之外，还会额外返回一组 Link，这组 Link 描述了对于该资源可以做哪些操作，以及具体的该怎么做。\r\n\r\n在日常的开发中，我们一般都是只实现到 Level2 这一层级，真正做到 Level3 的估计很少，不过虽然在工作中一般不会做到 Level3 这一层级，但是，我相信很多小伙伴应该是见过 Level3 层级的 REST 是啥样子的，特别是看过 vhr 视频的小伙伴，松哥在其中讲过，通过 Spring Data Jpa+Spring Rest Repositories 实现的 CURD 接口，其实就是一个达到了 Level3 层级的 REST。\r\n\r\n## 2. Spring HATEOAS\r\n\r\n那么接下来我先用 Spring HATEOAS 写一个简单的 REST，然后结合这个案例来和小伙伴们聊一聊到底 Spring HATEOAS 有何不一样的地方。\r\n\r\n首先我们创建一个 Spring Boot 工程，引入 Web 和 Spring HATEOAS 依赖，如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40dcae46d56a4515a8afcb4ea898ba63~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n创建好之后，我们首先创建一个 User 实体类：\r\n\r\n```java\r\npublic class User extends RepresentationModel {\r\n    private Integer id;\r\n    private String username;\r\n    private String address;\r\n    //省略 getter/setter\r\n}\r\n```\r\n\r\n注意这个 User 实体类需要继承自 RepresentationModel，以方便后续添加不同的 Link（以前旧的版本需要继承自 ResourceSupport）。\r\n\r\n接下来写一个简单的测试接口。\r\n\r\n查询所有用户：\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\\\"/users\\\")\r\npublic class UserController {\r\n\r\n    @GetMapping\r\n    public CollectionModel<User> list() {\r\n        List<User> list = new ArrayList<>();\r\n        User u1 = new User();\r\n        u1.setId(1);\r\n        u1.setUsername(\\\"javaboy\\\");\r\n        u1.setAddress(\\\"www.javaboy.org\\\");\r\n        u1.add(WebMvcLinkBuilder.linkTo(UserController.class).slash(u1.getId()).withSelfRel());\r\n        list.add(u1);\r\n        User u2 = new User();\r\n        u2.setId(2);\r\n        u2.setUsername(\\\"itboy\\\");\r\n        u2.setAddress(\\\"www.itboyhub.com\\\");\r\n        u2.add(WebMvcLinkBuilder.linkTo(UserController.class).slash(u2.getId()).withSelfRel());\r\n        list.add(u2);\r\n        CollectionModel<User> users = CollectionModel.of(list);\r\n        users.add(WebMvcLinkBuilder.linkTo(UserController.class).withRel(\\\"users\\\"));\r\n        return users;\r\n    }\r\n}\r\n```\r\n\r\n关于这个接口，我来说几点：\r\n\r\n1. 首先，对于这种返回一个集合或者数组的情况，返回的类型都是 CollectionModel<User>。\r\n2. 把集合弄好之后（正常应该去数据库中查询，我这里省事直接创建了），通过 `CollectionModel.of(list)` 方法去获取一个 `CollectionModel<User>` 对象。\r\n3. 对于每一个 user 对象，我都添加了一个 Link 对象，`WebMvcLinkBuilder.linkTo(UserController.class).slash(u1.getId()).withSelfRel()` 表示生成当前对象的访问链接。\r\n4. `WebMvcLinkBuilder.linkTo(UserController.class).withRel(\\\"users\\\")` 表示访问所有数据的链接。\r\n\r\n好了，这个接口写完之后，我们访问看下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d6c91ce43a643fdb69f88c874c6e2d7~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n可以看到，返回的每一个 user 对象中，都有一个链接表示如何单独访问这个对象。最下面还有一个访问所有对象的链接。\r\n\r\n对于上面这个案例，可能有小伙伴会质疑，难道我们从数据库中查询出来的 List 集合都要遍历一遍，然后给每一个 User 添加一个 Link 吗？其实不必，添加 Link 这个事可以直接在 User 类中完成，如下：\r\n\r\n```java\r\npublic class User extends RepresentationModel {\r\n    private Integer id;\r\n    private String username;\r\n    private String address;\r\n\r\n    public User(Integer id) {\r\n        super(WebMvcLinkBuilder.linkTo(UserController.class).slash(id).withSelfRel());\r\n        this.id = id;\r\n    }\r\n    //省略 getter/setter\r\n}\r\n```\r\n\r\n可以看到，直接在构造方法中完成即可。此时接口里就不用那么复杂了，如下：\r\n\r\n```java\r\n@GetMapping\r\npublic CollectionModel<User> list() {\r\n    List<User> list = new ArrayList<>();\r\n    User u1 = new User(1);\r\n    u1.setUsername(\\\"javaboy\\\");\r\n    u1.setAddress(\\\"www.javaboy.org\\\");\r\n    list.add(u1);\r\n    User u2 = new User(2);\r\n    u2.setUsername(\\\"itboy\\\");\r\n    u2.setAddress(\\\"www.itboyhub.com\\\");\r\n    list.add(u2);\r\n    CollectionModel<User> users = CollectionModel.of(list);\r\n    users.add(WebMvcLinkBuilder.linkTo(UserController.class).withRel(\\\"users\\\"));\r\n    return users;\r\n}\r\n```\r\n\r\n那么对于根据 ID 来查询用户的需求，我们也应该给一个接口如下：\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\\\"/users\\\")\r\npublic class UserController {\r\n\r\n    @GetMapping(\\\"/{id}\\\")\r\n    public EntityModel<User> getOne(@PathVariable Integer id) throws NoSuchMethodException {\r\n        User u = new User(id);\r\n        u.setUsername(\\\"javaboy\\\");\r\n        u.setAddress(\\\"深圳\\\");\r\n        u.add(Link.of(\\\"http://localhost:8080/users/\\\"+id, \\\"getOne\\\"));\r\n        Link users = WebMvcLinkBuilder.linkTo(UserController.class).withRel(\\\"users\\\");\r\n        u.add(users);\r\n        Link link = WebMvcLinkBuilder.linkTo(UserController.class).slash(u.getId()).withSelfRel();\r\n        u.add(link);\r\n        Method method = UserController.class.getMethod(\\\"getOne\\\", Integer.class);\r\n        Link link2 = WebMvcLinkBuilder.linkTo(method, id).withSelfRel();\r\n        u.add(link2);\r\n        return EntityModel.of(u);\r\n    }\r\n}\r\n```\r\n\r\n关于这个接口，我说如下几点：\r\n\r\n1. 如果返回类型是一个对象的话，需要使用 `EntityModel<User>` 类型。\r\n2. 搞好返回的对象之后，通过 `EntityModel.of(u)` 方法可以获取到目标数据类型。\r\n3. 这个地方，为了给小伙伴们演示不同的 Link 添加方式，我写了好多个（单纯为了演示不同的 Link 添加方式）：\r\n    1. `Link.of(\\\"http://localhost:8080/users/\\\"+id, \\\"getOne\\\")` 这种是自己纯手工去生成当前对象的访问链接，很明显这不是一个很好的方案。当前对象的访问链接建议使用上文中提到的方式。\r\n    2. `WebMvcLinkBuilder.linkTo(UserController.class).withRel(\\\"users\\\")` 这个是生成当前这个 Controller 的访问链接，一般就是访问所有用户对象的链接。\r\n    3. `WebMvcLinkBuilder.linkTo(UserController.class).slash(u.getId()).withSelfRel()` 前文已经用过了，不多说了，实际应用中建议使用这种。\r\n    4. 也可以根据某一个方法自动生成，像这样 `WebMvcLinkBuilder.linkTo(method, id).withSelfRel()`，这个是生成某一个具体方法的访问链接。\r\n\r\n好了，现在我们来看下这个接口生成的 JSON，如下：\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49d131ae6da04d36a419c8b99eece78c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n生成的这段 JSON 我将之标记为了三部分：\r\n\r\n1. 第一部分，self，就是自身的访问链接，这三个链接分别是 User 的构造方法，以及前面提到的 3.3 和 3.4 的方法生成的。\r\n2. 第二部分，getOne 这个，是前面 3.1 中提到的方法生成的。\r\n3. 第三部分，users 这个，是前面提到的 3.2 方法生成的。\r\n\r\n当然，其实这块还有很多其他的生成链接的玩法，但是我就不一一介绍了，小伙伴们可以参考官方文档：\r\n\r\n- [https://docs.spring.io/spring-hateoas/docs/current/reference/html](https://docs.spring.io/spring-hateoas/docs/current/reference/html)\r\n\r\n从上面 Spring HATEOAS 中返回的 JSON 我们大致上可以看到它的特点：\r\n\r\n> 当我们使用了 Spring HATEOAS，此时，客户端就会通过服务端返回的 Link Rel 来获取请求的 URI（如果没有使用 Spring HATEOAS，则客户端访问的 URI 都是提前在客户端硬编码的），现在我们就可以做到服务端在不破坏客户端实现的情况下动态的完成 URI 的修改，从而进一步解耦客户端和服务端。\r\n\r\n简而言之，现在客户端能干什么事情，在服务端返回的 JSON 中都会告诉客户端，客户端从服务端返回的 JSON 中获取到请求的 URL，然后直接执行即可。如果这个请求地址发生变化的话，客户端也会及时拿到最新的地址。\r\n\r\n可能上面的例子小伙伴们感受还不是很明显，我再给大家看一段 JSON：\r\n\r\n```json\r\n{\r\n    \\\"tracking_id\\\": \\\"666\\\",\r\n    \\\"status\\\": \\\"WAIT_PAYMENT\\\",\r\n    \\\"items\\\": [\r\n        {\r\n            \\\"name\\\": \\\"book\\\",\r\n            \\\"quantity\\\": 1\r\n        }\r\n    ],\r\n    \\\"_Links\\\": {\r\n        \\\"self\\\": {\r\n            \\\"href\\\": \\\"http://localhost:8080/orders/666\\\"\r\n        },\r\n        \\\"cancel\\\": {\r\n            \\\"href\\\": \\\"http://localhost:8080/orders/666\\\"\r\n        },\r\n        \\\"payment\\\": {\r\n            \\\"href\\\": \\\"http://localhost:8080/orders/666/payments\\\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这是电商系统下单之后等待支付的过程中返回的 JSON，这里的 links 给出了三个：\r\n\r\n- self：访问这个链接可以查看当前订单信息（GET 请求）。\r\n- cancel：访问这个链接可以取消当前订单（DELETE 请求）。\r\n- payment：访问这个链接可以支付当前订单（POST 请求）。\r\n\r\n这个例子就很直白了，就是在返回的 JSON 中，直接告诉你接下来能做哪些操作，对应的 URL 分别是什么，前端拿到之后直接操作，如果这些操作路径发生了变化，前端也会立马拿到最新的路径。\r\n\r\n这就是 Spring HATEOAS 的好处。总之一句话，Spring HATEOAS 提倡在响应返回的 Link 中给出对该资源接下来操作的 URL。这种方式解耦了服务端 URI，也可以让客户端开发者更容易地探索 API。\r\n\r\n\r\n## 3. REST 的优缺点\r\n\r\n虽然我们现在都鼓励设计 REST 风格的 API，然而 REST 也不全是优点，事物总是具有两面性，REST 的优缺点分别如下。\r\n\r\n### 3.1 优点\r\n\r\n1. 首先，REST 足够简单，有一定 Web 开发经验的小伙伴都可以快速上手 REST。\r\n2. REST 风格的接口测试起来也非常方便，利用浏览器自带的一些 REST 插件或者是 POSTMAN 之类的工具，就可以非常方便的实现 REST 接口的测试。\r\n3. 不需要中间代理，简化了系统的结构。\r\n4. HTTP 对防火墙比较友好。\r\n\r\n### 3.2 缺点\r\n\r\n1. REST 只支持**请求-响应**的通信方法，不支持服务端推送消息到客户端。\r\n2. 给请求取一个合适的名字比较困难，特别是有多个相类似的接口时，例如有多个添加接口、多个更新接口等。\r\n3. 由于没有中间代理，所以请求/响应的时候，服务端和客户端都必须在线。\r\n\r\n好啦，跟小伙伴们聊了 REST 和 Spring HATEOAS，感兴趣的小伙伴可以去试试哦～"
    },
    {
        "article_id": "7189059869020782651",
        "snapshot": "https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b38b95bf07834c0f8aa8b1321c29252f~tplv-k3u1fbpfcp-watermark.image?",
        "title": "🔥MySQL逻辑删除＋Mybatis-Plus = 墙裂推荐！",
        "preview": "讲解了逻辑删除的概念和理解，并给出了使用Mybatis-Plus过渡到逻辑删除的操作方案。90%的公司都在使用的逻辑删除，当搭配上Mybatis-Plus，写代码时将几乎无感，轻松的一匹！",
        "author": "阿杆",
        "view_count": 1422,
        "collect_count": 14,
        "comment_count": 4,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/de3dfdc0012f9090816782278813f241~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: devui-blue\r\nhighlight: agate\r\n---\r\n\r\n\r\n# 前言\r\n\r\n一般情况下，我们要删除一条数据，直接使用 delete 即可，就像这样：`delete from user where id = 1`，这样做的好处是：\r\n\r\n- 符合我们的理解，删除就是直接删掉嘛。\r\n- 节省数据库空间，某些情况下数据量较大，且新增和删除比较频繁时，delete可以帮我们回收很多的空间。\r\n\r\n但我今天想讲的是逻辑删除，那什么是逻辑删除呢？\r\n\r\n# 逻辑删除\r\n\r\n逻辑删除就是给数据表添加一个固定字段，用该字段的值来表示这条数据当前是否被删除，并把 delete 操作修改为 update 操作。\r\n\r\n比如，在我的项目中某些表会有一个固定的 `deleted` 字段，该字段是 `tinyint` 型的，其取值只有 0 和 1 两种，0表示这条数据未删除，1表示已删除，默认值为 0。\r\n\r\n当我要删除某条数据时，我会将这条数据的 `deleted` 值置为 1，而不会使用 delete 去真正的把它删掉。同时，我的所有 insert 语句和 update 语句都会带上一个固定的条件 `deleted = 0` ，来过滤掉所有在逻辑上被删除的数据。\r\n\r\n> 阿里巴巴Java编码规约提出：POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\r\n> \r\n> 我原来是用的 `is_deleted`，现已全部更改为了 `deleted`。\r\n\r\n![image-20230114151004431](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b872325cde4d27a2285c24eed798d1~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n<p align=center>△图 / 校园博客用户表数据</p>\r\n\r\n\r\n同样的，也来讲讲这样做的好处：\r\n\r\n- 方便数据恢复，保护数据本身的价值。\r\n- 保证数据连续性，对主键的影响可能会导致底层B+树重建，而 delete 和 update id 都会影响主键。\r\n\r\n事实上，在大多数公司里，都会采用逻辑删除的方式，因为数据的价值更大，被删除的数据也非常有记录价值，这样的操作也并不会提高太多的操作难度。\r\n\r\n# 使用Mybatis-Plus逻辑删除\r\n\r\n如果你的项目使用的是Mybatis-Plus框架来操作数据库，那你可以通过下面几个步骤快速的转变到逻辑删除模式。\r\n\r\n1. 在MySQL中给那些要改为逻辑删除的表添加一个 `deleted` 字段，当然也可以叫 `flag` 或者是别的名字，只要你喜欢就好。类型 `tinyint` 就够了，默认值最好也设置一下。\r\n\r\n   ```sql\r\n   -- 你也可以直接使用这条修改语句，记得把表名进行替换\r\n   ALTER TABLE user ADD `deleted` tinyint UNSIGNED NOT NULL DEFAULT 0 COMMENT '0为未删除，1为已删除';\r\n   ```\r\n\r\n2. 在你的Java代码中给刚刚修改过的表的实体类添加对应的属性：\r\n\r\n   ```java\r\n   public class User {\r\n   \\t// 添加isDeleted字段\r\n       Integer isDeleted;\r\n   }\r\n   ```\r\n\r\n3. 在项目的配置文件（application.yml）当中添加对应的配置：\r\n\r\n   ```yml\r\n   mybatis-plus:\r\n     global-config:\r\n       db-config:\r\n         logic-delete-field: isDeleted # 全局逻辑删除的实体字段名\r\n         logic-delete-value: 1 # 逻辑已删除值(默认为 1)\r\n         logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\r\n   ```\r\n\r\n4. 如果你的Mybatis-Plus版本在 3.3.0 以下，那你还需要在实体类的字段上添加 `@TableLogic` 注解：\r\n\r\n   ```java\r\n   @TableLogic\r\n   Integer isDeleted;\r\n   ```\r\n\r\n5. 如果你的项目中有通过xml或者`@Update`、`@Select`等注解编写的SQL语句，那你需要自己对他们进行调整：\r\n\r\n   - 将原有的 delete 语句统一修改为 update\r\n   - 将原有的 select、update 语句都加一个过滤条件 `deleted = 0`\r\n   - insert 语句，如果你在表上设置了默认值的话，则可以不用管它。如果你没有设置默认值，那我建议你还是设置一下😎。\r\n\r\n好了就这么简单，你甚至不需要修改你的业务代码，因为Mybatis-Plus已经帮你处理好了。\r\n\r\n## 它做了什么\r\n\r\n- 当你调用`userMapper.deleteById(1)`的时候，实际上传到MySQL的代码是这样的：\r\n\r\n  ```sql\r\n  update user set deleted = 1 where id = 1 and deleted = 0\r\n  ```\r\n\r\n- 当你通过`QueryWrapper`查询数据或者通过 `UpdateWrapper` 更新数据的时候，它也会自动帮你添加过滤条件：\r\n\r\n  ```sql\r\n  select * from user where deleted = 0\r\n  ```\r\n\r\n- 但如果你是在xml中直接写的SQL语句，那它是不会帮你进行修改的，比如我写的SQL是这样的：\r\n\r\n  ```xml\r\n  <update id=\\\"deleteById\\\">\r\n      update user\r\n      set deleted = ${id}\r\n      where id = ${id}\r\n  </update>\r\n  ```\r\n  \r\n  执行出来的SQL是这样的：\r\n\r\n  ![image-20230114215203805](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7baead53f9be425aae5dca46c58940e2~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n  **很显然它并没有帮我加上 `deleted = 0` ，这是使用者需要注意的。**\r\n\r\n当然我只是简单的对Mybatis-Plus的逻辑删除功能用法进行了简单讲解，如果你需要的话，也可以参考一下官方文档的说明：[逻辑删除 | MyBatis-Plus (baomidou.com)](https://baomidou.com/pages/6b03c5/) （虽然它写的也比较简洁👨‍💻）\r\n\r\n# 注意\r\n\r\n虽然把项目过渡到逻辑删除并不太费事，但它也有一些其他需要注意的点。\r\n\r\n\r\n\r\n首先是**使用理念**上，我这里直接引用 Mybatis-Plus 的说法：\r\n\r\n- 逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。\r\n- 如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。\r\n\r\n\r\n\r\n其次是**使用逻辑**上，对于MySQL而言，逻辑删除会导致唯一索引（UNIQUE KEY）的异常。\r\n\r\n- 原因很简单，已经删除的数据仍然存在，当再次插入一条同样的数据时，就会抛出异常。\r\n\r\n- 比如在我的 user 表中 username 字段设置了 UNIQUE KEY ，我先插入一条`username = 阿杆`的数据，再把这条数据逻辑删除掉，然后再重新插入一条`username = 阿杆`的数据。\r\n\r\n  那么理论上来说此时是应该允许插入的，但由于我使用了逻辑删除，MySQL不允许存在两条数据出现同样的 `username = 阿杆`的场景，此时就出现了异常。\r\n  \r\n- 当然，逻辑删除与唯一索引的冲突是可以解决的，解决方案也不难。\r\n\r\n  我们可以在原来的唯一索引里加上`deleted`字段，同时再删除数据的时候把`deleted`修改为表id，这样就可以保证未删除的数据不会出现重复值了，而且不会受到已删除数据的影响。但你要记得重写SQL方法，不然Mybatis-Plus还是会帮你修改为配置文件里的那个默认值。\r\n\r\n  ```sql\r\n  UNIQUE KEY `username` (`username`,`deleted`) USING BTREE\r\n  ```\r\n\r\n  方案不唯一，你也可以用别的方法，或者在这张表上不使用逻辑删除，毕竟，没有最好的，只有最合适的。\r\n\r\n\r\n\r\n# 写在后面的一些话\r\n\r\n本文是我在使用Mybatis-Plus将项目过渡到逻辑删除时写的，也算是刚接触逻辑删除这个东西，可能会有一些考虑不周全的地方，希望各位大佬在评论区提出。\r\n\r\n另外，如果你想找一个项目参考一下逻辑删除的具体代码或者过渡方案，可以来看看我的[校园博客](https://github.com/stick-i/scblogs)项目，也可以看看我过渡时修改的代码，这几个PR就是我修改的全部代码了：\r\n\r\n- 大部分修改的内容：[Dev 126 数据库表结构优化 by stick-i · Pull Request #132 · stick-i/scblogs (github.com)](https://github.com/stick-i/scblogs/pull/132)\r\n- 与业务代码有关的bug：[chore: 给user_view添加is_deleted字段（由于其继承自user表） by stick-i · Pull Request #133 · stick-i/scblogs (github.com)](https://github.com/stick-i/scblogs/pull/133)\r\n- 唯一索引与逻辑删除造成异常的解决：[fix: 处理user表和user_safety表的唯一索引和逻辑删除造成的冲突。 by stick-i · Pull Request #134 · stick-i/scblogs (github.com)](https://github.com/stick-i/scblogs/pull/134)\r\n\r\n也欢迎大家来参与项目贡献或者star😋，项目地址：[https://github.com/stick-i/scblogs](https://github.com/stick-i/scblogs)\r\n\r\n![6f88c1e56daebed179cbf337712b611b](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/438f7722b9c6497d8d85ebb41457899a~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n"
    },
    {
        "article_id": "7188126727443316773",
        "snapshot": "",
        "title": "韭菜的自我修养：一番折腾，90%工资用于还债，完全陷入中年危机 | 2022年终总结",
        "preview": "为了对抗中年危机，越是挣扎，仿佛陷得越深。工作上，年终奖缩水，升值加薪无望；债务上，房贷、消费贷、信用卡分期等等，吞噬掉了大部分工资收入。是就此躺平，还是总结经验教训，调整策略，再次出发？",
        "author": "布拉德特皮",
        "view_count": 1992,
        "collect_count": 2,
        "comment_count": 14,
        "avatar": "https://p6-passport.byteacctimg.com/img/user-avatar/f73f47f33309ce895cfe3f5a22559bb9~300x300.image",
        "category": "阅读",
        "content": "---\r\ntheme: channing-cyan\r\n---\r\n\r\n## 前言\r\n“你不理财，财不理你”，随着知识付费的热度上升，这句话逐渐普及开来。但事实上，疫情这三年，不理财，已经跑赢了 80% 的人。\r\n\r\n看视频、读著作，作为开发者，我可以写出高内聚、低耦合的代码，但是作为投资者，我只是众多韭菜中的一茬。\r\n\r\n下面，我用一些亲身经历，来复盘一下去年走过的弯路，也给大家提供参考。\r\n\r\n## 关于职场\r\n2021年初，一次极限操作，【在线教育】暴雷前夕，跳槽到了现在的公司。放弃了高薪，接受了稳定。\r\n\r\n公司很大，金融翘楚，世界500强；职位很小，总部某个小部门里的前端负责人。\r\n\r\n因为疫情，公司营收同比大跌，故开启了“降本增效”模式，削减人力、福利的同时，工作量还略有增加。\r\n\r\n### 1. 裁员\r\n去年公司裁了很多人，我们的业务线因为比较重要，且业务需求一直很多，故没有列入名单，只是象征性的裁了2个外包。\r\n\r\n但其他子公司就没这么好运了，整条线都裁掉的比比皆是。\r\n\r\n听说去年的预算又缩减了，估计还会继续裁员，早做准备吧，实在不行就找个海外的远程工作。\r\n\r\n### 2. 加班\r\n领导一直说我管理很佛系，事实上，我没法对组员要求什么，他们不爽可以随时离职，只会徒增项目难度。\r\n所以我一直跟组员们强调，当天任务做完了，就回家，没必要在这耗着，甚至为了消除顾虑，还主动提示新同事快点下班，并以身作则，几乎不加班。\r\n\r\n对于组员摸鱼，我也是睁一只眼闭一只眼，请假秒批，只要他能完成任务，我不关心过程如何。\r\n正是这种管理风格，组员们很信任我，工作按时完成，甚至遇到紧急需求，也会主动加班，对比后端组，前端组无论是人员稳定性还是响应时效性，都略胜一筹。\r\n\r\n但，领导不喜欢。\r\n\r\n领导属于那种比较卷的类型，经常加班到 9 点后，而我们前端组离领导工位很近，所以经常出现后端组在加班，而前端组空无一人。\r\n\r\n还避免不了被说闲话。\r\n\r\n所以，我经常被领导各种“说教”，表面“啊对对对”，独自扛下了所有，然后坚决不改。\r\n\r\n### 3. 绩效\r\n第一年，新人进来背绩效，能理解，如今已是第二年了，作为前端负责人，去年承接了 6 个其他组丢过来的代码库，还大胆使用了 Vue3 技术重构，并带领组员技术升级，结果还是拿着和去年一样的评分，就因为我们前端组加班少。\r\n\r\n「过程比结果重要」，似乎是大公司的潜规则呢。\r\n\r\n也许有了孩子后，会爱上加班吧，但是目前的状态下，还是早点回家，鼓捣一些自己的事情，提升认知，也比牺牲健康，无效加班，然后多那 1~2 个月的年终奖，要划算很多。\r\n\r\n## 关于理财\r\n为了财富自由，每人都应该努力打造三份收入：\r\n- 工作收入，作为原始资本积累；\r\n- 边际成本为 0 的杠杆收入，如出书、发布视频、编写程序等，作为财富裂变的关键收入；\r\n- 资本收入，来源于各种投资的收益；\r\n\r\n绝大多数人只有工作收入，无论是主业还是兼职，只能单纯的出卖时间，杠杆率太低，并且面临大龄被优化的风险。\r\n\r\n第二、第三收入属于被动收入，一份时间，可以被出售很多次，即使在睡觉，也有源源不断的收入，又称为「睡后收入」，所以应该尽量扩大这部分的比例。\r\n\r\n以下就是我在知行合一过程中交的学费和心得：\r\n\r\n### 1. 公寓\r\n\r\n**千万不要买公寓！千万不要买公寓！千万不要买公寓！重要的事情说三遍，尤其是带返租的公寓！**\r\n\r\n去年是房地产集体暴雷的一年，之前各公司为了提高资金周转率，研发了各种庞氏骗局，返租公寓就是其一。\r\n\r\n其运作模式为：先以较低的总价（通常是周边商品房1/3的价格）吸引客户，配合「低首付政策」，让「韭菜」觉得几万块就能拿\r\n\r\n下一套地铁口附近的“高端”公寓。然后再许诺交楼后，用高于附近 30%~50% 的租金，再租下公寓，按季或者更长的周期，将房租打到卡上。\r\n\r\n而我负债的 50%，都是因为买了这套公寓……踩的坑分别为：\r\n1. 低首付并不低：根据政策，公寓属于商业房产，需要 50% 的首付率，故开发商可以安排第三方贷款公司，将 40% 的款项以「不记录征信」的方式贷给韭菜，通常是2-3年期，年化单利 5% 左右，到期一次性本息付清。所以可以做到首付 10%，拿下公寓。重点来了，**如果你在约定的交楼时间，还没有还清这笔贷款，开发商就不会安排交楼程序，也就拿不到房产证。**\r\n2. 房贷利率高：不要相信中介说的什么和四大行有合作，能拿到 5% 左右的利率，事实上，**他只会把你引到能吃回扣的银行，而我的利率是 6.15%，10年。**\r\n3. 交楼周期长：开发商通常提前 2 年开始卖楼花，如果这套公寓是拿来出租的，那么算上装修，就会有 2 年多的空窗期，但贷款是按照合同签约开始计算利息。**扣除月供，实际上前 5 年基本不赚钱。**\r\n4. 租赁方不靠谱：**酒店返租，其实就是开发商注册的一个皮包公司，通常在交楼前几个月成立，然后需要韭菜先交几万块的装修费，美其名曰统一风格**， 这装修费基本需要租 1 年才回本，又是一把好镰刀啊。而且这种酒店，故意拖长租金给付周期，相当于支付了很少的利息，就拿到了一大笔资金，属于“高息”揽储了。**并且通常在 3~5 年内就会宣布破产**，长期合作？不存在的，都宣布破产了，租赁合同自然也就失效了。\r\n5. 羊毛出在羊身上：**哪有什么返租，只不过是把他们未来支付的房租，算在了总房价里**，并且租赁方可以随时申请破产，玩的就是高息揽储的庞氏骗局。如果真心喜欢公寓，就直接买那种不返租的，或者二手市场看看，总价比返租的低的不是一星半点。\r\n6. 有能力最好开车去：如果只是市内还好，就怕远郊、跨市那种，中介虽然说免费接送，但基本每个楼盘要待够 1~2 个小时，不然他们没法报销油费，**且如果你全程下来都不买，那可能会做出把你扔在半路的举动。** 要是自己开车，时间上，自己完全掌握主动权，**看到不满意的项目，根本无需废话，直接走人。**\r\n\r\n我买的是二线城市的公寓，虽然在地铁口，但离市中心很远，21年7月 签的合同，合同约定 22年12月31日 交楼，但是「首付贷」不还清，就无法办理交楼，于是我又从其他消费贷弄出了资金，来还「首付贷」。\r\n\r\n庆幸的是，在酒店给我打电话，表示想租我的公寓，提出了装修费方案时，我果断的拒绝了，因为已从其他渠道，了解到了返租模式核心玩法。\r\n\r\n哪有租房还要房东自己付装修费的道理，蛋壳都没这么狠。\r\n\r\n后面，专门就这件事请教了老丈人（在商界混迹多年），他给的建议是：**尽快出手，赔本也要出手，及时止损，因为这些贷款还会继续吞噬现金流，而收益又如此的低。**\r\n\r\n公寓不是散户能玩的，能在上面赚钱的，只有规模到了一定程度才可以。因为这间房可以租低点，那间房可以租高点，这样能保证总体收益大差不差。\r\n\r\n如果只有一间，租户遇到点问题，可能要请假专门处理，即使是开车，也会花费大量的时间成本。\r\n\r\n如果我没有买这套公寓，我的人生会宽敞许多吧（可能）。\r\n\r\n### 2. 币圈\r\n\r\n**绝大部分虚拟币没有任何价值，但是会加速镰刀挥舞的速度。**\r\n\r\n之前「狗屎币」（DOGE、SHIB）大热的时候，赚了1000% 多，但钱来得快，去的也快，后面又投了一些山寨币，基本把盈利赔光，尤其是 KISHU，亏掉了80%的利润。\r\n\r\n2021年5月，随着一系列的文件出台，导致虚拟币市值大跌，即使后面转了主流币，还是把本金赔掉了70%。\r\n\r\n最近 LUNA 币和 FTX 交易所相继暴雷，市场对币圈的信心已经降到了冰点，BTC 更是从最高点，缩水了2/3，更别提其他山寨币了。很多号称有项目、技术支撑的山寨币，沦为了彻头彻尾的骗局。\r\n\r\n**靠运气赚的钱，迟早在认知外连本带利的赔掉。**\r\n\r\n### 3. 股票\r\n**买股票就是买公司。**--- 段永平\r\n\r\n什么老鼠仓、抬轿子，经历了币圈的大起大落，A股那点伎俩也不算什么了。\r\n\r\n无论是A股还是港股，我的个股只买“大白马”，减少交易频率，长期持有，分红再投资，相信复利的奇迹。\r\n\r\n**分红再投资，是熊市的保护伞，牛市的加速器**---《投资者的未来》\r\n\r\n这也是我去年唯数不多挣钱的项目了，连续七年收益率超过7%，平均年化11%左右。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2822da825aad4c5da148691e2f5c9a03~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"width:300px\\\" />\r\n\r\n如果当时那笔钱，没有买公寓，而是买了房地产龙头股，持有到现在，早就回本了。\r\n\r\n### 4. 基金\r\n关于基金，巴老爷子说过：以绝大多数基金经理的投资收益率，连大盘都跑不赢。\r\n\r\n所以，我也只是定投指数基金，只是由于负债率比较高，暂停了几个策略，只保留了沪深300。\r\n\r\n大盘还是3000点附近徘徊，所以，去年基金整体并没有挣钱。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72857dccc79d4352a3ae961271f0cb79~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"width:300px\\\" />\r\n\r\n### 5. 车子\r\n为了方便提亲、扩宽视野、体验新能源和新技术，去年年初趁着特斯拉涨价前，购入了 Model Y，后面涨到最高点的时候还庆幸买的早，省了好几万，结果前不久就来了背刺，现在比当时还便宜了 2~3 万……\r\n\r\n车这个玩意，尤其是纯电车，看似省了油费，实际上，一年的用车成本还真不一定比油车便宜。\r\n\r\n第一年车险 9600 元/年，小区停车位 300 元/月，也就是，这车即使不开，固定成本约为 36.16 元/天，为啥保险那么贵？因为是尊贵的特斯拉车主（韭菜）啊！！\r\n\r\n如果开车的话，因为停车位没法自己装充电桩，只能用第三方的，平均 1.5元/度，外出的停车费、高速费，按一年5000公里算，用车成本基本在 16000~20000 元（罚单就另算了）。\r\n\r\n如果现金流不充裕，又是程序员这种不怎么吃资源的岗位的话，真心不建议在一线城市买车，除非有其他必须的理由（比如提亲）。\r\n\r\n### 6. 其他\r\n因为平时喜欢玩游戏，偶然间发现有款游戏饰品也能租赁（没错，就是CS:GO），于是在去年6月的时候，砸了约 10万，收购各种刀 和枪皮，后面（10月）涨得太凶了，稍微减仓了一些，把那种冷门刀都卖了，主要留下了蝴蝶刀和爪子刀（有把「M9刺刀-渐变大理石」和「蝴蝶刀-虎牙」在续租期间，被买断了，心痛了好久）。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b33192298741457186f91b98079e4c6e~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"width:300px\\\" />\r\n\r\n如果不算饰品本身的涨幅，光是租金，近似年化收益率都达到了10%左右。这些租金又被拿去买饰品，算是分红再投资吧。\r\n\r\n<img src=\\\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346f9fc8da234e1baeaedfdca03c286f~tplv-k3u1fbpfcp-zoom-1.image\\\" style=\\\"width:300px\\\" />\r\n只是后面知道的人越来越多，都想当包租公，大资本也有意搞垄断，饰品涨得狠凶（热门皮肤涨幅高达50%~500%），拉低了租金平均收益率。\r\n\r\n投资就是这样，先入场的能吃肉，后面的就只能喝汤了。\r\n\r\n值得一提的是，当年和大学室友怎么都冲不上去的官匹AK段位，在元旦的时候，不经意间冲上去了（多亏了一年来在完美C+被反复蹂躏）。\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6725278a03d4dc482fc62fa4d79a205~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 关于婚姻\r\n\r\n**人生只有三次改变命运的机会，第一次是高考，第二次是就业，第三次是婚姻。**\r\n\r\n重要性依次增加，前者的努力影响后者选择范围，**而后者如果没选好的话，又能反过来否定之前的努力**。\r\n\r\n而婚姻，本质上就是合伙开公司，是两个家庭的资源重组，所以「门当户对」是有一定的道理的。\r\n\r\n如果是自由恋爱，顺其自然的步入婚姻殿堂，这自然是最完美的结局。\r\n\r\n但如果是相亲，无论是网上还是线下，都要慎重选择，**毕竟这是要过一辈子的人，能一命通关的就尽量不要二婚重开吧**。\r\n\r\n我和老婆是在以前的公司认识的，她产品，我开发，之前真没想到过会在一起，毕竟是司花。\r\n\r\n后面需求对接多了，我的一些特性也吸引了她的注意，加上偶尔私下帮她改需求，越走越近，只是碍于公司环境，没有点破。\r\n\r\n离职后没了顾虑，才确认了关系，经过两年多的磨合，今年总算领证了。\r\n\r\n婚姻要互相包容，比如她喜欢出去玩，我喜欢当宅男，所以妥协后就是：平时她不管我玩游戏，每半个月市内约会一次（我和她的公司都是大小周），每两个月来一次短途旅行，每半年来一次长途旅行。\r\n\r\n**要想找到一个优秀的配偶，最好的方式就是让自己配得上Ta**---查理·芒格\r\n\r\n## 写在最后\r\n\r\n经过去年的一顿骚操作，负债组合为：深圳房贷+公寓商贷+消费贷+信用卡分期，月供高达工资的90%，加上其他生活支出，经常处于极度焦虑中，失眠是常态。\r\n\r\n最贵的学费莫过于买公寓了，还是在房价最高的时候上车的！\r\n\r\n要不是还有第二、第三收入，以及老婆也帮分担了一些，估计都要申请个人破产了。\r\n\r\n好在这些债务大部分都是短期的，咬咬牙撑过去也就是了，只能说现在吃亏，也好过老了之后被骗养老金要强。\r\n\r\n**欲买桂花同载酒，终不似，少年游。**\r\n\r\n「回顾2022，展望2023，我正在参与[2022年终总结征文大赛活动](https://juejin.cn/post/7172462429929111559)」\r\n"
    },
    {
        "article_id": "7146055238741393415",
        "snapshot": "",
        "title": "我又听到有人说：主要原因是人不行",
        "preview": "曾经有UI同事指着我的鼻子说，你们没有把设计稿百分百还原，是因为你们人不行。 昨天，我又听到一个研发经理朋友说，唉呀，项目干不好，主要是人不行。 哦，我听到这里，有似曾相识的感觉……",
        "author": "TF男孩",
        "view_count": 29410,
        "collect_count": 223,
        "comment_count": 183,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/16beff45c6c05f565b9d0663170a918b~300x300.image",
        "category": "代码人生",
        "content": "---\r\ntheme: juejin\r\n---\r\n\r\n\r\n> 在工作中，我们经常把很多问题的原因都归结为三个字：人不行。\r\n\r\n曾经有UI同事指着我的鼻子说，你们没有把设计稿百分百还原，是因为你们**人不行**。\r\n\r\n昨天，我又听到一个研发经理朋友说，唉呀，项目干不好，主要是**人不行**。\r\n\r\n哦，我听到这里，有种似曾相识的感觉，于是我详细问了一下，你的人哪个地方不行。\r\n\r\n> 朋友说，项目上线那天晚上，他们居然不主动留下来值班，下班就走了，自觉意识太差。代码写的很乱，不自测就发到生产环境，一点行业规范都没有。他们……还……反正就是，能不干就不干，能偷懒就偷懒，人不行！\r\n\r\n这个朋友，代码写的很好，人品也很好，刚刚当上管理岗，我也没有劝他，因为我知道，劝他没用，反而会激怒他。\r\n\r\n当一个人，代码写得好，人品好，他就会以为别人也和他一样。他的管理方式就会是：**大家一定要像我这样自觉，不自觉我就生闷气了！**\r\n\r\n反而，当一个人代码写得差，自觉性不那么强，如果凑巧还有点自知之明，那么因为他很清楚自己是如何糊弄的，因此他才会考虑如何通过管理的方法去促成目标。\r\n\r\n我的这些认知，满是血泪史。因为我就经历过了“好人”变“差人”的过程。\r\n\r\n因为代码写得好，几乎在每一个公司，干上一段时间，领导都会让我做管理，这在IT行业，叫：**码而优则仕**！\r\n\r\n做管理以后，我就发现，并不是所有人都像我一样，也并不是各个部门都各司其职，所谓课程上学的项目流程，只存在于理想状态下。当然，其中原因非常复杂，并不一定就是人不行，也可能是流程制度有问题。比如我上面的朋友，他就没有安排上线必须留人，留什么人，留到几点，什么时候开始，什么标准算是上线完成，完成之后有什么小奖励，这些他都没有强调和干预。\r\n\r\n但是，我们无法活在理想中。不能说产品经理的原型逻辑性差，UI的设计稿歪七扭八，我们就建议老板把公司解散吧，你这个公司不适合做软件产品，那样我们就失业了。\r\n\r\n你只能是就目前遇到的问题，结合目前手头的仅有的仨瓜俩枣，想办法去解决。可能有些方案不符合常规的思路，但都是解决实际问题特意设置的。\r\n\r\n比如我在项目实践中，经常遇到的一点：\r\n\r\n> 产品经理没有把原型梳理明白，就拿出来给开发人员看，导致浪费大家的时间，同时也打击大家的积极性：这样就开始了，这项目能好的了吗？我们也做不完就交给测试！\r\n\r\n这种情况，一般我都会提前和产品经理沟通，我先预审，我这关过了，再交给开发看，起码保证不会离大谱。这里面有一个点，产品没有干好自己的活，人不行？他也只有3天时间设计原型。\r\n\r\n还有一个问题也经常出现：\r\n\r\n> 即便是产品原型还算可以，评审也过了。让开发人员看原型，他们没有看的。一直到开发了，自己的模块发现了问题，然后开始吐槽产品经理设计的太烂，流程走不通。\r\n\r\n这是开发人不行？他们不仔细看，光想着糊弄。其实是他们没有看的重点，你让我看啥，我就是一个小前端，让我看整个平台吗？让我看整个技术架构？Java该用什么技术栈？看前端，你告诉我前端我做哪一模块的功能？此时，我一般都是先分配任务，然后再进行原型评审。如果先把任务分下去，他知道要做这一块，因为涉及自己的利益，会考虑自己好不好实现，就会认真审视原型，多发现问题。这样会避免做的过程中，再返过头来，说产品经理没设计好。已经进入开发了，再回头说产品问题，其实是开发人员不负责，更确切说是开发领导的责任。\r\n\r\n一旦听到“人不行”的时候，我就会想到一位老领导。\r\n\r\n他在我心中的是神一般的存在，在我看来，他有着化腐朽为神奇的力量。\r\n\r\n有一次，我们给市场人员做了一个开通业务的APP：上面是表单输入，下面是俩按钮，左边是立即开通，右边是暂时保存。后来，市场同事经常找我们：能不能把我已开通的业务，改为暂时保存，我点错了。这点小事还闹到公司大会上讨论，众人把原因归为市场推广的同事人不行：没有上过学？不认识字？开不开通自己分不清吗？\r\n\r\n此事持续了很久，闹得不愉快。甚至市场部和研发部出现了对立的局面，市场部说研发部不支持销售，研发部说市场部销售不利乱甩锅。\r\n\r\n我老领导知道后，他就去了解，不可能啊，成年人了，按钮老按错，肯定有问题。原来，客户即便是有合作意向，也很少有立即开通的，他们都会调查一下这个公司的背景，然后再联系市场人员开通。两个按钮虽然是左右平分，但是距离很近。于是，他把软件改了，立即开通按钮挪到上边，填完信息后，顺势点击暂时保存，想开通得滑到上面才能点击。此后，出错的人就少了。\r\n\r\n![phone.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c313f80d0743858baaf28854d37878~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n后来，行政部又有人抱怨员工人不行。发给员工的表格填的乱七八糟，根本不认真。有一项叫：请确认是否没有错误_____。明明没有错误，但是很多人都填了“否”。尽管反复强调，一天说三遍，依然有人填错，没有基本的职场素质。\r\n\r\n老领导，他又去了解。他把表格改了，“是否没有错误”改为“全对”，空格改为打钩。后来，填错的现象明显少了。\r\n\r\n\r\n![微信图片_20220922122020.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec753f986784c049f4c91eb315a5455~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n很多事情，我们都想以说教来控制形势。比如反复强调，多次要求，我嗓子都喊哑了。因为不管是区分按钮，还是填写表格，你不是个傻子，你的能力是可以做到的，不应该出错，出了错你就是**人不行**。而老领导总是以人性来控制，知道你是懒散的，肯定不愿意认真付出，因此设置一个流水线，让你随着预设的轨迹被迫走一圈。下线后，居然发现自己合格了，甚至自己都变成人才了。用他的话说就是：流程弥补能力不足。\r\n\r\n> 当归因为人不行时，其实分两种情况：**别人不行**、**自己不行**。\r\n"
    },
    {
        "article_id": "7166928035826909220",
        "snapshot": "https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d4fc4f6b9e2477eb4285e8bfc9e37ff~tplv-k3u1fbpfcp-watermark.image?",
        "title": "公司的这种打包启动方式，我简直惊呆了",
        "preview": "前言 大家都知道，SpringBoot应用最终会打出一个Fat Jar, 里面包含了用到的全部依赖，启动也非常简单，java -jar xxx.jar即可。 但是我们公司打出的最终包，将依赖包挪到了外",
        "author": "JAVA旭阳",
        "view_count": 20664,
        "collect_count": 374,
        "comment_count": 45,
        "avatar": "https://p9-passport.byteacctimg.com/img/user-avatar/e7ff7e07aaf9c553f05da5741e7badfa~300x300.image",
        "category": "后端",
        "content": "---\r\ntheme: cyanosis\r\n---\r\n## 前言\r\n> 如果本文对你有帮助的话，球球帮忙投个票吧，[投票通道](https://rank.juejin.cn/rank/2022/writer/3438928100329646) 感激不尽呀~~\r\n\r\n大家都知道，SpringBoot应用最终会打出一个`Fat Jar`, 里面包含了用到的全部依赖，启动也非常简单，`java -jar xxx.jar`即可。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bc703b2a97345a2bbe610b31b237d78~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n但是我们公司打出的最终包，将依赖包挪到了外部，然后启动的时候通过`loader.path`指定依赖包的位置，如`java -Dloader.path=libs -jar xxxx`的方式启动，也能够启动成功。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff29943a97914ddab8c5e3914dd6a135~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n这样做最大的一个好处就是如果发现某个依赖出现问题，那么我只需要在libs替换其中某个依赖，影响范围可以减小很多。\r\n\r\n那大家是不是很好奇是怎么做到的呢？\r\n\r\n## 打包方式详解\r\n\r\n主要是通过两个maven插件打出这样的结构的包。\r\n\r\n1.  **spring-boot-maven-plugin**\r\n\r\n该插件是`spring boot`官方提供的一个打包插件，主要用来打出`fat jar`，并且提供了支持`java -jar xxx.jar`方式启动。 官网地址：<https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/>。\r\n\r\n我们需要用这个插件,因为只有它可以打出支持启动的jar，但是打出的包中又不能有依赖，该怎么做呢？如下图：\r\n\r\n![aa.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7417109b8ce54686ae6e3480775fb323~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n-   `layout`: 布局方式，这里要选择`ZIP`，后面说明原因。\r\n-   `includes`: 选择包含哪些依赖，这里写了一个不存在的jar，那么也间接实现了不打入其他的依赖。这种方式比较ugly，但是目前没有找到更加合适的方案。\r\n\r\n2.  **maven-assembly-plugin**\r\n\r\nmaven-assembly-plugin插件可以灵活定制打包内容，官网地址：<https://maven.apache.org/plugins/maven-assembly-plugin/>。\r\n\r\n我们现在就是想办法利用该插件抽出我们用到的依赖包，该怎么做呢？\r\n\r\n\r\n![ss.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a49d25e682894d3b917d807e6da1e365~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我们现在看下`assembly.xml`中的关键配置：\r\n\r\n![dd.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/641b7bdc5a604d7ca4d5d034a5b24dc5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n-   可以根据`include`、`exclude`属性通过正则灵活的抽取相关依赖到指定的目录下\r\n\r\n最终执行`mvn clean package`在target目录下得到最终的安装包：\r\n\r\n![aac.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac357fd460654ae19f83ec09a42a83b1~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n解压该安装包：\r\n\r\n![tt.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0739b3c2d850454484c6bbfe1ca88235~tplv-k3u1fbpfcp-watermark.image?)\r\n打开libs目录：\r\n\r\n![ssc.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0adb91afc98646caaaaa0473c1d98646~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n## 启动方式解析\r\n\r\n现在我们已经按照自己想要的结构打出包了，那如何在启动的时候加载`libs`目录中的依赖呢？\r\n\r\n前面提到了`springboot`插件打出的包是启动的入口，实际上在这个包里面`springboot`会自动打入一个引导类`org.springframework.boot.loader.Launcher`，它是 `Spring Boot` 可执行 jar 的主要入口点，它是 `Spring Boot jar` 文件中的实际 `Main-Class`，用于设置适当的 `URLClassLoader` 并最终调用`  Spring Boot `项目中定义的 `main()`方法。\r\n\r\n`Launcher`有三个子类（`JarLauncher`、`WarLauncher` 和 `PropertiesLauncher`），如果我们打包插件的`layout`配置的是`ZIP`的方式，它会使用`PropertiesLauncher`。\r\n\r\n**PropertiesLauncher机制说明：**\r\n\r\n默认情况下，`PropertiesLauncher` 在 `BOOT-INF/lib/` 中加载，我们可以通过设置` loader.properties  `中的`loader.path` 或 `LOADER_PATH` 环境变量来增加其它的加载位置。\r\n\r\n-   `loader.path`：配置逗号分隔的 `Classpath` 类路径，例如 `lib,${HOME}/app/lib`，前面的路径优先，类似于 javac 命令中的 `-classpath`。\r\n-   `loader.home`：用于解析 `loader.path` 配置的相对路径，默认是`${user.dir}`。\r\n\r\n所以，打包成功后，我们可以通过`  java -jar -Dloader.path=xx1,xx2,public <jarName>.jar ` 命令来启动程序，这样对应目录下的依赖均会被加载。\r\n\r\n## 总结\r\n\r\n这种打包启动方式虽然不常见，但是还是有一定的价值的，特别是在项目组件模块比较多的时候，出现紧急缺陷，可以按需替换包，将影响范围控制到最小。\r\n\r\n> 如果本文对你有帮助的话，球球帮忙投个票吧，[投票通道](https://rank.juejin.cn/rank/2022/writer/3438928100329646) 感激不尽呀~~\r\n\r\n***本文正在参加[「金石计划 . 瓜分6万现金大奖」](https://juejin.cn/post/7162096952883019783 \\\"https://juejin.cn/post/7162096952883019783\\\")***\r\n"
    },
    {
        "article_id": "7179239346967412773",
        "snapshot": "",
        "title": "MYSQL中的14个神仙功能，惊艳到我了！！！",
        "preview": "前言 我最近几年用MYSQL数据库挺多的，发现了一些非常有用的小玩意，今天拿出来分享到大家，希望对你会有所帮助。 1.group_concat 在我们平常的工作中，使用group by进行分组的场景，",
        "author": "苏三说技术",
        "view_count": 19751,
        "collect_count": 468,
        "comment_count": 27,
        "avatar": "https://p3-passport.byteacctimg.com/img/user-avatar/dc678f02170ae25eb82989d0f7715e1f~300x300.image",
        "category": "后端",
        "content": "## 前言\r\n经过一年的努力，终于上了今年优秀作者榜单了，求票求票，每人可以投8票。顶我一波呀，非常感谢。\r\n掘金2022年度人气创作者打榜中，快来帮我打榜吧～ https://rank.juejin.cn/rank/2022/writer/465848661970824?utm_campaign=annual_2022&utm_medium=self_web_share&utm_source=%E8%8B%8F%E4%B8%89%E8%AF%B4%E6%8A%80%E6%9C%AF\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7d4785a4ba04841a748339b06e2ee0a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n我最近几年用`MYSQL`数据库挺多的，发现了一些非常有用的小玩意，今天拿出来分享到大家，希望对你会有所帮助。\r\n\r\n## 1.group_concat\r\n在我们平常的工作中，使用`group by`进行分组的场景，是非常多的。\r\n\r\n比如想统计出用户表中，名称不同的用户的具体名称有哪些？\r\n\r\n具体sql如下：\r\n```sql\r\nselect name from `user`\r\ngroup by name;\r\n```\r\n\r\n但如果想把name相同的code拼接在一起，放到另外一列中该怎么办呢？\r\n\r\n答：使用`group_concat`函数。\r\n\r\n例如：\r\n```sql\r\nselect name,group_concat(code) from `user`\r\ngroup by name;\r\n```\r\n执行结果：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74961bd075b04db2baf093a2eaed0ee6~tplv-k3u1fbpfcp-zoom-1.image)\r\n使用`group_concat`函数，可以轻松的把分组后，name相同的数据拼接到一起，组成一个字符串，用`逗号`分隔。\r\n\r\n## 2.char_length\r\n有时候我们需要获取字符的`长度`，然后根据字符的长度进行`排序`。\r\n\r\nMYSQL给我们提供了一些有用的函数，比如：`char_length`。\r\n\r\n通过该函数就能获取字符长度。\r\n\r\n获取字符长度并且排序的sql如下：\r\n```sql\r\nselect * from brand where name like '%苏三%' \r\norder by char_length(name) asc limit 5;\r\n````\r\n执行效果如图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b95b597e37f454d84353d610c395f2a~tplv-k3u1fbpfcp-zoom-1.image)\r\nname字段使用关键字`模糊查询`之后，再使用`char_length`函数获取name字段的字符长度，然后按长度`升序`。\r\n\r\n## 3.locate \r\n有时候我们在查找某个关键字，比如：`苏三`，需要明确知道它在某个字符串中的位置时，该怎么办呢？\r\n\r\n答：使用`locate`函数。\r\n\r\n使用locate函数改造之后sql如下：\r\n```sql\r\nselect * from brand where name like '%苏三%' \r\norder by char_length(name) asc, locate('苏三',name) asc limit 5,5;\r\n```\r\n执行结果：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd0aff3e45c45898262e9c55f51e777~tplv-k3u1fbpfcp-zoom-1.image)\r\n先按长度排序，小的排在前面。如果长度相同，则按关键字从左到右进行排序，越靠左的越排在前面。\r\n\r\n除此之外，我们还可以使用：`instr`和`position`函数，它们的功能跟`locate`函数类似，在这里我就不一一介绍了，感兴趣的小伙伴可以找我私聊。\r\n\r\n## 4.replace\r\n我们经常会有替换字符串中部分内容的需求，比如：将字符串中的字符A替换成B。\r\n\r\n这种情况就能使用`replace`函数。\r\n\r\n例如：\r\n```sql\r\nupdate brand set name=REPLACE(name,'A','B') \r\nwhere id=1;\r\n```\r\n这样就能轻松实现字符替换功能。\r\n\r\n也能用该函数去掉`前后空格`：\r\n```sql\r\nupdate brand set name=REPLACE(name,' ','') where name like ' %';\r\nupdate brand set name=REPLACE(name,' ','') where name like '% ';\r\n```\r\n使用该函数还能替换`json格式`的数据内容，真的非常有用。\r\n\r\n## 5.now\r\n时间是个好东西，用它可以快速缩小数据范围，我们经常有获取当前时间的需求。\r\n\r\n在MYSQL中获取`当前时间`，可以使用`now()`函数，例如：\r\n```sql\r\nselect now() from brand limit 1;\r\n```\r\n返回结果为下面这样的：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8efe4ee396483a900245744b5ff6f0~tplv-k3u1fbpfcp-zoom-1.image)\r\n它会包含`年月日时分秒`。\r\n\r\n如果你还想返回`毫秒`，可以使用`now(3)`，例如：\r\n```sql\r\nselect now(3) from brand limit 1;\r\n```\r\n返回结果为下面这样的：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ed94cc91467416e811873a49a9c8147~tplv-k3u1fbpfcp-zoom-1.image)\r\n使用起来非常方便好记。\r\n\r\n## 6.insert into ... select\r\n在工作中很多时候需要`插入数据`。\r\n\r\n传统的插入数据的sql是这样的：\r\n```sql\r\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nVALUES (5, '108', '苏三', '2022-09-02 19:42:21');\r\n```\r\n它主要是用于插入少量并且已经确定的数据。但如果有大批量的数据需要插入，特别是是需要插入的数据来源于，另外一张表或者多张表的结果集中。\r\n\r\n这种情况下，使用传统的插入数据的方式，就有点束手无策了。\r\n\r\n这时候就能使用MYSQL提供的：`insert into ... select`语法。\r\n\r\n例如：\r\n```sql\r\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nselect null,code,name,now(3) from `order` where code in ('004','005');\r\n```\r\n这样就能将order表中的部分数据，非常轻松插入到brand表中。\r\n\r\n## 7.insert into ... ignore\r\n不知道你有没有遇到过这样的场景：在插入1000个品牌之前，需要先根据name，判断一下是否存在。如果存在，则不插入数据。如果不存在，才需要插入数据。\r\n\r\n如果直接这样插入数据：\r\n```sql\r\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nVALUES (123, '108', '苏三', now(3));\r\n```\r\n肯定不行，因为brand表的name字段创建了唯一索引，同时该表中已经有一条name等于苏三的数据了。\r\n\r\n执行之后直接报错了：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc0d209c6eb74d50beec373c29b4ae80~tplv-k3u1fbpfcp-zoom-1.image)\r\n这就需要在插入之前加一下判断。\r\n\r\n当然很多人通过在sql语句后面拼接`not exists`语句，也能达到防止出现重复数据的目的，比如：\r\n```sql\r\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nselect null,'108', '苏三',now(3) \r\nfrom dual where  not exists (select * from `brand` where name='苏三');\r\n```\r\n这条sql确实能够满足要求，但是总觉得有些麻烦。那么，有没有更简单的做法呢？\r\n\r\n答：可以使用`insert into ... ignore`语法。\r\n\r\n例如：\r\n```sql\r\nINSERT ignore INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nVALUES (123, '108', '苏三', now(3));\r\n```\r\n这样改造之后，如果brand表中没有name为苏三的数据，则可以直接插入成功。\r\n\r\n但如果brand表中已经存在name为苏三的数据了，则该sql语句也能正常执行，并不会报错。因为它会忽略异常，返回的执行结果影响行数为0，它不会重复插入数据。\r\n\r\n## 8.select ... for update\r\nMYSQL数据库自带了`悲观锁`，它是一种排它锁，根据锁的粒度从大到小分为：`表锁`、`间隙锁`和`行锁`。\r\n\r\n在我们的实际业务场景中，有些情况并发量不太高，为了保证数据的正确性，使用悲观锁也可以。\r\n\r\n比如：用户扣减积分，用户的操作并不集中。但也要考虑系统自动赠送积分的并发情况，所以有必要加悲观锁限制一下，防止出现积分加错的情况发生。\r\n\r\n这时候就可以使用MYSQL中的`select ... for update`语法了。\r\n\r\n例如：\r\n```sql\r\nbegin;\r\nselect * from `user` where id=1 \r\nfor update;\r\n\r\n//业务逻辑处理\r\n\r\nupdate `user` set score=score-1 where id=1;\r\ncommit;\r\n```\r\n这样在一个事务中使用`for update`锁住一行记录，其他事务就不能在该事务提交之前，去更新那一行的数据。\r\n\r\n需要注意的是for update前的id条件，必须是表的`主键`或者`唯一索引`，不然行锁可能会失效，有可能变成`表锁`。\r\n\r\n## 9.on duplicate key update\r\n通常情况下，我们在插入数据之前，一般会先查询一下，该数据是否存在。如果不存在，则插入数据。如果已存在，则不插入数据，而直接返回结果。\r\n\r\n在没啥并发量的场景中，这种做法是没有什么问题的。但如果插入数据的请求，有一定的并发量，这种做法就可能会产生重复的数据。\r\n\r\n当然防止重复数据的做法很多，比如：`加唯一索引`、`加分布式锁`等。\r\n\r\n但这些方案，都没法做到让第二次请求也更新数据，它们一般会判断已经存在就直接返回了。\r\n\r\n这种情况可以使用`on duplicate key update`语法。\r\n\r\n该语法会在插入数据之前判断，如果主键或唯一索引不存在，则插入数据。如果主键或唯一索引存在，则执行更新操作。\r\n\r\n具体需要更新的字段可以指定，例如：\r\n```sql\r\nINSERT  INTO `brand`(`id`, `code`, `name`, `edit_date`) \r\nVALUES (123, '108', '苏三', now(3))\r\non duplicate key update name='苏三',edit_date=now(3);\r\n```\r\n这样一条语句就能轻松搞定需求，既不会产生重复数据，也能更新最新的数据。\r\n\r\n但需要注意的是，在高并发的场景下使用`on duplicate key update`语法，可能会存在`死锁`的问题，所以要根据实际情况酌情使用。\r\n\r\n## 10.show create table\r\n有时候，我们想快速查看某张表的字段情况，通常会使用`desc`命令，比如：\r\n```sql\r\ndesc `order`;\r\n```\r\n结果如图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/def4209d1a684885a5703f73c2d1402d~tplv-k3u1fbpfcp-zoom-1.image)\r\n确实能够看到order表中的字段名称、字段类型、字段长度、是否允许为空，是否主键、默认值等信息。\r\n\r\n但看不到该表的索引信息，如果想看创建了哪些索引，该怎么办呢？\r\n\r\n答：使用`show index`命令。\r\n\r\n比如：\r\n```sql\r\nshow index from `order`;\r\n```\r\n也能查出该表所有的索引：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1534e30af34f434d8356e387d366d055~tplv-k3u1fbpfcp-zoom-1.image)\r\n但查看字段和索引数据呈现方式，总觉得有点怪怪的，有没有一种更直观的方式？\r\n\r\n答：这就需要使用`show create table`命令了。\r\n\r\n例如：\r\n```sql\r\nshow create table `order`;\r\n```\r\n执行结果如图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b81ac558ecbc4596897034a9f6ccac5d~tplv-k3u1fbpfcp-zoom-1.image)\r\n其中`Table`表示`表名`，`Create Table`就是我们需要看的`建表信息`，将数据展开：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1709925cff34cdca15a8120f885c1a5~tplv-k3u1fbpfcp-zoom-1.image)\r\n我们能够看到非常完整的建表语句，表名、字段名、字段类型、字段长度、字符集、主键、索引、执行引擎等都能看到。\r\n\r\n非常直接明了。\r\n\r\n## 11.create table ... select\r\n有时候，我们需要快速备份表。\r\n\r\n通常情况下，可以分两步走：\r\n1. 创建一张临时表\r\n2. 将数据插入临时表\r\n\r\n创建临时表可以使用命令：\r\n```sql\r\ncreate table order_2022121819 like `order`;\r\n```\r\n创建成功之后，就会生成一张名称叫：order_2022121819，表结构跟order一模一样的`新表`，只是该表的`数据为空`而已。\r\n\r\n接下来使用命令：\r\n```sql\r\ninsert into order_2022121819 select * from `order`;\r\n```\r\n执行之后就会将order表的数据插入到order_2022121819表中，也就是实现数据备份的功能。\r\n\r\n但有没有命令，一个命令就能实现上面这两步的功能呢？\r\n\r\n答：用`create table ... select`命令。\r\n\r\n例如：\r\n```sql\r\ncreate table order_2022121820 \r\nselect * from `order`;\r\n```\r\n执行完之后，就会将order_2022121820表创建好，并且将order表中的数据自动插入到新创建的order_2022121820中。\r\n\r\n一个命令就能轻松搞定`表备份`。\r\n\r\n## 12.explain\r\n很多时候，我们优化一条sql语句的性能，需要查看`索引`执行情况。\r\n\r\n答：可以使用`explain`命令，查看mysql的`执行计划`，它会显示`索引的使用情况`。\r\n\r\n例如：\r\n```sql\r\nexplain select * from `order` where code='002';\r\n```\r\n结果：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8b231774924d3ca845bc571b3c3a75~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8651fb6730d54faa8345b95391f4cce4~tplv-k3u1fbpfcp-zoom-1.image)\r\n如果你想进一步了解explain的详细用法，可以看看我的另一篇文章《[explain | 索引优化的这把绝世好剑，你真的会用吗？](https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490262&idx=1&sn=a67f610afa984ecca130a54a3be453ab&chksm=c0ebc23ef79c4b2869dea998e413c5cbea6aeeea01ee74efc7c1a5fc228baa7beca215adf3ea&token=751314179&lang=zh_CN&scene=21#wechat_redirect)》\r\n\r\n说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。\r\n\r\n下面说说索引失效的常见原因：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e99db9042384936b49666ae4dc968ad~tplv-k3u1fbpfcp-zoom-1.image)\r\n如果不是上面的这些原因，则需要再进一步排查一下其他原因。\r\n\r\n## 13.show processlist\r\n有些时候我们线上sql或者数据库出现了问题。比如出现了数据库连接过多问题，或者发现有一条sql语句的执行时间特别长。\r\n\r\n这时候该怎么办呢？\r\n\r\n答：我们可以使用`show processlist`命令查看`当前线程执行情况`。\r\n\r\n如图所示：\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d741b262d2ac44d680bdc26d2459041b~tplv-k3u1fbpfcp-zoom-1.image)\r\n从执行结果中，我们可以查看当前的连接状态，帮助识别出有问题的查询语句。\r\n\r\n- id 线程id\r\n- User 执行sql的账号\r\n- Host 执行sql的数据库的ip和端号\r\n- db 数据库名称\r\n- Command 执行命令，包括：Daemon、Query、Sleep等。\r\n- Time 执行sql所消耗的时间\r\n- State 执行状态\r\n- info 执行信息，里面可能包含sql信息。\r\n\r\n如果发现了异常的sql语句，可以直接kill掉，确保数据库不会出现严重的问题。\r\n\r\n## 14.mysqldump\r\n有时候我们需要导出MYSQL表中的数据。\r\n\r\n这种情况就可以使用`mysqldump`工具，该工具会将数据查出来，转换成insert语句，写入到某个文件中，相当于`数据备份`。\r\n\r\n我们获取到该文件，然后执行相应的insert语句，就能创建相关的表，并且写入数据了，这就相当于`数据还原`。\r\n\r\nmysqldump命令的语法为：\r\n`mysqldump -h主机名 -P端口 -u用户名 -p密码 参数1,参数2.... > 文件名称.sql`\r\n\r\n备份远程数据库中的数据库：\r\n```java\r\nmysqldump -h 192.22.25.226 -u root -p123456 dbname > backup.sql\r\n```\r\n\r\n经过一年的努力，终于上了今年优秀作者榜单了，求票求票，每人可以投8票。顶我一波呀，非常感谢。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7d4785a4ba04841a748339b06e2ee0a~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n### 最后说一句(求关注，别白嫖我)\r\n\r\n如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。\r\n\r\n求一键三连：点赞、转发、在看。\r\n\r\n关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。\r\n\r\n "
    }
]